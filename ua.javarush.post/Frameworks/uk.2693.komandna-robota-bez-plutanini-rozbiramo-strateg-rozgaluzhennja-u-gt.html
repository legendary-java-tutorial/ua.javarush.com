Командна робота без плутанини: розбираємо стратегії розгалуження у Гіті
<p>----------------------------------------</p>
Гіт став де-факто промисловим стандартом системи контролю версій у створенні програмного забезпечення. Про те, що таке гіт і як почати, почитайте мою статтю про це. Прочитали? Чудово, поїхали далі! Подобається нам чи ні, але інструмент, яки
<p>----------------------------------------</p>
<h2>Вступ</h2>Гіт став де-факто промисловим стандартом системи контролю версій у створенні програмного забезпечення. Про те, що таке гіт і як почати, <a href="https://codegym.cc/groups/posts/2683-nachalo-rabotih-s-git-podrobnihy-gayd-dlja-novichkov" target="_blank">спочатку</a> почитайте мою статтю про це. Прочитали? Чудово, поїхали далі! <img data-max-width="800" data-id="0a6eb9f6-1e54-4eb7-a031-a5876a09fcae" class="img-fluid" alt="Командна робота без плутанини: розбираємо стратегії розгалуження у Гіті - 1" src="https://cdn.javarush.com/images/article/0a6eb9f6-1e54-4eb7-a031-a5876a09fcae/800.jpeg" style="width: 800px;">Подобається нам чи ні, але інструмент, який Лінус Товальдс створив, не має наміру йти на пенсію. Тому є сенс поговорити про те, як працювати розподіленим командам у гіті та яку стратегію розгалуження для цього вибрати. І це питання зовсім не пусте. Часто в ситуації, коли збирають нову команду розробників, котрі не співпрацювали один з одним, стратегія розгалуження — це одне з перших, що потрібно вирішити. І будуть люди, які з піною біля рота доводитимуть, що одна стратегія краща за іншу. Тому я хочу донести до вас інформацію про те, якими вони взагалі бувають. 
<h3>А чи потрібні стратегії розгалуження?</h3>А ось потрібні, та ще й як потрібні. Бо якщо не домовитися про щось у команді, вийде, що кожен робитиме, що хоче: 
<ul>
 <li>працювати у тій гілці, у якій хоче;</li>
 <li>смерджувати в інші гілки, які він хоче;</li>
 <li>видаляти якісь гілки;</li>
 <li>створювати нові;</li>
 <li>і так - кожен із членів команди в некерованому потоці.</li>
</ul>Тому нижче наведу три стратегії. Поїхали! 
<h3>GitHub Flow стратегія</h3><img data-max-width="800" data-id="40ca42c4-6492-4586-818b-05ed07b8bfd9" class="img-fluid" alt="Командна робота без плутанини: розбираємо стратегії розгалуження у Гіті - 2" src="https://cdn.javarush.com/images/article/40ca42c4-6492-4586-818b-05ed07b8bfd9/800.jpeg" style="width: 800px;">Стратегія розгалуження, як би це не було дивно, віддається перевага GitHub :) До неї додається <a href="https://githubflow.github.io/" rel="nofollow" target="_blank">набір правил</a> , яким потрібно слідувати: 
<ol>
 <li>Код у master гілці має бути не поламаним і готовим до розгортання у будь-який час (тобто не можна туди покласти код, який завадить зібрати проект і розгорнути його на сервері).</li>
 <li>Коли планується робота над новою функціональністю, необхідно створити нову гілку (feature гілку) на основі master гілки та дати їй зрозуміле ім'я. Комітувати свій код локально та регулярно пушити свої зміни на цю ж гілку у віддалений репозиторій.</li>
 <li>Відкрити Pull-Request (що таке pull-request, можна почитати <a href="https://habr.com/ru/post/125999/" rel="nofollow" target="_blank">тут</a> ), коли є чітке відчуття, що робота готова і може бути смержена в master гілку (або якщо впевненості немає, але хочеться отримати відгуки про виконану роботу).</li>
 <li>Після того, як нову фічу в пул-реквесті запругли, її можна смердити в master гілку.</li>
 <li>Коли зміни смерджені в master гілку, їх потрібно розгорнути на сервері негайно.</li>
</ol>По GitHub Flow виходить, що перш ніж почати роботу над чимось новим, чи це виправлення або нова фіча, потрібно створити нову гілку на основі master'а і дати їй відповідне ім'я. Далі починається робота над реалізацією. Потрібно постійно відправляти коміти на віддалений сервер з тим самим ім'ям. Коли приходить розуміння, що все готове, потрібно створити пул-реквест у master гілку. Потім хоча б один, а краще дві людини повинні подивитися цей код і натиснути Approve. Зазвичай обов'язково має подивитись тимлід проекту і хтось ще, і тоді вже можна завершувати пул-реквест. GitHub Flow ще відомий тим, що драйвіт <a href="https://rollout.io/blog/continuous-integration-continuous-delivery-continuous-deployment/" rel="nofollow" target="_blank">Continuous Delivery (CD)</a> на проекті. Тому що коли зміни заходять у master гілку, вони повинні одразу ж бути розгорнуті на сервері. 
<h3>GitFlow стратегія</h3><img data-max-width="512" data-id="5a14b4b7-158a-48fd-bebe-fe197309bf81" class="img-fluid" alt="Командна робота без плутанини: розбираємо стратегії розгалуження у Гіті - 3" src="https://cdn.javarush.com/images/article/5a14b4b7-158a-48fd-bebe-fe197309bf81/512.jpeg" style="width: 512px;">Попередня стратегія (GitHub Flow) була, по суті, не дуже складною. Є два типи гілок: master і фіче гілки. А ось GitFlow вже серйозніше. Як мінімум з картинки вище ви можете зрозуміти) Отже, як працює ця стратегія? Загалом GitFlow складається з двох постійних гілок і кількох типів тимчасових гілок (У контексті GitHub Flow, master гілка – постійна, а інші – тимчасові). <span class="text-bold">Постійні гілки:</span>
<ul>
 <li>master: цю гілку просто так ніхто не повинен чіпати/нічого не пушити туди. У цій стратегії master відображає останню стабільну версію, яку використовують у продакшені (тобто реальному сервері);</li>
 <li>development – ​​це гілка для розробки. Потенційно може бути нестабільна.</li>
</ul>Розробка ведеться за допомогою трьох <span class="text-bold">допоміжних тимчасових гілок</span> : 
<ol>
 <li>Фіче гілки (feature branches) – для розробки нової функціональності.</li>
 <li>Релізні гілки (release branches) для підготовки випуску нової версії проекту.</li>
 <li>Хотфікс гілки (hotfix branches) - швидке рішення дефекту, який знайшли реальні користувачі на реальному сервері.</li>
</ol>
<h4>Фіче гілки (feature branches)</h4>Фіче гілки створюються розробниками нового функціоналу. Вони завжди повинні створюватися на основі розвитку гілки. Після завершення роботи над новою функціональністю, потрібно створити пул-реквест у розвитку гілку. Зрозуміло, що у великих командах одночасно може бути більше однієї фічі гілки. Ще раз зверніть увагу на картинку на початку опису стратегії GitFlow. 
<h4>Релізні гілки (release branches)</h4>Коли необхідна кількість нових фіч підготовлена ​​в розробці гілці, можна підготуватися до випуску нової версії продукту. У цьому нам допоможе релізна гілка. яка створюється на основі розвитку гілки. У ході роботи з релізною гілкою потрібно знайти і полагодити всі дефекти. Всі нові зміни, які потрібні для стабілізації релізної гілки, потрібно також смердити назад у розробці. Робиться це для того, щоб стабілізувати та розвиток гілку. Коли тестувальники скажуть, що гілка досить стабільна для нового релізу, її смерджують у master гілку. Далі на цьому коміті створюється мітка (tag: докладніше можна прочитати <a href="https://git-scm.com/book/ru/v2/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D0%BC%D0%B5%D1%82%D0%BA%D0%B0%D0%BC%D0%B8" rel="nofollow" target="_blank">тут</a> ), якій присвоюється номер версії. Як приклад можна подивитися на картинку на початку стратегії. Так ось, там <span class="text-bold">Tag 1.0</span> — це мітка, яка вказує на версію 1.0 проекту. І останнє - це хотфікс гілки. 
<h4>Хотфікс гілки (Hotfix branches)</h4>Хотфікс гілки також призначені для релізу нової версії в master. Тільки різниця у тому, що цей реліз не планується. Бувають ситуації, коли дефекти сягають релізу і вже виявляються у роботі. Наприклад, iOS: як тільки випустять нову версію, так одразу тобі купа оновлень із фіксами дефектів, які виявляються після релізу. У зв'язку із цим потрібно швидко пофіксувати цей дефект та випустити нову версію. На нашому малюнку це відповідає версії 1.0.1. Ідея полягає в тому, що робота над новими функціональностями може не зупинятися в моменти, коли потрібно полагодити дефект на реальному сервері (як у нас кажуть, на проді: знову калька з англійського production). Хотфікс гілка повинна створюватися від master гілки, тому що вона відображає стан, який працює в проді. Як тільки рішення дефекту готове, смерджується в master, створюється нова мітка. Так само, як і підготовка релізної гілки, хотфікс гілка повинна смердити своє рішення в розробці гілки. 
<h3>The Forking Workflow стратегія</h3><img data-max-width="800" data-id="9caec5c2-7969-4cca-94ad-318ad3aca782" class="img-fluid" alt="Командна робота без плутанини: розбираємо стратегії розгалуження у Гіті - 4" src="https://cdn.javarush.com/images/article/9caec5c2-7969-4cca-94ad-318ad3aca782/800.jpeg" style="width: 800px;">У рамках Forking Workflow стратегії розробка ведеться так, що є два репозиторії: 
<ol>
 <li>Оригінальний репозиторій, до якого смерджуватимуться всі зміни.</li>
 <li>Форк репозиторій (це копія оригінального репозиторію у володінні іншого розробника, який хоче внести зміни до оригінального).</li>
</ol>Поки що звучить якось дивно, так? Тим, хто вже стикався з open-source розробкою, цей підхід уже знайомий. Така стратегія дає таку перевагу: розробка може вестись у форк-репозиторії та без надання прав на спільну розробку в оригінальному. Вочевидь, що власник оригінального репозиторію вправі відхаботи запропоновані зміни. Або погодитись і смердити їх. Це зручно і власнику оригінального репозиторію, і розробнику, який хоче взяти участь у створенні продукту. Наприклад, можна запропонувати зміни в <a href="https://github.com/torvalds/linux" rel="nofollow" target="_blank">ядро ​​лінуксу</a> . Якщо Лінус вирішить, що вони мають сенс, зміни буде додано (!!!). 
<h3>Приклад The ​​Forking Workflow</h3>The Forking Flow застосовується на GitHub'e в момент, коли є бібліотека, яку хочеться використовувати. У ній є дефект, який заважає використати її повноцінно. Припустимо, ви занурабося досить у проблему та знаєте рішення. За допомогою The Forking Workflow стратегії можна вирішити це завдання без надання прав на роботу в оригінальному репозиторії бібліотеки. Щоб почати роботу, потрібно вибрати якийсь репозиторій, наприклад, <a href="https://github.com/spring-projects/spring-framework" rel="nofollow" target="_blank">ядро ​​Spring Framework</a> , знаходимо у верхньому правому кутку кнопку Fork і натискаємо її: <img data-max-width="1024" data-id="0eba6191-9a64-4614-b4c9-020b1cd81c9d" class="img-fluid" alt="Командна робота без плутанини: розбираємо стратегії розгалуження у Гіті - 5" src="https://cdn.javarush.com/images/article/0eba6191-9a64-4614-b4c9-020b1cd81c9d/1024.jpeg" style="width: 1024px;">Це займе деякий час, після чого з'явиться копія цього оригінального репозиторію в особистому обліковому записі, в якому буде вказано, що вона є форком: <img data-max-width="800" data-id="248f8d47-290b-4ff9-9f4b-0b0ab0ead019" class="img-fluid" alt="Командна робота без плутанини: розбираємо стратегії розгалуження у Гіті - 6" src="https://cdn.javarush.com/images/article/248f8d47-290b-4ff9-9f4b-0b0ab0ead019/800.jpeg" style="width: 800px;">Далі ви можете працювати з цим репозиторієм у звичайному режимі, додавати зміни в master гілку і коли все буде готове створити Pull-Request в оригінальний репозиторій. Для цього потрібно натиснути кнопку <span class="text-bold">New Pull request</span> : <img data-max-width="800" data-id="2ec57367-e6a2-4203-8f06-c6004a01636e" class="img-fluid" alt="Командна робота без плутанини: розбираємо стратегії розгалуження у Гіті - 7" src="https://cdn.javarush.com/images/article/2ec57367-e6a2-4203-8f06-c6004a01636e/800.jpeg" style="width: 800px;">
<h3>Яку стратегію вибрати</h3>Гіт – це гнучкий та потужний інструмент, який дозволяє працювати, використовуючи широкий спектр процесів та стратегій. Але що більший вибір, то складніше вирішити, яку саме стратегію зараз обрати. Зрозуміло, що немає однозначної відповіді всім. Все залежить від ситуації. Тим не менш, є кілька рекомендацій, які можуть допомогти у цьому: 
<ol>
 <li>Спочатку краще вибирати найпростішу стратегію. Переходити до складніших стратегій лише тоді, коли це потрібно.</li>
 <li>Розглядати стратегії, в яких якнайменше типів гілок для розробників.</li>
 <li>Подивитися на плюси та мінуси різних стратегій та, відповідно до проекту, вибрати потрібну.</li>
</ol>Це все, що я хотів розповісти з приводу стратегії розгалуження у гіті. Дякую за увагу :) <span class="text-bold">Підписуйтесь на <a href="https://github.com/romankh3" rel="nofollow" target="_blank">мій гітхаб аккаунт</a></span> , я там часто викладаю свої напрацювання в різних технологіях та інструментах, які використовую в роботі <a href="https://codegym.cc/welcome" target="_blank"><img id="click_banner1_articles" data-max-width="1024" data-id="e4ffc34b-e63d-4bbd-bfda-0817cab5cac0" class="img-fluid" alt="Командна робота без плутанини: розбираємо стратегії розгалуження у Гіті - 8" src="https://cdn.javarush.com/images/article/e4ffc34b-e63d-4bbd-bfda-0817cab5cac0/1024.jpeg" style="width: 1024px;"></a>
<h2>Корисні посилання</h2>
<ul>
 <li><a href="https://githubflow.github.io/" rel="nofollow" target="_blank">GitHub flow:</a> the best way to use Git and GitHub</li>
 <li><a href="https://habr.com/ru/post/125999/" rel="nofollow" target="_blank">Pull request'и на GitHub або Як мені внести зміни до чужого проекту</a></li>
 <li>GitHub: <a href="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests" rel="nofollow" target="_blank">About Pull-Requests</a></li>
 <li><a href="https://rollout.io/blog/continuous-integration-continuous-delivery-continuous-deployment/" rel="nofollow" target="_blank">Continuous Integration, Delivery, and Deployment Differentiated</a></li>
 <li>Основи Гіт: <a href="https://git-scm.com/book/ru/v2/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D0%BC%D0%B5%D1%82%D0%BA%D0%B0%D0%BC%D0%B8" rel="nofollow" target="_blank">робота з мітками</a></li>
 <li>Хабр: <a href="https://habr.com/ru/post/106912/" rel="nofollow" target="_blank">Вдала модель розгалуження для Git</a></li>
</ul>