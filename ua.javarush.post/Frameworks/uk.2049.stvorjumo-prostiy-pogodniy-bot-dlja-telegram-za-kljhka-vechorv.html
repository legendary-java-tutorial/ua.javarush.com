Створюємо простий погодний бот для Telegram за кілька вечорів
<p>----------------------------------------</p>
Всім привіт! Тема створення ботів для телеграм дещо побита, і гайдів написано дуже багато (наприклад, ось ). Тому ми краще розглянемо докладніше роботу з будь-яким стороннім API, оскільки це критично важлива навичка для будь-якого веб-розро
<p>----------------------------------------</p>
Всім привіт! Тема створення ботів для телеграм дещо побита, і гайдів написано дуже багато (наприклад, ось <a href="https://codegym.cc/groups/posts/504-sozdanie-telegram-bota-na-java-ot-idei-do-deploja" target="_blank" rel="nofollow">цей</a> ). Тому ми краще розглянемо докладніше роботу з будь-яким стороннім API, оскільки це критично важлива навичка для будь-якого веб-розробника. Відразу скажу, що додаток не ставив за мету надати максимально функціональний і корисний прогноз, конкурувати з погодними сайтами немає сенсу, важливо було навчитися працювати з віддаленими з'єднаннями та парсингом даних засобами Java. Отже, з'ясуємо спершу, що нам потрібно. Наша програма, по суті, складається з трьох логічних частин: 
<ul>
 <li>прийняти повідомлення від користувача</li>
 <li>обробити повідомлення, і якщо це валідна команда, підготувати дані для відповіді. У нашому випадку підготувати прогноз погоди, якщо користувач ввів коректне місто</li>
 <li>надіслати готову інформацію користувачу в чат</li>
</ul>Перший і третій пункт досить простий, і стосується лише роботи з Telegram API, охочі можуть вивчити посилання, що залишилося вище. Ми ж звернемо увагу на другому пункті. API використовують тоді, коли одні розробники хочуть надати доступ до своїх даних іншим розробникам. Візьмемо, наприклад, Вконтакте. Кожен має список друзів, він зберігається десь у базі даних на серверах ВК. Припустимо, що якийсь програміст вирішив створити гру у шашки із друзями. Щоб його застосування працювало правильно, програма повинна вміти отримувати список друзів будь-якого гравця. Для цього програміст знаходить документацію до ВК API і дивиться, який запит потрібно зробити, щоб цей список отримати. Цей запит називається HTTP-запитом. А два найпоширеніші HTTP-запити - це GET і POST. Про них у мережі теж достатньо, зупиняти не буду. Для наших цілей, а саме отримання даних прогнозу погоди буде достатньо простого GET-запиту. Якщо звернутися з GET запитом до звичайного веб-сервера, він часто поверне html-код, який браузер перетворить на зручну для користувача сторінку, застосувавши стилі, скрипти та ін. Якщо ж ми звертаємося з таким запитом до API сервера, у відповідь зазвичай повертаються лише сирі дані без стилів та скриптів. У вікні браузера це виглядає приблизно так: <img data-id="20550be6-4530-4f91-bbc2-ebe81b50966c" data-max-width="1163" alt="Створюємо простий погодний бот для Telegram за кілька вечорів." src="https://cdn.javarush.com/images/article/20550be6-4530-4f91-bbc2-ebe81b50966c/1080.jpeg" style="width: 1163px;">Ці дані призначені не для людей, а для інших програм, тому нічого зайвого крім самої інформації в таких сторінках немає. Сирі дані найчастіше пересилають за одним із двох стандартів: JSON або XML. У кожного свої плюси та мінуси, однак, важливо розбиратися в обох. JSON ви вже бачабо на скрині вище, а ХМL виглядає так: <img data-id="7e1ac603-5f2e-4449-8338-7400d4bff9d5" data-max-width="1149" alt="Створюємо простий погодний бот для Telegram за кілька вечорів." src="https://cdn.javarush.com/images/article/7e1ac603-5f2e-4449-8338-7400d4bff9d5/1080.jpeg" style="width: 1149px;">Після недовгого пошуку, був знайдений англомовний проект Open Weather Map, який віддає дані безкоштовно, якщо не робити більше 50 запитів на хвабону. Для нас цього цілком достатньо, реєструємося, отримуємо унікальний токен(код), яким сервер буде знати, що ми не самозванці, а пристойні майбутні розробники. Заходимо на сторінку з API-документацією ( <a href="https://openweathermap.org/api" target="_blank" rel="nofollow">тиц</a> ), і з'ясовуємо, що прогноз на 5 днів у будь-якому місті можна отримати, якщо надіслати запит виду. 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java">https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>api<span class="token punctuation">.</span>openweathermap<span class="token punctuation">.</span>org<span class="token operator">/</span>data<span class="token operator">/</span><span class="token number">2.5</span><span class="token operator">/</span>forecast<span class="token operator">?</span>q<span class="token operator">=</span><span class="token punctuation">(</span>город<span class="token punctuation">)</span><span class="token operator">&amp;</span>APPID<span class="token operator">=</span><span class="token punctuation">(</span>уникальный токен<span class="token punctuation">,</span> полученный при регистрации<span class="token punctuation">)</span></code></pre> Ми вже з'ясували , що, по суті, потрібно <a href="https://samples.openweathermap.org/data/2.5/forecast?id=524901&amp;appid=b6907d289e10d714a6e88b30761fae22" target="_blank" rel="nofollow">просто</a> перейти за правильним посиланням і сервер видасть потрібні дані. Залишилося навчитися це робити засобами Java. Простий GET запит на Java виглядає так: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token comment">//создаём строку со ссылкой на нужную сторінку,</span>
<span class="token comment">//я тут её склеиваю из заранее определённых констант, меняя только сам город</span>
<span class="token class-name">String</span> urlString <span class="token operator">=</span> API_CALL_TEMPLATE <span class="token operator">+</span> city <span class="token operator">+</span> API_KEY_TEMPLATE<span class="token punctuation">;</span>
<span class="token comment">//создаём об'єкт который будет содержать ссылку</span>
<span class="token class-name">URL</span> urlObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">URL</span><span class="token punctuation">(</span>urlString<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//создаём соединение, используя об'єкт</span>
<span class="token class-name">HttpURLConnection</span> connection <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">HttpURLConnection</span><span class="token punctuation">)</span> urlObject<span class="token punctuation">.</span><span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//выбираем тип запита (GET)</span>
connection<span class="token punctuation">.</span><span class="token function">setRequestMethod</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//тут мы указываем, данные о себе, что мы можем принять всё то,</span>
<span class="token comment">//что примет и любой современный браузер</span>
connection<span class="token punctuation">.</span><span class="token function">setRequestProperty</span><span class="token punctuation">(</span><span class="token string">"User-Agent"</span><span class="token punctuation">,</span> <span class="token string">"Mozilla/5.0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//В начало ответа сервер всегда вставляет число, по которому можно судить, прошло ли всё хорошо.</span>
<span class="token comment">//200 - значит OK</span>
<span class="token keyword">int</span> responseCode <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">getResponseCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//на несуществующий город або город с опечаткой, сервер выдаст код ответа 404,</span>
<span class="token comment">//бросаем на него исключение, чтобы обработать на уровне повыше и предложить</span>
<span class="token comment">//пользователю ввести город заново</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>responseCode <span class="token operator">==</span> <span class="token number">404</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// создаём поток, вычитываем все строки, и склеиваем в одну большую строку,</span>
<span class="token comment">//которую будем потом обрабатывать в других методах</span>
<span class="token class-name">BufferedReader</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>connection<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> inputLine<span class="token punctuation">;</span>
<span class="token class-name">StringBuffer</span> response <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>inputLine <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     response<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>inputLine<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> response<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Якщо запит був коректним, а сервер - доступним, ми отримаємо простирадло даних, в якому корисна інформація перемішана з тим, що зараз не потрібне. Щоб зручно витягувати з JSON та XML потрібні дані, під Java написано тонни бібліотек на будь-який смак. Так як я віддав перевагу JSON, для його обробки вибрав дуже популярну бібліотеку під назвою Jackson. Вона, до речі, трохи вивчається на CodeGym на якихось високих рівнях. Для обробки великих обсягів JSON даних важливо розуміти структуру документа. На допомогу приходять корисні сайти на кшталт <a href="https://codebeautify.org/jsonviewer" target="_blank" rel="nofollow">цього</a> . Зліва у нас оригінальний JSON, праворуч - структурований: <img data-id="a9b49861-aab2-44cd-991c-145e3879f185" data-max-width="1408" alt="Створюємо простий погодний бот для Telegram за кілька вечорів." src="https://cdn.javarush.com/images/article/a9b49861-aab2-44cd-991c-145e3879f185/1080.jpeg" style="width: 1408px;"> Видно, що відповідь складається з 5 JSON-об'єктів вищого рівня, 2 з яких складні і є вузлами для наступних гілок. Дані, що цікавлять нас, зберігаються у вузлі <em>list</em>. Усередині <em>list</em> - масив із 38 JSON-рядків, у кожній описана погода у певний час. Тобто це така собі деревоподібна структура, де є корінь, гілки, гілочки і навіть листя :) А на вузлах якраз і відбувається розгалуження. На щастя, Jackson вміє представляти будь-який валідний JSON у вигляді дерева. Таким чином, знаючи як називається потрібний нам атрибут (наприклад, температура повітря), і на якому рівні дерева він знаходиться, дістати його не складе особливих проблем. Для початку я витягнув всі рядки з масиву "list" і додав їх в окремий список. Я, грубо кажучи, порізав простирадло з даними на шматки, кожен із яких – це окремий прогноз. Маленькі частини простіше пам'ятати і оперувати ними. 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token comment">//JsonNode - это один из узлов в древовидной иерархии, от которого идут ветви</span>
<span class="token comment">//получаем узел, который называется "list"</span>
<span class="token class-name">JsonNode</span> arrNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">readTree</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"list"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//если это действительно массив узлов</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>arrNode<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">//выполняем для каждого узла, который содержится в массиве</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">JsonNode</span> objNode <span class="token operator">:</span> arrNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">//в атрибуте "dt_txt" каждого маленького узла хранилось время прогноза, я отобрал данные за 9 утра и 6 вечера</span>
                <span class="token class-name">String</span> forecastTime <span class="token operator">=</span> objNode<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"dt_txt"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>forecastTime<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"09:00"</span><span class="token punctuation">)</span> <span class="token operator">||</span> forecastTime<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"18:00"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                weatherList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>objNode<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre> Так ми отримали список рядків, в якому кожен рядок є JSON-зведенням погоди в певний час. Залишилося отримати бажане та відформатувати. Якщо у нас є такий рядок: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token string">"main"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">"temp"</span><span class="token operator">:</span><span class="token number">261.45</span><span class="token punctuation">,</span><span class="token string">"temp_min"</span><span class="token operator">:</span><span class="token number">259.086</span><span class="token punctuation">,</span><span class="token string">"temp_max"</span><span class="token operator">:</span><span class="token number">261.45</span><span class="token punctuation">,</span><span class="token string">"pressure"</span><span class="token operator">:</span><span class="token number">1023.48</span><span class="token punctuation">,</span><span class="token string">"sea_level"</span><span class="token operator">:</span><span class="token number">1045.39</span><span class="token punctuation">,</span><span class="token string">"grnd_level"</span><span class="token operator">:</span><span class="token number">1023.48</span><span class="token punctuation">,</span><span class="token string">"humidity"</span><span class="token operator">:</span><span class="token number">79</span><span class="token punctuation">,</span><span class="token string">"temp_kf"</span><span class="token operator">:</span><span class="token number">2.37</span><span class="token punctuation">}</span></code></pre> це вузол під назвою "main". Щоб отримати з нього будь-які дані, наприклад рівень моря, достатньо такого коду: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token class-name">ObjectMapper</span> objectMapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//line - это наша JSON-строка</span>
mainNode <span class="token operator">=</span> objectMapper<span class="token punctuation">.</span><span class="token function">readTree</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"main"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> seaLevel <span class="token operator">=</span> mainNode<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"sea_level"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Jackson дозволяє відразу подавати дані у числовому форматі: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token keyword">double</span> seaLevel <span class="token operator">=</span> mainNode<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"sea_level"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asDouble</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Тепер ми можемо витягувати будь-які дані з прогнозу, і залишилося тільки їх склеїти, як забажається, і надіслати користувачеві Telegram. Повний вихідний код у мене на <a href="https://github.com/OlegSvidunov/FineWeatherBot" target="_blank" rel="nofollow">гітхабі</a> , а ось спробувати бота в дії можна <a href="https://web.telegram.org/#/im?p=@denifoBot" target="_blank" rel="nofollow">за посиланням</a> , або знайшовши @denifoBot у пошуку телеграм. Назва міста потрібно писати в латинській транслітерації, наприклад Kyiv або Moscow. Дякую, якщо подужали до кінця, приймаю розумну критику, бо тільки навчаюсь і напрацьовую простенькі проекти на гітхаб, щоб конкурувати з голодними талантами зі свого міста :) Всім поки що! PS Вважаю, що тут можуть бути друкарські помилки, тому можете все надсилати в особу, ну, або в коментарі, якщо ви дуже злі :)