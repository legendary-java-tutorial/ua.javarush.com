Посібник з мікросервісів Java. Частина 3: загальні питання
<p>----------------------------------------</p>
Переклад та адаптація . Попередні частини гайду: Давайте розглянемо властиві Java проблеми мікросервісів, починаючи з абстрактних речей і закінчуючи конкретними бібліотеками. Нагадаємо, що при створенні мікросервісів ви по суті змінюєте дзв
<p>----------------------------------------</p>
Переклад та адаптація <a href="https://www.marcobehler.com/guides/java-microservices-a-practical-guide#_deploying_and_testing_java_microservices" rel="nofollow" target="_blank">Java Microservices: A Practical Guide</a> . Попередні частини гайду: 
<ul>
 <li><a href="https://codegym.cc/groups/posts/2660-rukovodstvo-po-mikroservisam-java-chastjh-1-osnovih-mikroservisov-i-ikh-arkhitektura" target="_blank">основи мікросервісів та їх архітектура</a> ;</li>
 <li><a href="https://codegym.cc/groups/posts/2661-rukovodstvo-po-mikroservisam-java-chastjh-2-razvertihvanie-i-testirovanie" target="_blank">розгортання та тестування мікросервісів</a> .</li>
</ul>Давайте розглянемо властиві Java проблеми мікросервісів, починаючи з абстрактних речей і закінчуючи конкретними бібліотеками. <img data-max-width="800" data-id="cf3a526a-f8de-4b61-b8d2-b782c506671e" class="img-fluid" alt="Посібник з мікросервісів Java.  Частина 3: загальні питання - 1" src="https://cdn.javarush.com/images/article/cf3a526a-f8de-4b61-b8d2-b782c506671e/800.jpeg" style="width: 800px;">
<h3>Як зробити мікросервіс Java стійким?</h3>Нагадаємо, що при створенні мікросервісів ви по суті змінюєте дзвінки методів JVM на синхронні дзвінки HTTP або асинхронний обмін повідомленнями. В той час, як виконання виклику методу в основному гарантовано (за винятком несподіваного завершення роботи JVM), мережний виклик за замовчуванням ненадійний. Він може працювати, але може і не працювати з різних причин: перевантажена мережа, запровадабо нове правило брандмауера і таке інше. Щоб побачити, яке це має значення, погляньмо на приклад BillingService. 
<h2>Паттерни стійкості HTTP/REST</h2>Допустимо, клієнти можуть купити електронні книги на сайті вашої компанії. Для цього ви тільки-но впровадабо мікросервіс білінгу, який може викликати ваш інтернет-магазин для створення фактичних рахунків у форматі PDF. Зараз ми зробимо цей виклик синхронно, через HTTP (хоча розумніше викликати цю службу асинхронно, оскільки генерація PDF не обов'язково має бути миттєвою з точки зору користувача. Ми використовуємо цей приклад у наступному розділі і подивимося на відмінності). 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token annotation punctuation">@Service</span>
<span class="token keyword">class</span> <span class="token class-name">BillingService</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">HttpClient</span> client<span class="token punctuation">;</span>

     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bill</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">,</span> <span class="token class-name">Plan</span> plan<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Invoice</span> invoice <span class="token operator">=</span> <span class="token function">createInvoice</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> plan<span class="token punctuation">)</span><span class="token punctuation">;</span>
        httpClient<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token function">invoiceRequest</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getEmail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> invoice<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">responseHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre> Якщо узагальнити, ось три можливі результати цього HTTP-дзвінка. 
<ul>
 <li>ОК: дзвінок пройшов, рахунок успішно створено.</li>
 <li>ЗАТРИМКА: дзвінок пройшов, але знадобилося занадто багато часу для цього.</li>
 <li>ПОМИЛКА. Виклик не відбувся, можливо, ви надіслали несумісний запит або система не працювала.</li>
</ul>Від будь-якої програми очікують на обробку помилкових ситуацій, а не лише успішних. Те саме стосується і мікросервісів. Навіть якщо вам потрібно докласти додаткових зусиль для забезпечення сумісності всіх розгорнутих версій API, як тільки почнете з розгортань і випусків окремих мікросервісів. <img data-max-width="800" data-id="b1fcc533-d15c-484f-bbd4-f67db6eceed3" class="img-fluid" alt="Посібник з мікросервісів Java.  Частина 3: загальні питання - 2" src="https://cdn.javarush.com/images/article/b1fcc533-d15c-484f-bbd4-f67db6eceed3/800.jpeg" style="width: 800px;">Цікавий випадок, який варто звернути увагу, — випадок затримки. Наприклад, мікросервісний жорсткий диск респондента переповнений і замість 50 мс для відповіді потрібно 10 секунд. Ще цікавішим стає тоді, коли ви відчуваєте певне навантаження, так що нечуйність вашого BillingService починає каскадно проходити через вашу систему. Як наочний приклад уявіть кухню, що запускає "блок" всіх офіціантів ресторану. Цей розділ, очевидно, не може дати вичерпний огляд теми стійкості мікросервісів, але служить нагадуванням для розробників про те, що насправді це те, що потрібно вирішувати, а не ігнорувати до першого випуску (що, за досвідом, відбувається частіше, ніж слід). Популярною бібліотекою, яка допомагає вам думати про затримки та стійкість до відмов, є Hystrix від Netflix. 
<h4>Messaging Resilience Patterns.</h4>Розгляньмо асинхронну комунікацію. Наша програма BillingService тепер може виглядати приблизно так, за умови, що ми використовуємо Spring та RabbitMQ для обміну повідомленнями. Щоб створити рахунок, ми відправляємо повідомлення нашому брокеру повідомлень RabbitMQ, де є кілька працівників, які очікують нових повідомлень. Ці працівники створюють рахунки у форматі PDF та надсилають їх відповідним користувачам. 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token annotation punctuation">@Service</span>
<span class="token keyword">class</span> <span class="token class-name">BillingService</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">RabbitTemplate</span> rabbitTemplate<span class="token punctuation">;</span>

     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bill</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">,</span> <span class="token class-name">Plan</span> plan<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Invoice</span> invoice <span class="token operator">=</span> <span class="token function">createInvoice</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> plan<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// преобразует счет, например, в json и использует его як тело повідомлення</span>
        rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>exchange<span class="token punctuation">,</span> routingkey<span class="token punctuation">,</span> invoice<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre> Тепер потенційні помилки виглядають трохи інакше, тому що ви не отримуєте негайних відповідей OK або ERROR, як це було з синхронним HTTP-з'єднанням. Натомість у нас може бути три потенційні варіанти неправильного розвитку подій, які можуть викликати такі питання: 
<ol>
 <li>Чи було моє повідомлення доставлено та використано працівником? Чи це втрачено? (Користувач не отримує рахунок-фактуру).</li>
 <li>Моє повідомлення було доставлене лише один раз? Чи доставлено більше одного разу та обробляється лише один раз? (Користувач отримає кілька рахунків).</li>
 <li>Конфігурація: Від «Чи я використовував правильні ключі маршрутизації/імена для обміну» до «Чи правильно налаштований і підтримується мій брокер повідомлень або переповнені його черги?» (Користувач не отримує рахунок-фактуру).</li>
</ol>Детальний опис кожного окремого патерну стійкості асинхронного мікросервісу виходить за межі даного посібника. Проте тут є вказівники в правильному напрямку. Тим більше, що вони залежатимуть від технології обміну повідомленнями. Приклади: 
<ul>
 <li>Якщо ви використовуєте реалізації JMS, наприклад ActiveMQ, ви можете обміняти швидкість на гарантії двофазних (XA) коммітів (two-phase (XA) commits).</li>
 <li>Якщо ви використовуєте RabbitMQ, для початку прочитайте цей посібник, а потім добре обміркуйте підтвердження, відмовостійкість і надійність повідомлень в цілому.</li>
 <li>Можливо, хтось добре розуміється на конфігуруванні серверів Active або RabbitMQ, особливо у поєднанні з кластеризацією та Docker (хто-небудь?;))</li>
</ul>
<h3>Який фрейморк буде найкращим рішенням для мікросервісів Java?</h3>З одного боку, можна встановити дуже популярний варіант, такий як <a href="https://spring.io/projects/spring-boot" rel="nofollow" target="_blank">Spring Boot</a> . Він дозволяє легко створювати файли .jar, що поставляється з вбудованим веб-сервером, таким як Tomcat або Jetty, і який можна запустити швидко і будь-де. Ідеально підходить для створення програм мікросервісу. Нещодавно з'явилася пара спеціалізованих мікросервісних фреймворків <a href="https://kubernetes.io/" rel="nofollow" target="_blank">Kubernetes</a> або <a href="https://www.graalvm.org/" rel="nofollow" target="_blank">GraalVM</a> , частково натхнених реактивним програмуванням. Ось ще кілька цікавих претендентів: <a href="https://quarkus.io/" rel="nofollow" target="_blank">Quarkus</a> , <a href="https://micronaut.io/" rel="nofollow" target="_blank">Micronaut</a> , <a href="https://vertx.io/" rel="nofollow" target="_blank">Vert.x</a> , <a href="https://helidon.io/#/" rel="nofollow" target="_blank">Helidon</a>. Зрештою, вам доведеться вибирати самостійно, але ми можемо дати вам кілька рекомендацій, можливо, не цілком стандартних: За винятком Spring Boot, всі платформи мікросервісів зазвичай позиціонуються як неймовірно швидкі, з майже миттєвим запуском, малим об'ємом пам'яті, що використовується, можливістю масштабування до нескінченності. У маркетингових матеріалах зазвичай фігурують вражаючі графіки, що представляють платформу у вигідному світлі поруч із “бегемотом” Spring Boot чи друг з одним. Це за ідеєю щадить нерви розробників, що підтримують легаси-проекти, які часом завантажуються по кілька хвабон. Або розробникам, які працюють у хмарі, які хочуть запустити стільки мікроконтейнерів, скільки їм зараз потрібно протягом 50 мс. <img data-max-width="800" data-id="81482268-0c40-474e-aafc-89c9ed55a5f5" class="img-fluid" alt="Посібник з мікросервісів Java.  Частина 3: загальні питання – 3" src="https://cdn.javarush.com/images/article/81482268-0c40-474e-aafc-89c9ed55a5f5/800.jpeg" style="width: 800px;">Проблема, однак, полягає в тому, що такий (штучний) час старту «голого заліза» та час повторного розгортання навряд чи впливають на загальний успіх проекту. Принаймні впливають набагато менше, ніж сильна фреймворкова інфраструктура, сильна документація, спільнота і сильні навички розробника. Так що краще дивитися на це так: Якщо досі: 
<ul>
 <li>Ви дозволяєте своїм ORM працювати у режимі нестримної генерації сотень запитів для простих робочих процесів.</li>
 <li>Вам потрібні нескінченні гігабайти для запуску моноліту помірної складності.</li>
 <li>У вас так багато коду і складність настільки висока (зараз ми говоримо не про потенційно повільні стартери, такі як Hibernate), що вашому додатку потрібно кілька хвабон для завантаження.</li>
</ul>Якщо справа саме так, то додавання додаткових мікосервісних проблем (відмовостійкість, обмін повідомленнями, DevOps, інфраструктура) набагато більше вплине на ваш проект, ніж завантаження порожнього Hello, world. А для гарячих повторних розгортань під час розробки вам можуть стати в нагоді такі рішення, як <a href="https://www.jrebel.com/products/jrebel" rel="nofollow" target="_blank">JRebel</a> або <a href="http://dcevm.github.io/" rel="nofollow" target="_blank">DCEVM</a> . Не полінуємося знову процитувати <a href="https://www.marcobehler.com/guides/java-microservices-a-practical-guide#simon-brown" rel="nofollow" target="_blank">Саймона Брауна</a> : " <span class="text-bold">якщо люди не можуть створювати (швидкі та ефективні) моноліти, їм буде важко створювати (швидкі та ефективні) мікросервіси незалежно від структури</span> ". Тож вибирайте фрейморки з розумом. 
<h3 id="topic1">Які бібліотеки найкраще підходять для синхронних викликів Java REST?</h3>На низькорівневому технічному боці ви, ймовірно, отримаєте одну з наступних клієнтських бібліотек HTTP: Власний <a href="https://openjdk.java.net/groups/net/httpclient/intro.html" rel="nofollow" target="_blank">HttpClient Java</a> (починаючи з Java 11), <a href="https://hc.apache.org/httpcomponents-client-4.5.x/index.html" rel="nofollow" target="_blank">HttpClient Apache</a> або <a href="https://square.github.io/okhttp/" rel="nofollow" target="_blank">OkHttp</a> . Зверніть увагу, що тут я говорю «ймовірно», тому що є й інші варіанти, починаючи зі старих добрих <a href="https://github.com/jax-rs" rel="nofollow" target="_blank">клієнтів JAX-RS</a> до сучасних клієнтів <a href="https://www.oracle.com/technical-resources/articles/java/jsr356.html" rel="nofollow" target="_blank">WebSocket</a> . У будь-якому випадку, існує тенденція до генерації HTTP-клієнта, з відходом від самостійної метушні з HTTP-викликами. Для цього вам потрібно поглянути на проект <a href="https://github.com/OpenFeign/feign" rel="nofollow" target="_blank">OpenFeign</a> та його документацію як відправну точку для подальшого читання. 
<h3 id="topic2">Які брокери найкращі для асинхронного обміну повідомленнями Java?</h3>Швидше за все, ви зіткнетеся з популярними <a href="https://activemq.apache.org/" rel="nofollow" target="_blank">ActiveMQ (Classic або Artemis)</a> , <a href="https://www.rabbitmq.com/" rel="nofollow" target="_blank">RabbitMQ</a> або <a href="https://kafka.apache.org/" rel="nofollow" target="_blank">Kafka</a> . 
<ul>
 <li>ActiveMQ та RabbitMQ є традиційними, повноцінними брокерами повідомлень. Вони передбачають взаємодію "розумного брокера" і "дурненьких користувачів".</li>
 <li>Історично ActiveMQ мав перевагу простого вбудовування (для тестування), яке можна пом'якшити за допомогою налаштувань RabbitMQ/Docker/TestContainer.</li>
 <li>Kafka не можна назвати традиційним "розумним" брокером. Навпаки, це «дурне» сховище повідомлень (файл журналу), для обробки якого потрібні розумні споживачі.</li>
</ul>Щоб краще зрозуміти, коли використовувати RabbitMQ (або інші традиційні брокери повідомлень в цілому) або Kafka, погляньте на<a href="https://content.pivotal.io/blog/understanding-when-to-use-rabbitmq-or-apache-kafka" rel="nofollow" target="_blank"> цю посаду в Pivotal</a>(англійською мовою) як відправна точка. Загалом, коли вибираєте брокер обміну повідомленнями, намагайтеся ігнорувати штучні причини продуктивності. Був час, коли команди та інтернет-спільноти постійно сперечалися про те, наскільки швидким був RabbitMQ та наскільки повільним ActiveMQ. Тепер ті ж аргументи наводяться щодо RabbitMQ, мовляв, він повільно працює з 20-30 тисячами повідомлень за секунду. У Kafka фіксується 100 тисяч повідомлень за секунду. Відверто кажучи, такі порівняння подібні до порівняння теплого з м'яким. Крім того, в обох випадках значення пропускної спроможності можуть бути на нижньому або середньому рівні, скажімо, Alibaba Group. Однак ви навряд чи стикалися з проектами такого масштабу (мільйони повідомлень за хвабону) насправді. Вони безперечно існують, і у них були б проблеми. На відміну від решти 99% "звичайних" бізнес-проектів Java. Так що не звертайте уваги на моду та хайп. Вибирайте з розумом. 
<h3>Які бібліотеки я можу використати для тестування мікросервісів?</h3>Це залежить від вашого стека. Якщо у вас розгорнута екосистема Spring, буде розумно використовувати <a href="https://spring.io/guides/gs/testing-web/" rel="nofollow" target="_blank">спеціальні інструменти цього фреймворку</a> . Якщо JavaEE - щось на зразок <a href="http://arquillian.org/" rel="nofollow" target="_blank">Arquillian</a> . Можливо, варто подивитися на Docker і справді хорошу бібліотеку <a href="https://www.testcontainers.org/" rel="nofollow" target="_blank">Testcontainers</a> , яка допомагає, зокрема, легко та швидко налаштувати базу даних Oracle для локальних тестів розробки чи інтеграції. Для мок-тестів цілих HTTP-серверів, зверніть увагу на <a href="http://wiremock.org/" rel="nofollow" target="_blank">Wiremock</a> . Для тестування асинхронного обміну повідомленнями спробуйте впровадити ActiveMQ або RabbitMQ, а потім написати тести за допомогою <a href="https://github.com/awaitility/awaitility" rel="nofollow" target="_blank">Awaitility DSL</a> . Крім цього, застосовуються всі ваші звичні інструменти - <a href="https://junit.org/junit5/" rel="nofollow" target="_blank">Junit</a> , <a href="https://testng.org/doc/" rel="nofollow" target="_blank">TestNG</a>для <a href="https://joel-costigliola.github.io/assertj/" rel="nofollow" target="_blank">AssertJ</a> і <a href="https://site.mockito.org/" rel="nofollow" target="_blank">Mockito</a> . Зверніть увагу, що це далеко не повний перелік. Якщо раптом ви не знайшли тут ваш улюблений інструмент, опублікуйте його в розділі коментарів. 
<h3>Як увімкнути логування для всіх мікросервісів Java?</h3>Логування у випадку з мікросервісами – цікава та досить складна тема. Замість одного файлу лога, з яким ви можете працювати за допомогою команд less або grep, тепер у вас є n файлів логування, і бажано, щоб вони не були занадто розрізнені. Добре розписані особливості екосистеми логування у <a href="https://www.marcobehler.com/guides/a-guide-to-logging-in-java" rel="nofollow" target="_blank">цій статті</a> (англійською мовою). Обов'язково прочитайте його і зверніть увагу на розділ <span class="text-bold">Централізоване ведення лога з точки зору мікросервісів</span>. На практиці ви зіткнетеся з різними підходами: Системний адміністратор пише певні сценарії, які збирають та об'єднують файли логів з різних серверів в один файл логів та поміщають їх на FTP-сервери для завантаження. Запуск комбінацій cat/grep/unig/sort у паралельних SSH-сесіях. Саме так чинить Amazon AWS, про що ви можете повідомити свого менеджера. Використовуйте такий інструмент, як <a href="https://www.graylog.org/" rel="nofollow" target="_blank">Graylog</a> або <a href="https://www.elastic.co/what-is/elk-stack" rel="nofollow" target="_blank">ELK Stack (Elasticsearch, Logstash, Kibana)</a>
<h3>Як мої мікросервіси знаходять одне одного?</h3>Досі ми припускали, що наші мікросервіси знають один про одного, знають відповідний IPS. Поговоримо про статичне налаштування. Отже, наш банківський моноліт [ip = 192.168.200.1] знає, що йому потрібно поговорити з ризик-сервером [ip = 192.168.200.2], який захардкожен у файлі properties. Однак ви можете зробити все динамічнішим: 
<ul>
 <li>Використовуйте хмарний сервер конфігурації, з якого всі мікросервіси виймають конфігурації замість розгортання файлів application.properties на своїх мікросервісах.</li>
 <li>Оскільки екземпляри ваших служб можуть динамічно змінювати своє розташування, варто придивитися до служб, які знають, де живуть ваші служби, які IP і як їх маршрутизувати.</li>
 <li>Тепер, коли все динамічно, з'являються нові проблеми, такі як автоматичне обрання лідера: хто є майстром, який працює над певними завданнями, щоб, наприклад, не обробити їх двічі? Хто заміняє лідера, коли він зазнає невдачі? За яким принципом відбувається заміна?</li>
</ul>Загалом, це те, що називається мікросервісним оркеструванням і воно є ще однією бездонною темою. Такі бібліотеки, як <a href="https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance" rel="nofollow" target="_blank">Eureka</a> або <a href="https://zookeeper.apache.org/" rel="nofollow" target="_blank">Zookeeper</a> , намагаються "вирішити" ці проблеми, показуючи які служби доступні. З іншого боку, вони приносять додаткову складність. Запитайте будь-кого, хто колись встановлював ZooKeeper. 
<h3>Як організувати авторизацію та аутентифікацію за допомогою мікросервісів Java?</h3>Ця тема також варта окремої розповіді. Знову ж таки, варіанти варіюються від захардшкіреної базової автентифікації HTTPS із самописними фреймфорками безпеки до запуску установки Oauth2 із власним сервером авторизації. 
<h3>Як переконатись, що всі мої оточення виглядають однаково?</h3>Те, що правильне для розгортань без мікросервісу, також вірно і для розгортань з ним. Спробуйте комбінацію Docker/Testcontainers, а також Scripting/Ansible. 
<h3>Не питання: коротко про YAML</h3>Давайте ненадовго відійдемо від бібліотек та пов'язаних із ними питань і коротко розглянемо Yaml. Цей формат файлу використовується де-факто як формат для «запису конфігурації у вигляді коду». Використовують його і прості інструменти, на зразок Ansible і гіганти на кшталт Kubernetes. Щоб випробувати біль від відступів в YAML, спробуйте написати простий Ansible-файл і подивіться, скільки вам доведеться редагувати файл, перш ніж він запрацює як треба. І це незважаючи на підтримку формату всіма великими IDE! Після цього повертайтеся, щоб дочитати цей посібник. 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token class-name">Yaml</span><span class="token operator">:</span>
  <span class="token operator">-</span> is<span class="token operator">:</span>
    <span class="token operator">-</span> so
    <span class="token operator">-</span> great</code></pre>
<h3>А як щодо розподілених транзакцій? Тестування продуктивності? Інші теми?</h3>Може, колись у наступних редакціях керівництва. А поки що все. Залишайтеся з нами! 
<h2>Концептуальні проблеми мікросервісів</h2>Крім специфічних проблем мікросервісів Java, є й інші проблеми, скажімо, ті, які з'являються в будь-якому мікросервісному проекті. Вони стосуються переважно організації, команди та управління. 
<h3>Невідповідність Frontend та Backend</h3>Невідповідність Frontend та Backend — дуже поширена проблема багатьох мікросервісних проектів. Що вона означає? Лише те, що в старих добрих монолітах, розробники веб-інтерфейсу мали одне конкретне джерело для отримання даних. У мікросервісних проектах у розробників веб-інтерфейсу зненацька з'являються n джерел для отримання даних. Уявіть, що ви створюєте проект мікросервісів IoT (інтернет речей) на Java. Скажімо, управляєте геодезичними машинами, промисловими печами по всій Європі. І ці печі регулярно відправляють вам оновлення із зазначенням їх температури тощо. Рано чи пізно ви, можливо, захочете знайти печі в інтерфейсі користувача адміністратора, можливо, за допомогою мікросервісів «пошуку печі». Залежно від того, наскільки строго ваші бекенд-колеги застосовують<span class="text-bold">предметно-орієнтоване проектування</span> чи закони мікросервісів, мікросервіс “знайти піч” може повертати лише ідентифікатори печей, а чи не інші дані, такі як тип, модель чи місцезнаходження. Для цього фронтенд-розробникам потрібно буде виконати один або n додаткових викликів (залежно від реалізації пейджингу) у мікросервісі «отримати дані про печі» з ідентифікаторами, які вони отримали від першого мікросервісу. <img data-max-width="800" data-id="e7b2ca26-43c9-4ed5-a3c2-103b0e34c052" class="img-fluid" alt="Посібник з мікросервісів Java.  Частина 3: загальні питання – 4" src="https://cdn.javarush.com/images/article/e7b2ca26-43c9-4ed5-a3c2-103b0e34c052/800.jpeg" style="width: 800px;">І хоча це лише простий приклад, нехай і взятий із реального (!) проекту, навіть він демонструє наступну проблему: супермаркети стали надзвичайно популярними. А все тому, що з ними вам не потрібно йти в 10 різних місць, щоб купити овочі, лимонад, заморожену піцу та туалетний папір. Натомість ви йдете в одне місце. Це простіше і швидше. Те саме стосується розробників інтерфейсів та мікросервісів. 
<h2>Очікування керівництва</h2>У менеджменту складається помилкове враження, що тепер потрібно наймати нескінченну кількість розробників у (всеосяжний) проект, оскільки розробники тепер можуть працювати абсолютно незалежно один від одного, кожен на своєму мікросервісі. Наприкінці потрібна лише невелика робота з інтеграції (незадовго до запуску). <img data-max-width="800" data-id="6d63eedb-63e1-4ef6-94ae-d3405cafc594" class="img-fluid" alt="Посібник з мікросервісів Java.  Частина 3: загальні питання – 5" src="https://cdn.javarush.com/images/article/6d63eedb-63e1-4ef6-94ae-d3405cafc594/800.jpeg" style="width: 800px;">Насправді такий підхід є вкрай проблематичним. У наступних параграфах ми намагатимемося пояснити, чому. 
<h2>"Менші шматочки" не одно "кращі шматочки"</h2>Буде великою помилкою вважати, що розділений на 20 частин код обов'язково буде якісніше одного цільного шматка. Навіть якщо взяти якість з суто технічної точки зору: наші окремі служби, як і раніше, можуть виконувати 400 запитів Hibernate для вибору користувача з бази даних, проходячи по шарах коду, що не підтримується. Вкотре повертаємося до цитати Саймона Брауна: якщо не вдасться побудувати моноліти належним чином, буде складно створити належні мікросервіси. Найчастіше про стійкість до відмови в мікросервісних проектах вкрай несвоєчасно. Настільки, що часом страшно дивитися, як мікросервіси працюють у реальних проектах. Причина цього полягає в тому, що Java-розробники не завжди готові вивчати стійкість до відмов, мережі та інші суміжні теми на належному рівні. Самі "шматочки" - менше, а ось "технічних частин" - більше. Уявіть, що вашій мікросервісній команді пропонується написати технічний мікросервіс для входу в систему бази даних приблизно такою: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token annotation punctuation">@Controller</span>
<span class="token keyword">class</span> <span class="token class-name">LoginController</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/login"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">User</span> user <span class="token operator">=</span> userDao<span class="token punctuation">.</span><span class="token function">findByUserName</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>user <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// обработка варианта с несуществующим пользователем</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>user<span class="token punctuation">.</span><span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token function">hashed</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// обработка неверного пароля</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 'Ю-ху, залогинабось!';</span>
        <span class="token comment">// установите cookies, делайте, что угодно</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre> Тепер ваша команда може вирішити (і, можливо, навіть переконати людей бізнесу), мовляв, це все надто просто і нудно, краще замість служби входу в систему написати дійсно корисний мікросервіс UserStateChanged (зміна стану користувача) без будь-яких реальних та відчутних бізнес- вимог. А оскільки до Java зараз деякі люди ставляться як до динозавра, напишемо наш мікросервіс UserStateChanged на модному Erlang. І давайте спробуємо де-небудь використовувати червоно-чорні дерева, тому що Стів Єгге написав, що ви повинні знати їх зсередини, щоб подати заявку в Google. З погляду інтеграції, обслуговування та загального проекту це так само погано, як написання шарів спагетті-коду всередині одного моноліту. Штучний та пересічний приклад? Так і є. Проте подібне може бути і насправді. 
<h2>Менше шматочки - менше розуміння</h2>Потім природним чином спливає питання про розуміння системи в цілому, її процесів і робочих потоків, але при цьому ви як розробник несете відповідальність тільки за роботу на своєму ізольованому мікросервісі [95: login-101: updateUserProfile]. Він гармонує з попереднім параграфом, але залежно від вашої організації, рівня довіри та комунікації це може призвести до великої кількості подиву, знизувань плечима, звинувачень у разі випадкової поломки в мікросервісному ланцюжку. І немає того, хто б прийняв на себе повну відповідальність за те, що сталося. І справа зовсім не в несумлінності. Насправді дуже важко поєднати різні детальки та зрозуміти їхнє місце у загальній картині проекту. 
<h2>Комунікації та обслуговування</h2>Рівень комунікації та обслуговування залежить від розміру компанії. Проте, загальна залежність очевидна: що більше, то проблематичніше. 
<ul>
 <li>Хто працює на мікросервісі №47?</li>
 <li>Вони щойно розгорнули нову несумісну версію мікросервісу? Де це було задокументовано?</li>
 <li>З ким мені потрібно поговорити, щоб запитити нову функцію?</li>
 <li>Хто підтримуватиме той мікросервіс на Erlang, після того, як єдиний хто знав цю мову покинув компанію?</li>
 <li>Усі наші мікросервісні команди працюють не тільки різними мовами програмування, але й у різних часових поясах! Як ми це правильно скоординуємо?</li>
</ul><img data-max-width="800" data-id="e600574d-255a-47a7-ae88-90390da6e8d9" class="img-fluid" alt="Посібник з мікросервісів Java.  Частина 3: загальні питання - 6" src="https://cdn.javarush.com/images/article/e600574d-255a-47a7-ae88-90390da6e8d9/800.jpeg" style="width: 800px;">Головна думка полягає в тому, що як і у випадку з DevOps, повноцінний підхід до мікросервісів у великій, можливо навіть міжнародній компанії, пов'язаний з купою додаткових комунікаційних проблем. І компанія має серйозно до цього підготуватись. <a href="https://codegym.cc/welcome" target="_blank"><img id="click_banner1_articles" data-max-width="1024" data-id="0b611c35-5c14-4765-80c7-9c0ebb09e63b" class="img-fluid" alt="Посібник з мікросервісів Java.  Частина 3: загальні питання – 7" src="https://cdn.javarush.com/images/article/0b611c35-5c14-4765-80c7-9c0ebb09e63b/1024.jpeg" style="width: 1024px;"></a>
<h2>Висновки</h2>Прочитавши цю статтю, ви можете вирішити, що автор - затятий противник мікросервісів. Це не зовсім правильно - я здебільшого намагаюся виділити моменти, на які мало хто звертає увагу в шалених перегонах за новими технологіями. 
<h3>Мікросервіси чи моноліт?</h3>Використання Java-мікросервісів завжди і скрізь це одна крайність. Інший виявляється щось на кшталт сотень старих добрих модулів Maven у моноліті. Ваше завдання знайти правильний баланс. Особливо це стосується нових проектів. Тут вам ніщо не завадить дотримуватись більш консервативного, “монолітного” підходу та створювати меншу кількість хороших модулів Maven, замість того, щоб починати з двадцяти мікросервісів, готових до роботи у хмарах. 
<h3>Мікросервіси генерують додаткову складність</h3>Майте на увазі, що чим більше у вас мікросервісів і чим менше у вас дійсно потужних DevOps'ів (ні, запуск пари-трійки сценаріїв Ansible або розгортання на Heroku не вважається!), тим більше проблем у вас виникне пізніше у роботі. Навіть просто прочитати до кінця розділ цього посібника, присвячений загальним питанням про мікросервіси Java - досить стомлююче заняття. Добре подумайте про реалізацію рішень для всіх цих інфраструктурних завдань, і ви раптово зрозумієте, що все це більше не пов'язане з бізнес-програмуванням (за що вам платять), а скоріше з фіксацією більшої кількості технологій на більшій кількості технологій. Шива Прасад Редді відмінно резюмував у <a href="http://sivaprasadreddy.com/posts/2019/06/the-ugly-truth/" rel="nofollow" target="_blank">своєму блозі</a> : <span class="text-bold">"Ви не уявляєте собі, як це жахливо, коли команда 70% часу бореться з цією сучасною інфраструктурою і лише 30% часу залишається на реальну бізнес-логіку"</span> <span style="text-alige:right;"> Шива Прасад Редді</span>
<h3>Чи варто створювати мікросервіси Java?</h3>Щоб відповісти на це питання, я хотів би закінчити цю статтю дуже зухвалою, схожою на співбесіду в Google тизером. Якщо ви знаєте відповідь на це питання за своїм досвідом, навіть якщо він, мабуть, не має нічого спільного з мікросервісами, ви можете бути готові до мікросервісного підходу. 
<h3>Сценарій</h3>Уявіть, що у вас є Java-моноліт, що працює один на самому маленькому виділеному сервері <a href="https://www.hetzner.de/dedicated-rootserver/matrix-ex" rel="nofollow" target="_blank">Hetzner</a> . Те саме стосується і вашого сервера баз даних, він також працює на аналогічній машині <a href="https://www.hetzner.de/dedicated-rootserver/matrix-ex" rel="nofollow" target="_blank">Hetzner</a> . І давайте також припустимо, що ваш Java-моноліт може обробляти робочі процеси, скажімо, реєстрацію користувачів, і ви створюєте не сотні запитів до бази даних на робочий процес, а розумнішу кількість (&lt;10). 
<h4>Питання</h4>Скільки з'єднань з базою даних має відкрити моноліт Java (пул з'єднань) на вашому сервері баз даних? Чому так? Як ви вважаєте, скільки активних користувачів одночасно може (приблизно) масштабувати ваш моноліт? 
<h4>Відповідь</h4>Залишіть свою відповідь на ці запитання у розділі коментарів. Я з нетерпінням чекаю на всі відповіді. <img data-max-width="800" data-id="cce2a448-fe19-4d78-8abf-b00a8f78a586" class="img-fluid" alt="Посібник з мікросервісів Java.  Частина 3: загальні питання – 8" src="https://cdn.javarush.com/images/article/cce2a448-fe19-4d78-8abf-b00a8f78a586/800.jpeg" style="width: 800px;">Тепер наважуйтесь. Якщо ви дочитали до кінця, ми дуже вам вдячні!