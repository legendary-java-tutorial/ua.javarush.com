Реалізуємо розгортання програми - "Java-проект від А до Я"
<p>----------------------------------------</p>
Всім привіт. Продовжуємо цикл статей щодо написання свого проекту. З важливого, щоб не загубитися у гілках та їх порядку в репозиторії, я вирішив їх перейменувати, додавши приставку . Наприклад, у нас є три гілки, крім головної: Відразу не 
<p>----------------------------------------</p>
Всім привіт. Продовжуємо цикл статей щодо написання свого проекту. <img data-max-width="800" data-id="b90d4b3b-cbf0-4c7e-a6df-945302d7f20a" alt="&quot;Java-проект від А до Я&quot;: Реалізуємо розгортання програми - 1" src="https://cdn.javarush.com/images/article/b90d4b3b-cbf0-4c7e-a6df-945302d7f20a/800.jpeg" style="width: 800px;">
<h2>Сортуємо гілки</h2>З важливого, щоб не загубитися у гілках та їх порядку в репозиторії, я вирішив їх перейменувати, додавши <span class="text-bold">STEP_{number}</span> приставку . Наприклад, у нас є три гілки, крім головної:
<ul>
 <li>JRTB-0</li>
 <li>JRTB-2</li>
 <li>JRTB-3</li>
</ul>Відразу не зрозумієш, яка за якою має йти. Тому я їх перейменую так:
<ul>
 <li>STEP_1_JRTB-0 - перший крок</li>
 <li>STEP_2_JRTB-2 - другий крок</li>
 <li>STEP_3_JRTB-3 - третій крок</li>
</ul>І так далі для наступних статей. Щоб перейменувати гілки, заходимо на <a href="https://github.com/codegymcommunity/codegym-telegrambot" rel="nofollow" target="_blank">сторінку репозиторію</a> , знаходимо плашку <span class="text-bold">branches</span> , переходимо по ній: <img data-max-width="1080" data-id="12e7cd1d-e782-4c9e-996f-07fd1469d62b" alt="&quot;Java-проект від А до Я&quot;: Реалізуємо розгортання програми - 2" src="https://cdn.javarush.com/images/article/12e7cd1d-e782-4c9e-996f-07fd1469d62b/1080.jpeg" style="width: 1080px;">Під кожною гілкою натискаємо на олівець і перейменовуємо гілку: <img data-max-width="512" data-id="2083743b-d4d8-4f7e-94b2-1d736d6ebf22" alt="&quot;Java-проект від А до Я&quot;: Реалізуємо розгортання програми - 3" src="https://cdn.javarush.com/images/article/2083743b-d4d8-4f7e-94b2-1d736d6ebf22/512.jpeg" style="width: 512px;">І в результаті отримаємо: <img data-max-width="1080" data-id="facd6ae3-25f3-4b7a-bc7c-d30973d5a772" alt="&quot;Java-проект від А до Я&quot;: Реалізуємо розгортання програми - 4" src="https://cdn.javarush.com/images/article/facd6ae3-25f3-4b7a-bc7c-d30973d5a772/1080.jpeg" style="width: 1080px;">До речі, всі, хто підписаний на <a href="https://t.me/romankh3" rel="nofollow" target="_blank">мій телеграм-канал</a> , дізналися відразу ж, що я перейменував гілки.
<h2>Трохи про докер</h2>Що таке Docker? Коротко це інструмент, за допомогою якого можна швидко і безпечно розгортати (деплоїти) програми, створюючи для них закриту інфраструктуру, необхідну тільки для них. Поки що складно, я розумію. Загалом докер можна розуміти як платформу для розробки, де можна швидко і ефективно працювати. Докер можна розуміти як програму, яка працює на сервері. Ця програма може зберігати контейнери з додатками. Що таке контейнер? Це окрема інфраструктура, до якої можна додати все, що потрібно. Наприклад, для Java-програми нам потрібна JRE, щоб запустити програму, ось контейнер буде мати це, потрібно буде ще якесь програмне забезпечення — можна додати це. А можливо, нам потрібен Лінукс і Tomcat сервлет контейнер. Таке також можна буде зробити. Контейнери створюються на основі image (образу): тобто, це певний шаблон, в якому написано все необхідне для створення докеру контейнера. Як створити цей образ? У нашому випадку нам потрібно буде створити файл Dockerfile у корені проекту з описом того, що має бути у контейнері. Так як ми не хочемо десь показувати токен бота, доведеться викрутитися і передавати його щоразу, коли ми захочемо розгортати програму. Більш детально про цю тему можна почитати коли ми захочемо розгортати програму. Більш детально про цю тему можна почитати коли ми захочемо розгортати програму. Більш детально про цю тему можна почитати<a href="https://habr.com/ru/post/253877/" rel="nofollow" target="_blank">тут</a> і <a href="https://habr.com/ru/post/309556/" rel="nofollow" target="_blank">тут</a> .
<h2>Пишемо JRTB-13</h2>Потрібно налаштувати швидкий та легкий процес розгортання (деплою) нашої програми на сервер. Тобто на машину, яка працює 24/7. За основу візьмемо докер. Але завдання у нашому списку, яка б відповідала за додавання цієї функціональності, немає. Якось я його пропустив під час створення. Нічого страшного зараз створимо. Заходимо на вкладку <a href="https://github.com/codegymcommunity/codegym-telegrambot/issues/new/choose" rel="nofollow" target="_blank">створення issue</a> на гітхаб і вибираємо Feature Request: <img data-max-width="1080" data-id="5013c175-6776-4d30-860e-55a733150703" alt="&quot;Java-проект від А до Я&quot;: Реалізуємо розгортання програми - 5" src="https://cdn.javarush.com/images/article/5013c175-6776-4d30-860e-55a733150703/1080.jpeg" style="width: 1080px;">Додаємо опис завдання, критерії його приймання, встановлюємо, до якого проекту цей issue відноситься і можна створювати нове issue: <img data-max-width="1080" data-id="47809c3f-cd45-41c7-9726-ee2e07e38b57" alt="&quot;Java-проект від А до Я&quot;: Реалізуємо розгортання програми - 6" src="https://cdn.javarush.com/images/article/47809c3f-cd45-41c7-9726-ee2e07e38b57/1080.jpeg" style="width: 1080px;">Тепер щоб показати, що <a href="https://github.com/codegymcommunity/codegym-telegrambot/issues/18" rel="nofollow" target="_blank">завдання</a> взято в роботу, змінимо статус завдання з To do на In Progress:<img data-max-width="1080" data-id="ff6e6f4d-75a2-4c4b-b5be-b01b2473b6ba" alt="&quot;Java-проект від А до Я&quot;: Реалізуємо розгортання програми - 7" src="https://cdn.javarush.com/images/article/ff6e6f4d-75a2-4c4b-b5be-b01b2473b6ba/1080.jpeg" style="width: 1080px;">Це буде найскладніша стаття. Якщо будуть проблеми — пишіть у коментарях: я стежитиму і відповідатиму на них у міру сил. Такою буде невелика Customer Support :D
<h2>Створюємо Dockerfile</h2>Що таке докерфайл? Для докера це скрипт (покрокова інструкція), як створювати образ для докеру контейнера. Для роботи нашої програми потрібна JDK, причому 11 версії. Тобто нам потрібно знайти докер-образ JDK 11 і додати його до нашого образу. Це щось схоже на те, як ми додаємо залежність до пам'ятника. Для цієї справи у докера є <a href="https://hub.docker.com/" rel="nofollow" target="_blank">DockerHub</a> . Щоб локально завантажувати образи, потрібно зареєструватися. Після реєстрації йдемо шукати нам JDK11. З того, що вдалося знайти - ось цей контейнер: <a href="https://hub.docker.com/r/adoptopenjdk/openjdk11/" rel="nofollow" target="_blank">adoptopenjdk/openjdk11</a> . В описі цього контейнера є те, що потрібно для докерфайлу: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><code class=" language-java">FROM adoptopenjdk<span class="token operator">/</span>openjdk11<span class="token operator">:</span>ubi
RUN mkdir <span class="token operator">/</span>opt<span class="token operator">/</span>app
COPY japp<span class="token punctuation">.</span>jar <span class="token operator">/</span>opt<span class="token operator">/</span>app
CMD <span class="token punctuation">[</span><span class="token string">"java"</span><span class="token punctuation">,</span> <span class="token string">"-jar"</span><span class="token punctuation">,</span> <span class="token string">"/opt/app/japp.jar"</span><span class="token punctuation">]</span></code></pre> Виправимо папку, з якої ми беремо jar файл. У нас він знаходиться в target папці після того, як ми запускаємо mvn package завдання мавену. Перед тим, як все це робити, на основі оновленої main гілки створюємо нову, для нашого завдання: <span class="text-bold">STEP_4_JRTB-13</span> . Тепер можна працювати. У корені проекту створюємо файл без розширення <span class="text-bold">Dockerfile</span> і додамо всередину наступне: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><code class=" language-java">FROM adoptopenjdk<span class="token operator">/</span>openjdk11<span class="token operator">:</span>ubi
<span class="token class-name">ARG</span> JAR_FILE<span class="token operator">=</span>target<span class="token comment">/*.jar
COPY ${JAR_FILE} app.jar
ENTRYPOINT ["java","-jar","/app.jar"]</span></code></pre> Перший рядок — на основі чого складатиметься образ — adoptopenjdk/openjdk11. Другий рядок - додаємо аргумент в образ з ім'ям JAR_FILE, який знаходиться в папці target. Причому поточна папка визначається за місцем Dockerfile. Третій рядок - копіюємо в докер-образ jar нашого проекту. Останній рядок містить масив, створений з команди в терміналі, яку розділабо за пробілом. Тобто, в результаті буде виконано наступне: "java -jar /app.jar" Щоб тримати в таємниці токен бота, при запуску контейнера нам потрібно буде передавати дві змінні - ім'я бота та його токен. Для цього напишемо запит, який має запустити наш проект зі змінними. А як це зробити? Потрібно загуглити: ось <a href="https://stackoverflow.com/questions/55440726/how-to-make-environment-variables-work-in-a-jar-file" rel="nofollow" target="_blank">перше посилання</a>із нормальним описом. А що хочемо зробити? У нас у application.properties файлі є дві змінні, які ми там визначаємо:
<ul>
 <li>bot.username</li>
 <li>bot.token</li>
</ul>Я хочу запускати контейнер докеру і щоразу передавати туди своє значення, щоб ніхто не бачив ці значення. Я знаю, що в SpringBoot змінні оточення, які задаються в момент запуску jar проекту, будуть пріоритетнішими, ніж ті, що знаходяться у файлі application.properties. Щоб передати змінну у запиті, потрібно додати наступну конструкцію: <span class="text-bold">-D{ім'я змінної}=”{значення змінної}”</span> . Фігурні дужки не дописуємо ;) Отримаємо запит, при якому буде запущено наш додаток з визначеними значеннями - ім'я та токена бота: java <span class="text-bold">-jar</span> Тепер потрібно передати ці змінні докер контейнера. Це природна умова. Щоб у майбутньому у нас база даних працювала чітко та без проблем із нашим додатком, будемо використовувати docker-compose. Це окремий інструмент, в якому можна впорядкувати роботу, запуск та залежність між контейнерами. Іншими словами, це надбудова над докером, щоб керувати контейнерами однієї інфраструктури. Плюс перед тим, як запустити docker-compose, потрібно бути впевненим, що ми стягнули всі зміни коду з сервера, зібрали програму та зупинабо стару версію. Для цього будемо використовувати баш скрипт. Ух ... Звучить все непросто, згоден. Але робота з налаштуванням розгортання додатків — це завжди моторний та складний процес. Тому в нас вимальовується нехила схема:
<ol>
 <li>Запускаємо баш скрипт.</li>
 <li>Баш-скрипт запускає docker-compose.</li>
 <li>Docker-compose запускає контейнер docker з нашим додатком.</li>
 <li>Docker контейнер запускає нашу програму.</li>
</ol>І ось потрібно зробити так, щоб дві змінні – ім'я бота та його токен – пройшли з 1 пункту в 4. Причому так, щоб ці дві змінні використовувалися при запуску нашого java-додатку. Ходімо з кінця на початок. Ми вже знаємо, яку команду потрібно виконати, щоби запустити джарник. Тому налаштовуватимемо Dockerfile, щоб він навчився приймати дві змінні і передавати їх у запит. Для цього наведемо Dockerfile до такого вигляду: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java">FROM adoptopenjdk<span class="token operator">/</span>openjdk11<span class="token operator">:</span>ubi
<span class="token class-name">ARG</span> JAR_FILE<span class="token operator">=</span>target<span class="token comment">/*.jar
ENV BOT_NAME=test.codegym_community_bot
ENV BOT_TOKEN=1375780501:AAE4A6Rz0BSnIGzeu896OjQnjzsMEG6_uso
COPY ${JAR_FILE} app.jar
ENTRYPOINT ["java", "-Dbot.username=${BOT_NAME}", "-Dbot.token=${BOT_TOKEN}", "-jar", "/app.jar"]</span></code></pre> Видно, що ми додали два рядки і оновлено ENTRYPOINT. Рядки: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class=" language-java"><span class="token class-name">ENV</span> BOT_NAME<span class="token operator">=</span>test<span class="token punctuation">.</span>codegym_community_bot
<span class="token class-name">ENV</span> BOT_TOKEN<span class="token operator">=</span><span class="token number">1375780501</span><span class="token operator">:</span><span class="token class-name">AAE4A6Rz0BSnIGzeu896OjQnjzsMEG6_uso</span></code></pre> оголошують змінні всередині кодера файлу. За замовчуванням значення вказано. Якщо при створенні образу з цього докерфайлу буде передано змінні оточення з такими іменами, значення будуть інші. А в ENTRYPOINT ми додали ще кілька елементів, які зчитуватимуть ці змінні середовища. 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token string">"-Dbot.username=${BOT_NAME}"</span><span class="token punctuation">,</span> <span class="token string">"-Dbot.token=${BOT_TOKEN}"</span></code></pre> Тут видно, що всередині рядка за допомогою ${} конструкції буде передано значення BOT_NAME і BOT_TOKEN. Далі нам потрібно навчити отримувати та передавати ці змінні до docker-compose.
<h2>Створюємо docker-compose.yml</h2>Добре вам про YAML формат почитати окремо, а то стаття і так вже росте, як на дріжджах. Для нас це просто ще один опис змінних на кшталт .properties. Тільки в пропертях записується через точку, а в YAML це робиться трохи красивішим. Наприклад, так. Дві змінні в .properties: codegym.telegram.bot.name=ivan codegym.telegram.bot.token=pupkin А ось у .yaml (теж саме .yml) буде це так: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java">codegym<span class="token operator">:</span>
	telegram<span class="token operator">:</span>
		bot<span class="token operator">:</span>
		  name<span class="token operator">:</span> ivan
		  token<span class="token operator">:</span> pupkin</code></pre> Другий варіант більш гарний та зрозумілий. Прогалини мають бути саме такі, як зазначено вище. Якось перекладемо наші application.properties і application.yml. Спершу потрібно його створити. У корені проекту створюємо файл <span class="text-bold">docker-compose.yml</span> та записуємо туди наступне: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java">version<span class="token operator">:</span> <span class="token string">'3.1'</span>

services<span class="token operator">:</span>
 jrtb<span class="token operator">:</span>
   build<span class="token operator">:</span>
     context<span class="token operator">:</span> <span class="token punctuation">.</span>
   environment<span class="token operator">:</span>
     <span class="token operator">-</span> BOT_NAME<span class="token operator">=</span>$<span class="token punctuation">{</span>BOT_NAME<span class="token punctuation">}</span>
     <span class="token operator">-</span> BOT_TOKEN<span class="token operator">=</span>$<span class="token punctuation">{</span>BOT_TOKEN<span class="token punctuation">}</span>
   restart<span class="token operator">:</span> always</code></pre> Перший рядок – це версія docker-compose. <span class="text-bold">services:</span> говорить про те, що всі наступні рядки після цього (будуть зрушені) - відносяться до сервісів, які ми налаштовуємо. У нас такий поки що тільки один - java-додаток під назвою <span class="text-bold">jrtb</span> . І вже під ним будуть усі його налаштування. Наприклад, <span class="text-bold">build: context: . </span>говорить про те, що ми шукатимемо Dockerfile у тій же директорії, що й docker-compose.yml. А ось секція <span class="text-bold">environment:</span> відповідатиме за те, щоб ми передали в Dockerfile необхідні змінні середовища (environment variables). Саме те, що нам і потрібно. Тому нижче ми змінні та передаємо. Їхні docker-compose буде шукати в змінних операційного середовища сервера. Додамо їх у баш скрипті.
<h2>Створюємо баш скрипти</h2>І останній крок – створити баш скрипт. Створюємо в корені проекту файл з ім'ям start.sh і пишемо туди: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java">#<span class="token operator">!</span><span class="token operator">/</span>bin<span class="token operator">/</span>bash

# <span class="token class-name">Pull</span> <span class="token keyword">new</span> changes
git pull

# <span class="token class-name">Prepare</span> <span class="token class-name">Jar</span>
mvn clean
mvn <span class="token keyword">package</span>

# <span class="token class-name">Ensure</span><span class="token punctuation">,</span> that docker<span class="token operator">-</span>compose stopped
docker<span class="token operator">-</span>compose stop

# <span class="token class-name">Add</span> environment variables
export BOT_NAME<span class="token operator">=</span>$<span class="token number">1</span>
export BOT_TOKEN<span class="token operator">=</span>$<span class="token number">2</span>

# <span class="token class-name">Start</span> <span class="token keyword">new</span> deployment
docker<span class="token operator">-</span>compose up <span class="token operator">--</span>build <span class="token operator">-</span>d</code></pre> Перший рядок потрібний для всіх баш скриптів: без нього працювати не буде. А далі просто набір команд у терміналі, які потрібно виконати. Я додав коментарі у кожній команді, тому має бути зрозуміло. Єдине, що хочеться пояснити, це те, що означає $1 і $2. Це дві змінні, які будуть передані у запуску баш скрипта. За допомогою команди export вони будуть додані до змінних серверів і лічені вже в docker-compose. Це працює для убунти, для віндоуса, мабуть, ні, але я не певен. Тепер потрібно додати скрипт stop.sh, який зупинятиме роботу. У ньому буде кілька рядків: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java">#<span class="token operator">!</span><span class="token operator">/</span>bin<span class="token operator">/</span>bash

# <span class="token class-name">Ensure</span><span class="token punctuation">,</span> that docker<span class="token operator">-</span>compose stopped
docker<span class="token operator">-</span>compose stop

# <span class="token class-name">Ensure</span><span class="token punctuation">,</span> that the old application won't be deployed again<span class="token punctuation">.</span>
mvn clean</code></pre> Тут ми зупиняємо docker-compose та зачищаємо джарник проекту, який лежить ще з минулого збирання. Робимо ми це для того, щоб наш проект точно перезбирався. Були прецеденти, тому і додаю) У результаті у на виходить 4 нових файли:
<ul>
 <li>Dockerfile - файл для створення образу нашої програми;</li>
 <li>docker-compose.yml — файл із налаштуванням того, як ми будемо запускати наші контейнери;</li>
 <li>start.sh - баш скрипт для розгортання нашої програми;</li>
 <li>stop.sh - баш скрипт для зупинки нашої програми.</li>
</ul>Також оновимо версію нашої програми з 0.2.0-SNAPSHOT на 0.3.0-SNAPSHOT. Додамо до RELEASE_NOTES опис до нової версії і трохи відрефакторимо те, що було: 
<div class="terminal">
 # Release Notes ## 0.3.0-SNAPSHOT * JRTB-13: added deployment process to the project ## 0.2.0-SNAPSHOT * JRTB-3: implemented Command pattern for handling Telegram Bot commands ## 0.1.0-SNAPSHOT * JRTB -2: added stub telegram bot * JRTB-0: added SpringBoot skeleton project
</div> І в README додамо новий параграф з описом того, як деплоїти наш додаток: 
<div class="terminal">
 ## Deployment Deployment process as asy posible: Required software: - terminal for running bash scripts - docker - docker-compose to deploy application, switch to needed branch and run bash script: $ bash start.sh ${bot_username} ${bot_token } That's all.
</div> Зрозуміло, все пише англійською. Вже як завжди, у нашій новоствореній гілці STEP_4_JRTB-13 створюємо новий коміт з ім'ям: <span class="text-bold">JRTB-13: implement deployment process via docker</span> і робимо пуш. Я перестаю докладно зупинятись на речах, які я вже описував у минулих статтях. Не бачу сенсу повторювати те саме. До того ж, хто розібрався і зробив у себе, у запитань не виникне. Це я про те, як створити нову гілку, як створити коміт, як запустити комміт у репозиторій.
<h2>Підсумок</h2>За сьогодні я показав безліч нової інформації, яку потрібно добре обміркувати і розширити додатковим читанням. Найголовніше: за допомогою ОДНІЙ (!!!) команди все необхідне для розгортання нашої програми буде зроблено. Це настільки класно, що я навіть передати вам не можу. Так, довелося витратити пристойну кількість часу в документації докера, щоб зрозуміти, як правильно прокидати змінні. З цього моменту телеграм-бот завжди працюватиме на останній версії <span class="text-bold">main</span> гілки. <a href="https://t.me/test_codegym_community_bot" rel="nofollow" target="_blank">Посилання на телеграм-бота. </a> Сьогодні не будуть посилань на матеріали, які добре було б прочитати: відповідальність лежить на вас. Потрібно вчитися шукати інформацію. Усі, хто підписаний на мій телеграм-канал, дізналися про депло бота майже відразу. Друзі, подобається проект? Ставте йому <a href="https://github.com/codegymcommunity/codegym-telegrambot/stargazers" rel="nofollow" target="_blank">зірку</a>! Так він стане популярнішим і більше людей зможуть дізнатися про нього та повчитися. <em>Традиційно пропоную зареєструватися на GitHub і підписатися на <a href="https://github.com/romankh3" rel="nofollow" target="_blank">мій обліковий запис</a> , щоб стежити за цією серією та іншими моїми проектами, які я веду там. </em> Наразі ми готові підключати базу даних. Наступна стаття буде більшою і в ній ми зробимо все необхідне для роботи з БД. Весь опис - в <a href="https://github.com/codegymcommunity/codegym-telegrambot/issues/1" rel="nofollow" target="_blank">JRTB-1</a> .<a href="https://codegym.cc/welcome" target="_blank"><img id="click_banner1_articles" data-max-width="1080" data-id="5736eb4b-2b1c-4ab6-b4cc-b9e2d1cef628" alt="&quot;Java-проект від А до Я&quot;: Реалізуємо розгортання програми - 8" src="https://cdn.javarush.com/images/article/5736eb4b-2b1c-4ab6-b4cc-b9e2d1cef628/1080.jpeg" style="width: 1080px;"></a>
<h4><a href="https://codegym.cc/groups/posts/2935-java-proekt-ot-a-do-ja-pishem-realjhnihy-proekt-dlja-portfolio#articles" target="_blank">Список всіх матеріалів серії на початку цієї статті.</a></h4>