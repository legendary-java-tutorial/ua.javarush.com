Частина 1. Що потрібно знати перед вивченням Spring та JavaEE
<p>----------------------------------------</p>
Якщо ти вже закінчив вивчення Java SE або близький до цього, настав час задуматись про подальші кроки у підкоренні професії Java-девелопера. З одного боку, ти вже непогано розумієшся на Java: знаєш, як працювати з IDE, писати програми та ба
<p>----------------------------------------</p>
Якщо ти вже закінчив вивчення Java SE або близький до цього, настав час задуматись про подальші кроки у підкоренні професії Java-девелопера. <img data-max-width="850" alt="Частина 1. Що потрібно знати перед вивченням Spring та JavaEE - 1" src="https://cdn.javarush.com/images/article/0f024f83-d3b6-4727-b11c-f9abfb1c49bb/original.jpeg">З одного боку, ти вже непогано розумієшся на Java: знаєш, як працювати з IDE, писати програми та багато іншого. Але що з ними, програмами, треба робити далі? Як зробити їх крутішим і “випустити у світ”? Стає очевидно, що настав час братися за вивчення Enterprise-технологій. І тут починається найцікавіше. Не має значення, з якого стеку технологій ти вирішиш почати. Будь то JavaEE або Spring, ти, напевно, зіткнешся з масою речей, які поки що знаходяться за межами твого розуміння. Між основами Java та сучасними технологіями є ще проміжна сходинка знань, які допоможуть тобі не розгубити залишки самовладання та віри себе при читанні об'ємної документації. <span class="text-bold">Тому мета даного циклу статей</span> — дати тобі мінімум необхідних теоретичних знань подальшого вивчення JavaEE чи Spring. Весь матеріал розбитий на 7 частин: 
<ol>
 <li>Поговоримо трохи про мережу.</li>
 <li>Розглянемо пристрій клієнт-серверної та трирівневої архітектури.</li>
 <li>Розберемося з протоколами HTTP/HTTPS.</li>
 <li>Дізнаємося все, що потрібно, про Maven.</li>
 <li>Поговоримо про сервлети.</li>
 <li>Контейнери сервлетів.</li>
 <li>І нарешті – про MVC.</li>
</ol>
<h2>Частина 1. Поговоримо трохи про мережу</h2>Почнемо з найголовнішого і поговоримо про те, на основі чого будуються всі соціальні мережі, web-сервіси та додатки, месенджери та простенькі сайти - про мережу (в контексті цього циклу статей під терміном "мережа" мається на увазі Глобальна мережа Інтернет <em>)</em> . Мережа складається з величезної кількості комп'ютерів: вони з'єднані між собою і здатні спілкуватися. Важливо розуміти, як вони це роблять, тому що web-програми якраз і займаються передачею інформації від одного комп'ютера іншому. 
<h3>Мережева модель OSI</h3>Модель OSI (Open Systems Interconnection) створює рівневий підхід до побудови мережі. Вона чітко показує, як і на якому рівні між собою можуть взаємодіяти члени однієї мережі. Усього дана модель містить 7 рівнів: 
<div class="table-container">
 <table style="background:#eceff1; border: 2px solid black;">
  <tbody>
   <tr style="border: 2px solid black;">
    <td style="border: 2px solid black;">7</td>
    <td style="border: 2px solid black;">Прикладний</td>
   </tr>
   <tr style="border: 2px solid black;">
    <td style="border: 2px solid black;">6</td>
    <td style="border: 2px solid black;">Уявлення</td>
   </tr>
   <tr style="border: 2px solid black;">
    <td style="border: 2px solid black;">5</td>
    <td style="border: 2px solid black;">Сеансовий</td>
   </tr>
   <tr style="border: 2px solid black;">
    <td style="border: 2px solid black;">4</td>
    <td style="border: 2px solid black;">Транспортний</td>
   </tr>
   <tr style="border: 2px solid black;">
    <td style="border: 2px solid black;">3</td>
    <td style="border: 2px solid black;">Мережевий</td>
   </tr>
   <tr style="border: 2px solid black;">
    <td style="border: 2px solid black;">2</td>
    <td style="border: 2px solid black;">Канальний</td>
   </tr>
   <tr style="border: 2px solid black;">
    <td style="border: 2px solid black;">1</td>
    <td style="border: 2px solid black;">Фізичний</td>
   </tr>
  </tbody>
 </table>
</div>Розбивка на рівні абстракції дозволяє фахівцям, які працюють, наприклад, над транспортним рівнем, не замислюватись про деталі реалізації мережі на мережевому та сеансових рівнях. Такий підхід використовують і в програмуванні. 
<div class="email-subscription">
 <iframe frameborder="0" src="https://secure.esputnik.com.ua/4Q0Ef6d2SOs" width="100%" height="200" scrolling="no" data-savepage-key="0-2"></iframe>
</div><span class="text-bold">Розглянемо всі рівні моделі OSI, і з'ясуємо, які нам цікаві:</span>
<ol>
 <li>
  <p><span class="text-bold">1. Фізичний рівень</span> – тут свою справу роблять закони фізики, а завдання людини – використовувати та спрямовувати це у своїх цілях. Наприклад, створення кабелів та прокладання їх до членів мережі.</p>
  <p><em>Нам не цікавий.</em></p></li>
 <li>
  <p><span class="text-bold">Канальний рівень</span> - відповідає за передачу даних мережевим вузлам, створення каналів передачі на фізичних об'єктах.</p>
  <p><em>Нам не цікавий, якщо немає бажання писати прошивку для каналоутворювальної апаратури.</em></p></li>
 <li>
  <p><span class="text-bold">Мережевий рівень</span> — для визначення адреса окремих користувачів мережі та маршрутів до них. На цьому рівні варто зупинитися докладніше, а саме на адресаі користувача в мережі.</p>
  <p>Він визначається спеціальним протоколом: найпоширеніший - IPv4 (Internet Protocol version 4). Саме його потрібно використовувати веб-програміст для звернення до іншого абонента мережі.</p>
  <p>IPv4 складається з чотирьох байтових значень, розділених точкою, наприклад: 192.0.2.235. Варто пам'ятати, що значення байтові, отже, вони лежать у межах 0..255.</p>
  <p>IP-адресаи, у свою чергу, діляться на класи, і просто так привласнити собі гарну комбінацію циферок не вийде, але так сильно заглиблюватись ми не станемо. Досить розуміти, що IP-адресаа — це унікальний ідентифікатор абонента в мережі, яким ми зможемо до нього звернутися.</p></li>
 <li>
  <p><span class="text-bold">Транспортний рівень</span> займається доставкою інформації адресаату. Для цього використовуються різні протоколи, які нам поки що не цікаві. Набагато більше за нас цікавить поняття, яке з'являється на цьому рівні, — <span class="text-bold">port</span> .</p>
  <p><span class="text-bold">Порти відповідають за ідентифікацію конкретної програми на комп'ютері. </span>Наприклад, ти написав чат на Java, встановив на 2 комп'ютери і хочеш відправити своєму співрозмовнику. Твоє повідомлення упаковується, відправляється за конкретною IP-адресаою, доставляється твоєму співрозмовнику, але його ПК не знає, що робити з отриманою інформацією, тому що не розуміє, який додаток має обробити твоє повідомлення. Для цього і вказуються порти під час спілкування абонентів у мережі.</p>
  <p>Порт є числом від 0 до 65535. Він додається до IP-адресаи після двокрапки: <em>192.0.2.235:8080</em> . Але не можна використовувати всі порти із зазначеного діапазону: частина з них зарезервована під операційну систему, ще частину прийнято використовувати з обумовленою метою. На призначення різних портів заглиблюватися не будемо, поки що достатньо розуміти їх роль у процесі спілкування в мережі.</p></li>
 <li>
  <p><span class="text-bold">Сеансовий рівень</span> — створює та керує сеансами зв'язку додатків. На цьому рівні стає можливою взаємодія додатків, надсилання запитів службового рівня. Для нас важливо знати, що на цьому рівні між двома абонентами відкривається <span class="text-bold">сесія (session)</span> , з якою нам часто доведеться працювати.</p>
  <p><span class="text-bold">Сесія</span> – сутність, яка створюється під час встановлення зв'язку між двома користувачами. У ньому можна зберігати необхідну нам інформацію про користувача, історію їх взаємодії. Важливою деталлю є те, що при зупинці обміну інформацією сесія не пропадає, а зберігає свій стан протягом встановленого проміжку часу, тому користувачі можуть продовжити обмін інформацією після перерви.</p>
  <p>Якщо програма спілкується одночасно з кількома користувачами, встановлюється відповідна кількість з'єднань, а отже, і сесій. <span class="text-bold">Кожна сесія має унікальний ідентифікатор (ID)</span> , що дозволяє додатку розрізняти користувачів, з якими відбувається спілкування.</p></li>
 <li>
  <p><span class="text-bold">Рівень подання</span> – відповідає за кодування/декодування даних. Очевидно, якщо нам потрібно передати іншому користувачі рядок “Hello web”, спочатку він перетворюється (кодується) в бінарний код, і лише потім відправляється. Досягши адресаата, повідомлення перетворюється назад (декодується), і адресаат може побачити вихідний рядок. Ці дії відбуваються лише на рівні уявлення.</p></li>
 <li>
  <p><span class="text-bold">Прикладний рівень</span> – найцікавіший рівень для нас. Він забезпечує взаємодію програм з мережею. На цьому рівні ми прийматимемо, надсилатимемо повідомлення, робитимемо запити до сервісів і віддалених баз даних.</p>
  <p>Існує безліч протоколів, які використовуються на цьому рівні: POP3, FTP, SMTP, XMPP, RDP, SIP, TELNET і, звичайно, HTTP/HTTPS. Протокол — це загальна угода, яку ми дотримуємося, складаючи повідомлення. Про протоколи HTTP/HTTPS ми обов'язково поговоримо окремо та докладніше.</p></li>
</ol><img data-max-width="850" alt="Частина 1. Що потрібно знати перед вивченням Spring та JavaEE - 2" src="https://cdn.javarush.com/images/article/fbd83468-8b60-4d0c-bfb5-f25673c06e45/original.jpeg"> Знати, як працює кожен рівень цієї моделі, нам не обов'язково. Головне — розбиратися в принципах роботи елементів, з якими нам доведеться стикатися під час написання веб-додатків, а саме: 
<ul>
 <li>IP-адресаа - адресаа абонента в мережі;</li>
 <li>Порт - адресаа програми конкретного абонента;</li>
 <li>Сесія - сутність яка існує протягом усього спілкування двох абонентів;</li>
 <li>Прикладні протоколи (HTTP/HTTPS) — правила, якими ми керуватимемося при складанні та надсиланні повідомлень.</li>
</ul>Коли ми переходимо, скажімо, до інтернет-магазину, ми вказуємо його адресау знаходження та порт. Під час першого відвідування створюється сесія, в яку магазин може записувати інформацію. Наприклад, про товари, які ми залишабо у кошику. Якщо ми закриємо вкладку з інтернет-магазином, а потім знову зайдемо до нього, наші товари залишаться у кошику, бо вони збережені у сесії. Ну і, звичайно, всю інформацію, яку ми отримуємо від магазину, ми отримуємо за протоколом HTTP/HTTPS, а наш браузер вміє обробляти його. Ти можеш заперечити та сказати, що ніколи не вводив адресау та порт у браузері, і будеш частково правий, адже ти вводив доменне ім'я, яке перетворювалося на DNS-сервері. А ось тут давай розберемося краще, що до чого. <a href="https://codegym.cc/welcome" target="_blank"><img id="click_banner1_articles" data-id="7a184aea-b972-442f-9bdd-8c9d6b481704" data-max-width="1080" alt="Частина 1. Що потрібно знати перед вивченням Spring та JavaEE - 3" src="https://cdn.javarush.com/images/article/7a184aea-b972-442f-9bdd-8c9d6b481704/1080.jpeg" style="width: 1080px;"></a>
<h3>DNS (Domain Name System)</h3>Як ми вже з'ясували, кожен абонент в мережі має унікальну адресау. Якщо мова йде про програму, її унікальною адресаою буде <span class="text-bold">IPv4:port</span> . Знаючи цю адресау, можна безпосередньо звернутися до програми. Уявимо, що ми написали веб-додаток, який відображає середню температуру повітря у всіх країнах у режимі реального часу. Ми розгорнули його на сервері з адресаою 226.69.237.119 та на порту 8080. Щоб користувач зміг отримати від нас інформацію, йому потрібно ввести в браузері 5 чисел: 226.69.237.119:8080. Люди не дуже люблять запам'ятовувати набори чисел: далеко не всі ми пам'ятають більше двох телефонних номерів. Ось тому і була вигадана <span class="text-bold">система доменних імен</span>. Ми можемо створити “псевдонім” нашої адресаи – наприклад, world-temperature.com, і користувач замість того, щоб шукати нас на адресау з п'яти складних чисел, може ввести в адресаному рядку браузера наше доменне ім'я. Для порівняння доменних імен та реальних адреса існують <span class="text-bold">DNS-сервера</span> . Коли користувач у браузері вводить, наприклад codegym.cc, його запит відправляється на DNS-сервер, де він перетворюється на реальну адресау. <img data-max-width="850" alt="Частина 1. Що потрібно знати перед вивченням Spring та JavaEE - 4" src="https://cdn.javarush.com/images/article/b3c41b90-bf86-49cd-bb61-6925463b2bc3/original.jpeg">Нам важливо це розуміти, тому що в наших додатках ми будемо викликати віддалені сервіси як по доменному імені, так і за реальною адресаою, і це будуть ті самі сервіси. От і все! У цій статті ми розглянули основи пристрою мережі, які стануть у нагоді перед початком вивчення веб-програмування. Наступного разу розглянемо, що таке клієнт-серверна архітектура і чому розумітися на ній так важливо. <a href="https://codegym.cc/groups/posts/2519-chastjh-2-pogovorim-nemnogo-ob-arkhitekture-po" target="_blank">Частина 2. Поговоримо трохи про архітектуру ПЗ </a> <a href="https://codegym.cc/groups/posts/2521-chastjh-3-protokolih-httphttps" target="_blank">Частина 3. Протоколи HTTP/HTTPS </a> <a href="https://codegym.cc/groups/posts/2523-chastjh-4osnovih-maven" target="_blank">Частина 4. Основи Maven </a> <a href="https://codegym.cc/groups/posts/2529-chastjh-5-servletih-pishem-prostoe-veb-prilozhenie" target="_blank">Частина 5. Сервлети. Пишемо просте веб-додаток </a> <a href="https://codegym.cc/groups/posts/2533-chastjh-6-konteynerih-servletov" target="_blank">Частина 6. Контейнери сервлетів </a> <a href="https://codegym.cc/groups/posts/2536-chastjh-7-znakomstvo-s-patternom-mvc-model-view-controller" target="_blank">Частина 7. Знайомство з патерном MVC (Model-View-Controller) </a> <a href="https://codegym.cc/groups/posts/2537-chastjh-8-pishem-neboljhshoe-prilozhenie-na-spring-boot" target="_blank">Частина 8. Пишемо невелику програму на spring-boot</a>