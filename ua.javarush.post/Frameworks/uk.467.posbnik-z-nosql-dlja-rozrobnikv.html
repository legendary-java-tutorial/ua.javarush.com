Посібник з NoSQL для розробників
<p>----------------------------------------</p>
Якщо ви стежите за тенденціями у сферах backend-розробки та Big Data, то, ймовірно, вже звернули увагу на галас навколо баз даних , характерну для останніх років. Когось такий підхід до БД надихає, комусь здається, що в ньому прихований яки
<p>----------------------------------------</p>
Якщо ви стежите за тенденціями у сферах backend-розробки та Big Data, то, ймовірно, вже звернули увагу на галас навколо баз даних <em><strong>NoSQL</strong></em> , характерну для останніх років. Когось такий підхід до БД надихає, комусь здається, що в ньому прихований якийсь трюк: моделі даних у них не такі, як у звичних реляційних базах, інтерфейси програмування додатків незвичні, а програми найчастіше незрозумілі. <img data-id="6b267f5d-9f92-44d6-b64a-ff40ab75d906" data-max-width="850" alt="Посібник з NoSQL для розробників - 1" src="https://cdn.javarush.com/images/article/6b267f5d-9f92-44d6-b64a-ff40ab75d906/800.jpeg" style="width: 850px;">У цій статті я розповім, чому вони взагалі були створені, ці бази даних NoSQL, які завдання вони вирішують і чому раптом потрібно так багато різних баз даних. Якщо ви новачок в NoSQL, вас може особливо зацікавити остання частина статті, в якій перераховуються бази даних цього типу, які, на мою думку, варто вивчити перш за все, щоб отримати повне уявлення про цю область. 
<h2>Навіщо нам раптом потрібна нова база даних?</h2>Ви можете здивуватися: а що не так з реляційними базами даних? Справа в тому, що вони справді чудово працювали протягом багатьох років, але тепер постала проблема, з якою вони більше не можуть упоратися. Згідно з деякими передбаченнями, у 2018 році людство генеруватиме 50000 гігабайт даних за секунду. Це величезний обсяг даних! Його зберігання та обробка є серйозним інженерним викликом. А ще страшніше те, що цей обсяг постійно зростає. Як виявилося, реляційні бази даних погано пристосовані до роботи з справді великими обсягами даних. Вони спроектовані для роботи на одній машині, і якщо ви хотіли б обробляти більшу кількість запитів, то єдиний варіант - купити комп'ютер з великою кількістю оперативної пам'яті та потужнішим процесором. На жаль, кількість запитів, які здатна обробити одна машина, обмежена, а для розподіленої роботи на кількох машинах нам потрібна інша технологія баз даних. Звичайно, деякі з читачів у цей момент посміхнуться і скажуть, що існує два широко поширені методи використання кількох машин у разі реляційної бази даних: реплікація та шардинг. Воно так, але цих методів недостатньо, щоб упоратися з нашими завданнями. <em><strong>Реплікація читання</strong></em> – методика, коли кожне оновлення бази даних поширюється інші машини, які можуть опрацьовувати лише запити на читання. У цьому випадку всі зміни виконуються одним сервером, який називається провідним вузлом, тоді як інші сервери, які називають репліками читання, лише підтримують копії даних. Користувач може читати з будь-якої машини, але змінювати дані лише через провідний вузол. Це зручний і дуже популярний метод, але дозволяє лише обробляти більше запитів на читання і ніяк не вирішує завдання обробки необхідних обсягів даних. 
<div class="row justify-content-center jr-image-wrap">
 <div class="col-12 col-sm-10 col-md-8">
  <img data-id="c588d03a-22e1-493d-9b43-547ab74954da" data-max-width="710" alt="Посібник з NoSQL для розробників - 2" src="https://cdn.javarush.com/images/article/c588d03a-22e1-493d-9b43-547ab74954da/512.jpeg" style="width: 710px;">
 </div>
 <center>
  <em>На рис.: <br>
    Leader (read and write): Провідний вузол (читає та записує) <br>
    Read-replicas (read-only): Репліки читання (тільки для читання)</em>
 </center>
</div><em><strong>Шардинг</strong></em> – ще один популярний підхід, у якому використовується кілька екземплярів реляційної бази даних. Кожен з них обробляє операції запису та читання для частини даних. Якщо в базі даних зберігається, наприклад, інформація про покупців, за допомогою шардингу одна машина може обробляти всі запити про покупців, імена яких починаються на A, інша – зберігати всі дані про покупців, чиї імена починаються на B, і так далі. 
<div class="row justify-content-center jr-image-wrap">
 <div class="col-12 col-sm-10 col-md-8">
  <img data-id="b4e8bde7-dbde-42a0-aab9-c98370424777" data-max-width="710" alt="Посібник з NoSQL для розробників - 3" src="https://cdn.javarush.com/images/article/b4e8bde7-dbde-42a0-aab9-c98370424777/512.jpeg" style="width: 710px;">
 </div>
 <center>
  <em>На рис.: <br>
   Multi-master (read and write part of data): Кілька провідних вузлів (частини даних, що читають і записують)</em>
 </center>
</div>Хоча шардинг дозволяє записувати більше даних, керування такою базою даних - справжній кошмар: доводиться вирівнювати дані по машинах і масштабувати кластер в обидві сторони за необхідності. Хоча теоретично це виглядає просто, правильна реалізація – дуже складне завдання. 
<h2>Чи можна удосконалити реляційні бази даних?</h2>Думаю, ви вже повірабо в те, що реляційні бази даних не найкраще пристосовані до обсягів даних, що генеруються в сучасному світі. Хоча, можливо, ви все ще дивуєтесь, чому ніхто досі не створив "поліпшеної" реляційної бази даних, яка могла б ефективно працювати на кількох машинах. Може здатися, що ця технологія просто ще не розроблена, і незабаром з'являться розподілені реляційні бази даних. <em><strong>На жаль, цього не станеться. Це неможливо з точки зору математики, і нічого вдіяти з цим не можна. </strong></em> Щоб зрозуміти чому це так, необхідно звернутися до так званої теореми CAP (вона ж теорема Брюера). Її довели в 1999 році, і вона стверджує, що у розподілена база даних, що працює на декількох машинах, може мати наступні три властивості: <em><strong>Узгодженістю</strong></em> (<em><strong> C</strong></em> onsistency) – у результаті будь-якої операції читання повертаються результати останньої відповідної операції запису. Якщо система узгоджена, після запису нових даних, прочитати старі вже перезаписані неможливо. <em><strong>Доступністю</strong></em> (<em><strong> A</strong></em> vailability) – розподілена система у будь-який момент може обслужити вхідний запит і повернути неправильну відповідь. <em><strong>Стійкістю до порушення зв'язності</strong></em> (<em><strong> P</strong></em>artition tolerance) – база даних продовжує відповідати запити читання і запис навіть у разі, коли частина її серверів тимчасово нездатні взаємодіяти друг з одним. Цей тимчасовий збій називається порушенням зв'язності мережі і може викликатися безліччю фактором, починаючи від фізичних проблем з мережею через сервер, що повільно працює, і закінчуючи фізичним пошкодженням мережевого обладнання. Всі ці властивості, безумовно, зручні, і нам дуже хотілося б, щоб база даних поєднувала їх все. Жоден розсудливий розробник не захоче відмовитися від, скажімо, доступності, не отримавши нічого натомість. <em><strong>На жаль, теорема CAP також стверджує, що одночасне виконання всіх трьох властивостей неможливе.</strong></em> Зрозуміти це може бути непросто, але можливо. По-перше, якщо нам потрібна розподілена база даних, вона повинна бути "стійкою до порушення зв'язності". Це навіть не обговорюється. Порушення зв'язності відбуваються <a href="http://queue.acm.org/detail.cfm?id=2655736" target="_blank">весь час</a> і наша база даних має працювати, попри це. Тепер давайте зрозуміємо, чому ми не можемо досягти одночасно узгодженості та доступності. Уявіть, що у нас є проста база даних, що працює на двох машинах: A і B. Будь-який користувач може виконувати запис на будь-яку з машин, після чого дані копіюються на іншу. 
<div class="row justify-content-center jr-image-wrap">
 <div class="col-12 col-sm-10 col-md-8">
  <img data-id="d0fcd850-98ed-44e7-806d-57730957b5f8" data-max-width="710" alt="Посібник з NoSQL для розробників - 4" src="https://cdn.javarush.com/images/article/d0fcd850-98ed-44e7-806d-57730957b5f8/512.jpeg" style="width: 710px;">
 </div>
</div>Тепер уявіть собі, що ці машини тимчасово втратабо можливість обміну повідомленнями один з одним, і машина B не може надсилати дані на машину A або отримувати дані від неї. Якщо в цей проміжок часу машина B отримає запит на читання від клієнта, вона має дві можливості: 
<ol>
 <li>Повернути свої локальні дані, навіть якщо вони не найсвіжіші. У цьому випадку надається перевага доступності (повернути хоч якісь дані, навіть застарілі).</li>
 <li>Повернути помилку. В цьому випадку віддається перевага узгодженості: клієнт не отримає застарілі дані, але й не отримає взагалі жодних.</li>
</ol>
<div class="row justify-content-center jr-image-wrap">
 <div class="col-12 col-sm-10 col-md-8">
  <img data-id="3a7b1045-229a-4624-8256-6ec90c4c6ac4" data-max-width="710" alt="Посібник з NoSQL для розробників - 5" src="https://cdn.javarush.com/images/article/3a7b1045-229a-4624-8256-6ec90c4c6ac4/512.jpeg" style="width: 710px;">
 </div>
 <center>
  <em>На рис.: <br>
   Network partition: Порушення зв'язності мережі</em>
 </center>
</div>Реляційні бази даних прагнуть реалізувати властивості "узгодженості" і "доступності" одночасно, і, отже, не можуть працювати в розподіленому середовищі. Спроба реалізувати всі можливості реляційної бази даних у розподіленій системі виявиться або нереалістичною, або просто <a href="https://ferd.ca/beating-the-cap-theorem-checklist.html" target="_blank">нездійсненною</a> . З іншого боку, бази даних NoSQL надають основне значення масштабованості та продуктивності. У них зазвичай відсутні такі "базові" можливості, як з'єднання та транзакції, а модель даних виявляється зовсім іншою, можливо, в чомусь навіть обмежує. Все це дає можливість зберігання більших обсягів даних та обробки більшої кількості запитів, ніж було можливо колись раніше. 
<h2>Як базам даних NoSQL вдається поєднувати узгодженість та доступність?</h2>Вам може здаватися, що вибравши NoSQL БД, ви завжди отримуватимете або якісь застарілі дані, або помилку у разі будь-якого збою. Насправді ж, доступність і узгодженість — аж ніяк не єдині можливі варіанти. Існує широкий спектр доступних для вибору варіантів. У реляційних базах даних цих параметрів немає, але NoSQL дозволяє керувати виконанням запитів подібним чином. Так чи інакше вони дозволяють задавати два параметри при виконанні операцій запису або читання в NoSQL базі даних: <em><strong>W</strong></em> – скільки машин у кластері повинно підтвердити збереження даних при <em><strong>виконанні операції запису</strong></em> . Чим більша кількість машин, куди ви запишете свої дані, тим легше буде прочитати найсвіжіші дані при наступній операції читання, але й тим більше часу це займе. <em><strong>R</strong></em> - з якої кількості машин ви хотіли б<em><strong> читати дані</strong></em> . У розподіленій системі поширення даних по всіх машинах кластера може зайняти деякий час, так що на деяких серверах дані будуть актуальними, а інші відставатимуть. Чим більша кількість машин, з яких читаються дані, тим вищі шанси прочитати актуальні дані. Розглянемо практичний приклад. Якщо у вашому кластері п'ять комп'ютерів, і ви вирішабо записувати дані лише на один, а потім читати дані з одного випадково вибраного комп'ютера, з ймовірністю 80% ви прочитаєте застарілі дані. З іншого боку, при цьому використовуватиметься мінімум ресурсів. Так що, якщо застарілі дані вас влаштовують, це не такий поганий варіант. У цьому випадку параметри W та R дорівнюють 1. 
<div class="row justify-content-center jr-image-wrap">
 <div class="col-12 col-sm-10 col-md-8">
  <img data-id="8d01704a-f65e-4432-b370-309678099e94" data-max-width="710" alt="Посібник з NoSQL для розробників - 6" src="https://cdn.javarush.com/images/article/8d01704a-f65e-4432-b370-309678099e94/512.jpeg" style="width: 710px;">
 </div>
</div>З іншого боку, якщо ви записуєте дані на всі п'ять машин у базі даних NoSQL, можете читати дані з будь-якої машини, і щоразу гарантовано отримаєте актуальні дані. Виконання тієї ж операції при більшій кількості машин займе довше, але якщо актуальні дані для вас важливі, то можна вибрати цей варіант. У цьому випадку W = R = 5. Яка мінімальна кількість операцій читання та запису, необхідна для узгодженості бази даних? Ось проста формула: <em><strong>R + W ≥ N + 1</strong></em> де N - число машин в кластері. Це означає, що при п'яти серверах можна вибрати або R = 2 і W = 4, або R = 3 і W = 3 або R = 4 і W = 2. У цьому випадку не має значення, на які машини записуються дані, читання завжди буде вироблятися принаймні з однієї машини з актуальними даними. 
<div class="row justify-content-center jr-image-wrap">
 <div class="col-12 col-sm-10 col-md-8">
  <img data-id="0c8587ac-0868-4ac2-82b3-0a5e2d242ae8" data-max-width="710" alt="Посібник з NoSQL для розробників - 7" src="https://cdn.javarush.com/images/article/0c8587ac-0868-4ac2-82b3-0a5e2d242ae8/512.jpeg" style="width: 710px;">
 </div>
</div>В інших баз даних, наприклад DynamoDB, обмеження відрізняються, і вони дозволяють лише узгоджені операції запису. Кожен елемент даних зберігається на трьох серверах, і при записі будь-яких даних він записується на дві машини з трьох. Але при читанні даних можна вибрати один із двох варіантів: 
<ol>
 <li>Суворе читання, при якому дані читаються з двох машин з трьох і завжди повертаються останні записані дані.</li>
 <li>Читання, узгоджене в кінцевому рахунку, при якому вибирається випадково одна машина, з якої читаються дані. Однак можуть тимчасово повертатися застарілі дані.</li>
</ol>
<h2>Чому існує так багато баз даних NoSQL?</h2>Якщо ви стежите за останніми новинами в галузі розробки програмного забезпечення, то напевно чули про безліч різних NoSQL баз даних, наприклад MongoDB, DynamoDB, Cassandra, Redis та багатьох інших. Можливо, ви здивуєтеся: навіщо потрібно так багато різних NoSQL баз даних? Причина проста: різні бази даних NoSQL призначені для вирішення різних завдань. Саме тому кількість конкуруючих баз даних така велика. NoSQL бази даних поділяються на чотири основні категорії: 
<h3>Документно-орієнтовані бази даних</h3>Ці бази даних надають можливість зберігання складних вкладених документів, тоді як більшість реляційних баз даних підтримує лише одновимірні рядки. Така можливість може стати в нагоді в багатьох випадках, наприклад, при необхідності зберігання в системі інформації про користувача з кількома адресаами. При використанні документно-орієнтованої бази даних, у такому разі можна просто зберігати складний об'єкт, що включає масив адреса, тоді як у реляційній базі даних вам довелося б створити дві таблиці: одну для інформації про користувача, а другу для адреса. Документно-орієнтовані бази даних дозволяють <a href="https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch" target="_blank">скоротити розрив</a>між об'єктною моделлю та моделлю даних. Деякі реляційні бази даних, такі як PostgreSQL, тепер теж підтримують документно-орієнтоване сховище, але в більшості реляційних баз даних ця можливість ще немає. 
<h3>Бази даних типу "ключ/значення"</h3>Бази даних типу "ключ/значення" зазвичай реалізують найпростішу NoSQL-модель. По суті, вони надають вам розподілену <a href="https://en.wikipedia.org/wiki/Hash_table" target="_blank">хеш-таблицю</a> , що дозволяє записувати дані за заданим ключем і читати їх назад за допомогою. Бази даних типу "ключ/значення" легко масштабуються і відрізняються від інших баз даних значно нижчою затримкою. 
<h3>Графові бази даних</h3>Багато предметних областей, наприклад, соціальні мережі або інформацію про фільми та акторів, можна подати у вигляді графів. Хоча граф можна уявити і за допомогою реляційної бази даних, це складно та незручно. Якщо вам потрібні графові дані, краще скористатися спеціалізованою графовою базою даних, яка може зберігати інформацію про графу у розподіленому кластері та дає можливість ефективної реалізації алгоритмів на графах. 
<h3>Стовпцеві бази даних</h3>Основна відмінність між стовпцевими та іншими типами баз даних полягає у способі зберігання даних на диску. Реляційні бази даних створюють файл для кожної таблиці і зберігають значення для всіх рядків послідовно. Стовпцеві бази даних створюють файл для кожного стовпця ваших таблиць. Така структура дозволяє агрегувати дані та виконувати певні запити ефективніше, проте необхідно переконатися, що дані відповідають обмеженням таких баз даних. 
<h3>Яку базу даних вибрати?</h3>Вибір бази даних – зазвичай болісна проблема, і за такої кількості можливих варіантів може здатися нездійсненним завданням. Хороша новина полягає в тому, що немає потреби обирати лише одну. Замість створення єдиного монолітного додатка, що реалізує всі можливості та має доступ до всіх даних системи, можна скористатися ще одним сучасним патерном під назвою " <a href="https://martinfowler.com/articles/microservices.html" target="_blank">мікросервіси</a> ": розбити додаток на набір незалежних сервісів. Кожен сервіс вирішує своє вузьке завдання і використовує тільки свою базу даних, яка максимально підходить для вирішення цього завдання. 
<h2>Як накажете все це вивчити?</h2>При <a href="https://db-engines.com/en/ranking" target="_blank">такій кількості баз даних</a> вивчити їх все може здатися нездійсненним завданням. Хороша новина: цього робити не треба. Існує лише кілька основних типів NoSQL баз даних, і якщо розібратися в принципах їх роботи, розібратися з іншими буде набагато простіше. Також, деякі NoSQL бази даних використовуються набагато частіше за інших, так що краще зосередити зусилля на найбільш популярних рішеннях. Ось список найчастіше використовуваних NoSQL баз даних, на які, як мені здається, вам варто подивитися: 
<ol>
 <li><em><strong>MongoDB</strong></em> . Мабуть, найпопулярніша NoSQL база даних на ринку. Якщо компанія не використовує як основне сховище даних реляційну базу даних, то, ймовірно, вона використовує MongoDB. Це гнучке сховище документів із гарним набором інструментарію. На початку своєї "кар'єри" у MongoDB була не найкраща репутація, тому що<a href="https://aphyr.com/posts/284-call-me-maybe-mongodb" target="_blank"> дані в ній в деяких випадках губабося</a> , але з того часу її стабільність і надійність набагато підвищабося. Погляньте на цей<a href="http://shrsl.com/kzpn" target="_blank"> присвячений MongoDB курс</a> , якщо хочете дізнатися більше.</li>
 <br>
 <li><em><strong>DynamoDB</strong></em> . Якщо ви використовуєте веб-сервіси Amazon (AWS), вам краще дізнатися більше про DynamoDB. Це виключно надійна база даних з низькою затримкою, багатим набором можливостей та інтеграцією з безліччю інших сервісів AWS. А найприємніше те, що її не потрібно розгортати самостійно. Налаштувати масштабований кластер DynamoDB, здатний обробляти тисячі запитів, можна лише за кілька клацань мишею. Якщо це вас зацікавило, можете поглянути на<a href="http://shrsl.com/kzpt" target="_blank"> цей курс</a> .</li>
 <br>
 <li><em><strong>Neo4j</strong></em> . Найпоширеніша графова база даних. Це масштабоване і стабільне рішення, яке підходить для бажаючих скористатися графовою моделлю даних. Якщо хочете дізнатися більше – почніть<a href="http://shrsl.com/kzsy" target="_blank"> із цього курсу</a> .</li>
 <br>
 <li><em><strong>Redis</strong></em> . У той час як інші описані тут бази даних використовуються для зберігання основних даних програми, Redis застосовується в основному для реалізації кешу та зберігання допоміжних даних. У багатьох випадках використовується одна з вищезгаданих баз даних у тандемі з Redis. Щоб дізнатися більше, завітайте до цього<a href="http://shrsl.com/kzt5" target="_blank"> курсу.</a></li>
</ol>
<h2>У 2018-му з NoSQL</h2>NoSQL бази даних – широка область, що швидко розвивається. Вони дозволяють зберігати та обробляти нечувані досі обсяги даних, але за це доводиться платити. У цих базах даних немає багатьох звичних за реляційними базами даних можливостей, і налаштувати себе на їх використання може виявитися непросто. Але коли ви з ними розберетеся, зможете створювати масштабовані розподілені бази даних, здатні обробляти разючі обсяги запитів на читання і запис, що може мати виняткове значення в міру генерації все більших і більших обсягів даних. <em><strong>Оригінал:</strong></em><a href="https://simpleprogrammer.com/guide-nosql-software-developers/" target="_blank"> https://simpleprogrammer.com/guide-nosql-software-developers/</a>
<div class="table-container">
 <table>
  <tbody>
   <tr>
    <th>Що ще почитати?</th>
   </tr>
   <tr>
    <td>
     <p><a href="https://codegym.cc/groups/posts/292-kljevihe-optimizacii-sql-ne-zavisjajshie-ot-stoimostnoy-modeli" target="_blank">Кльові оптимізації SQL, що не залежать від вартісної моделі. Частина 1</a></p>
     <p><a href="https://codegym.cc/groups/posts/72-kak-praviljhno-nachatjh-razrabotku-pod-subd-oracle" target="_blank">Як правильно розпочати розробку під СУБД Oracle</a></p></td>
   </tr>
  </tbody>
 </table>
</div>