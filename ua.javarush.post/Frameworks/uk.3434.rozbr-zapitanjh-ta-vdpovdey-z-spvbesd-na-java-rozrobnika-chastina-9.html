Розбір запитань та відповідей із співбесід на Java-розробника. Частина 9
<p>----------------------------------------</p>
Салют! Бути програмістом непросто. Потрібно постійно вчитися, завжди пізнавати щось нове. Але, як і в будь-якій іншій справі, найскладніше — почати зробити перший крок на шляху до своєї мети. І коли ти сидиш на даному сайті і читаєш цю стат
<p>----------------------------------------</p>
Салют! Бути програмістом непросто. Потрібно постійно вчитися, завжди пізнавати щось нове. Але, як і в будь-якій іншій справі, найскладніше — почати зробити перший крок на шляху до своєї мети. І коли ти сидиш на даному сайті і читаєш цю статтю, з першим кроком ти впорався. Отже, тепер потрібно цілеспрямовано рухатися до своєї мети, не гальмуючи і не згортаючи по дорозі. Якщо я розумію правильно, твоя мета - стати Java-розробником або посаботи знання, якщо ти є таким. Якщо все так, то ти за адресаою, адже ми будемо продовжувати розбирати список з 250+ питань на співбесідах для Java-розробника. <img data-max-width="800" data-id="a6110bf1-17ba-4174-bc77-cc58d37f741c" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 9 - 1" src="https://cdn.javarush.com/images/article/a6110bf1-17ba-4174-bc77-cc58d37f741c/800.jpeg" style="width: 800px;">Продовжимо! 
<h3>Collections</h3>
<h4>84. Розкажіть про ітератори та їх застосування</h4>Колекції - одна з найулюбленіших тем на будь-якій співбесіді Java-розробника, і розповідаючи про ієрархію колекцій кандидати часто говорять, що вона починається з інтерфейсу <span class="code">Collection</span> . Але це не так, адже над цим інтерфейсом є ще один – <span class="code">Iterable</span> . Цей інтерфейс є методом <span class="code">iterator()</span> , який дозволяє викликати об'єкт <span class="code">Iterator</span> для поточної колекції. І що ж таке цей об'єкт <span class="code">Iterator</span> ? <span class="code">Iterator</span>— це об'єкт, що надає можливість рухатися колекцією і перебирати елементи, причому користувачу не потрібно знати реалізацію конкретної колекції. Тобто, це деякий покажчик на елементи колекції, який дивиться на певне місце в ній. Ітератор має такі методи: 
<ul>
 <li><span class="code">hasNext()</span> — повертає <span class="text-bold">true</span> якщо є елемент, розташований після покажчика (даний метод дозволяє дізнатися, чи досягнуть кінець колекції);</li>
 <li><span class="code">next()</span> - Повертає наступний елемент після покажчика. Якщо не буде, викидається <span class="text-bold">NoSuchElementException</span> . Тобто перед використанням цього методу краще переконатися, що елемент є — за допомогою <span class="code">hasNext()</span> ;</li>
 <li><span class="code">remove()</span> - видаляє з колекції останній отриманий елемент методом <span class="code">next()</span> . Якщо ж <span class="code">next()</span> до виклику <span class="code">remove()</span> жодного разу не викликали, буде кинуто виняток - <span class="text-bold">IllegalStateException</span> ;</li>
 <li><span class="code">forEachRemaining(&lt;Consumer&gt;)</span> - виконує передану дію з кожним елементом колекції (метод з'явився з Java 8).</li>
</ul>Ось невеликий приклад проходу за списком та видалення всіх його елементів за допомогою розглянутих методів ітератора: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Hello "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"World, "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"It's "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Amigo!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Iterator</span> iterator <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">while</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   iterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> У консолі буде виведено: 
<div class="terminal">
 0
</div> І це означає, що видалення елементів пройшло успішно. Отримавши ітератор, можна було б скористатися методом виведення всіх елементів на екран: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java">iterator<span class="token punctuation">.</span><span class="token function">forEachRemaining</span><span class="token punctuation">(</span>x <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Але після цього ітератор став би непридатний для подальшого використання, оскільки він обійшов би весь список, а методів зворотного перебору у звичайного ітератора немає. Тут ми плавно підходимо до <span class="code">LinkedList</span> , а саме до його методу <span class="code">listIterator()</span> , який повертає модернізований вигляд ітератора — <span class="code">ListIterator</span> . Крім методів звичайного (стандартного) ітератора, це має додаткові: 
<ul>
 <li><span class="code">add(&lt;Element&gt;)</span> — вставляє новий елемент до списку;</li>
 <li><span class="code">hasPrevious()</span> — повертає <span class="text-bold">true</span> якщо є елемент, розташований перед покажчиком (чи є попередній елемент);</li>
 <li><span class="code">nextIndex()</span> - повертає індекс у списку наступного елемента після покажчика;</li>
 <li><span class="code">previous()</span> - Повертає попередній елемент (до покажчика);</li>
 <li><span class="code">previousIndex()</span> - Повертає індекс попереднього елемента;</li>
 <li><span class="code">set(&lt;Element&gt;)</span> — замінює останній елемент, повернутий методами <span class="code">next()</span> або <span class="code">previous()</span> .</li>
</ul>Як бачимо, функціонал цього ітератора набагато цікавіший: він дозволяє ходити в обидві сторони та розв'язує руки у роботі з елементами. Також коли говорять про ітераторів іноді мають на увазі сам патерн. Щоб не потрапити в халепу і розповісти про неї переконливо, читайте <a href="https://codegym.cc/groups/posts/1884-pattern-iterator" target="_blank">цю статтю про патерн Iterator</a> . <img data-max-width="512" data-id="b0409dab-794d-4385-abf6-f46397c836c2" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 9 - 2" src="https://cdn.javarush.com/images/article/b0409dab-794d-4385-abf6-f46397c836c2/512.jpeg" style="width: 512px;">
<h4>85. Яка ієрархія колекцій у Java Collection Framework?</h4>Існує дві ієрархії колекцій у Java. <span class="text-bold">Перша ієрархія</span> - безпосередньо ієрархія <span class="code">Collection</span> з наступною структурою: <img data-max-width="800" data-id="8cc198bf-1349-45d3-9475-c19ca5d6a622" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 9 - 3" src="https://cdn.javarush.com/images/article/8cc198bf-1349-45d3-9475-c19ca5d6a622/800.jpeg" style="width: 800px;">Вона ділиться на наступні підколекції: 
<ul>
 <li><span class="code">Set</span> - інтерфейс, що описує таку структуру даних як <span class="text-bold">безліч</span> , що містить невпорядковані унікальні (неповторні) елементи. Інтерфейс має стандартні реалізації - <span class="code">TreeSet</span> , <span class="code">HashSet</span> і <span class="code">LinkedHashSet</span> .</li>
 <li><span class="code">List</span> - інтерфейс, що описує структуру даних, яка зберігає впорядковану послідовність об'єктів. Примірники, які містяться в <span class="code">List</span> -і, можна вставляти та видаляти за їх індексом у даній колекції (аналог масиву, але з динамічною зміною розміру). У інтерфейсу є стандартні реалізації - <span class="code">ArrayList</span> , <span class="code">Vector</span> ( <em>вважається застарілою і фактично не використовується</em> ) і <span class="code">LinkedList</span> .</li>
 <li><span class="code">Queue</span> - інтерфейс, що описує структуру даних, що зберігає елементи у вигляді черги, яка слідує правилу <span class="text-bold">FIFO - First In First Out</span> (першим увійшов, першим вийшов). Інтерфейс має такі стандартні реалізації: <span class="code">LinkedList</span> (так, він реалізує і <span class="code">Queue</span> теж) і <span class="code">PriotityQueue</span> .</li>
</ul><span class="text-bold">Друга ієрархія колекцій</span> — <span class="code">Map</span> , яка має таку структуру: <img data-max-width="800" data-id="7a7daedd-9e51-48ba-8b52-5cc9bb393037" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 9 - 4" src="https://cdn.javarush.com/images/article/7a7daedd-9e51-48ba-8b52-5cc9bb393037/800.jpeg" style="width: 800px;">У цій колекції поділів на підколекції немає (оскільки сама ієрархія <span class="code">Map</span> — щось на зразок підколекції, але що лежить окремо). Стандартні реалізації <span class="code">Map</span> - <span class="code">Hashtable</span> (вважається застарілою), <span class="code">LinkedHashMap</span> і <span class="code">TreeMap</span> . Власне, коли запитують про <span class="code">Collection</span> , як правило, мають на увазі обидві ієрархії. <img data-max-width="512" data-id="9c41946b-3e28-45b2-9dc3-e273fd9b9982" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 9 - 5" src="https://cdn.javarush.com/images/article/9c41946b-3e28-45b2-9dc3-e273fd9b9982/512.jpeg" style="width: 512px;">
<h3>86. Яка внутрішня будова ArrayList?</h3><span class="code">ArrayList</span> - це аналог масиву, але зі здатністю динамічно розширюватися. Що це означає? Справа в тому, що <span class="code">ArrayList</span> працює на основі звичайного масиву, а саме він зберігає елементи у внутрішньому масиві (його розмір за замовчуванням – 10 осередків). Коли внутрішній масив заповнюється, створюється новий масив, розмір якого визначається за такою формулою: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token operator">&lt;</span>размерТекущегоМассива<span class="token operator">&gt;</span> <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">/</span> <span class="token number">2</span>  <span class="token operator">+</span> <span class="token number">1</span></code></pre> Тобто, якщо розмір нашого масиву 10, розмір нового буде: 10 * 3 / 2 + 1 = 16. Далі в нього копіюються всі значення з першого (старого) масиву за допомогою нативного методу System.arraycopy() , і перший масив <span class="code">видаляється</span> . Власне, так і реалізується динамічна розширюваність <span class="code">ArrayList</span> . Розглянемо найпопулярніші методи <span class="code">ArrayList</span> : 1. <span class="code">add(&lt;Elelement&gt;)</span> — додає елемент у кінець масиву (в останню порожню комірку), у своїй спочатку перевіряється, чи є місце у цьому масиві. Якщо його немає, створюється новий масив, який копіюються елементи. Логарифмічна складність цієї операції - O(1). Є аналогічний метод - <span class="code">add (&lt;Index&gt;, &lt;Elelement&gt;)</span>. Він додає елемент не в кінець списку (масиву), а в певну комірку з індексом, який прийшов як аргумент. У такому разі логарифмічна складність буде відрізнятися залежно від місця додавання:
<ul>
 <li>якщо це був приблизно початок списку, логарифмічна складність буде близька до O(N), адже доведеться всі елементи, розташовані праворуч від нового, рухати на одну комірку праворуч;</li>
 <li>якщо елемент вставляється усередину — O(N/2) т.к. нам потрібно зрушити на одну комірку праворуч лише половину елементів списку.</li>
</ul>Тобто логарифмічна складність цього методу коливається від O(N) до O(1) залежно від місця вставки елемента. 2. <span class="code">set(&lt;Index&gt;,&lt;Elelement&gt;)</span> — записує елемент у вказану позицію у списку. Якщо в цій позиції вже є елемент, перезаписує його. Логарифмічна складність цієї операції — O(1), адже там жодних зрушень немає: лише пошук індексу в масиві, що, як ми пам'ятаємо, має складність O(1), і запис елемента. 3. <span class="code">remove(&lt;index&gt;)</span> - видалення елемента за його індексом у внутрішньому масиві. При видаленні елемента, який розташований не в кінці списку, необхідно зрушити всі елементи праворуч від нього на одну комірку вліво, щоб закрити пролом після видалення елемента. Тому логарифмічна складність буде такою ж, як і у<span class="code">add(&lt;Index&gt;,&lt;Elelement&gt;)</span> , якщо елемент був усередині — O(N/2), — адже потрібно половину елементів зрушити однією вліво. Відповідно, якщо він був на початку - O (N). Ну і якщо наприкінці — O(1), то й рухати нічого не потрібно. Для охочих заглибитися в цю тему я залишу <a href="https://codegym.cc/groups/posts/2472-podrobnihy-razbor-klassa-arraylist" target="_blank">це посилання</a> на статтю з розбором класу <span class="code">ArrayList</span> . <img data-max-width="512" data-id="4aa018c5-c124-454a-abbb-4359255f37be" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 9 - 6" src="https://cdn.javarush.com/images/article/4aa018c5-c124-454a-abbb-4359255f37be/512.jpeg" style="width: 512px;">
<h4>87. Яка внутрішня будова LinkedList?</h4>Якщо <span class="code">ArrayList</span> містить елементи у внутрішньому масиві, <span class="code">LinkedList</span> — у вигляді двозв'язкового списку. Це означає, кожен елемент містить посилання попередній елемент ( <span class="text-bold">previous</span> ) і наступний ( <span class="text-bold">next</span> ). У першого елемента немає посилання на попередній (адже він перший), при цьому він вважається главою списку, і в <span class="code">LinkedList</span> є посилання безпосередньо на нього. Останній елемент, власне, не має наступного елемента, він є хвостом списку, і тому пряме посилання на нього є в самому <span class="code">LinkedList</span> . Тому логарифмічна складність при доступі до глави або хвоста списку O(1). <img data-max-width="800" data-id="da052cec-21ce-4a02-9ea2-aaa65434bc2f" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 9 - 7" src="https://cdn.javarush.com/images/article/da052cec-21ce-4a02-9ea2-aaa65434bc2f/800.jpeg" style="width: 800px;">В <span class="code">ArrayList</span>при збільшенні списку збільшувався внутрішній масив, відразу все відбувається простіше - при додаванні елемента просто змінюються пару посилань. <span class="code">Давайте розглянемо деякі методи LinkedlList</span> -а , що найбільш використовуються : 1. <span class="code">add(&lt;Elelement&gt;)</span> — відбувається додавання в кінці списку, тобто. після останнього елемента (5) додасться посилання новий елемент як <span class="text-bold">next</span> . Новому елементу додасться посилання останній (5) як <span class="text-bold">previous</span> елемент. Логарифмічна складність такої операції буде O(1), так як необхідне лише посилання на останній елемент, а як ви пам'ятаєте, на хвіст є пряме посилання з <span class="code">LinkedList</span> і логарифмічна складність доступу до нього мінімальна. 2. <span class="code">add(&lt;Index&gt;,&lt;Elelement&gt;)</span>- Додавання елемента за індексом. При додаванні елемента, наприклад, в середину списку, спочатку перебираються елементи з голови та хвоста (з обох боків), доки не буде знайдено потрібне місце. Якщо ми хочемо вставити елемент між третім та четвертим (на малюнку вище), то при пошуку потрібного місця посилання <span class="text-bold">next</span> третього елемента вже вказуватиме на новий. Нове ж посилання <span class="text-bold">previous</span> буде вказувати на третій. Відповідно, посилання четвертого елемента - <span class="text-bold">previous</span> - вказуватиме вже на новий елемент, а у нового елемента посилання <span class="text-bold">next</span> буде вказувати на четвертий елемент: <img data-max-width="512" data-id="f3439f20-903c-4b40-a329-60742504b3d5" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 9 - 8" src="https://cdn.javarush.com/images/article/f3439f20-903c-4b40-a329-60742504b3d5/512.jpeg" style="width: 512px;">Логарифмічна складність даного методу залежатиме від індексу, що задається новому елементу: 
<ul>
 <li>якщо він буде близький до голови або хвоста, то наближатися до O(1), оскільки перебирати елементи фактично не буде потрібно;</li>
 <li>якщо ж близько до середини, то O(N/2) - відбуватиметься перебирання елементів з голови та хвоста одночасно, доки не буде знайдений потрібний елемент.</li>
</ul>3. <span class="code">set(&lt;Index&gt;,&lt;Elelement&gt;)</span> — записує елемент у вказану позицію у списку. Логарифмічна складність цієї операції коливатиметься від O(1) до O(N/2), знову ж таки залежно від того, наскільки близький елемент до голови, хвоста або середини. 4. <span class="code">remove(&lt;index&gt;)</span> - видаляє елемент зі списку, по суті роблячи так, щоб елемент, який знаходиться перед видаленим ( <span class="text-bold">previous</span> ), посилався на елемент, що йде після видаленого ( <span class="text-bold">next</span> ). І навпаки: щоб елемент, що йде після видаленого, посилався на той, що йде перед видаленим: Вийшов <img data-max-width="512" data-id="d2320bd0-75f5-4fdc-8520-064b601634af" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 9 - 9" src="https://cdn.javarush.com/images/article/d2320bd0-75f5-4fdc-8520-064b601634af/512.jpeg" style="width: 512px;">процес, зворотний додавання по індексу ( <span class="code">add(&lt;Index&gt;,&lt;Elelement&gt;)</span> ). Бажаючим дізнатися більше про внутрішній пристрій <span class="code">LinkedList</span>пораджу прочитати <a href="https://codegym.cc/groups/posts/1938-linkedlist" target="_blank">ось цю статтю</a> .
<h4>88. Яка внутрішня будова HashMap?</h4>Мабуть, одне з найпопулярніших питань при співбесіді Java-розробника. <span class="code">HashMap</span> v працює з парами <span class="text-bold">ключ - значення</span> . Як же вони зберігаються всередині самого <span class="code">HashMapv</span> ? Усередині <span class="code">HashMap</span> є масив нод: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table</code></pre> За умовчанням розмір масиву - 16, і він збільшується щоразу вдвічі в міру заповнення елементами (при досягненні <span class="text-bold">LOAD_FACTOR</span> - певного відсотка заповненості, за умовчанням він - <span class="text-bold">0.75</span> ). Кожна з нод зберігає в собі хеш ключа, ключ, значення, посилання на наступний елемент: <img data-max-width="512" data-id="9932ab13-5613-41f8-8bc4-e018a9b980f3" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 9 - 10" src="https://cdn.javarush.com/images/article/9932ab13-5613-41f8-8bc4-e018a9b980f3/512.jpeg" style="width: 512px;">Власне, "посилання на наступний елемент" означає, що ми маємо справу з списком, де кожен елемент містить посилання на наступний елемент. Тобто <span class="code">HashMap</span> зберігає дані в масиві списків. Але відразу зазначу: коли один осередок масиву <span class="code">table</span> має посилання на подібний список, що складається з більш ніж одного елемента, це не є добре. Таке явище називається <span class="text-bold">колізія</span>. Але про все по порядку. Давайте розберемося, як відбувається збереження нової пари через метод <span class="code">put</span> . Спочатку береться ключ <span class="code">hachCode()</span> . Тому для коректної роботи <span class="code">hashmap</span> як ключі потрібно брати класи, в яких даний метод перевизначено. Далі цей хеш-код використовується у внутрішньому методі — <span class="code">hash()</span> — для визначення числа в межах розміру масиву <span class="code">table</span> . Далі по отриманому числу йде звернення до конкретної осередку масиву <span class="code">table</span> . Тут у нас два випадки: 
<ol>
 <li>Осередок порожній — у ньому зберігається нове значення <span class="code"> Node</span> .</li>
 <li>Осередок не порожній — порівнюється значення ключів. Якщо вони рівні, нове значення <span class="code"> Node</span> перезаписує старе, якщо не рівні - йде звернення до елемента <span class="text-bold">next</span> (наступного), йде порівняння вже з його ключем ... І так доти, поки нове значення не перезапише деяке старе або не досягне кінця однозв'язкового списку збережеться там останнім елементом.</li>
</ol>При пошуку елемента за ключом (метод <span class="code">get(&lt;key&gt;)</span> ), обчислюється <span class="code">hashCode</span> ключа, потім його значення в межах масиву за допомогою <span class="code">hash()</span> , і по отриманому числу знаходиться осередок масиву <span class="code">table</span> , в якому вже ведеться пошук шляхом перебору нід та порівняння ключа шуканої ноди із ключем поточної. Операції у <span class="code">Map</span>при ідеальному розкладі мають алгоритмічну складність O(1), адже йде звернення до масиву, а як ви пам'ятаєте, незалежно від кількості елементів операції масив мають складність O(1). Але це в ідеальному випадку. Коли осередок масиву не порожній (2) і там вже є деякі ноди, алгоритмічна складність перетворюється на лінійну O(N), адже тепер необхідно перебрати елементи, перш ніж знайдеться потрібне місце. Не можу не згадати ось що: починаючи з Java 8, якщо у однозв'язкового списку node більше 8 елементів (колізії), він перетворюється на двійкове дерево. У такому разі алгоритмічна складність буде вже не O(N), а O(log(N)) — це вже інша річ, чи не так? <img data-max-width="512" data-id="05b5698b-f092-4f29-8a35-5370521a429c" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 9 - 11" src="https://cdn.javarush.com/images/article/05b5698b-f092-4f29-8a35-5370521a429c/512.jpeg" style="width: 512px;"><span class="code">HashMap</span>— велика тема і по ній люблять ставити запитання на співбесідах. Тому раджу докладно розібратися у ній (щоб аж від зубів відсякувало). Особисто у мене не було співбесід без питань щодо <span class="code">HashMap</span> . Глибокий розбір <span class="code">HashMap</span> ви можете знайти <a href="https://codegym.cc/groups/posts/2496-podrobnihy-razbor-klassa-hashmap" target="_blank">у цій статті</a> . На цьому сьогодні все, продовження... <img data-max-width="512" data-id="528f29d9-7e73-4f79-b05c-b848904dc5b4" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 9 - 12" src="https://cdn.javarush.com/images/article/528f29d9-7e73-4f79-b05c-b848904dc5b4/512.jpeg" style="width: 512px;"><a href="https://codegym.cc/login/signup" target="_blank"><img id="click_banner1_articles" data-max-width="1080" data-id="5736eb4b-2b1c-4ab6-b4cc-b9e2d1cef628" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 9 - 13" src="https://cdn.javarush.com/images/article/5736eb4b-2b1c-4ab6-b4cc-b9e2d1cef628/1080.jpeg" style="width: 1080px;"></a>
<div class="table-container">
 <table>
  <tbody>
   <tr>
    <th>Інші матеріали серії:</th>
   </tr>
   <tr>
    <td>
     <ul>
      <li><a href="https://codegym.cc/groups/posts/3243-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-1" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 1</a></li>
      <li><a href="https://codegym.cc/groups/posts/3252-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-2" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 2</a></li>
      <li><a href="https://codegym.cc/groups/posts/3273-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-3" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 3</a></li>
      <li><a href="https://codegym.cc/groups/posts/3284-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-4" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 4</a></li>
      <li><a href="https://codegym.cc/groups/posts/3296-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-5" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 5</a></li>
      <li><a href="https://codegym.cc/groups/posts/3341-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-6" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 6</a></li>
      <li><a href="https://codegym.cc/groups/posts/3386-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-7" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 7</a></li>
      <li><a href="https://codegym.cc/groups/posts/3415-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-8" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 8</a></li>
      <li><a href="https://codegym.cc/groups/posts/3452-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-10" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 10</a></li>
      <li><a href="https://codegym.cc/groups/posts/3464-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-11" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 11</a></li>
      <li><a href="https://codegym.cc/groups/posts/3475-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-12" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 12</a></li>
      <li><a href="https://codegym.cc/groups/posts/3507-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-13" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 13</a></li>
      <li><a href="https://codegym.cc/groups/posts/3558-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-14" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 14</a></li>
      <li><a href="https://codegym.cc/groups/posts/3592-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-15" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 15</a></li>
      <li><a href="https://codegym.cc/groups/posts/3621-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-16" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 16</a></li>
     </ul></td>
   </tr>
  </tbody>
 </table>
</div>