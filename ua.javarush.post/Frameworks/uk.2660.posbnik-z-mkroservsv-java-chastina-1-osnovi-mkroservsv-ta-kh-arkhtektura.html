Посібник з мікросервісів Java. Частина 1: основи мікросервісів та їх архітектура
<p>----------------------------------------</p>
З цього посібника ви дізнаєтеся що таке мікросервіси Java, як їх проектувати та створювати. Також тут порушені питання про бібліотеки мікросервісів Java та доцільність застосування мікросервісів. Переклад та адаптація . Щоб зрозуміти мікрос
<p>----------------------------------------</p>
З цього посібника ви дізнаєтеся що таке мікросервіси Java, як їх проектувати та створювати. Також тут порушені питання про бібліотеки мікросервісів Java та доцільність застосування мікросервісів. Переклад та адаптація <a href="https://www.marcobehler.com/guides/java-microservices-a-practical-guide#_deploying_and_testing_java_microservices" rel="nofollow" target="_blank">Java Microservices: A Practical Guide</a> . 
<h2>Мікросервіси Java: основи</h2>Щоб зрозуміти мікросервіси, потрібно спочатку визначити, що не є. А чи не є ними “моноліт” — Java monolith: що це таке і які його переваги чи недоліки? <img data-max-width="800" data-id="dff44531-5438-48ab-8074-8faa018cb89f" class="img-fluid" alt="Посібник з мікросервісів Java.  Частина 1: основи мікросервісів та їх архітектура." src="https://cdn.javarush.com/images/article/dff44531-5438-48ab-8074-8faa018cb89f/800.jpeg" style="width: 800px;">
<h3>Що таке Java-моноліт?</h3>Уявіть, що ви працюєте у банку чи фінтех-стартапі. Ви надаєте користувачам мобільну програму, яку можна використовувати для відкриття нового банківського рахунку. У Java коді це призведе до наявності класу-контролера. Спрощено він виглядає так: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token annotation punctuation"><span class="token annotation punctuation">@Controller</span></span>
<span class="token keyword"><span class="token keyword">class</span></span> <span class="token class-name"><span class="token class-name">BankController</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>

    <span class="token annotation punctuation"><span class="token annotation punctuation">@PostMapping</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">"/users/register"</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
    <span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">register</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">RegistrationForm</span></span> form<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
        <span class="token function"><span class="token function">validate</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>form<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token function"><span class="token function">riskCheck</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>form<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token function"><span class="token function">openBankAccount</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>form<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token comment"><span class="token comment">// etc..</span></span>
    <span class="token punctuation"><span class="token punctuation">}</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> Вам потрібно, щоб контролер: 
<ol>
 <li>Підтверджував форму реєстрації.</li>
 <li>Перевіряв ризики на адресау користувача, щоб вирішити, чи надавати йому банківський рахунок.</li>
 <li>Відкривав банківський рахунок.</li>
</ol>Клас <code class=" language-none">BankController</code>буде упакований разом з рештою ваших вихідних файлів bank.jar або bank.war для розгортання - це і є старий добрий моноліт, що містить весь код, необхідний для роботи вашого банку. За грубими підрахунками, початковий розмір .jar (або .war) файлу складе від 1 до 100 МБ. Тепер ви можете просто запустити .jar файл на своєму сервері… і це все, що потрібно зробити для розгортання Java-додатки. <img data-max-width="800" data-id="7604ffac-8a1a-4af2-8a86-01a1bfe61a40" class="img-fluid" alt="Посібник з мікросервісів Java.  Частина 1: основи мікросервісів та їх архітектура." src="https://cdn.javarush.com/images/article/7604ffac-8a1a-4af2-8a86-01a1bfe61a40/800.jpeg" style="width: 800px;">Зображення, лівий прямокутник зверху: розгортання моно(літного) банку java -jar bank.jar (cp .war/.ear into appserver). Правий прямокутник: відкритий браузер. 
<h3>У чому проблема з Java-монолітами?</h3>По суті, в Java-монолітах немає нічого поганого. Однак досвід показав, що якщо у вас у проекті: 
<ul>
 <li>Працює багато програмістів / команд / консультантів.</li>
 <li>...над одним і тим же монолітом під тиском замовників з вельми невиразними вимогами...</li>
 <li>протягом кількох років...</li>
</ul>… то в такому разі ваш маленький файлик bank.jar перетворюється на неозорий гігабайт одного тільки коду, до якого навіть підступитися страшно, не кажучи вже про розгортання. 
<h3>Як зменшити розмір моноліту Java?</h3>Виникає природне питання: як зробити моноліт менше? Зараз ваш bank.jar працює на одній JVM, один процес на одному сервері. Ні більше, ні менше. І ось саме зараз на думку може спасти логічна думка: «Але ж служба перевірки ризиків може використовуватися й іншими відділами в моїй компанії! Вона не має безпосереднього відношення до моєї монолітної банківської програми! Можливо, чи варто вирізати її з моноліту і розгорнути, як окремий продукт? Тобто якщо говорити технічно, запустити його як окремий процес Java”. 
<h3>Що таке мікросервіс Java?</h3>На практиці таке словосполучення означає, що тепер виклик методу <code class=" language-none">riskCheck()</code>здійснюватиметься не з BankController: цей метод або bean-компонент з усіма його допоміжними класами буде переміщений у власний Maven- або Gradle-проект. Також його буде розгорнуто та поміщено під систему контролю версій незалежно від банківського моноліту. Однак весь цей процес вилучення не перетворює ваш новий модуль RiskCheck на мікросервіс як такий, оскільки визначення мікросервісу відкрито для інтерпретації. Це призводить до частих дискусій усередині команд та компаній. 
<ul>
 <li>5-7 класів у проекті – це мікро чи як?</li>
 <li>100 чи 1000 класів... все ще мікро?</li>
 <li>Мікросервіс взагалі пов'язаний із кількістю класів чи ні?</li>
</ul>Давайте залишимо теоретичні міркування, а замість них дотримуватимемося прагматичних міркувань і зробимо ось що: 
<ol>
 <li>Назвемо всі сервіси, що окремо розгортаються, мікросервісами, незалежно від їх розмірів або меж домену.</li>
 <li>Подумаємо, як влаштувати міжсервісне спілкування. Нашим мікросервісам потрібні способи спілкування.</li>
</ol>Отже, підіб'ємо підсумки: раніше у вас був один JVM-процес, цілісний моноліт для роботи банку. Тепер у вас є JVM-процес банківського моноліту та окремий мікросервіс RiskCheck, який працює в рамках власного JVM-процесу. І тепер для перевірки ризиків ваш моноліт має викликати цей мікросервіс. Як це зробити? 
<h3>Як налагодити комунікацію між мікросервісами Java?</h3>Загалом є два варіанти — синхронна та асинхронна комунікація. 
<h4>Синхронна комунікація: (HTTP)/REST</h4>Зазвичай синхронізована комунікація між мікросервісами здійснюється через HTTP та REST-подібні сервіси, які повертають XML чи JSON. Зрозуміло, можуть бути й інші варіанти взяти хоча б <a href="https://developers.google.com/protocol-buffers" rel="nofollow" target="_blank">Google Protocol Buffers</a> . Якщо вам потрібна негайна відповідь, краще використовувати REST-комунікацію. У нашому прикладі саме так і потрібно робити, оскільки перевірка ризиків є обов'язковою перед відкриттям рахунку. Якщо немає перевірки ризиків, немає і рахунку. Інструменти обговоримо нижче, у розділі “ <a href="https://codegym.cc/groups/posts/2663-rukovodstvo-po-mikroservisam-java-chastjh-3-objshie-voprosih#topic1" target="_blank">Які бібліотеки найкраще підходять для синхронних викликів Java REST</a> ”. 
<h4>Обмін повідомленнями – асинхронна комунікація</h4>Асинхронний мікросервісний зв'язок зазвичай здійснюється за допомогою обміну повідомленнями з реалізацією JMS та/або за допомогою протоколу, наприклад, <a href="https://www.amqp.org/" rel="nofollow" target="_blank">AMQP</a> . Ми тут написали "зазвичай" не просто так: скажімо, кількість інтеграцій електронною поштою/SMTP не можна недооцінювати. Використовуйте його тоді, коли вам не потрібна негайна відповідь. Наприклад, користувач натискає кнопку "купити зараз", а ви у свою чергу хочете згенерувати рахунок-фактуру. Цей процес, безумовно, не повинен відбуватися в рамках циклу запиту-відповіді користувача на покупку. Нижче описано, які інструменти найкраще підходять для <a href="https://codegym.cc/groups/posts/2663-rukovodstvo-po-mikroservisam-java-chastjh-3-objshie-voprosih#topic2" target="_blank">асинхронного обміну повідомленнями Java</a> . 
<h3>Приклад: виклик REST API у Java</h3>Припустимо, ми обрали синхронну мікросервісну комунікацію. У такому разі наш Java-код (той, що ми наводабо вище) на низькому рівні виглядатиме приблизно так. (Під низьким рівнем тут ми розуміємо той факт, що для мікросервісної комунікації зазвичай створюються клієнтські бібліотеки, які абстрагують вас від реальних HTTP-дзвінків). 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token annotation punctuation"><span class="token annotation punctuation">@Controller</span></span>
<span class="token keyword"><span class="token keyword">class</span></span> <span class="token class-name"><span class="token class-name">BankController</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>

    <span class="token annotation punctuation"><span class="token annotation punctuation">@Autowired</span></span>
    <span class="token keyword"><span class="token keyword">private</span></span> <span class="token class-name"><span class="token class-name">HttpClient</span></span> httpClient<span class="token punctuation"><span class="token punctuation">;</span></span>

    <span class="token annotation punctuation"><span class="token annotation punctuation">@PostMapping</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">"/users/register"</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
    <span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">register</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">RegistrationForm</span></span> form<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
        <span class="token function"><span class="token function">validate</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>form<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
        httpClient<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">send</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>riskRequest<span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token function"><span class="token function">responseHandler</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token function"><span class="token function">setupAccount</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>form<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token comment"><span class="token comment">// etc..</span></span>
    <span class="token punctuation"><span class="token punctuation">}</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> Виходячи з коду, стає ясно, що тепер нам потрібно розгорнути два Java-(мікро) сервіси, Bank та RiskCheck. У результаті у нас буде запущено два JVM-процеси. <img data-max-width="800" data-id="455f7fb3-fff7-4dac-b278-e4a825523060" class="img-fluid" alt="Посібник з мікросервісів Java.  Частина 1: основи мікросервісів та їх архітектура." src="https://cdn.javarush.com/images/article/455f7fb3-fff7-4dac-b278-e4a825523060/800.jpeg" style="width: 800px;">Ось і все, що вам потрібно для розробки проекту з мікросервісами Java: просто створюйте та розгортайте менші фрагменти (файли .jar або .war) замість одного монолітного. Залишається незрозумілою відповідь на питання, яким чином нам слід розрізати моноліт на мікросервіси? Наскільки дрібними мають бути ці шматочки, як визначити правильний розмір? Давайте перевіримо. 
<h2>Архітектура Java Microservices</h2>Насправді компанії розробляють мікросервісні проекти по-різному. Підхід залежить від того, чи намагаєтеся ви перетворити існуючий моноліт на проект із мікросервісами або ж починаєте проект з нуля. 
<h3>Від моноліту до мікросервісів</h3>Одна з найлогічніших ідей - витягти мікросервіси з існуючого моноліту. Зверніть увагу, що приставка «мікро» тут насправді не означає, що вилучені сервіси будуть невеликими, це зовсім не обов'язково. Розгляньмо теоретичні основи. 
<h4>Ідея: розбити моноліт на мікросервіси</h4>До легасі-проектів можна застосувати мікросервісний підхід. І ось чому: 
<ol>
 <li>Найчастіше такі проекти складно підтримувати/змінювати/розширювати.</li>
 <li>Усі, починаючи від розробників і до керівництва, хочуть спрощення.</li>
 <li>У вас (щодо) чіткі межі домену, тобто ви знаєте, що саме має робити ваше програмне забезпечення.</li>
</ol>Повертаючись до нашого прикладу, це означає, що ви можете поглянути на свій банківський Java-моноліт і спробувати розбити його за межами домену. 
<ul>
 <li>Так, буде розумно виділити в окремий мікросервіс «Управління обліковими записами», обробку даних користувача (таких як імена, адресаи, номери телефонів).</li>
 <li>Або вищезгаданий «Модуль перевірки ризиків, який перевіряє рівні ризику користувача та може використовуватись багатьма іншими проектами або навіть відділами компанії.</li>
 <li>Або модуль виставлення рахунків, який надсилає рахунки у форматі PDF або поштою.</li>
</ul>
<h3>Втілення ідеї: нехай це зробить хтось інший</h3>Описаний вище підхід відмінно виглядає на папері та UML-подібних діаграмах. Однак, все не так просто. Для його практичної реалізації потрібна серйозна технічна підготовка: прірва між розумінням того, що було б непогано витягти з моноліту і процесом вилучення — величезна. Більшість корпоративних проектів сягають стадії, коли розробники побоюються, скажімо, оновити 7-річну версію Hibernate до новішої. Разом з нею оновляться бібліотеки, проте існує неілюзорна небезпека щось поламати. І ось, ті ж розробники тепер повинні копатися в стародавньому легасі-коді з незрозумілими межами транзакцій бази даних і отримувати чітко визначені мікросервіси? Найчастіше це завдання дуже складна, її не вийде "вирішити" на дошці або на нарадах з архітектури. <img data-max-width="800" data-id="cd989204-e4bc-49bd-a943-1e9911943763" class="img-fluid" alt="Посібник з мікросервісів Java.  Частина 1: основи мікросервісів та їх архітектура." src="https://cdn.javarush.com/images/article/cd989204-e4bc-49bd-a943-1e9911943763/800.jpeg" style="width: 800px;">Процитую Twitter розробника @simonbrown: <em><span class="text-bold">Я повторюватиму це знову і знову ... якщо люди не можуть правильно будувати моноліти, мікросервіси не допоможуть. </span></em> Саймон Браун 
<h3>Проект "з нуля" на базі мікросервісної архітектури</h3>У разі нових Java-проектів три нумеровані пункти з попередньої частини виглядають дещо інакше: 
<ol>
 <li>Ви починаєте з чистого листа, тому немає “багажу” для обслуговування.</li>
 <li>Розробники хотіли б, щоб у майбутньому все було просто.</li>
 <li>Проблема: у вас набагато туманніша картина меж доменів: ви не знаєте, що насправді має робити ваше програмне забезпечення (підказка: agile;))</li>
</ol>Це призводить до того, що компанії намагаються використати нові проекти з мікросервісами Java. 
<h4>Технічна мікросервісна архітектура</h4>Перший пункт здається найбільш очевидним для розробників, однак є й ті, хто вкрай не рекомендує його. Хаді Харірі рекомендує рефакторинг "Extract Microservice" в IntelliJ. І хоча наступний приклад дуже спрощений, реалізації, які спостерігаються в реальних проектах, на жаль, не надто далеко від нього пішли. <span class="text-bold">До мікросервісів</span>
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token annotation punctuation"><span class="token annotation punctuation">@Service</span></span>
<span class="token keyword"><span class="token keyword">class</span></span> <span class="token class-name"><span class="token class-name">UserService</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>

    <span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">register</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">User</span></span> user<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
        <span class="token class-name"><span class="token class-name">String</span></span> email <span class="token operator"><span class="token operator">=</span></span> user<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">getEmail</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token class-name"><span class="token class-name">String</span></span> username <span class="token operator"><span class="token operator">=</span></span>  email<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">substring</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token number"><span class="token number">0</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> email<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">indexOf</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">"@"</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token comment"><span class="token comment">// ...</span></span>
    <span class="token punctuation"><span class="token punctuation">}</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre><span class="text-bold">З substring-мікросервісом Java</span>
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token annotation punctuation"><span class="token annotation punctuation">@Service</span></span>
<span class="token keyword"><span class="token keyword">class</span></span> <span class="token class-name"><span class="token class-name">UserService</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>

    <span class="token annotation punctuation"><span class="token annotation punctuation">@Autowired</span></span>
    <span class="token keyword"><span class="token keyword">private</span></span> <span class="token class-name"><span class="token class-name">HttpClient</span></span> client<span class="token punctuation"><span class="token punctuation">;</span></span>

    <span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">register</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">User</span></span> user<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
        <span class="token class-name"><span class="token class-name">String</span></span> email <span class="token operator"><span class="token operator">=</span></span> user<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">getEmail</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token comment"><span class="token comment">//теперь вызываем substring microservice via http</span></span>
        <span class="token class-name"><span class="token class-name">String</span></span> username <span class="token operator"><span class="token operator">=</span></span>  httpClient<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">send</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token function"><span class="token function">substringRequest</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>email<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token function"><span class="token function">responseHandler</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token comment"><span class="token comment">// ...</span></span>
    <span class="token punctuation"><span class="token punctuation">}</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> Таким чином, ви, по суті, включає виклик Java в виклик HTTP, без очевидних причин для цього. Одна з причин, однак, полягає у наступному: відсутність досвіду та спроба форсувати підхід на основі мікросервісів Java. Рекомендація: не робіть цього. 
<h3>Workflow-орієнтована мікросервісна архітектура</h3>p align="justify"&gt; Наступним поширеним підходом є поділ мікросервісів Java на модулі на базі workflow. Приклад із реального життя: у Німеччині, коли ви звертаєтесь до (загальнодоступного) лікаря, він має записати ваше відвідування у своїй медичній CRM-системі. Щоб отримати оплату від страховки, він надішле дані про ваше лікування (і лікування інших пацієнтів) посереднику через XML. Посередник розгляне цей файл XML і (спрощено): 
<ol>
 <li>Перевірить, чи правильний XML-файл отримано.</li>
 <li>Перевірить правдоподібність процедур: скажімо, однорічна дитина, яка отримала три процедури чищення зубів за один день від лікаря-гінеколога виглядає дещо підозріло.</li>
 <li>Об'єднає XML із деякими іншими бюрократичними даними.</li>
 <li>Перешле XML-файл до страхової компанії, щоб ініціювати платежі.</li>
 <li>І перешле результат лікаря, забезпечивши його повідомленням «успіх» або «будь ласка, надішліть цей запис ще раз, як тільки це матиме сенс».</li>
</ol>Примітка. У цьому прикладі комунікація між мікросервісами не відіграє ролі, але цілком може бути виконана асинхронно брокером повідомлень (наприклад, RabbitMQ), оскільки лікар все одно не отримує негайного зворотного зв'язку. <img data-max-width="1024" data-id="85982516-ac7f-47cc-b929-e5bf0befca7a" class="img-fluid" alt="Посібник з мікросервісів Java.  Частина 1: основи мікросервісів та їх архітектура." src="https://cdn.javarush.com/images/article/85982516-ac7f-47cc-b929-e5bf0befca7a/1024.jpeg" style="width: 1024px;">Знову ж таки, це чудово виглядає на папері, але виникають закономірні питання: 
<ul>
 <li>Чи є потреба у розгортанні шести додатків для обробки одного XML-файлу?</li>
 <li>Чи ці мікросервіси незалежні один від одного? Чи можуть вони бути розгорнуті незалежно один від одного? З різними версіями та схемами API?</li>
 <li>Що робить мікросервіс правдоподібності інформації, якщо мікросервіс перевірки не працює? Система все ще працює?</li>
 <li>Чи поділяють ці мікросервіси одну й ту саму базу даних (їм, безумовно, потрібні деякі загальні дані в таблицях БД), чи кожен має свою власну?</li>
 <li>… і багато іншого.</li>
</ul>Цікаво, що наведена вище діаграма виглядає простіше, тому що кожен сервіс тепер має своє точне, чітко визначене призначення. Раніше це виглядало приблизно як цей страшний моноліт: <img data-max-width="512" data-id="c70383eb-9122-4e69-8d47-5dbee864b5ca" class="img-fluid" alt="Посібник з мікросервісів Java.  Частина 1: основи мікросервісів та їх архітектура." src="https://cdn.javarush.com/images/article/c70383eb-9122-4e69-8d47-5dbee864b5ca/512.jpeg" style="width: 512px;">Незважаючи на те, що можна сперечатися про простоту цих діаграм, тепер вам безперечно потрібно вирішити ці додаткові операційні завдання. 
<ul>
 <li>Вам потрібно не просто розгорнути одну програму, а як мінімум шість.</li>
 <li>Можливо, навіть потрібно розгорнути кілька баз даних, залежно від того, як далеко ви хочете заглибитись у мікросервісну архітектуру.</li>
 <li>Потрібно стежити, щоб кожна система працювала в режимі онлайн, причому працювала нормально.</li>
 <li>Необхідно переконатися, що ваші виклики між мікросервісами дійсно стійкі (див. Як зробити мікросервіс Java стійким?).</li>
 <li>І все інше, що має на увазі це налаштування — від локальних налаштувань розробки до інтеграційного тестування.</li>
</ul>Тож рекомендація буде наступною: 
<ul>
 <li>Якщо ви не Netflix (скоріше за все, ви не Netflix) ...</li>
 <li>Якщо ви не маєте надсильних навичок роботи, при яких ви відкриваєте середовище розробки, а воно викликає хаосну мавпу, яка відкидає вашу виробничу базу даних, яка легко відновлюється через 5 секунд.</li>
 <li>або ви почуваєтеся як @monzo і готові випробувати 1500 мікросервісів просто тому, що можете.</li>
</ul>→ Не робіть цього. А тепер менш гіперболізовано. Спроба моделювати мікросервіс після доменних кордонів здається цілком розумною. Але це не означає, що потрібно взяти один робочий процес та розділити його на крихітні окремі частини (отримати XML, перевірити XML, надіслати XML). Отже, кожного разу, коли ви починаєте новий проект з мікросервісів Java, і межі домену все ще дуже розпливчасті, намагайтеся підтримувати розмір мікросервісів на нижньому рівні. Пізніше ви завжди зможете додати більше модулів. І переконайтеся, що у вас знайдеться розвинений DevOps у команді/компанії/підрозділі для підтримки нової інфраструктури. <a href="https://codegym.cc/welcome" target="_blank"><img id="click_banner1_articles" data-max-width="1024" data-id="58a993c5-430e-485c-becc-56b8ecb6e847" class="img-fluid" alt="Посібник з мікросервісів Java.  Частина 1: основи мікросервісів та їх архітектура." src="https://cdn.javarush.com/images/article/58a993c5-430e-485c-becc-56b8ecb6e847/1024.jpeg" style="width: 1024px;"></a>
<h2>Поліглот або командно-орієнтована мікросервісна архітектура</h2>Існує третій, майже лібертаріанський, підхід до розробки мікросервісів: надання командам або навіть окремим особам можливості реалізовувати власні історії із застосуванням будь-якої кількості мов або мікросервісів (маркетологи називають такий підхід "поліглотським програмуванням"). Так, описана вище служба перевірки XML може бути написана на Java, а мікросервіс валідації в той же час – мовою Haskell (щоб зробити його математично обґрунтованим). Для мікросервісу пересилання страховки можна застосувати мову Erlang (бо він дійсно повинен масштабуватися;)). Те, що може здатися кумедним з погляду розробника (розробка ідеальної системи з вашою ідеальною мовою в ізольованому середовищі), по суті, ніколи не є тим, чого хоче організація: гомогенізація та стандартизація. <img data-max-width="800" data-id="fb4bbf84-771d-4ffb-8f9a-b279a060d429" class="img-fluid" alt="Посібник з мікросервісів Java.  Частина 1: основи мікросервісів та їх архітектура." src="https://cdn.javarush.com/images/article/fb4bbf84-771d-4ffb-8f9a-b279a060d429/800.jpeg" style="width: 800px;">Історія показує, що зазвичай стандартизація укорінюється надто глибоко. Скажімо, розробникам великих компаній зі списку Fortune 500 іноді навіть не дозволяли використовувати Spring, оскільки це «не входить у план компанії з технологій». Втім, повний перехід на підхід поліглоту — це майже те саме, інша сторона тієї ж монети. Рекомендація: якщо ви збираєтеся використовувати поліглот-програмування, спробуйте менше різноманіття в одній екосистемі мови програмування. Так, краще застосовувати разом Kotlin і Java (обидві мови засновані на JVM і 100% сумісні один з одним), а не Java і, скажімо, Haskell. У <a href="https://codegym.cc/groups/posts/2661-rukovodstvo-po-mikroservisam-java-chastjh-2-razvertihvanie-i-testirovanie" target="_blank">наступній частині</a> ви дізнаєтеся про розгортання та тестування мікросервісів Java.