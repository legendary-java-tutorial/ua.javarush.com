JUnit для JavaRush або трохи про тестування в домашніх умовах.
<p>----------------------------------------</p>
Набридло десятки разів вбивати в консоль тестові дані, щоб перевірити своє завдання? Ласкаво просимо під кат, я розповім, що можна з цим зробити.
<p>----------------------------------------</p>
Набридло десятки разів вбивати в консоль тестові дані, щоб перевірити своє завдання? Ласкаво просимо під кат, я розповім, що можна з цим зробити. <cut>
 Кінцевою метою даного матеріалу буде автоматизація запуску розв'язуваної задачі з різними параметрами та перевіркою результатів без внесення змін до її вихідного коду. Як Ви вже напевно зрозуміли із заголовка, головним нашим помічником у цій досить простій справі буде 
 <a href="https://codegym.cc/groups/posts/605-junit" target="_blank">JUnit</a> . Якщо Ви ще не чули про 
 <strong>модульне тестування</strong> та 
 <strong>юніт-тести</strong>, пропоную Вам трохи відволіктися і самостійно познайомитися з цими поняттями, благо в інтернеті достатньо інформації. Ні, не бажаєте? Ну і гаразд, думаю великою проблемою для розуміння того, що відбувається, це не стане. Адже Ви знаєте що таке тест і тестування взагалі? Ви ж займаєтеся цим щоразу, коли запускаєте своє завдання, вводите початкові дані і порівнюєте результат, що вийшов, з тим, що очікували побачити. 
 <h6>Hello, <s>world</s> JUnit!</h6> Що таке JUnit? На 
 <a href="http://junit.org/" rel="nofollow">оф.сайті</a> проекту ми можемо прочитати такий опис: 
 <blockquote>
  JUnit is a simple framework to write repeatable tests. Це is instance of xUnit architecture for unit testing frameworks.
 </blockquote> Для нас це означає можливість писати спеціальним чином оформлені класи, методи яких будуть взаємодіяти з нашою програмою, звіряти результат з еталонним і інформувати нас якщо вони не збіглися. Для розуміння принципу розглянемо простий приклад. Припустимо, у нас є допоміжний клас, один з методів якого приймає дві змінні типу 
 <em>int</em> і повертає їхню суму: 
 <img data-id="82cd5e6c-0021-4e16-827c-11d6cd142439" data-max-width="570" alt="JUnit для CodeGym або трохи про тестування в домашніх умовах.  - 1" src="https://cdn.javarush.com/images/article/82cd5e6c-0021-4e16-827c-11d6cd142439/512.jpeg" style="width: 570px;"> Ось цей функціонал ми і спробуємо протестувати. На щастя, наша улюблена IDEA вже має все необхідне для швидкого створення тестів, все, що нам потрібно, це встановити курсор у рядку оголошення класу, натиснути "Alt+Enter" та в контекстному меню вибрати "Create Test": 
 <img data-id="91a25a7a-05c3-4183-8314-e60daab81707" data-max-width="423" alt="JUnit для CodeGym або трохи про тестування в домашніх умовах.  - 2" src="https://cdn.javarush.com/images/article/91a25a7a-05c3-4183-8314-e60daab81707/256.jpeg" style="width: 423px;"> Після того, як Ви уточните, де варто створити тест, IDEA запропонувати вибрати бібліотеку тестування (в даному матеріалі я використовую JUnit4, для того, щоб класи бібліотеки були підключені до проекту необхідно натиснути кнопку "Fix"), методи, що тестуються, і додаткові опції. 
 <img data-id="5cbf58c8-dac4-48d1-a0cd-9230e0836609" data-max-width="570" alt="JUnit для CodeGym або трохи про тестування в домашніх умовах.  - 3" src="https://cdn.javarush.com/images/article/5cbf58c8-dac4-48d1-a0cd-9230e0836609/512.jpeg" style="width: 570px;"> IDE створить шаблон тестового класу: Ім'яКласу = ім'яТестованогоКласу + "Test" ім'яМетода = "test" + Ім'яТестованогоМетоду 
 <img data-id="55408809-a34b-48bb-aab3-b0832a6861dc" data-max-width="570" alt="JUnit для CodeGym або трохи про тестування в домашніх умовах.  - 4" src="https://cdn.javarush.com/images/article/55408809-a34b-48bb-aab3-b0832a6861dc/512.jpeg" style="width: 570px;"> Нам залишається тільки наповнити тіло методу. У цьому на допомогу так звані 
 <a href="https://github.com/junit-team/junit/wiki/Assertions" rel="nofollow">"Assertions \ Затвердження"</a>, методи, що надаються JUnit. Спрощено їх робота виглядає наступним чином: метод .assert* передається очікуваний результат і результат виклику тестованого методу, для зручності першим параметром можна додати пояснювальне повідомлення. Якщо під час виконання тесту параметри не співпадуть, Ви будете проінформовані про це. Запускати тестовий клас на виконання можна як і звичайний клас, я волію використовувати комбінацію клавіш Ctrl+Shift+F10 
 <img data-id="806422be-7177-43bd-8e28-1e724b172799" data-max-width="570" alt="JUnit для CodeGym або трохи про тестування в домашніх умовах.  - 5" src="https://cdn.javarush.com/images/article/806422be-7177-43bd-8e28-1e724b172799/512.jpeg" style="width: 570px;">
 <h6>Конкретизуємо завдання</h6> Теоретично все просто і красиво, але в розрізі запропонованого прикладу не особливо те і потрібно, скласти два числа ми можемо довірити комп'ютеру. Нас більше цікавить як будуть справи з реальними завданнями, що вирішуються студентами CodeGym, для прикладу я пропоную взяти улюблену level05.lesson12.bonus03. 
 <blockquote>
  /* Завдання за алгоритмами Написати програму, яка: 1. вводить з консолі число N &gt; 0 2. потім вводить N чисел з консолі 3. виводить на екран максимальне із введених N чисел. */
 </blockquote> Нам необхідно написати три тести для позитивних, негативних чисел і змішаного набору. 
 <h6>Чим далі у ліс...</h6> Ось тут на нас і чекають деякі сюрпризи: 
 <code class=" language-none">public class UtilApp { public static void main(String[] args) throws Exception { BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); //напишите здесь ваш код int n; int maximum; /* Конечно же я не буду размещать решение задачи ;) Код приведенный тут переработан для наглядности, и не в коем случае не означает что он должен присутствовать в "правильном решении" */ System.out.println(maximum); } }</code>
 <ul>
  <li>Логіка програми розміщується у методі main()</li>
  <li>Вихідні дані не передаються методом, а вводяться з клавіатури.</li>
  <li>Метод main() не повертає результату, а виводить його в консоль.</li>
 </ul> Якщо перший пункт не особливо і проблематичний (ми можемо викликати метод main() як завжди), то наступні два змушують заглиблюватися в тему і напружувати звивини. Я знайшов кілька варіантів вирішення проблеми: 
 <ol>
  <li><u>Винесення логіки знаходження максимуму окремий метод.</u></li>
  <ul>
   <li><strong>Плюси:</strong> Правильний підхід з погляду рефакторингу</li>
   <li><strong>Мінуси:</strong> Програма обростає кодом, зайвими структурами, як мінімум додається масив або ArrayList (на смак та колір...). Тестується лише механізм знаходження максимуму, введення даних, як і висновок, не перевіряються.</li>
  </ul>
  <li><u>Написання обгорток-wrapper'ів для System.in/System.out.</u></li>
  <ul>
   <li><strong>Плюси:</strong> Не використовуємо сторонні бібліотеки.</li>
   <li><strong>Мінуси:</strong> Шлях не для новачків. Відносна складність реалізації тесту, обсяг коду в тесті може бути більшим ніж у задачі, що тестується.</li>
  </ul>
  <li><u>Використання для тестування додаткових бібліотек.</u></li>
  <ul>
   <li><strong>Плюси:</strong> Чистота коду у тестах, відносна простота написання тесту. Не змінюється вихідний код класу, що тестується.</li>
   <li><strong>Мінуси:</strong> Необхідність підключити до проекту сторонні бібліотеки.</li>
  </ul>
 </ol> Зізнатись чесно, третій варіант мені сподобався найбільше, ось його і спробуємо реалізувати. 
 <h6>System Rules</h6> Недовгі пошуки привели мене на сторінку 
 <a href="http://stefanbirkner.github.io/system-rules/" rel="nofollow">http://stefanbirkner.github.io/system-rules/</a> , і відразу стало зрозуміло, що це, що мені потрібно. 
 <blockquote>
  Збірка JUnit правил для тестування коду, що використовує java.lang.System.
 </blockquote> Отже, 
 <a href="http://stefanbirkner.github.io/system-rules/download.html" rel="nofollow">завантажуємо бібліотеку</a> . Завантажуємо необхідну для роботи system rules бібліотеку 
 <a href="http://commons.apache.org/proper/commons-io/download_io.cgi" rel="nofollow">Commons IO</a> . Підключаємо обидві бібліотеки до нашого проекту (File -&gt; Project Structure -&gt; Libraries -&gt; + -&gt; Java) і починаємо ваяти: Після запуску наше завдання просить ввести з консолі N+1 чисел, де перше число повідомляє про те, скільки чисел піде за ним. У System Rules для цих цілей служить клас TextFromStandardInputStream, спочатку нам необхідно додати до нашого тестового класу поле цього типу і позначити його анотацією @Rule: Потім, 
 <code class=" language-none">@Rule public final TextFromStandardInputStream systemInMock = emptyStandardInputStream();</code> безпосередньо в тестовому методі вказуємо необхідні дані: 
 <code class=" language-none">systemInMock.provideText("4\n2\n6\n1\n3\n");</code> Як бачите, числа передаються в текстовому вигляді та поділяються знаком перенесення рядка "\n". Виходячи з цього, виходить що N у нас буде 4, а шукати максимум ми будемо з чисел {2, 6, 1, 3}. Далі нам необхідно створити екземпляр класу, що тестується, і викликати метод main(). Наша програма вважає дані з systemInMock, обробить їх і роздрукує результат, а нам залишається тільки рахувати його і порівняти з еталоном. Для цього система правил надає нам клас StandardOutputStreamLog. Додаємо поле зазначеного типу: 
 <code class=" language-none"> @Rule public final StandardOutputStreamLog log = new StandardOutputStreamLog();</code> Вважати роздруковані дані можна за допомогою методу .getLog(), при цьому потрібно враховувати наявність символів перекладу рядка, остаточні варіанти можуть бути такі: 
 <code class=" language-none">assertEquals("{2, 6, 1, 3}, max = 6", "6", log.getLog().trim()); // або assertEquals("{2, 6, 1, 3}, max = 6", "6\r\n", log.getLog());</code> Між тестами, щоб уникнути нашарування даних, необхідно очищати log 
 <code class=" language-none">log.clear();</code> Повний текст мого тестового класу: 
 <code class=" language-none">import org.junit.Rule; import org.junit.Test; import org.junit.contrib.java.lang.system.StandardOutputStreamLog; import org.junit.contrib.java.lang.system.TextFromStandardInputStream; import static org.junit.Assert.*; import static org.junit.contrib.java.lang.system.TextFromStandardInputStream.emptyStandardInputStream; public class UtilAppTest { @Rule public final TextFromStandardInputStream systemInMock = emptyStandardInputStream(); @Rule public final StandardOutputStreamLog log = new StandardOutputStreamLog(); @Test public void testAddition() throws Exception { systemInMock.provideText("4\n2\n6\n1\n3\n"); UtilApp utilApp = new UtilApp(); utilApp.main(new String[]{}); assertEquals("{2, 6, 1, 3}, max = 6", "6", log.getLog().trim()); systemInMock.provideText("5\n-100\n-6\n-15\n-183\n-1\n"); log.clear(); utilApp.main(new String[]{}); assertEquals("{-100, -6, -15, -183, -1}, max = -1", "-1", log.getLog().trim()); systemInMock.provideText("3\n2\n0\n-1\n"); log.clear(); utilApp.main(new String[]{}); assertEquals("{2, 0, -1}, max = 2", "2", log.getLog().trim()); } }</code> Запускаємо та насолоджуємося. 
 <strong>-=! ВАЖЛИВО !!!=-</strong> Даний матеріал наданий ТІЛЬКИ в ознайомлювальних цілях, я не гарантую успішного проходження тестування завдання на сервері у разі наявності стороннього класу в пакеті із завданням. Перш ніж надсилати завдання на перевірку на сервер, видаляйте все стороннє: зайві файли, зайві класи, закоментований код. Вдале проходження придуманих тестів не гарантує успішного проходження тестів на сервері. Я навмисне не розжовував теоретичний матеріал: теорію модульного тестування, анотації JUnit, assert та інше, весь матеріал є у запропонованих у тексті посиланнях. Можливо, у Вас є свої способи тестування завдань, я з радістю обговорю їх з Вами в коментарях.
</cut>