Spring Framework. Вступ
<p>----------------------------------------</p>
Вітання! Поки адміністрація JavaRush працює над новими рівнями, я хочу почати серію навчальних статей по Spring Framework. Так, я знаю, що у мережі вже багато матеріалу на цю тему, але, як показує практика, всі вони на рівні Hello World'a. 
<p>----------------------------------------</p>
Вітання! Поки адміністрація CodeGym працює над новими рівнями, я хочу почати серію навчальних статей по Spring Framework. Так, я знаю, що у мережі вже багато матеріалу на цю тему, але, як показує практика, всі вони на рівні Hello World'a. Я хочу розповісти не про те, як правильно розставити анотації, а про те, як це все влаштовано «під капотом». Стаття розрахована на тих, хто вже так чи інакше працював із цим фреймворком та знайомий з основними поняттями. <img data-id="571d0b4a-30a5-426f-8040-8ff3c0b371ba" data-max-width="850" alt="Spring Framework.  Вступ - 1" src="https://cdn.javarush.com/images/article/571d0b4a-30a5-426f-8040-8ff3c0b371ba/800.jpeg" style="width: 850px;">
<h2>Ініціалізація контексту.</h2>Отже, почнемо з основ. На мій погляд, одним із найважливіших моментів є розуміння того, як відбувається налаштування контексту та ініціалізації бінів. Як відомо, перш ніж <a href="https://codegym.cc/groups/posts/476-spring-dlja-lenivihkh-osnovih-bazovihe-koncepcii-i-primerih-s-kodom-chastjh-1" target="_blank">Spring</a> почне працювати, його необхідно налаштувати. У допотопні часи це робабо за допомогою XML файлів (на деяких проектах, переважно старих, продовжують робити це досі). Ось невеликий приклад такого файлу конфігурації: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token operator"><span class="token operator">&lt;</span></span><span class="token operator"><span class="token operator">?</span></span>xml version<span class="token operator"><span class="token operator">=</span></span><span class="token string"><span class="token string">"1.0"</span></span> encoding<span class="token operator"><span class="token operator">=</span></span><span class="token string"><span class="token string">"UTF-8"</span></span><span class="token operator"><span class="token operator">?</span></span><span class="token operator"><span class="token operator">&gt;</span></span>

<span class="token operator"><span class="token operator">&lt;</span></span>beans xmlns<span class="token operator"><span class="token operator">=</span></span><span class="token string"><span class="token string">"http://www.springframework.org/schema/beans"</span></span>
    xmlns<span class="token operator"><span class="token operator">:</span></span>xsi<span class="token operator"><span class="token operator">=</span></span><span class="token string"><span class="token string">"http://www.w3.org/2001/XMLSchema-instance"</span></span>
    xsi<span class="token operator"><span class="token operator">:</span></span>schemaLocation<span class="token operator"><span class="token operator">=</span></span>"http<span class="token operator"><span class="token operator">:</span></span><span class="token operator"><span class="token operator">/</span></span><span class="token operator"><span class="token operator">/</span></span>www<span class="token punctuation"><span class="token punctuation">.</span></span>springframework<span class="token punctuation"><span class="token punctuation">.</span></span>org<span class="token operator"><span class="token operator">/</span></span>schema<span class="token operator"><span class="token operator">/</span></span>beans
    http<span class="token operator"><span class="token operator">:</span></span><span class="token operator"><span class="token operator">/</span></span><span class="token operator"><span class="token operator">/</span></span>www<span class="token punctuation"><span class="token punctuation">.</span></span>springframework<span class="token punctuation"><span class="token punctuation">.</span></span>org<span class="token operator"><span class="token operator">/</span></span>schema<span class="token operator"><span class="token operator">/</span></span>beans<span class="token operator"><span class="token operator">/</span></span>spring<span class="token operator"><span class="token operator">-</span></span>beans<span class="token operator"><span class="token operator">-</span></span><span class="token number"><span class="token number">3.0</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>xsd"<span class="token operator"><span class="token operator">&gt;</span></span>

   <span class="token operator"><span class="token operator">&lt;</span></span>bean id<span class="token operator"><span class="token operator">=</span></span><span class="token string"><span class="token string">"helloWorld"</span></span> <span class="token keyword"><span class="token keyword">class</span></span><span class="token operator"><span class="token operator">=</span></span><span class="token string"><span class="token string">"com.codegym.HelloWorld"</span></span><span class="token operator"><span class="token operator">&gt;</span></span>
       <span class="token operator"><span class="token operator">&lt;</span></span>property name<span class="token operator"><span class="token operator">=</span></span><span class="token string"><span class="token string">"message"</span></span> value<span class="token operator"><span class="token operator">=</span></span><span class="token string"><span class="token string">"Hello World!"</span></span><span class="token operator"><span class="token operator">/</span></span><span class="token operator"><span class="token operator">&gt;</span></span>
   <span class="token operator"><span class="token operator">&lt;</span></span><span class="token operator"><span class="token operator">/</span></span>bean<span class="token operator"><span class="token operator">&gt;</span></span>

<span class="token operator"><span class="token operator">&lt;</span></span><span class="token operator"><span class="token operator">/</span></span>beans<span class="token operator"><span class="token operator">&gt;</span></span></code></pre> За великим рахунком, цього достатньо, щоб створити пару контролерів і запустити стартап (який не злетить). Але як ця конфігурація змусить працювати Spring? А ось тут починається найцікавіше. Для того щоб наша конфігурація була зрозуміла Spring'ом існує <code class=" language-none">XmlBeanDefinitionReader</code>. Це внутрішній компонент Spring'a, який сканує (парсит) xml та на основі того, що ми там написали створює <code class=" language-none">BeanDefinition</code>'и. <code class=" language-none">BeanDefinition</code>– це об'єкт, який зберігає інформацію про бине. Сюди входить: із якого класу його (бін) треба створити; scope; чи встановлена ​​лінива ініціалізація; потрібно перед цим біном ініціалізувати інший та інші проперти, які описані в xml. Усі отримані <code class=" language-none">BeanDefinition</code>'и складаються в <code class=" language-none">HashMap</code>, в якій ідентифікатором є ім'я біна (встановлене вами або присвоєне спрингом) і сам<code class=" language-none">BeanDefinition</code>об'єкт. Після того, як всі <code class=" language-none">BeanDefinition</code>створені на сцену виходить новий герой – <code class=" language-none">BeanFactory</code>. Цей об'єкт ітерується за <code class=" language-none">HashMap’e</code>с'ами <code class=" language-none">BeanDefinition</code>, створює на їх основі біни і складає в IoC контейнер. Тут є нюанс, насправді, при старті програми, в IoC контейнер потраплять бины, які мають scope Singleton (встановлюється за замовчуванням), інші створюються, тоді як вони потрібні (prototype, request, session). А тепер невеликий відступ, познайомимось із ще одним персонажем. 
<h2>Зустрічайте - BeanPostProcessor. (BPP)</h2><img data-id="c7086349-9c05-4e77-b8eb-8eddbcc6306c" data-max-width="600" alt="bean post processor" src="https://cdn.javarush.com/images/article/c7086349-9c05-4e77-b8eb-8eddbcc6306c/512.jpeg" style="width: 600px;">Справа в тому, що бін це не обов'язково клас бізнес-логіки вашої програми. Біном також називають інфраструктурний бін. Коротко, інфраструктурний бін це клас, який налаштовує біни вашої бізнес-логіки (так-так, надто багато бінів). Докладніше про нього я розповім нижче, але щоб було трохи зрозуміліше, що саме BPP налаштовує, наведу приклад. Всім же знайома інструкція <code class=" language-none">@Autowired</code>? Так ось, саме <code class=" language-none">AutowiredAnnotationBeanPostProcessor</code>відповідальний за те, щоб усі ваші класи були запроваджені один в одного. <img data-max-width="180" alt="uknowimean" src="https://cdn.javarush.com/images/article/e4313405-c16d-44f6-b695-a9f288963e5e/original.jpeg">
<h2>Повернімося до BeanFactory</h2>Знаючи тепер про BPP, потрібно уточнити, що ітеруючись по <code class=" language-none">HashMap</code>'e з <code class=" language-none">BeanDefinition</code>'ами спершу створюються і кладуться окремо (не в IoC контейнер) всі <code class=" language-none">BeanPostProcessor</code>'и. Після цього створюються звичайні біни нашої бізнес-логіки, складаються в IoC-контейнер і починається їх налаштування за допомогою окремо відкладених BPP. А відбувається це ось як, кожен BPP має 2 методи: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class="  language-java"><span class="token function"><span class="token function">postProcessorBeforeInitialization</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">Object</span></span> bean<span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token class-name"><span class="token class-name">String</span></span> beanName<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token function"><span class="token function">postProcessorAfterInitialization</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">Object</span></span> bean<span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token class-name"><span class="token class-name">String</span></span> beanName<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> Відбувається ітерація нашими бінами двічі. Вперше викликається метод <code class=" language-none">postProcessorBeforeInitialization</code>, а вдруге викликається метод <code class=" language-none">postProcessorAfterInitialization</code>. Напевно постало питання, навіщо потрібні два методи, пояснюю. Справа в тому, що для обробки деяких анотацій (таких як <code class=" language-none">@Transactional</code>наприклад) наш бін замінюється proxy класом. Щоб зрозуміти навіщо це робиться, потрібно знати, як працює <code class=" language-none">@Transactional</code>, а працює це ось як. У спосіб, позначений цією інструкцією потрібно нальоту додати ще кілька рядків коду. Як це зробити? Правильно, за допомогою створення класу proxy, всередині якого буде доданий необхідний код у потрібний метод. А тепер уявимо таку ситуацію, у нас є клас: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">class</span></span> <span class="token class-name"><span class="token class-name">A</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
    <span class="token annotation punctuation"><span class="token annotation punctuation">@Autowired</span></span>
    <span class="token keyword"><span class="token keyword">private</span></span> <span class="token class-name"><span class="token class-name">SomeClass</span></span> someClass<span class="token punctuation"><span class="token punctuation">;</span></span>

    <span class="token annotation punctuation"><span class="token annotation punctuation">@Transactional</span></span>
    <span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">method</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
        <span class="token comment"><span class="token comment">// модификатор доступа обязательно public</span></span>
    <span class="token punctuation"><span class="token punctuation">}</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> У цьому класі 2 інструкції <code class=" language-none">@Autowired</code>та <code class=" language-none">@Transactional</code>. Обидві інструкції обробляються різними BPP. Якщо першим відпрацює <code class=" language-none">AutowiredBPP</code>, то все буде гаразд, але якщо ні, то ми зіткнемося з ось якою проблемою. Справа в тому, що коли створюється клас proxy, то вся мета-інформація втрачається. Іншими словами, інформації про інструкцію <code class=" language-none">@Autowired</code>в proxy класі не буде, а значить і <code class=" language-none">AutowiredBPP</code>не відпрацює, а значить наше поле <code class=" language-none">someClass</code>матиме значення <code class=" language-none">null</code>, що, швидше за все, призведе до NPE. Також варто знати, що між викликами методів <code class=" language-none">postProcessorBeforeInitialization</code>і <code class=" language-none">postProcessorAfterInitialization</code>відбувається виклик <code class=" language-none">init</code>методу, якщо він є. Це другий конструктор, але відмінність в тому, що в цей момент всі наші залежності вже впроваджені в клас і ми можемо до них звернутися з<code class=" language-none">init</code>-Методу. Отже, ще раз алгоритм ініціалізації контексту: 
<ol>
 <li><code class=" language-none">XmlBeanDefinitionReader</code>сканує наш XML-конфігураційний файл.</li>
 <li>Створює <code class=" language-none">BeanDefinition</code>і кладе їх у <code class=" language-none">HashMap</code>.</li>
 <li>Приходить <code class=" language-none">BeanFactory</code>і з цієї <code class=" language-none">HashMap</code>окремо складає всі <code class=" language-none">BeanPostProcessor</code>ти.</li>
 <li>Створює з ' <code class=" language-none">BeanDefinition</code>ів біни і кладе їх у IoC-контейнер.</li>
 <li>Тут приходять BPP та налаштовують ці біни за допомогою 2х методів.</li><il>
  Готово.
 </il>
</ol>Власне, на цьому все, пишіть, сподобалася вам стаття і чи варто продовжувати писати подібні туторіали.