Використання JNDI в Java
<p>----------------------------------------</p>
Вітання! Сьогодні ми познайомимося з тобою з JNDI. Дізнаємося, що це таке, для чого воно потрібне, як працює, як нам з ним працювати. А потім напишемо Spring Boot юніт тест, усередині якого гратимемося з цим самим JNDI. Перш ніж занурюватис
<p>----------------------------------------</p>
Вітання! Сьогодні ми познайомимося з тобою з JNDI. Дізнаємося, що це таке, для чого воно потрібне, як працює, як нам з ним працювати. А потім напишемо Spring Boot юніт тест, усередині якого гратимемося з цим самим JNDI. <img data-max-width="800" data-id="a3259e80-13ea-4e15-a815-c3931e1df2ea" class="img-fluid" alt="Використання JNDI в Java - 1" src="https://cdn.javarush.com/images/article/a3259e80-13ea-4e15-a815-c3931e1df2ea/800.jpeg" style="width: 800px;">
<h2>Вступ. Служби імен та каталогів</h2>Перш ніж занурюватися в JNDI, розберемося з тим, що таке служби імен і каталогів. Найбільш наочним прикладом такої служби є файлова система на будь-якому ПК, ноутбуці або смартфоні. Файлова система управляє (хоч як це дивно) файлуми. Файли у таких системах згруповані у деревоподібну структуру. Кожен файл має унікальне повне ім'я, наприклад: C:\windows\notepad.exe. Зверніть увагу: повне ім'я файлу є шлях від деякої кореневої точки (диск C) до самого файлу (notepad.exe). Проміжними вузлами такого ланцюга є каталоги (каталог windows). Файли всередині каталогів мають атрибути. Наприклад "Прихований", "Тільки для читання" та ін. Детальний опис такої простої речі як файлова система допоможе краще зрозуміти визначення служби імен та каталогів. Отже,<span class="text-bold"></span>- Це система, яка управляє відображенням безлічі імен у безлічі об'єктів. У нашій файловій системі ми взаємодіємо з іменами файлів, за якими ховаються об'єкти – самі файли у різних форматах. У службі імен та каталогів іменовані об'єкти зібрані у деревоподібну структуру. А об'єкти каталогу мають атрибути. Ще одним прикладом служби імен та каталогів є DNS (англ. - Domain Name System, "система доменних імен"). Ця система керує відповідністю між зрозумілими людині доменними іменами (наприклад, https://codegym.cc/) та зрозумілими комп'ютеру IP-адресаами (наприклад, 18.196.51.113). Крім DNS і файлових систем, є ще безліч інших служб, таких як: 
<ul>
 <li><a href="https://ru.wikipedia.org/wiki/LDAP" rel="nofollow" target="_blank">Lightweight Directory Access Protocol (LDAP)</a> ;</li>
 <li><a href="https://ru.wikipedia.org/wiki/CORBA" rel="nofollow" target="_blank">сервіс іменування CORBA</a> ;</li>
 <li><a href="https://ru.wikipedia.org/wiki/Network_Information_Service" rel="nofollow" target="_blank">Network Information Service (NIS)</a> ;</li>
 <li>Та інші.</li>
</ul>
<h2>JNDI</h2>JNDI, або ж Java Naming and Directory Interface, є Java API для доступу до служб імен і каталогів. JNDI – це API, яке надає одноманітний механізм взаємодії Java-програми з різними службами імен та каталогів. "Під капотом" інтеграція між JNDI та будь-якою конкретною службою здійснюється за допомогою інтерфейсу постачальника послуг (Service Provider Interface, SPI). SPI дозволяє прозоро підключати різні служби іменування та каталогів, що дозволяє Java-програмі використовувати JNDI API для доступу до підключених служб. Рисунок нижче ілюструє архітектуру JNDI: <img data-max-width="512" data-id="bba8e179-d07d-4971-9757-01b9724c5e5a" class="img-fluid" alt="Використання JNDI в Java - 2" border="0" src="https://cdn.javarush.com/images/article/bba8e179-d07d-4971-9757-01b9724c5e5a/512.jpeg" style="width: 512px;">
<center>
 <p><small><em>Джерело: <a href="https://docs.oracle.com/javase/tutorial/jndi/overview/index.html" rel="nofollow" target="_blank">Oracle Java Tutorials</a></em></small></p>
</center>
<h2>JNDI. Сенс простими словами</h2>Головне питання: навіщо потрібний JNDI? JNDI потрібен для того, щоб ми могли з Java-коду отримати Java-об'єкт з деякої "Реєстратури" об'єктів на ім'я об'єкта, прив'язаного до цього об'єкта. Розіб'ємо твердження вище на тези, щоб розмаїття повторюваних слів не збило нас з пантелику: 
<ol>
 <li>Зрештою, нам потрібно отримати Java-об'єкт.</li>
 <li>Ми отримаємо цей об'єкт із деякої реєстратури.</li>
 <li>У цій реєстратурі є купа об'єктів.</li>
 <li>Кожен об'єкт у цій реєстратурі має унікальне ім'я.</li>
 <li>Щоб отримати певний об'єкт із реєстратури, ми маємо у своєму запиті передати ім'я. Як би сказати: "Дайте мені, будь ласка, те, що у вас лежить під таким ім'ям".</li>
 <li>Ми можемо не тільки зчитувати об'єкти за їхнім ім'ям з реєстратури, але й зберігати в цій реєстратурі об'єкти під певними іменами (адже вони туди потрапляють).</li>
</ol>Отже, у нас є якась реєстратура, або сховище об'єктів, або JNDI Tree. Далі, наприклад, спробуємо зрозуміти сенс JNDI. Варто відзначити, що здебільшого JNDI використовується в Enterprise-розробці. А подібні програми працюють всередині деякого застосування сервера. Цим сервером може бути якийсь Java EE Application Server або контейнер сервлетів, на зразок Tomcat, або будь-який інший контейнер. Сама реєстратура об'єктів, тобто JNDI Tree, зазвичай знаходиться всередині цього application сервера. Останнє не завжди є обов'язковим (таке дерево можна мати локально), але найбільш типове. JNDI Tree може керуватися спеціальною людиною (системний адміністратор або DevOps фахівець), яка "зберігатиме в реєстратурі" об'єкти з їх іменами. Коли наша програма та JNDI Tree знаходяться спільно всередині одного контейнера, ми без будь-яких проблем можемо отримати доступ до будь-якого Java-об'єкта, який зберігається в такій реєстратурі. Більше того, реєстратура та наше застосування можуть знаходитися в різних контейнерах і навіть на різних фізичних машинах. JNDI навіть у такому разі дозволяє отримувати доступ до Java-об'єктів віддалено. Типовий кейс. Адміністратор Java EE сервера кладе в реєстратуру об'єкт, де зберігається необхідна інформація для підключення до бази даних. Відповідно, для роботи з БД ми просто запитаємо потрібний об'єкт із JNDI tree та будемо з ним працювати. Це дуже зручно. Зручність полягає ще й у тому, що в enterprise-розробці існують різні оточення. Є продакшн сервера, є тестові (і часто тестових буває більше 1 шт.). Тоді, розмістивши на кожному сервері всередині JNDI об'єкт для підключення до БД і використовуючи цей об'єкт усередині нашої програми, нам не доведеться нічого змінювати при депло нашого додатка з одного сервера (тестового, релізного) на інший. Всюди буде доступ до бази даних. Приклад, звичайно, певною мірою спрощений, але, сподіваюся, він допоможе краще зрозуміти, навіщо потрібний JNDI. Далі будемо знайомитись з JNDI in Java ближче, з деякими елементами рукоприкладства. 
<h2>JNDI API</h2>JNDI постачається усередині платформи Java SE. Для використання JNDI необхідно імпортувати JNDI класи, а також один або більше постачальників послуг для доступу до служб імен та каталогів. JDK включає постачальників послуг до наступних служб: 
<ul>
 <li>Lightweight Directory Access Protocol (LDAP);</li>
 <li>Common Object Request Broker Architecture (CORBA);</li>
 <li>Common Object Services (COS) name service;</li>
 <li>Java Remote Method Invocation (RMI) Registry;</li>
 <li>Domain Name Service (DNS).</li>
</ul>Код JNDI API поділено на кілька пакетів: 
<ul>
 <li>javax.naming;</li>
 <li>javax.naming.directory;</li>
 <li>javax.naming.ldap;</li>
 <li>javax.naming.event;</li>
 <li>javax.naming.spi.</li>
</ul>Знайомство з JNDI ми почнемо з двох інтерфейсів – Name та Context, які містять ключову функціональність JNDI 
<h2>Інтерфейс Name</h2>За допомогою інтерфейсу Name можна керувати іменами компонентів, а також синтаксисом імен JNDI. У JNDI всі операції з іменами та каталогами виконуються щодо контексту. Абсолютного коріння немає. Тому JNDI визначає InitialContext, який забезпечує відправну точку для іменування та операцій із каталогами. Після отримання доступу до початкового контексту його можна використовувати для пошуку об'єктів та інших контекстів. 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">Name</span></span> objectName <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">CompositeName</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">"java:comp/env/jdbc"</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> У коді вище ми визначабо деяке ім'я, під яким знаходиться певний об'єкт (можливо, і не перебуває, але розраховуємо на це). Наша кінцева мета – отримати посилання на цей об'єкт і використовувати його в нашій програмі. Отже, ім'я складається з кількох частин (або токенів), розділених слешем. Такі токени називають контекстами (context). Найперший – просто context, всі наступні – sub-context (далі за текстом – підконтекст). Контексти простіше розуміти, якщо їх як аналогію каталогів чи директорій, чи навіть звичайних папок. Кореневий контекст – коренева папка. Підконтекст – вкладена папка. Ми можемо побачити всі складові (контекст та підконтексти) даного імені, виконавши наступний код: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">Enumeration</span></span><span class="token generics"><span class="token punctuation"></span><span class="token generics"><span class="token punctuation"><span class="token punctuation">&lt;</span></span><span class="token class-name"><span class="token class-name">String</span></span><span class="token punctuation"><span class="token punctuation">&gt;</span></span></span><span class="token punctuation"></span></span> elements <span class="token operator"><span class="token operator">=</span></span> objectName<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">getAll</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token keyword"><span class="token keyword">while</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>elements<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">hasMoreElements</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
  <span class="token class-name"><span class="token class-name">System</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>elements<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">nextElement</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> Висновок буде наступним: 
<pre class=" language-none" tabindex="0"><code class=" language-none">
java:comp
env
jdbc</code></pre> Висновок демонструє, що токени відокремлюються один від одного слешем (втім, ми це згадували). Кожен токен імені має власний індекс. Індексація токенів починається з 0. Нульовим індексом має кореневий контекст, наступний контекст має індекс 1, наступний 2 і т.д. Ми можемо отримати ім'я підконтексту за його індексом: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">System</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>objectName<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">get</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token number"><span class="token number">1</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span> <span class="token comment"><span class="token comment">// -&gt; env</span></span></code></pre> Можемо також додавати додаткові токени (або в кінець, або у певне місце за індексом): 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class="  language-java">objectName<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">add</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">"sub-context"</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span> <span class="token comment"><span class="token comment">// Добавит sub-context в конец</span></span>
objectName<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">add</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token number"><span class="token number">0</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token string"><span class="token string">"context"</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span> <span class="token comment"><span class="token comment">// Добавит context в налачо</span></span></code></pre> З повним переліком методів можна ознайомитись <a href="https://docs.oracle.com/javase/8/docs/api/javax/naming/Name.html" rel="nofollow" target="_blank">офіційною в документації</a> . 
<h2>Інтерфейс Context</h2>Цей інтерфейс містить набір констант для ініціалізації контексту, а також набір методів для створення та видалення контекстів, прив'язки об'єктів до імені, а також для пошуку та отримання об'єктів. Розглянемо деякі операції, які виконуються за допомогою даного інтерфейсу. Найчастіша дія - пошук об'єкта на ім'я. Здійснюється за допомогою методів: 
<ul>
 <li><code class=" language-none">Object lookup(String name)</code></li>
 <li><code class=" language-none">Object lookup(Name name)</code></li>
</ul>Прив'язка об'єкта до імені здійснюється за допомогою методів <code class=" language-none">bind</code>: 
<ul>
 <li><code class=" language-none">void bind(Name name, Object obj)</code></li>
 <li><code class=" language-none">void bind(String name, Object obj)</code></li>
</ul>Обидва методи прив'яжуть ім'я name до об'єкта <code class=" language-none">Object</code> Зворотня операція прив'язки - відв'язування об'єкта від імені здійснюється за допомогою <code class=" language-none">unbind</code>методів 
<ul>
 <li><code class=" language-none">void unbind(Name name)</code></li>
 <li><code class=" language-none">void unbind(String name)</code></li>
</ul>Повний перелік методів є на <a href="https://docs.oracle.com/javase/8/docs/api/javax/naming/Context.html" rel="nofollow" target="_blank">сайті офіційної документації</a> . 
<h2>InitialContext</h2><code class=" language-none">InitialContext</code>- Це клас, який являє собою кореневий елемент JNDI tree і реалізує інтерфейс <code class=" language-none">Context</code>. Шукати об'єкти на ім'я всередині JNDI tree потрібно щодо деякого вузла. Таким вузлом може бути кореневий вузол дерева — <code class=" language-none">InitialContext</code>. Типовим сценарієм використання JNDI є: 
<ul>
 <li>Отримати <code class=" language-none">InitialContext</code>.</li>
 <li>Використовувати <code class=" language-none">InitialContext</code>для вилучення об'єктів на ім'я з JNDI tree.</li>
</ul>Способів отримати <code class=" language-none">InitialContext</code>буває кілька. Все залежить від оточення, де знаходиться Java-програма. Наприклад, якщо Java-програма та JNDI tree запущені всередині одного і того ж application сервера, отримати <code class=" language-none">InitialContext</code>досить просто: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">InitialContext</span></span> context <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">InitialContext</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> Якщо це не так, отримати контекст стає трохи складніше. Деколи буває необхідно передати список пропертів оточення для ініціалізації контексту: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">Hashtable</span></span> env <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">Hashtable</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
env<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">put</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">Context</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>INITIAL_CONTEXT_FACTORY<span class="token punctuation"><span class="token punctuation">,</span></span>
    <span class="token string"><span class="token string">"com.sun.jndi.fscontext.RefFSContextFactory"</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>

<span class="token class-name"><span class="token class-name">Context</span></span> ctx <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">InitialContext</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>env<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> Приклад вище демонструє один із можливих способів ініціалізації контексту та іншого смислового навантаження у собі не несе. Детально занурюватись у код не потрібно. 
<h2>Приклад використання JNDI усередині SpringBoot unit тесту</h2>Вище ми говорабо про те, що для взаємодії JNDI зі службою імен та каталогів необхідно мати під рукою SPI (Service Provider Interface), за допомогою якого здійснюватиметься інтеграція між Джавою та службою імен. Стандартна JDK поставляється з декількома різними SPI (вище ми їх перераховували), кожен із яких не викликає великого інтересу для демонстраційних цілей. Підняти JNDI і Java додаток всередині якогось контейнера якоюсь мірою цікаво. Однак автор цієї статті - людина лінива, тому для демонстрації роботи JNDI вибрав шлях найменшого опору: запустити JNDI всередині юніт-тесту SpringBoot програми та отримати доступ до контексту JNDI за допомогою невеликого хаку від Spring Framework. Отже, наш план: 
<ul>
 <li>Напишемо порожній Spring Boot проект.</li>
 <li>Усередині цього проекту створимо юніт-тест.</li>
 <li>Усередині тесту продемонструємо роботу з JNDI: 
  <ul>
   <li>отримаємо доступ до контексту;</li>
   <li>прив'яжемо (bind) деякий об'єкт під деяким ім'ям JNDI;</li>
   <li>отримаємо об'єкт на його ім'я (lookup);</li>
   <li>перевіримо, що об'єкт не null.</li>
  </ul></li>
</ul>Почнемо по порядку. <em>File-&gt;New-&gt;Project...</em> <img data-max-width="800" data-id="b91c7249-661a-41da-a482-b045db2f53d8" class="img-fluid" alt="Використання JNDI в Java - 3" src="https://cdn.javarush.com/images/article/b91c7249-661a-41da-a482-b045db2f53d8/800.jpeg" style="width: 800px;"> Далі виберемо пункт <em>Spring Initializr</em> : <img data-max-width="800" data-id="7916acb5-6f97-41b7-add8-21e74aad6f70" class="img-fluid" alt="Використання JNDI в Java - 4" src="https://cdn.javarush.com/images/article/7916acb5-6f97-41b7-add8-21e74aad6f70/800.jpeg" style="width: 800px;">Заповним метадані про проект: <img data-max-width="800" data-id="a1707760-212c-4084-ab25-fcab1a527da2" class="img-fluid" alt="Використання JNDI в Java - 5" src="https://cdn.javarush.com/images/article/a1707760-212c-4084-ab25-fcab1a527da2/800.jpeg" style="width: 800px;">Після чого виберемо необхідні компоненти Spring Framework. Ми будемо прив'язувати якісь DataSource-об'єкти, тому нам потрібні компоненти для роботи з БД: 
<ul>
 <li>JDBC API;</li>
 <li>H2 DDatabase.</li>
</ul><img data-max-width="1024" data-id="e9d47924-d95c-432c-a988-2989a1807615" class="img-fluid" alt="Використання JNDI в Java - 6" src="https://cdn.javarush.com/images/article/e9d47924-d95c-432c-a988-2989a1807615/1024.jpeg" style="width: 1024px;">Визначимо розташування у файловій системі: <img data-max-width="800" data-id="1f9706fb-4dd4-4431-89df-11ab6eecd148" class="img-fluid" alt="Використання JNDI в Java - 7" src="https://cdn.javarush.com/images/article/1f9706fb-4dd4-4431-89df-11ab6eecd148/800.jpeg" style="width: 800px;">І проект створено. Насправді за нас автоматично згенерували один юніт тест, яким ми й скористаємося для демонстраційних цілей. Нижче - структура проекту і потрібний нам тест: <img data-max-width="800" data-id="9b81a366-06b5-4259-9033-be6efde79f3f" class="img-fluid" alt="Використання JNDI в Java - 8" src="https://cdn.javarush.com/images/article/9b81a366-06b5-4259-9033-be6efde79f3f/800.jpeg" style="width: 800px;">Приступимо до написання коду всередині тесту contextLoads. Невеликий хак від спрингу, про який йшлося вище - це клас <code class=" language-none">SimpleNamingContextBuilder</code>. Даний клас призначений для того, щоб легко піднімати JNDI всередині юніт-тестів або stand-alone додатків. Напишемо код для отримання контексту: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">final</span></span> <span class="token class-name"><span class="token class-name">SimpleNamingContextBuilder</span></span> simpleNamingContextBuilder
       <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">SimpleNamingContextBuilder</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
simpleNamingContextBuilder<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">activate</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>

<span class="token keyword"><span class="token keyword">final</span></span> <span class="token class-name"><span class="token class-name">InitialContext</span></span> context <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">InitialContext</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> Перші два рядки коду дозволять нам простим чином ініціалізувати контекст JNDI. Без них під час створення екземпляра <code class=" language-none">InitialContext</code>буде викинуто виняток: <code class=" language-none">javax.naming.NoInitialContextException</code>. Дисклеймер. Клас <code class=" language-none">SimpleNamingContextBuilder</code>є Deprecated класом. І цей приклад має показати, як можна попрацювати з JNDI. Це не найкращі практики з використання JNDI усередині юніт-тестів. Це можна сказати мабоця для побудови контексту та демонстрації прив'язки та отримання об'єктів з JNDI. Отримавши контест, ми можемо витягувати з нього об'єкти або шукати об'єкти в контексті. Поки що в JNDI об'єктів немає, тому логічно буде покласти туди щось. Наприклад <code class=" language-none">DriverManagerDataSource</code>: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class="  language-java">context<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">bind</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">"java:comp/env/jdbc/datasource"</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">DriverManagerDataSource</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">"jdbc:h2:mem:mydb"</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> У цьому рядку ми прив'язали об'єкт класу <code class=" language-none">DriverManagerDataSource</code>до імені <code class=" language-none">java:comp/env/jdbc/datasource</code>. Далі ми можемо отримати об'єкт із контексту на ім'я. Нам нічого іншого не залишається, окрім як отримати об'єкт, який ми поклали щойно, тому що інших об'єктів у контексті немає =( 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">final</span></span> <span class="token class-name"><span class="token class-name">DataSource</span></span> ds <span class="token operator"><span class="token operator">=</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">DataSource</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> context<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">lookup</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">"java:comp/env/jdbc/datasource"</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> Тепер перевіримо, що наш DataSource має коннекшн (коннекшн, connection або з'єднання – це Java-клас, який призначений для роботи з базою даних): 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">assert</span></span> ds<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">getConnection</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token operator"><span class="token operator">!=</span></span> <span class="token keyword"><span class="token keyword">null</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token class-name"><span class="token class-name">System</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>ds<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">getConnection</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> Якщо ми все зробабо правильно, висновок буде приблизно таким: 
<pre class=" language-none" tabindex="0"><code class=" language-none">
conn1: url=jdbc:h2:mem:mydb user=</code></pre> Варто сказати, деякі рядки коду можуть залишити винятки. Наступні рядки кидають <code class=" language-none">javax.naming.NamingException</code>: 
<ul>
 <li><code class=" language-none">simpleNamingContextBuilder.activate()</code></li>
 <li><code class=" language-none">new InitialContext()</code></li>
 <li><code class=" language-none">context.bind(...)</code></li>
 <li><code class=" language-none">context.lookup(...)</code></li>
</ul>А при роботі з класом <code class=" language-none">DataSource</code>може бути кинуто <code class=" language-none">java.sql.SQLException</code>. У зв'язку з цим необхідно виконувати код усередині блоку <code class=" language-none">try-catch</code>або вказувати в сигнатурі юніт тесту, що він може викинути винятки. Наведемо повний код тестового класу: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token annotation punctuation"><span class="token annotation punctuation">@SpringBootTest</span></span>
<span class="token keyword"><span class="token keyword">class</span></span> <span class="token class-name"><span class="token class-name">JndiExampleApplicationTests</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>

    <span class="token annotation punctuation"><span class="token annotation punctuation">@Test</span></span>
    <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">contextLoads</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
        <span class="token keyword"><span class="token keyword">try</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
            <span class="token keyword"><span class="token keyword">final</span></span> <span class="token class-name"><span class="token class-name">SimpleNamingContextBuilder</span></span> simpleNamingContextBuilder
                    <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">SimpleNamingContextBuilder</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
            simpleNamingContextBuilder<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">activate</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>

            <span class="token keyword"><span class="token keyword">final</span></span> <span class="token class-name"><span class="token class-name">InitialContext</span></span> context <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">InitialContext</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>

            context<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">bind</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">"java:comp/env/jdbc/datasource"</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">DriverManagerDataSource</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">"jdbc:h2:mem:mydb"</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>

            <span class="token keyword"><span class="token keyword">final</span></span> <span class="token class-name"><span class="token class-name">DataSource</span></span> ds <span class="token operator"><span class="token operator">=</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">DataSource</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> context<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">lookup</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">"java:comp/env/jdbc/datasource"</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>

            <span class="token keyword"><span class="token keyword">assert</span></span> ds<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">getConnection</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token operator"><span class="token operator">!=</span></span> <span class="token keyword"><span class="token keyword">null</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
            <span class="token class-name"><span class="token class-name">System</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>ds<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">getConnection</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>

        <span class="token punctuation"><span class="token punctuation">}</span></span> <span class="token keyword"><span class="token keyword">catch</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">SQLException</span></span> <span class="token operator"><span class="token operator">|</span></span> <span class="token class-name"><span class="token class-name">NamingException</span></span> e<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
            e<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">printStackTrace</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token punctuation"><span class="token punctuation">}</span></span>
    <span class="token punctuation"><span class="token punctuation">}</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> Після запуску тесту можна спостерігати такі логи: 
<pre class=" language-none" tabindex="0"><code class=" language-none">
o.s.m.jndi.SimpleNamingContextBuilder    : Activating simple JNDI environment
o.s.mock.jndi.SimpleNamingContext        : Static JNDI binding: [java:comp/env/jdbc/datasource] = [org.springframework.jdbc.datasource.DriverManagerDataSource@4925f4f5]
conn1: url=jdbc:h2:mem:mydb user=</code></pre><a href="https://codegym.cc/welcome" target="_blank"><img id="click_banner1_articles" data-max-width="1024" data-id="e4698be0-cb00-4356-9252-aefd62f81478" class="img-fluid" alt="Використання JNDI в Java - 9" src="https://cdn.javarush.com/images/article/e4698be0-cb00-4356-9252-aefd62f81478/1024.jpeg" style="width: 1024px;"></a>
<h2>Висновок</h2>Сьогодні ми розбирали JNDI. Дізналися про те, що таке служби імен і каталогів, і що JNDI - це Java API, яке дозволяє одноманітно взаємодіяти з різними службами Java програми. А саме за допомогою JNDI ми можемо записувати об'єкти в JNDI tree під деяким ім'ям і отримувати ці об'єкти на ім'я. Як бонусне завдання можна запустити приклад роботи JNDI. Прив'язати в контекст будь-який інший об'єкт, а потім рахувати цей об'єкт на ім'я.