З 8 до 13: повний огляд версій Java. Частина 2
<p>----------------------------------------</p>
Ця стаття є другою частиною мого огляду за нововведеннями Java версій 8-13. Перша частина - . Без зайвих передмов рухаємося далі: у 25 вересня 2018 року, коли і вийшла нова JDK: Відтепер і на віки віків ми можемо вказати типи лямбда-парамет
<p>----------------------------------------</p>
Ця стаття є другою частиною мого огляду за нововведеннями Java версій 8-13. Перша частина - <a href="https://codegym.cc/groups/posts/2547-iz-8-v-13-polnihy-obzor-versiy-java-chastjh-1" target="_blank">тут</a> . Без зайвих передмов рухаємося далі: у 25 вересня 2018 року, коли і вийшла нова JDK: 
<h2>Java 11</h2><img data-max-width="650" alt="З 8 до 13: повний огляд версій Java.  Частина 2 - 1" src="https://cdn.javarush.com/images/article/d218a72d-c99e-4b9f-9711-611706eaab86/original.jpeg">
<h3>var (у лямбді)</h3>Відтепер і на віки віків ми можемо вказати типи лямбда-параметрів або пропустити їх при написанні лямбда-вирази (неявно типізованих лямбда-виразів): 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">Function</span></span><span class="token generics"><span class="token punctuation"></span><span class="token generics"><span class="token punctuation"><span class="token punctuation">&lt;</span></span><span class="token class-name"><span class="token class-name">String</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token class-name"><span class="token class-name">String</span></span><span class="token punctuation"><span class="token punctuation">&gt;</span></span></span><span class="token punctuation"></span></span> append <span class="token operator"><span class="token operator">=</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">var</span></span> string<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token operator"><span class="token operator">-&gt;</span></span> string <span class="token operator"><span class="token operator">+</span></span> <span class="token string"><span class="token string">" Text"</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token class-name"><span class="token class-name">String</span></span> appendedString <span class="token operator"><span class="token operator">=</span></span> append<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">apply</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">"Some"</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token class-name"><span class="token class-name">System</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>appendedString<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> Також можна додавати інструкції до лямбда-параметрів без необхідності писати повне ім'я типу змінної: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">Function</span></span><span class="token generics"><span class="token punctuation"></span><span class="token generics"><span class="token punctuation"><span class="token punctuation">&lt;</span></span><span class="token class-name"><span class="token class-name">String</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token class-name"><span class="token class-name">String</span></span><span class="token punctuation"><span class="token punctuation">&gt;</span></span></span><span class="token punctuation"></span></span> append <span class="token operator"><span class="token operator">=</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token annotation punctuation"><span class="token annotation punctuation">@NonNull</span></span> <span class="token keyword"><span class="token keyword">var</span></span> string<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token operator"><span class="token operator">-&gt;</span></span> string <span class="token operator"><span class="token operator">+</span></span> <span class="token string"><span class="token string">" Text"</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre>
<h3>Z (ZGC)</h3>ZGC — це новий збирач сміття, яке не працює. Він виділяє нову пам'ять, але ніколи не перезапускає її. ZGC обіцяє керувати великими обсягами пам'яті з високою пропускною здатністю та коротким часом паузи (ZGC доступний лише на 64-бітових платформах). Еталонне забарвлення - ZGC використовує 64-бітові покажчики з технікою, яка називається фарбуванням покажчиків. Кольорові покажчики зберігають додаткову інформацію про об'єкти купи. Коли пам'ять стає фрагментованою, це допомагає уникнути зниження продуктивності, коли GC необхідно знайти місце нового розподілу. Складання сміття за допомогою ZGC складається з таких етапів: 
<ol>
 <li>зупинки світу: ми шукаємо відправні точки для досягнення об'єктів у купі (наприклад, локальних змінних чи статичних полів);</li>
 <li>перетин граф об'єктів, починаючи з кореневих посилань. Ми відзначаємо кожен об'єкт, який досягаємо (ZGC ходить по графі об'єктів та досліджує кольорові покажчики, позначаючи доступні об'єкти);</li>
 <li>обробки деяких крайніх випадків, наприклад слабких посилань;</li>
 <li>рух живих об'єктів, звільняючи великі ділянки купи, щоб прискорити розподіл.</li>
 <li>коли починається фаза переміщення, ZGC поділяє купу на сторінки і по одній сторінці за раз;</li>
 <li>ZGC закінчує рух будь-якого коріння, і відбувається решта переміщення.</li>
</ol>Ця тема дуже складна та заплутана. Детальний розгляд тягне на окрему статтю, тож просто залишу це тут: 
<ul>
 <li><a href="https://www.baeldung.com/jvm-zgc-garbage-collector" rel="nofollow" target="_blank">An Introduction to ZGC: A Scalable and Experimental Low-Latency JVM Garbage Collector</a></li>
 <li><a href="https://habr.com/ru/company/jugru/blog/443250/" rel="nofollow" target="_blank">Саморобний збирач сміття для Open JDK</a></li>
 <li><a href="https://www.opsian.com/blog/javas-new-zgc-is-very-exciting/" rel="nofollow" target="_blank">Java's new Z Garbage Collector (ZGC) is very exciting</a></li>
</ul>
<h3>Epsilon GC</h3>Епсилон - це збирач сміття, який обробляє виділення пам'яті, але не реалізує будь-який реальний механізм відновлення пам'яті. Як тільки доступна купа Java буде вичерпана, JVM закриється. Тобто, якщо в нескінченному масиві запустити створення об'єкта без прив'язки до посилання з даним збирачем сміття, програма впаде з <em>OutOfMemoryError</em> (а якщо з будь-яким іншим немає, тому що він підчищатиме об'єкти без посилань). Навіщо він потрібен? А ось навіщо: 
<ol>
 <li>Тестування продуктивності.</li>
 <li>Тестування тиску пам'яті.</li>
 <li>Тестування інтерфейсу VM.</li>
 <li>Надзвичайно недовга робота.</li>
 <li>Поліпшення латентності останньої краплі.</li>
 <li>Поліпшення пропускної спроможності останньої краплі.</li>
</ol><span class="text-bold">Корисні посилання:</span>
<ul>
 <li><a href="https://habr.com/ru/post/321856/" rel="nofollow" target="_blank">Новий GC Epsilon. У джави може бути складання сміття. Шок. Сенсація</a></li>
 <li><a href="https://www.baeldung.com/jvm-epsilon-gc-garbage-collector" rel="nofollow" target="_blank">An Introduction to Epsilon GC: A No-Op Experimental Garbage Collector</a></li>
</ul><span class="text-bold">Інші нововведення:</span>
<ol>
 <li><code class=" language-none">ByteArrayOutputStream</code>отримав метод <code class=" language-none">void writeBytes(byte [])</code>, що записує всі байти з аргументу в <code class=" language-none">OutputStream</code>.</li>
 <li><code class=" language-none">FileReader</code>та <code class=" language-none">FileWriter</code>отримали нові конструктори, що дозволяють вказувати Charset.</li>
 <li><code class=" language-none">Path</code>відхопив два нових методи, <code class=" language-none">of(String, String [])</code>що повертає <code class=" language-none">Path</code>з рядкового аргументу шляху або послідовності рядків, які при об'єднанні утворюють рядок шляху і <code class=" language-none">of(URI)</code>: повертає Path з URI.</li>
 <li><code class=" language-none">Pattern</code>— отримав метод <code class=" language-none">asMatchPredicate()</code>, який перевіряє, чи відповідає заданий рядок введення, заданому шаблону (дозволяє створити предикат за регулярним виразом, щоб можна було, наприклад, фільтрувати дані в stream).</li>
 <li><code class=" language-none">String</code>відхопив багато корисних методів, таких як:
  <ul>
   <li><code class=" language-none">String strip()</code>: поверне нам рядок, який є цим рядком, при цьому видаляються всі прогалини на початку та в кінці рядка (аналог trim(), але по-іншому визначає прогалини);</li>
   <li><code class=" language-none">String stripLeading()</code>: поверне нам рядок, який є цим рядком, при цьому видаляються всі прогалини на початку рядка;</li>
   <li><code class=" language-none">String stripTrailing()</code>: поверне нам рядок, який є цим рядком, при цьому видаляються всі прогалини в кінці рядка;</li>
   <li><code class=" language-none">Stream lines()</code>: поверне нам <code class=" language-none">Stream</code>з <code class=" language-none">String</code>, витягнутих із цього рядка, поділених роздільниками рядків;</li>
   <li><code class=" language-none">String repeat(int)</code>: поверне нам рядок, який є конкатенацією цього рядка, повторюється кількість разів.</li>
   <li><code class=" language-none">boolean isBlank()</code>: поверне нам true, якщо рядок порожній або містить лише пробіли, інакше false.</li>
  </ul></li>
 <li><code class=" language-none">Thread</code>- були видалені методи destroy() та stop(Throwable).</li>
 <li><code class=" language-none">Files</code>отримав низку нових методів: 
  <ul>
   <li><code class=" language-none">String readString(Path)</code>: читає всі дані з файлу в рядок, при цьому декодуючи з байт символи з використанням кодування UTF-8;</li>
   <li><code class=" language-none">String readString(Path, Charset)</code>: так само, як і в методі вище, з різницею в тому, що декодування з байт символи відбувається з використанням вказаної Charset;</li>
   <li><code class=" language-none">Path writeString (Path, CharSequence, OpenOption [])</code>: записує послідовність символів у файл. Символи кодуються в байти, використовуючи кодування UTF-8;</li>
   <li><code class=" language-none">Path writeString(Path, CharSequence,Charset, OpenOption [])</code>: такий самий метод, як і вище, тільки символи кодуються в байти, використовуючи кодування, вказане в Charset.</li>
  </ul></li>
</ol>Це були найцікавіші нововведення API (на мою скромну думку), ось пара матеріалів для детальнішого ознайомлення: 
<ul>
 <li><a href="https://codegym.cc/groups/posts/1961-vihshla-java-11-novihe-fichi-i-vozmozhnosti-" target="_blank">Java 11: Що нового? Нові фічі та можливості</a></li>
 <li><a href="https://habr.com/ru/post/441154/" rel="nofollow" target="_blank">Одинадцять прихованих перлин Java 11</a></li>
</ul>
<h2>Java 12</h2>Минає півроку, і ми бачимо наступний ступінь еволюції Java. Значить, настав час діставати лопатку знань і копати. <img data-max-width="1024" img-fluid="" alt="З 8 до 13: повний огляд версій Java.  Частина 2 - 2" src="https://codegym-com.translate.goog/images/article/9fe24f32-06c4-415b-a366-d2d56a750854/original.jpeg%20class=">
<h3>Update G1</h3>Для G1 були внесені такі покращення: 
<ol>
 <li>
  <p><span class="text-bold">Повернення виділеної пам'яті, що не використовується.</span></p>
  <p>У Java heap memory є таке поняття як пам'ять, що не використовується (або по-іншому — неактивна). У Java 12 вирішабо пофіксувати цю проблему, тепер:</p>
  <ul>
   <li>G1 повертає пам'ять із купи в повному GC або під час паралельного циклу; G1 намагається запобігти повному GC і запускає паралельний цикл, виходячи з розподілу купи. Прийде змушувати G1 до повернення пам'яті з купи.</li>
  </ul>
  <p>Це покращення фокусується на швидкодії за рахунок автоматичного повернення пам'яті з купи в ОС, коли G1 не використовується.</p></li>
 <li>
  <p><span class="text-bold">Переривання змішаних колекцій, коли час паузи перевищено</span></p>
  <p>G1 використовує механізм аналізу для вибору обсягу роботи, необхідного для збирання сміття. Він збирає живі об'єкти без зупинки після визначення набору та запуску очищення. Це призводить до того, що збирач сміття перевищує цільове значення часу паузи. Власне, таку проблему і вирішує поліпшення, оскільки якщо виконання наступного кроку виходить за рамки розумного, цей крок можна перервати.</p></li>
</ol>
<h3>Microbenchmark</h3>У Java 12 ввели тести мікробенчмаркінгу, щоб продуктивність JVM легко тестувалася за допомогою вже існуючих тестів. Це було б дуже корисно для всіх, хто хоче працювати над JVM. Тести, що додаються, створюються з використанням Java Microbenchmark Harness (JMH). Ці тести дозволяють проводити безперервне тестування продуктивності JVM. JEP 230 пропонує запровадити близько 100 тестів, причому нові тести вводяться у міру випуску нових версій Java. Ось <a href="https://www.baeldung.com/java-microbenchmark-harness" rel="nofollow" target="_blank">приклад доданих тестів</a> .
<h3>Shenandoah</h3>Це алгоритм складання сміття (GC), мета якого – гарантувати низький час відгуку (нижня межа – 10-500 мс). Це зменшує час паузи GC під час роботи з очищення одночасно з працюючими потоками Java. У Shenandoah час паузи не залежить від розміру купи. Це означає, що час паузи буде однаковим незалежно від розміру вашої купи. Це <span class="text-bold">експериментальна функція</span> , яка не включена до стандартної (Oracle) збірки OpenJDK. 
<h3>Improve Switch</h3>У Java 12 покращено вирази Switch для зіставлення зі зразком. Введено новий синтаксис L →. Ось список <span class="text-bold">ключових моментів нового switch</span> : 
<ol>
 <li>Новий синтаксис усуває потребу в операторі break для запобігання помилкам.</li>
 <li>Вирази перемикача більше не провалюються.</li>
 <li>Крім того, ми можемо визначити кілька констант в одній мітці.</li>
 <li>default регістр тепер є обов'язковим у виразах перемикачів.</li>
 <li>break використовується у виразах Switch для повернення значень із самого регістру (по суті switch може повертати значення).</li>
</ol>Розглянемо як приклад: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">var</span></span> result <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">switch</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span>someDay<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
  <span class="token keyword"><span class="token keyword">case</span></span> <span class="token string"><span class="token string">"M"</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token string"><span class="token string">"W"</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token string"><span class="token string">"F"</span></span> <span class="token operator"><span class="token operator">-&gt;</span></span> <span class="token string"><span class="token string">"MWF"</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
  <span class="token keyword"><span class="token keyword">case</span></span> <span class="token string"><span class="token string">"T"</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token string"><span class="token string">"TH"</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token string"><span class="token string">"S"</span></span> <span class="token operator"><span class="token operator">-&gt;</span></span> <span class="token string"><span class="token string">"TTS"</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
  <span class="token keyword"><span class="token keyword">default</span></span> <span class="token operator"><span class="token operator">-&gt;</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
      <span class="token keyword"><span class="token keyword">if</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>someDay<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">isEmpty</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
            <span class="token keyword"><span class="token keyword">break</span></span> <span class="token string"><span class="token string">"Please insert a valid day."</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
      <span class="token keyword"><span class="token keyword">else</span></span>
            <span class="token keyword"><span class="token keyword">break</span></span> <span class="token string"><span class="token string">"Looks like a Sunday."</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
  <span class="token punctuation"><span class="token punctuation">}</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre><a href="https://blog.codefx.org/java/switch-expressions/" rel="nofollow" target="_blank"> Definitive Guide To Switch Expressions In Java 13 </a> <span class="text-bold">Інші нововведення:</span>
<ol>
 <li>
  <p><code class=" language-none"><span class="text-bold">String:</span></code></p>
  <p><code class=" language-none">transform(Function f)</code>- застосовує надану функцію до рядка. Результат може бути рядком. <br><code class=" language-none">indent(int x)</code>— додає x прогалин у рядок. Якщо параметр від'ємний, то ця кількість початкових прогалин буде видалена (якщо це можливо).</p></li>
 <li>
  <p><code class=" language-none"><span class="text-bold">Files</span></code>- відхопив такий метод як <code class=" language-none">mismatch()</code>, який, у свою чергу, знаходить і повертає позицію першого байта, що не збігається, у вмісті двох файлів або -1L, якщо немає невідповідності.</p></li>
 <li>
  <p><span class="text-bold">З'явився новий клас —</span><code class=" language-none"><span class="text-bold">CompactNumberFormat</span></code> для форматування десяткового числа в компактній формі. Приклад такої компактної форми — 1M замість 1000000. Таким чином, потрібно лише два-два замість дев'яти символів.</p></li>
 <li>
  <p>Існує також <span class="text-bold">новий</span> <code class=" language-none"><span class="text-bold">enum</span></code> , <code class=" language-none">NumberFormatStyle</code>, який має два значення - LONG і SHORT.</p></li>
 <li>
  <p><code class=" language-none"><span class="text-bold">InputStream</span></code> <span class="text-bold">отримав спосіб -</span> <code class=" language-none"><span class="text-bold">skipNBytes(long n)</span></code> : пропустити n-е кількість байтів з вхідного потоку.</p></li>
</ol><span class="text-bold">Цікаві посилання на Java 12:</span>
<ul>
 <li><a href="https://codegym.cc/groups/posts/2171-java-12-uzhe-zdesjh-chto-novogo" target="_blank">Java 12 вже тут: Що нового?</a></li>
 <li><a href="https://blog.gypsyengineer.com/ru/tech-ru/what-is-new-in-java-12-ru.html" rel="nofollow" target="_blank">Що нового в Java 12</a></li>
 <li><a href="https://urvanov.ru/2019/03/20/%D1%87%D1%82%D0%BE-%D0%BD%D0%BE%D0%B2%D0%BE%D0%B3%D0%BE-%D0%B2-java-12/" rel="nofollow" target="_blank">Що нового в Java 12 (з блогу записки відьмака-програміста)</a></li>
</ul>
<h2>Java 13</h2>Світ не стоїть на місці, рухається, розвивається, як і Java - Java 13. <img data-max-width="450" alt="З 8 до 13: повний огляд версій Java.  Частина 2 - 3" src="https://cdn.javarush.com/images/article/44205340-0908-4979-975c-0058aad9ab50/original.jpeg">
<h3>Text block</h3>Java завжди трохи страждала від визначення рядків. Якщо нам потрібно визначити рядок з пробілом, перенесення рядка, лапку або ще щось, це викликало деякі труднощі, так доводилося використовувати спеціальні символи: наприклад, \n для перенесення рядка, або екранувати деякі з рядка. Це істотно знижує читання коду, і займає зайвий час під час написання такого рядка. Це стає особливо помітним під час написання рядків, що відображають JSON, XML, HTML тощо. У результаті, якщо ми хочемо написати невеликий Json, це буде виглядати якось так: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">String</span></span> JSON_STRING <span class="token operator"><span class="token operator">=</span></span> <span class="token string"><span class="token string">"{\r\n"</span></span> <span class="token operator"><span class="token operator">+</span></span> <span class="token string"><span class="token string">"\"name\" : \"someName\",\r\n"</span></span> <span class="token operator"><span class="token operator">+</span></span> <span class="token string"><span class="token string">"\"site\" : \"https://www.someSite.com/\"\r\n"</span></span> <span class="token operator"><span class="token operator">+</span></span> <span class="token string"><span class="token string">"}"</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> І тут на сцену виходить Java 13 і пропонує нам своє рішення у вигляді потрійних подвійних лапок до та після тексту (які й обізвали текстовими блоками). Давайте розглянемо попередній приклад json з використанням цього нововведення: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">String</span></span> TEXT_BLOCK_JSON <span class="token operator"><span class="token operator">=</span></span> <span class="token triple-quoted-string string"><span class="token triple-quoted-string string">"""
{
    "name" : "someName",
    "site" : "https://www.someSite.com/"
}
"""</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> В рази простіше і наочніше, чи не так? Також було <code class=" language-none">String</code>додано три нових методи, відповідно, для управління даними блоками: 
<ul>
 <li><code class=" language-none">stripIndent()</code>: видаляє випадкові пробіли з рядка. Це корисно, якщо ви читаєте багаторядкові рядки і хочете застосувати такий самий виняток випадкових прогалин, як це відбувається з явним оголошенням (по суті імітує компілятор для видалення випадкових прогалин);</li>
 <li><code class=" language-none">formatted(Object... args )</code>: аналог <code class=" language-none">format(String format, Object... arg)</code>, але для текстових блоків;</li>
 <li><code class=" language-none">translateEscapes()</code>: повертає рядок з escape-послідовностями (наприклад \r), переведеними у відповідне значення Unicode.</li>
</ul>
<h3>Improve Switch</h3>Вирази-перемикачі були введені Java 12, а 13 уточнює їх. У 12 ви визначаєте значення, що повертаються за допомогою break. У 13 значення, що повертається замінабо на yield. Тепер вираз зі switch, який був у нас у розділі Java 12, можна переписати як: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">var</span></span> result <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">switch</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span>someDay<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
  <span class="token keyword"><span class="token keyword">case</span></span> <span class="token string"><span class="token string">"M"</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token string"><span class="token string">"W"</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token string"><span class="token string">"F"</span></span> <span class="token operator"><span class="token operator">-&gt;</span></span> <span class="token string"><span class="token string">"MWF"</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
  <span class="token keyword"><span class="token keyword">case</span></span> <span class="token string"><span class="token string">"T"</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token string"><span class="token string">"TH"</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token string"><span class="token string">"S"</span></span> <span class="token operator"><span class="token operator">-&gt;</span></span> <span class="token string"><span class="token string">"TTS"</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
  <span class="token keyword"><span class="token keyword">default</span></span> <span class="token operator"><span class="token operator">-&gt;</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
      <span class="token keyword"><span class="token keyword">if</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>someDay<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">isEmpty</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
          <span class="token keyword"><span class="token keyword">yield</span></span> <span class="token string"><span class="token string">"Please insert a valid day."</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
      <span class="token keyword"><span class="token keyword">else</span></span>
          <span class="token keyword"><span class="token keyword">yield</span></span> <span class="token string"><span class="token string">"Looks like a Sunday."</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
  <span class="token punctuation"><span class="token punctuation">}</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> Хоча нам програмістам, вже знайомим з Java, було нормально прийняти break, але це було досить дивно. Що break true намагається мені сказати? Нове (умовно нове) ключове слово yield більш зрозуміле, і в майбутньому воно може з'явитися в інших місцях, де повертаються значення. Кому глибоко цікава ця тема, рекомендую ознайомитися з цими матеріалами: 
<ul>
 <li><a href="https://www.dariawan.com/tutorials/java/java-13-switch-expressions-jep-354/" rel="nofollow" target="_blank">Java 13 - Switch Expressions (JEP 354)</a></li>
 <li><a href="https://blog.codefx.org/java/java-13-guide/" rel="nofollow" target="_blank">Definitive Guide To Java 13</a></li>
</ul>
<h3>Dynamic CDS Archives</h3>CDS - Class-Data Sharing. Дозволяє упаковувати набір класів, що часто використовуються, в архів, який пізніше може бути завантажений кількома екземплярами JVM. Навіщо це нам? Справа в тому, що в процесі завантаження класів JVM робить досить багато ресурсозатратних дій, таких як читання класів, збереження їх у внутрішніх структурах, перевірка правильності прочитаних класів, пошук і завантаження залежних класів і т. д., і лише після цього класи готові до роботи. Зрозуміло, даремно витрачається велика кількість ресурсів, адже екземпляри JVM часто можуть завантажувати одні й самі класи. Наприклад String, LinckedList, Integer. Ну чи класи одного й того ж додатка, а все це — ресурси. Якби ми виконали всі необхідні дії лише один раз і після помістабо перероблені класи до архіву, який може бути завантажений в пам'ять кількох JVM, це могло б суттєво заощадити місце в пам'яті та скоротити час запуску програми. Власне, CDS дає змогу створити саме такий архів. Java 9 дозволяла додавати до архіву лише системні класи. Java 10 - включати в архів класи програми. <span class="text-bold">Створення такого архіву</span> складається з: 
<ul>
 <li>створення списку класів, що завантажуються додатком;</li>
 <li>створення так необхідного нам архіву зі знайденими класами.</li>
</ul>Нововведення в Java 13 покращує CDS так, щоб він міг створювати архів після завершення програми. Це означає, що наведені вище два кроки тепер будуть об'єднані в один. І ще один важливий момент: тільки класи, завантажені під час роботи програми, будуть додані в архів. Іншими словами, ті класи, які все ж таки містяться в application.jar, але з якихось причин не були завантажені, не додадуться в архів. 
<h3>Update Socket API</h3>API Socket ( <em>java.net.Socket і java.net.ServerSocket</em> ) - по суті невід'ємна частина Java з моменту її появи, але при цьому сокети жодного разу не апдейтабо за останні двадцять років. Написані на C і Java, вони були дуже громіздкими і складними в обслуговуванні. Але Java 13 вирішила внести свої корективи в цю справу і замінила базову реалізацію. Тепер замість <em>PlainSocketImpl</em> інтерфейс провайдера замінюється на <em>NioSocketImpl</em> . Ця нова кодована реалізація ґрунтується на тій самій внутрішній інфраструктурі, що й <em>java.nio</em>. По суті, клас використовує механізм буферного кешу та блокування java.util.concurrent (які є сегментними), а не синхронізовані методи. Він більше не вимагає нативного коду, тим самим спрощуючи портування на різні платформи. Тим не менш, у нас є спосіб повернутися до використання <em>PlainSocketImpl</em> , але відтепер по дефолту використовується <em>NioSocketImpl</em> . <a href="https://codegym.cc/welcome" target="_blank"><img id="click_banner1_articles" data-max-width="1024" class="img-fluid" alt="З 8 до 13: повний огляд версій Java.  Частина 2 - 4" src="https://codegym-com.translate.goog/images/article/3207f383-91f5-402b-a40c-19d9d56b647e/original.jpeg"></a>
<h3>Memory Return for ZGC</h3>Як ми пам'ятаємо, <span class="text-bold">Z Складальник сміття</span> ввели в Java 11 як механізм складання сміття з малою затримкою, щоб GC пауза ніколи не перевищувала 10 мс. Але при цьому, на відміну від інших віртуальних GC HotSpot, таких як Shenandoah та G1, він міг повертати невикористану динамічну пам'ять у ОС. Ця модифікація додає цю можливість J ZGC. Відповідно, ми отримуємо зменшений обсяг пам'яті разом з покращенням продуктивності, і ZGC тепер повертає не зафіксовану пам'ять операційній системі за умовчанням, доки не буде досягнуто зазначеного мінімального розміру купи. І ще: у ZGC тепер є максимальний розмір купи 16 ТБ, що підтримується. Раніше 4ТБ було межею. <span class="text-bold">Інші нововведення:</span>
<ol>
 <li><code class=" language-none">javax.security</code>- Додано властивість <code class=" language-none">jdk.sasl.disabledMechanisms</code>для відключення механізмів SASL.</li>
 <li><code class=" language-none">java.nio</code>- Доданий метод <code class=" language-none">FileSystems.newFileSystem (Path, Map &lt;String,?&gt;)</code>- відповідно, для створення нового файлу.</li>
 <li>Класи <code class=" language-none">java.nio</code>тепер мають абсолютні (на відміну від відносних) <code class=" language-none">get</code>та <code class=" language-none">set</code>-методи. Вони, як і базовий абстрактний клас <code class=" language-none">Buffer</code>, включають метод <code class=" language-none">slice()</code>вилучення частини буфера.</li>
 <li>Додані <code class=" language-none">javax.xml.parsers</code>методи для створення екземплярів фабрик DOM і SAX (з підтримкою просторів імен).</li>
 <li>Підтримка Unicode оновлено до версії 12.1.</li>
</ol><span class="text-bold">Цікаві посилання на Java 13:</span>
<ul>
 <li><a href="https://codegym.cc/groups/posts/2353-java-13-novihe-vozmozhnosti" target="_blank">Java 13: нові можливості</a></li>
 <li><a href="https://proglib.io/p/vse-o-java-13-pogruzhenie-v-mir-obnovleniy-2019-10-18" rel="nofollow" target="_blank">Все про Java 13: занурення у світ оновлень</a></li>
 <li><a href="https://dzone.com/articles/81-new-features-and-apis-in-jdk-13" rel="nofollow" target="_blank">81 New Features and APIs в JDK 13</a></li>
</ul>
<h2>Підсумки</h2>Ми могли б і пройтися за заявленими нововведеннями в Java 14, але оскільки вона незабаром побачить світ - випуск JDK 14 запланований на 17 березня 2020 року, найкраще буде провести окремий, повноцінний огляд на неї вже безпосередньо після виходу. Ще хотілося б звернути увагу на те, що в інших мовах програмування з великими перервами між випусками, як, наприклад, у Python 2–3, немає сумісності: тобто якщо код написаний на Python 2, потрібно буде добряче попотіти, перекладаючи його на 3. Java — особлива щодо цього, оскільки вона <em>надзвичайно</em>назад сумісна. Це означає, що ваша програма на Java 5 або 8 гарантовано працюватиме з віртуальною машиною Java 8-13 - з деякими винятками, про які вам зараз не потрібно турбуватися. Зрозуміло, що це не працює навпаки: наприклад, якщо ваша програма юзає функції Java 13, які просто недоступні в Java 8 JVM. На цьому у мене сьогодні все, тим хто дочитав до цього місця респект)) <img data-max-width="500" alt="З 8 до 13: повний огляд версій Java.  Частина 2 - 5" src="https://cdn.javarush.com/images/article/69fd2c0a-d711-49ec-bb53-a0240a842ac4/original.jpeg">