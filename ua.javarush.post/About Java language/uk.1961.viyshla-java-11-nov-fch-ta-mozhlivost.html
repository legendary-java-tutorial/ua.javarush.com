Вийшла Java 11: нові фічі та можливості
<p>----------------------------------------</p>
Це раніше нові версії Java з'являлися рідко та із затримками. Тепер же успішно тримає заданий ритм «нова Java раз на півроку». Так що кілька днів тому, строго за графіком, ми отримали і реалізацію (Java Development Kit). Як завжди, нова вер
<p>----------------------------------------</p>
Це раніше нові версії Java з'являлися рідко та із затримками. Тепер же <em>Oracle</em> успішно тримає заданий ритм «нова Java раз на півроку». Так що кілька днів тому, строго за графіком, ми отримали <strong>Java SE 11</strong> і реалізацію <strong>JDK</strong> (Java Development Kit). <img data-id="079a2d92-8f28-448f-b20b-7ebec06d293a" data-max-width="850" alt="Вийшла Java 11: нові фічі та можливості - 1" src="https://cdn.javarush.com/images/article/079a2d92-8f28-448f-b20b-7ebec06d293a/800.jpeg" style="width: 850px;">Як завжди, нова версія буде сумісна зі старими, а підтримка Java 11 закінчиться не раніше грудня 2026 року. 
<h2>Нові фічі Java SE 11 (видимі розробникам)</h2>Нагадаємо, Java зміни вносяться за допомогою впровадження JEP «JDK Enchancement Proposal». <strong>JEP</strong> – це пропозиція щодо покращення OpenJDK, яку можуть затвердити, відкласти або відхаботи. Тобто, по суті, збірка JEP'ів є стратегією розвитку OpenJDK. У квадратних дужках перед новою фічею ми вкажемо номер відповідного JEP. <a href="http://openjdk.java.net/jeps/323" rel="nofollow" target="_blank">[323] Local-Variable Syntax for Lambda Parameters</a> - var-синтаксис для лямбда-параметрів <a href="https://codegym.cc/groups/posts/542-novaja-java-opjatjh-vstrechaem-java-10" target="_blank">Java 10 ввели ключове слово var,</a> яке дозволяло не вказувати явно тип локальної змінної. Це спрощує код. <em>JEP 323</em> розширює можливості використання такого синтаксису по відношенню до лямбда-виразів. Простий приклад: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class="  language-java">list<span class="token punctuation"><span class="token punctuation">.</span></span>stream <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
                 <span class="token punctuation"><span class="token punctuation">.</span></span>map <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">var</span></span> s<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token operator"><span class="token operator">-&gt;</span></span> s<span class="token punctuation"><span class="token punctuation">.</span></span>toLowerCase <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
                 <span class="token punctuation"><span class="token punctuation">.</span></span>collect <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">Collectors</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>toList <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> Як пише <strong>Саймон Ріттер</strong> , відомий Java-євангеліст, досвідчений Java-програміст помітить, що використання var в даному випадку може бути зайвим, оскільки код вище можна замінити наступним: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class="  language-java">list<span class="token punctuation"><span class="token punctuation">.</span></span>stream <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
                  <span class="token punctuation"><span class="token punctuation">.</span></span>map <span class="token punctuation"><span class="token punctuation">(</span></span>s <span class="token operator"><span class="token operator">-&gt;</span></span> s<span class="token punctuation"><span class="token punctuation">.</span></span>toLowerCase <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
                  <span class="token punctuation"><span class="token punctuation">.</span></span>collect <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">Collectors</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>toList <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> Навіщо, у такому разі, підтримувати var? Просто є один особливий випадок - коли ви хочете додати інструкцію до лямбда-параметру. Це неможливо зробити без будь-якого типу, і щоб не використовувати явний тип, ми можемо спростити все за допомогою var наступним чином: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class="  language-java">list<span class="token punctuation"><span class="token punctuation">.</span></span>stream <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
                 <span class="token punctuation"><span class="token punctuation">.</span></span>map <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>@ <span class="token class-name"><span class="token class-name">Notnull</span></span> <span class="token keyword"><span class="token keyword">var</span></span> s<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token operator"><span class="token operator">-&gt;</span></span> s<span class="token punctuation"><span class="token punctuation">.</span></span>toLowerCase <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
                 <span class="token punctuation"><span class="token punctuation">.</span></span>collect <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">Collectors</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>toList <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre><a href="http://openjdk.java.net/jeps/330" rel="nofollow" target="_blank">[330] Launch Single-File Source-Code Programs</a> Удосконалення Java-лаунчера для запуску програми у вигляді єдиного файлу з Java-вихідниками Java часто критикують за багатослівний синтаксис і багатоступінчасту «церемонію» запуску навіть тривіальної програми. Іноді це відлякує новачків. Для написання програми, яка просто друкує <em>Hello World! </em>», потрібно написати клас із загальнодоступним статичним <code class=" language-none">void</code>основним методом та використовувати метод <code class=" language-none">System.out.println</code>. Зробивши це, ви повинні скомпілювати код за допомогою <em>javac</em> . Нарешті, після цього ви можете запустити програму, яка виведе злощасне вітання (зрозуміло, інтегроване середовище розробки як <strong>IDEA</strong> , так і вбудоване в <strong>CodeGym</strong>, Виконує цю «магію запуску програми» самостійно - прим. ред.). Будемо відвертими: у більшості мов програмування реальний сценарій запуску програм виглядає набагато простіше. JEP 330 усуває необхідність компіляції однофайлової програми, тому тепер, якщо ви користуєтеся командним рядком, просто введіть 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class="  language-java">java <span class="token class-name"><span class="token class-name">HelloWorld</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>java</code></pre> Лаунчер Java визначить, що файл містить вихідний код Java і скомпілює код у файл класу перед його виконанням. Після або до імені файлу з вихідним кодом можна розмістити параметри. Ті, що поміщені після імені, передаються як параметри під час виконання програми. Ті, що розміщені до імені, передаються як параметри лаунчеру Java після компіляції коду. Параметри, що стосуються компілятора (наприклад, шлях до класів), також передадуть <em>javac</em> для компіляції. <em><strong>приклад. Рядок:</strong></em>
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class="  language-java">java <span class="token operator"><span class="token operator">-</span></span>classpath <span class="token operator"><span class="token operator">/</span></span> home <span class="token operator"><span class="token operator">/</span></span> foo <span class="token operator"><span class="token operator">/</span></span> java <span class="token class-name"><span class="token class-name">Hello</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>java <span class="token class-name"><span class="token class-name">Bonjour</span></span></code></pre><em><strong>буде еквівалентна таким рядкам:</strong></em>
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class="  language-java">javac <span class="token operator"><span class="token operator">-</span></span>classpath <span class="token operator"><span class="token operator">/</span></span> home <span class="token operator"><span class="token operator">/</span></span> foo <span class="token operator"><span class="token operator">/</span></span> java <span class="token class-name"><span class="token class-name">Hello</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>java
java <span class="token operator"><span class="token operator">-</span></span>classpath <span class="token operator"><span class="token operator">/</span></span> home <span class="token operator"><span class="token operator">/</span></span> foo <span class="token operator"><span class="token operator">/</span></span> java <span class="token class-name"><span class="token class-name">Hello</span></span> <span class="token class-name"><span class="token class-name">Bonjour</span></span></code></pre><a href="http://openjdk.java.net/jeps/321" rel="nofollow" target="_blank">[321] HTTP Client (Standard)</a> - підтримка HTTP Client API стандартизована У JDK 9 був представлений новий <em>API</em> для підтримки протоколу <em>HTTP Client (JEP 110)</em> . Оскільки в JDK 9 також впровадабо платформу <em>Java Platform Module System (JPMS)</em> , цей API був включений як <a href="http://openjdk.java.net/jeps/11" rel="nofollow" target="_blank">інкубаторний модуль</a> (це модулі для надання розробникам нових API, які ще не стали стандартом Java SE, тоді як «діючі» API готуються до видалення розробники можуть випробувати нові API та спробувати забезпечити зворотний зв'язок). Після внесення необхідних змін (це API було оновлено в JDK 10), API може стати частиною стандарту. Так ось, <em>API HTTP Client тепер офіційно входить до Java SE 11</em>. Це вводить новий модуль та пакет для <em>JDK, java.net.http</em> . Основні нові типи: <em><strong>HttpClient HttpRequest HttpResponse WebSocket</strong></em> Цей API можна використовувати синхронно або асинхронно. В асинхронному режимі використовуються <code class=" language-none">CompletionFutures</code>і <code class=" language-none">CompletionStages</code>. <a href="http://openjdk.java.net/jeps/320" rel="nofollow" target="_blank">[320] Remove The Java EE та CORBA Modules</a> — видалені модулі Java EE та COBRA Разом із впровадженням платформи <a href="https://jcp.org/en/jsr/detail?id=376" rel="nofollow" target="_blank">Java Platform Module System (JPMS)</a> у дев'ятій версії Java, з'явилася можливість розділити монолітний файл <strong>rt.jar</strong>на кілька модулів. Крім того, JPMS дозволяє створити середовище виконання Java, яке включає тільки модулі, необхідні для вашої програми, що суттєво зменшує її розмір. З прозоро визначеними межами модулів стало набагато простіше видалити застарілі частини Java API - ось що робить JEP 320. Метамодуль <strong>java.se.ee</strong> включає шість модулів, які не будуть входити в стандарт Java SE 11 і не будуть включені в JDK: 
<ul>
 <li>corba</li>
 <li>transaction</li>
 <li>activation</li>
 <li>xml.bind</li>
 <li>xml.ws</li>
 <li>xml.ws.annotation</li>
</ul> Ці модулі оголосабо застарілими (deprecated) ще JDK 9, і не були включені за умовчанням в компіляцію або виконання. Це означає, якщо ви намагалися скомпілювати або запустити програму, яка використовує API цих модулів на JDK 9 або JDK 10, у вас нічого не вийшло. Якщо ви використовуєте API цих модулів у своєму коді, вам потрібно буде надати їх у вигляді окремого модуля або бібліотеки. 
<h2>Нові API</h2>Велика кількість нових API у JDK 11 з'явилася завдяки включенню до стандарту мови модуля <em>HTTP Client</em> та <em>Flight Recorder</em> . З повним списком API можна ознайомитись у наступному повному та ґрунтовному <a href="https://gunnarmorling.github.io/jdk-api-diff/jdk10-jdk11-api-diff.html" rel="nofollow" target="_blank">порівнянні різних версій JDK</a> , складеному Гуннаром Морлінгом. А в цій замітці перерахуємо деякі нові методи, які не входять до модулів <em>java.net.http</em> , <em>jdk.jfr</em> та <em>java.security</em> . <strong>java.lang.String</strong> Можливо, <strong>зміна в String</strong> є одним з найважливіших в API JDK 11. Тут є кілька корисних нових методів. 
<ul>
 <li><code class=" language-none">boolean isBlank ()</code>: повертає true, якщо рядок порожній або містить лише пробіли, інакше false.</li>
 <br>
 <li><code class=" language-none">Stream lines()</code>: повертає потік рядків, витягнутих із цього рядка, розділених термінаторами рядків.</li>
 <br>
 <li><code class=" language-none">String repeat (int)</code>: повертає рядок, значення якого є конкатенацією цього рядка, що повторюється <em>int</em> разів.</li>
 <br>
 <li><code class=" language-none">String strip ()</code>: Повертає рядок, з якого видалено всі пробіли, які знаходяться до першого символу, що не є пробілом, або після останнього.</li>
 <br>
 <li><code class=" language-none">String stripLeading ()</code>: Повертає рядок, з якого видалено всі пробіли, які знаходяться до першого символу, що не є пробілом.</li>
 <br>
 <li><code class=" language-none">String stripTrainling ()</code>: Повертає рядок, з якого видалено всі пробіли, які знаходяться після останнього символу, що не є пробілом.</li>
</ul> Щось схоже на <code class=" language-none">strip()</code>вже робив метод <code class=" language-none">trim ()</code>, тільки ось під пробілами ці методи розуміють різні речі. У разі <code class=" language-none">trim()</code>відсікаються тільки прогалини, а в <code class=" language-none">strip()</code>ще й спецсимволи, на зразок табуляції. <strong>java.lang.StringBuffer java.lang.StringBuilder</strong> Обидва ці класи містять новий метод <code class=" language-none">compareTo ()</code>, який приймає <code class=" language-none">StringBuffer</code>і <code class=" language-none">StringBuilder</code>повертає <code class=" language-none">int</code>. Метод лексичного порівняння аналогічний новому методу <code class=" language-none">compareTo() CharSequence</code>. <strong>java.io.ByteArrayOutputStream</strong>
<ul>
 <li><code class=" language-none">void writeBytes (byte [])</code>: записує всі байти параметра у вихідний потік <strong>java.io.FileReader</strong></li>
</ul> Тут з'явабося два нові конструктори, які дозволяють вказати <code class=" language-none">Charset</code>. <strong>java.io.FileWriter</strong> Чотири нові конструктори, які дозволяють вказати <code class=" language-none">Charse</code>t. <strong>java.io.InputStream</strong>
<ul>
 <li><code class=" language-none">io.InputStream nullInputStream ()</code>: повертає <code class=" language-none">InputStream</code>, який не зчитує байти Як використати цей метод? Можете вважати його чимось на кшталт /dev/null для викидання непотрібного вам висновку чи запровадження введення, який завжди повертає нуль байтів.</li>
</ul><strong>java.io.OutputStream</strong>
<ul>
 <li><code class=" language-none">io.OutputStream nullOutputStream ()</code></li>
</ul><strong>java.io.Reader</strong>
<ul>
 <li><code class=" language-none">io.Reader nullReader ()</code></li>
</ul><strong>java.io.Writer</strong>
<ul>
 <li><code class=" language-none">io.Writer nullWriter ()</code></li>
</ul><strong>java.lang.Character</strong>
<ul>
 <li><code class=" language-none">String toString (int)</code>: це перевантажена форма існуючого методу, але замість char використовується int.</li>
</ul><strong>java.lang.CharSequence</strong>
<ul>
 <li><code class=" language-none">int compare (CharSequence, CharSequence)</code><code class=" language-none">CharSequence</code>: лексикографічно порівнює два екземпляри Повертає негативне значення, нуль або позитивне значення, якщо перша послідовність лексикографічно менша, дорівнює або більше другої, відповідно.</li>
</ul><strong>java.lang.ref.Reference</strong>
<ul>
 <il>
  <code class=" language-none">lang.Object clone ()</code>: євангеліст Java Саймон Ріттер зізнається, що цей метод його бентежить Клас 
  <code class=" language-none">Reference</code>не реалізує інтерфейс 
  <code class=" language-none">Cloneable</code>, і цей метод завжди генеруватиме виняток 
  <code class=" language-none">CloneNotSupportedException</code>. Проте експерт припускає, що цей метод стане в нагоді для чогось у майбутньому.
 </il>
</ul><strong>java.lang.Runtime java.lang.System</strong> Тут нових методів немає. Згадаємо лише, що метод <code class=" language-none">runFinalizersOnExit ()</code>видалений з обох цих класів, що може спричинити проблеми із сумісністю. <strong>java.lang.Thread</strong> Ніяких додаткових методів, згадаємо тільки, що <code class=" language-none">destroy ()</code>і <code class=" language-none">stop (Throwable)</code>були видалені. Однак <code class=" language-none">stop ()</code>, який не приймає аргументів, все ще є. Пам'ятайте про це, оскільки цілком можливі проблеми із сумісністю. <strong>java.nio.ByteBuffer java.nio.CharBuffer java.nio.DoubleBuffer java.nio.FloatBuffer java.nio.LongBuffer java.nio.ShortBuffer</strong> У всі ці класи розробники мови додали метод <code class=" language-none">mismatch ()</code>, який знаходить і повертає відносний індекс першого та заданим буфером. <strong>java.nio.channels.SelectionKey</strong>
<ul>
 <li><code class=" language-none">int interestOpsAnd (int)</code></li>
 <br>
 <li><code class=" language-none">int interestOpsOr (int)</code></li>
</ul><strong>java.nio.channels.Selector</strong>
<ul>
 <li><code class=" language-none">int select (java.util.function.Consumer, long)</code>: вибирає та виконує дію на клавішах, відповідні канали яких готові для операцій введення-виведення. Параметр long – це тайм-аут.</li>
 <br>
 <li><code class=" language-none">int select (java.util.function.Consumer)</code>: працює як метод вище, тільки без таймууту</li>
 <br>
 <li><code class=" language-none">int selectNow (java.util.function.Consumer)</code>: працює як метод вище, тільки він non-blocking.</li>
 <br>
</ul><strong>java.nio.file.Files</strong>
<ul>
 <li><code class=" language-none">String readString (Path)</code>: зчитує весь контент з файлу в рядок, декодуючи байти символи з використанням кодування <em>UTF-8</em> .</li>
 <br>
 <li><code class=" language-none">String readString (Path, Charset)</code>: працює як метод вище, тільки декодує байти символи за допомогою <code class=" language-none">Charset</code>.</li>
 <br>
 <li><code class=" language-none">Path writeString (Path, CharSequence, java.nio.file. OpenOption [])</code>: якщо записуватиме послідовність символів <code class=" language-none">CharSequence</code>у файл, ці символи будуть закодовані в байти (за допомогою <em>UTF-8</em> ).</li>
 <br>
 <li><code class=" language-none">Path writeString (Path, CharSequence, java.nio.file. Charset, OpenOption [])</code>: працює, як метод вище, тільки кодування символів у байти здійснюється за допомогою <code class=" language-none">Charset</code>.</li>
</ul><strong>java.nio.file.Path</strong>
<ul>
 <li>Шлях (String, String []): повертає шлях (Path), перетворюючи рядок колії або послідовність рядків, які при об'єднанні утворюють рядок колії.</li>
 <br>
 <li>Шлях (net.URI): повертає шлях, перетворюючи URI.</li>
</ul><strong>java.util.Collection</strong>
<ul>
 <li><code class=" language-none">Object [] toArray (java.util.function.IntFunction)</code>: повертає масив, що містить всі елементи в цій колекції, використовуючи надану генераторну функцію для розподілу масива, що повертається.</li>
</ul><strong>java.util.concurrent.PriorityBlockingQueue java.util.PriorityQueue</strong>
<ul>
 <li><code class=" language-none">void forEach (java.util.function.Consumer)</code>: виконує задану дію для кожного елемента <em>Iterable</em> доти, доки всі елементи не будуть оброблені, або дія не викличе виняток.</li>
 <br>
 <li><code class=" language-none">boolean removeAll (java.util.Collection)</code>: видаляє всі елементи цієї колекції, які також містяться у вказаній колекції (додаткова операція).</li>
 <br>
 <li><code class=" language-none">boolean removeIf (java.util.function.Predicate)</code>: Видаляє всі елементи цієї колекції, які задовольняють заданий предикат.</li>
 <br>
 <li><code class=" language-none">boolean retainAll (java.util.Collection)</code>: Зберігає лише елементи цієї колекції, які містяться у вказаній колекції (додаткова операція).</li>
</ul><strong>java.util.concurrent.TimeUnit</strong>
<ul>
 <li><code class=" language-none">long convert (java.time.Duration)</code>: конвертує задану тривалість часу в цей юніт</li>
</ul><strong>java.util.function.Predicate</strong>
<ul>
 <li><code class=" language-none">Predicate not(Predicate)</code>: повертає предикат, який є запереченням поставленого предикату</li>
</ul> Наприклад, наступний код: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class="  language-java">lines<span class="token punctuation"><span class="token punctuation">.</span></span>stream <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>

<span class="token punctuation"><span class="token punctuation">.</span></span>filter <span class="token punctuation"><span class="token punctuation">(</span></span>s <span class="token operator"><span class="token operator">-&gt;</span></span><span class="token operator"><span class="token operator">!</span></span> s<span class="token punctuation"><span class="token punctuation">.</span></span>isBlank <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span></code></pre> можна перетворити на такий: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class="  language-java">lines<span class="token punctuation"><span class="token punctuation">.</span></span>stream <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>

<span class="token punctuation"><span class="token punctuation">.</span></span>filter <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">Predicate</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>not <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">String</span></span> <span class="token operator"><span class="token operator">::</span></span> ISBLANK<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span></code></pre> а якщо ми використовуємо статичний імпорт, то ось що ми отримаємо: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class="  language-java">lines<span class="token punctuation"><span class="token punctuation">.</span></span>stream <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
<span class="token punctuation"><span class="token punctuation">.</span></span>filter <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token function"><span class="token function">not</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">String</span></span> <span class="token operator"><span class="token operator">::</span></span> ISBLANK<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span></code></pre><em><strong>java.util.Optional java.util.OptionalInt java.util.OptionalDouble java.util.OptionalLong</strong></em>
<ul>
 <li><code class=" language-none">boolean isEmpty ()</code>: Якщо значення відсутнє, повертає <em>true</em> , інакше <em>false</em> .</li>
</ul><strong>java.util.regex.Pattern</strong>
<ul>
 <li><code class=" language-none">Predicate asMatchPredicate ()</code>: експерт Java Саймон Ріттер вважає, що тут може бути прихований справжній скарб API JDK 11. Цей метод створює предикат, який перевіряє, чи відповідає цей шаблон заданому рядку введення.</li>
</ul><strong>java.util.zip.Deflater</strong>
<ul>
 <li><code class=" language-none">int deflate (ByteBuffer)</code>: стискає вхідні дані та заповнює вказаний буфер стислими даними.</li>
 <br>
 <li><code class=" language-none">int deflate (ByteBuffer, int)</code>: стискає вхідні дані та заповнює вказаний буфер стислими даними. Повертає фактичну кількість стислих даних.</li>
 <br>
 <li><code class=" language-none">void setDictionary (ByteBuffer)</code>: встановлює заданий словник для стиснення байти в даному буфері. Це перевантажена форма існуючого методу, який тепер може приймати <code class=" language-none">ByteBuffer</code>, а не байтовий масив.</li>
 <br>
 <li><code class=" language-none">void setInput (ByteBuffer)</code>: Встановлює вхідні дані для стиснення. Також є перевантаженою формою наявного методу.</li>
</ul><strong>java.util.zip.Inflater</strong>
<ul>
 <li><code class=" language-none">int inflate (ByteBuffer)</code>: розпаковує байти у вказаний буфер. Повертає фактичну кількість стиснених байтів.</li>
 <br>
 <li><code class=" language-none">void setDictionary (ByteBuffer)</code>: встановлює заданий словник байти в даному буфері. Є перевантаженою формою наявного методу.</li>
 <br>
 <li><code class=" language-none">void setInput (ByteBuffer)</code>: встановлює вхідні дані для декомпресії Перевантажена форма наявного методу.</li>
</ul><strong>javax.print.attribute.standard.DialogOwner</strong> Це новий клас в JDK 11 і він є класом атрибутів, який використовується для підтримки запитів на сторінку друку або налаштування, повинен відображатися поверх всіх вікон або певного вікна. <strong>javax.swing.DefaultComboBoxModel javax.swing.DefaultListModel</strong>
<ul>
 <li><code class=" language-none">void addAll (Collection)</code>: додає всі елементи в колекції.</li>
 <br>
 <li><code class=" language-none">void addAll (int, Collection)</code>: додає всі елементи, які є в колекції, починаючи з зазначеного індексу.</li>
</ul><strong>javax.swing.ListSelectionModel</strong>
<ul>
 <li><code class=" language-none">int [] getSelectedIndices ()</code>: повертає масив усіх вибраних індексів у вибраній моделі у порядку зростання.</li>
 <br>
 <li><code class=" language-none">int getSelectedItemsCount ()</code>: повертає кількість вибраних елементів.</li>
</ul><strong>jdk.jshell.EvalException</strong>
<ul>
 <li><code class=" language-none">shell.JShellException getCause ()</code>: повертає причину throwable у виконуючому клієнті, представленому цим EvalException, або null, якщо причини не існує або вона невідома.</li>
</ul>
<h2>Недевелоперські фічі Java 11</h2><a href="http://openjdk.java.net/jeps/181" rel="nofollow" target="_blank">[181] Nest-Based Access Control</a> Java та інші мови підтримують вкладені класи через внутрішні класи. Щоб це працювало, компілятор повинен виконати певні трюки. Наприклад: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">class</span></span> <span class="token class-name"><span class="token class-name">Outer</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
    <span class="token keyword"><span class="token keyword">private</span></span> <span class="token keyword"><span class="token keyword">int</span></span> outerInt<span class="token punctuation"><span class="token punctuation">;</span></span>

     <span class="token keyword"><span class="token keyword">class</span></span> <span class="token class-name"><span class="token class-name">Inner</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
       <span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">printOuterInt</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
         <span class="token class-name"><span class="token class-name">System</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">"Outer int = "</span></span> <span class="token operator"><span class="token operator">+</span></span> outerInt<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
       <span class="token punctuation"><span class="token punctuation">}</span></span>
     <span class="token punctuation"><span class="token punctuation">}</span></span>
   <span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> Компілятор модифікує це, щоб створити перед виконанням компіляції щось на зразок такого: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">class</span></span> <span class="token class-name"><span class="token class-name">Outer</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
      <span class="token keyword"><span class="token keyword">private</span></span> <span class="token keyword"><span class="token keyword">int</span></span> outerInt<span class="token punctuation"><span class="token punctuation">;</span></span>

      <span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">int</span></span> access$<span class="token function"><span class="token function">000</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
        <span class="token keyword"><span class="token keyword">return</span></span> outerInt<span class="token punctuation"><span class="token punctuation">;</span></span>
      <span class="token punctuation"><span class="token punctuation">}</span></span>

    <span class="token punctuation"><span class="token punctuation">}</span></span>


    <span class="token keyword"><span class="token keyword">class</span></span> <span class="token class-name"><span class="token class-name">Inner</span></span>$<span class="token class-name"><span class="token class-name">Outer</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>

      <span class="token class-name"><span class="token class-name">Outer</span></span> outer<span class="token punctuation"><span class="token punctuation">;</span></span>

      <span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">printOuterInt</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
        <span class="token class-name"><span class="token class-name">System</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">"Outer int = "</span></span> <span class="token operator"><span class="token operator">+</span></span> outer<span class="token punctuation"><span class="token punctuation">.</span></span>access$<span class="token function"><span class="token function">000</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
      <span class="token punctuation"><span class="token punctuation">}</span></span>
    <span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> Хоча за логікою внутрішній клас є частиною того самого коду, що і зовнішній клас, він скомпільований як окремий клас. Тому для цієї операції потрібен синтетичний з'єднувальний метод, який повинен створити компілятор для забезпечення доступу до <em>private</em> -поля зовнішнього класу. Цей JEP є концепцією вкладень (гнізд), де два члени одного вкладення (Outer and Inner з нашого прикладу) є «друзями по вкладенню». Для формату файлу класу визначено два нові атрибути - <em>NestHost</em> і <em>NestMembers</em> . Ці зміни корисні для інших мов, які підтримують вкладені класи та байткод. Ця функція представляє три нові методи для <strong>java.lang.Class</strong> : <strong>Class getNestHost () Class [] getNestMembers () boolean isNestmateOf (Class) </strong> <a href="http://openjdk.java.net/jeps/309" rel="nofollow" target="_blank">[309] Dynamic Class-File Constants</a> Цей JEP описує розширення формату файлу класу підтримки нової форми з постійним пулом CONSTANT_Dynamic. Ідея динамічної константи здається оксюмороном, але, по суті, ви можете думати про неї як про кінцеве значення Java 11. Значення константи-пулу не задано під час компіляції (на відміну від інших констант), але використовує метод початкового завантаження для визначення значення в час виконання. Тому значення є динамічним, але оскільки його значення задано лише один раз, воно також є постійним. Ця функція в першу чергу націлена на людей, які розробляють нові мови та компілятори, які генеруватимуть байт-коди та файли класів як висновок для запуску на JVM. <a href="http://openjdk.java.net/jeps/315" rel="nofollow" target="_blank">[315] Improve Aarch64 Intrinsics</a> Цей JEP запропонував співтовариство Red Hat. Тепер JVM може використовувати більше спеціалізованих інструкцій, доступних у наборі команд Arm 64. Зокрема, це покращує роботу методів <code class=" language-none">sin ()</code>і класу <strong>java.lang.Math</strong> . <a href="http://openjdk.java.net/jeps/318" rel="nofollow" target="_blank">[318] Epsilon: A No-Op Garbage Collector</a> Як і у випадку <em>JEP 315</em> , за появу збирача сміття Epsilon можете дякувати Red Hat. Epsilon незвичайний хоча б тим, що насправді він не збирає сміття! При створенні нових об'єктів він виділяє пам'ять, якщо це потрібно, але не відновлює простір, зайнятий незареєстрованими об'єктами. « <em>І в чому сенс? </em>», - Запитайте ви. Виявляється у такої «складання сміття» є два види використання: <code class=" language-none">cos ()</code><code class=" language-none">log ()</code><strong></strong><a href="http://openjdk.java.net/jeps/318" rel="nofollow" target="_blank"></a><em></em><em></em>
<ol>
 <li>Насамперед цей збирач сміття призначений для того, щоб нові алгоритми GC були оцінені з точки зору їх впливу на продуктивність. Ідея полягає в тому, щоб запустити приклад програми з Epsilon та згенерувати набір показників. Включається новий алгоритм складання сміття, запускаються самі тести, та був результати порівнюються.</li>
 <br>
 <li>Для дуже коротких завдань (вважайте безсерверні функції у хмарі), де ви можете гарантувати, що не перевищите пам'ять виділену купі. Це може підвищити продуктивність за рахунок відсутності накладних витрат (включаючи збирання статистики, необхідної для ухвалення рішення про запуск колектора) у коді програми. Якщо простір купи вичерпано, JVM може бути налаштований з помилкою одним із трьох способів: 
  <ul>
   <li>Викликається звичайний <code class=" language-none">OutOfMemoryError</code>.</li>
   <li>Виконати скидання купи</li>
   <li>Збій жорсткого диска JVM і, можливо, виконання іншого завдання (наприклад, запуск відладчика).</li>
  </ul></li>
</ol><a href="http://openjdk.java.net/jeps/328" rel="nofollow" target="_blank">[328]: Flight Recorder </a> <strong>Flight Recorder</strong> – це низькорівнева структура збору даних для JVM. До JDK 11 це була комерційна функція Oracle JDK binary. Тепер Oracle усуває функціональні відмінності між Oracle JDK та одним білдом із OpenJDK. Ось що робить <strong>Flight Recorder</strong> : 
<ul>
 <li>Надає API для виробництва та споживання даних як подій</li>
 <li>Надає буферний механізм та формат двійкових даних</li>
 <li>Дозволяє налаштування та фільтрацію подій</li>
 <li>Надавати події для ОС, JVM HotSpot та бібліотек JDK</li>
</ul>Тут з'явабося два нові модулі: <strong>jdk.jfr</strong> і <strong>jdk.management.jfr</strong> . <a href="https://codegymco422-my.sharepoint.com/personal/masha_chip_codegym_co/Documents/%D0%A4%D0%B0%D0%B9%D0%BB%D1%8B%20%D1%87%D0%B0%D1%82%D0%BE%D0%B2%20Microsoft%20Teams/JEP%20329:%20ChaCha20%20and%20Poly1305%20Cryptographic%20Algorithms" rel="nofollow" target="_blank">[329] Криптографічні алгоритми ChaCha20 і Poly1305</a> Цей <em>JEP</em> присвячений <em>оновленню шифрів</em> , що використовуються JDK. В даному випадку реалізовані алгоритми шифрування <em>ChaCha20</em> і <em>ChaCha20-Poly1305</em> , як зазначено в RFC 7539. <em>ChaCha20</em> - це відносно новий потоковий шифр, який може замінити старий небезпечний шифр <em>RC4</em> . <a href="http://openjdk.java.net/jeps/333" rel="nofollow" target="_blank">[333] ZGC: A Scalable Low-Latency Garbage Collector</a> Експериментальний масштабувальник сміття з низькою затримкою. Призначений для використання з додатками, для яких потрібна велика (багатогігабайтна) купа і низька затримка. Він використовує купу одного покоління та виконує більшість (але не всі) роботи зі складання сміття одночасно з додатком. <a href="http://openjdk.java.net/jeps/332" rel="nofollow" target="_blank">[332] Transport Layer Security (TLS) 1.3 </a> <em>TLS 1.3 (RFC 8446)</em> - серйозна латка протоколу захисту транспортного рівня TLS, яка забезпечує значне підвищення безпеки та продуктивності порівняно з попередніми версіями. JDK тепер підтримує цю версію протоколу. <em>Матеріал заснований на статті <a href="https://www.azul.com/90-new-features-and-apis-in-jdk-11/" rel="nofollow" target="_blank">Саймона Ріттера</a> та <a href="http://openjdk.java.net/" rel="nofollow" target="_blank">офіційної документації</a> .</em>