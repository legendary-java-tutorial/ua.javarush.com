Модифікатори або як накладати чари у світі Java
<p>----------------------------------------</p>
Доброго галактичного часу доби, комради! Це мій перший міжпланетний манускрипт, а оскільки я інженер, трактування деяких понять може проводитися позаземною мовою. Java схожа на нескінченний коридор з дверима (package). За кожним з таких две
<p>----------------------------------------</p>
Доброго галактичного часу доби, комради! Це мій перший міжпланетний манускрипт, а оскільки я інженер, трактування деяких понять може проводитися позаземною мовою. 
<div class="row justify-content-center jr-image-wrap">
 <div class="col-12 col-sm-10 col-md-8">
  <img width="800" height="500" data-id="16fb55c8-8ec6-496e-9b19-e6d0bdaa13ea" alt="Модифікатори або як накладати чари у світі Java - 1" src="https://cdn.javarush.com/images/article/16fb55c8-8ec6-496e-9b19-e6d0bdaa13ea/1080.jpeg">
 </div>
</div><u><strong>На мій погляд</strong></u> Java схожа на нескінченний коридор з дверима (package). За кожним з таких дверей є вільний простір та картотека, в якій зберігається гора магічних сувоїв з інструкціями (класів) щодо створення об'єктів. У кожному сувої описується набір характеристик (змінних) і здібностей (методів) - дій (полів), що здійснюються або самим класом, або зібраним на його основі об'єктом. На цьому етапі представимо себе чарівниками і спробуємо створити нову інструкцію (клас). Отже: <img width="800" height="500" data-id="054face5-8ad4-461a-a60e-3ed477f77e09" alt="Модифікатори або як накладати чари у світі Java - 2" src="https://cdn.javarush.com/images/article/054face5-8ad4-461a-a60e-3ed477f77e09/1080.jpeg">Випиваємо еліксир мудрості (вивчаємо основи) та приступаємо до написання інструкції. <u><strong>Access та non-access модифікатори</strong></u> Уявімо, що будь-яка інструкція і створюваний на її основі об'єкт, а також його характеристики і здібності спочатку магічно зачаровані, тобто. їм буде присвоєно певні набори модифікаторів. Спробуємо створити посібник із можливих зачарувань. 
<ol>
 <li>
  <p>Модифікатор <strong>доступу</strong> , який описує доступність класу, об'єкта чи поля — обов'язковий: за його відсутності JVM (це джерело вселенської магії) автоматично присвоює ідентифікатор за промовчанням package.</p>
  <p>Починаючи з другого модифікатора, йдуть non-access модифікатори, які не є обов'язковими, а також можуть конфліктувати один з одним (але про все по порядку).</p></li>
 <li>
  <p>Модифікатор <strong>Static</strong> говорить про те, що клас, об'єкт чи поле статичні. Але що це означає? В основному він приміряється до полів.</p>
  <p>Статичні змінні називаються змінними класу та є унікальними для всіх екземплярів даного класу. Статичні методи можуть бути викликані без створення об'єкта, де вони описані. Статичні класи використовуються при вкладенні одного класу в інший і принцип взаємодії внутрішнього класу із зовнішнім схожим з методами (є темою окремої розмови). Також може використовуватися як окремий блок всередині об'єкта.</p></li>
 <li>
  <p>Модифікатор <strong>Final</strong> фактично служить змінної вказівкою те що, що вона є константою. Для методів - що вони не можуть бути перевизначені при успадкування, а для класів це вказівка ​​на те, що успадковуватися від нього не можна (immutable).</p>
  <p>Модифікатори static і final застосовні до класів, об'єктів та полів. Однак є модифікатори, які застосовуються лише до деяких з них (або навіть частини, адже і змінна і метод — це поле, але не всі модифікатори можна застосувати до обох). Якщо проводити аналогію, на швидкість можна зачарувати лише черевики та рукавички (щоб швидше рухалися), а от зачаровувати капелюх на швидкість безглуздо (та й Вселенська Наглядова Рада (компілятор) не дасть).</p></li>
 <li>
  <p>Модифікатор <strong>Abstract </strong> <em>застосовується тільки до методів і класів</em> . Абстрактний метод – це метод без реалізації (тіла).</p>
  <p>Якщо клас позначається як абстрактний, він містить абстрактні методи, або це робиться для того щоб заборонити створення екземплярів цього класу. Якщо проводити аналогію, серед інструкції можна побачити заголовок "Розмальовка об'єкта", після якого немає опису. Тобто. за цією інструкцією можна створити об'єкт і розфарбувати його теж можна, але в цій інструкції не написано як (пишіть свою інструкцію зі створення червоного об'єкта на основі цього об'єкта і опишіть як його розфарбовувати).</p></li>
</ol>При роботі в багатопотоковому середовищі можуть використовуватися спеціальні модифікатори:
<ol>
 <li>
  <p>Модифікатор <strong>Syncronized </strong> <em>використовується лише для методів. </em>Його наявність свідчить у тому, що може одночасно виконувати лише одне поток. Також може використовуватися як окремий блок коду всередині об'єкта (із зазначенням об'єкта синхронізації).</p></li>
 <li>
  <p>Модифікатор <strong>Volatile</strong> – <em>тільки для змінних</em> . Його рекомендується використовувати для змінних, які можуть одночасно використовуватися кількома потоками. Змінна з таким модифікатором при кожній зміні моментально копіюється з кеша процесора в основну пам'ять, дозволяючи паралельним потокам отримувати «свіже» значення.</p>
  <p>Варто відзначити, що volatile застосовується в тих випадках, коли тільки один потік може записувати в змінну, а решта лише читає з неї. Для решти випадків краще вішати модифікатор synchronized на методи, які записують у волатильну змінну.</p></li>
 <li>
  <p>Модифікатор <strong>Transient</strong> – <em>​​лише для змінних</em> . Таким модифікатором позначаються змінні, які потрібно пропускати під час серіалізації об'єкта (це такий розумний процес, про який, в принципі, і самостійно почитати можна…)*</p>
  <p>* - дана стаття написана мною на 17 рівні і доти серіалізація як процес описаний не був, тому замість копіпасти я раджу, за необхідності, вивчити його самостійно.</p></li>
</ol><u><strong>Конфліктуючі пари модифікаторів</strong></u> Крім застосування модифікаторів до різних класів, об'єктів і полів існує також поняття конфліктуючих пар. Допустимо, накладання на шолом чар міцності робить його важким, і одночасно ви хочете зачарувати його на легкість. Одне з іншим не в'яжеться. 
<ol>
 <li><em>Final і Volatile</em> – коли йдеться про змінні, ми не можемо одночасно сказати, що вона фінальна (константа) і що кілька потоків мають можливість її змінити… Адже вона постійна, і в будь-який момент потік може її вважати, але жоден потік не в силах змінити константу (Всесвітня Наглядова Рада не дасть).</li>
 <li><em>Final і Abstract</em> — класи і методи неможливо знайти одночасно абстрактними (що найчастіше передбачає необхідність їх уточнення для реалізації) і фінальними, тобто. незмінними. Виходить, що в інструкції написано, як створити хороший міцний шолом з будь-якого матеріалу (абстрактна частина), але для цього обов'язково не повинно бути отворів (фінальна обов'язкова частина, зміні не підлягає).</li>
 <li><em>Abstract і Static</em> - абстрактний метод не може одночасно бути статичним або синхронізованим. Статичний абстрактний метод не має сенсу, адже мало того, що нічого не робить, так ще й належить цілому класу — марна штука виходить.</li>
 <li><em>Abstract і Syncronized</em> — який сенс синхронізації роботи з методом, який нічого не робить?</li>
</ol><strong><u>Підведення підсумків</u></strong> Отже, опис модифікаторів закінчився, всі конфлікти розібрані і тепер можна закріпити отриманий результат шпаргалкою - схемою зачарувань: <img width="800" height="500" data-id="c75b48f6-3120-4f51-b0f1-55c66da594b6" alt="Модифікатори або як накладати чари у світі Java - 3" src="https://cdn.javarush.com/images/article/c75b48f6-3120-4f51-b0f1-55c66da594b6/1080.jpeg">На завершення хочу сказати, що написання цієї статті стало реалізацією мого бажання вивчити модифікатори. Успішний досвід чи ні – на ваш суд. Я чекаю на ваші пропозиції щодо її поліпшення/виправлення і, можливо, спільно ми зробимо з неї корисний мануал для джавістів-початківців.