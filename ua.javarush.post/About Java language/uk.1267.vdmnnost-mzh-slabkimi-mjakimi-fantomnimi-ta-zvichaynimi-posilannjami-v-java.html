Відмінності між слабкими, м'якими, фантомними та звичайними посиланнями в Java
<p>----------------------------------------</p>
«Слабкі» посилання та «м'які» посилання (WeakReference, SoftReference) були додані в API давно, але не кожен програміст знайомий з ними. Це свідчить про прогалину в розумінні, де і як їх використовувати. Посилальні класи особливо важливі в 
<p>----------------------------------------</p>
«Слабкі» посилання та «м'які» посилання (WeakReference, SoftReference) були додані в <em>Java</em> API давно, але не кожен програміст знайомий з ними. Це свідчить про прогалину в розумінні, де і як їх використовувати. Посилальні класи особливо важливі в контексті <a href="http://javarevisited.blogspot.sg/2011/04/garbage-collection-in-java.html" rel="nofollow">складання сміття</a> . Як всі ми знаємо збирач сміття сам звільняє пам'ять займану об'єктами, але не всі програмісти знають, що рішення про звільнення пам'яті він приймає виходячи з типу посилань, що є на об'єкт. <img data-id="3506eaac-ad59-4fd4-ab17-a3b1eb72725a" data-max-width="850" alt="Відмінності між слабкими, м'якими, фантомними та звичайними посиланнями в Java - 1" src="https://cdn.javarush.com/images/article/3506eaac-ad59-4fd4-ab17-a3b1eb72725a/800.jpeg" style="width: 850px;">Головна відмінність <em>SoftReference</em> від <em>WeakReference</em> у тому, як збирач з ними працюватиме. Він може видалити об'єкт у будь-який момент, якщо на нього вказують тільки weak посилання, з іншого боку об'єкти з soft посиланням будуть зібрані тільки коли <em>JVM</em>дуже потрібна пам'ять. Завдяки таким особливостям класів посилань кожен з них має своє застосування. <em>SoftReference</em> можна використовувати для реалізації кешів і коли <em>JVM</em> знадобиться пам'ять, вона звільнить її за рахунок видалення таких об'єктів. А <em>WeakReference</em> відмінно підійдуть для зберігання метаданих, наприклад, для зберігання посилання на ClassLoader. Якщо немає класів для завантаження, то немає сенсу зберігати посилання на <a href="http://javarevisited.blogspot.sg/2012/12/how-classloader-works-in-java.html" rel="nofollow">ClassLoader</a> , слабке посилання робить ClassLoader доступним для видалення, як тільки ми призначимо його замість міцного посилання (Strong reference). У цій статті ми розглянемо відмінності типів посилань, у тому числі <em>Strong reference</em> та <em>Phantom reference</em> (фантомне посилання). 
<h2>WeakReference vs SoftReference в Java</h2>Для тих хто не знає є 4 види посилань: 
<ol>
 <li>Strong reference</li>
 <li>Weak Reference</li>
 <li>Soft Reference</li>
 <li>Phantom Reference</li>
</ol> Strong посилання найпростіше, тому що ми використовуємо її в програмуванні день у день, наприклад в коді виду <em>String s = "abc"</em> змінна <em>s</em> це і є strong посилання. Будь-який об'єкт що має strong посилання заборонений для видалення збирачем сміття. Очевидно що це об'єкти які необхідні <em>Java</em> програмі. Слабкі посилання представлені класом <em>java.lang.ref.WeakReference</em> , ви можете визначити слабке посилання так: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class=" language-java"><span class="token class-name">Counter</span> counter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// strong reference</span>
<span class="token class-name">WeakReference</span><counter> weakCounter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token punctuation"></span><counter><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//weak reference</span>
counter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// now Counter object is eligible for garbage collection</span>
</counter></counter></code></pre> Тепер, як тільки ви надали strong посилання counter значення null (counter = null), той об'єкт що створений в першому рядку стає доступним для видалення збирачем сміття, тому що він більше не має strong посилання. Створена Weak посилання weakCounter не може запобігти видаленню збирачем об'єкта Counter. З іншого боку якби це було Soft посилання, об'єкт типу Counter не був би видалений до тих пір, поки <em>JVM</em> не потребувала б пам'яті особливо сильно. Soft посилання в <em>Java</em> представлені класом <em>java.lang.ref.SoftReference</em> . Приклад створення SoftReference в <em>Java</em>
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class=" language-java"><span class="token class-name">Counter</span> prime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// prime holds a strong reference</span>
<span class="token class-name">SoftReference</span><counter> soft <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token punctuation"></span><counter><span class="token punctuation">(</span>prime<span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment">//soft reference variable has SoftReference to Counter Object</span>
prime <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment">// now Counter object is eligible for garbage collection but only be collected when JVM absolutely needs memory</span>
</counter></counter></code></pre> Після обнулення strong посилання (у 3-му рядку) на об'єкт Counter залишиться тільки 1 м'яке посилання, яке не зможе запобігти видаленню цього об'єкта збирачем сміття, але на відміну від weak посилання зможе відкласти цей процес до тих пір, поки не з'явиться гостра нестача пам'яті. З огляду на цю відмінність soft посилання від weak, перша більше підходить для кешів, а weak для метаданих. Хорошим прикладом служить клас WeakHashMap, який є спадкоємцем інтерфейсу Map як і класи <a href="http://java67.blogspot.sg/2013/08/best-way-to-iterate-over-each-entry-in.html" rel="nofollow">HashMap</a> або <a href="http://javarevisited.blogspot.sg/2011/12/treemap-java-tutorial-example-program.html" rel="nofollow">TreeMap</a> , але з однією відмінністю. <em>WeakHashMap</em> обертає ключі як weak посилання, що означає що як тільки не залишилося strong посилань на об'єкт, weak посилання які розташовані всередині <em>WeakHashMap</em>не врятують від збирача сміття. Фантомні посилання – третій тип посилань, доступних у пакеті java.lang.ref. Phantom посилання представлені класом <em>java.lang.ref.PhantomReference</em> . Об'єкт на який вказують тільки phantom посилання може бути видалений збирачем будь-якої миті. <em>Phantom</em> посилання створюється так само як weak або soft. 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class=" language-java"><span class="token class-name">DigitalCounter</span> digit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DigitalCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// digit reference variable has strong reference</span>
<span class="token class-name">PhantomReference</span><digitalcounter> phantom <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token punctuation"></span><digitalcounter><span class="token punctuation">(</span>digit<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// phantom reference</span>
digit <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</digitalcounter></digitalcounter></code></pre> Як тільки ви обнулите сильні посилання на об'єкт DigitalCounter, збирач сміття видалить його в будь-який момент, тому що тепер на нього ведуть тільки фантом посилання. Крім класів WeakReference, SoftReference, PhantomReference, WeakHashMap, корисно знати про клас <em>ReferenceQueue</em> . Ви можете скористатися цим класом під час створення об'єкта класу WeakReference, SoftReference або PhantomReference: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class=" language-java"><span class="token class-name">ReferenceQueue</span> refQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//reference will be stored in this queue for cleanup</span>
<span class="token class-name">DigitalCounter</span> digit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DigitalCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">PhantomReference</span><digitalcounter> phantom <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token punctuation"></span><digitalcounter><span class="token punctuation">(</span>digit<span class="token punctuation">,</span> refQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
</digitalcounter></digitalcounter></code></pre> Посилання на об'єкт буде додано до <em>ReferenceQueue</em> і ви зможете контролювати стан посилань шляхом опитування ReferenceQueue. Життєвий цикл Object добре представлений на цій діаграмі: <img data-id="accd1b65-d122-4f9e-aae0-b76f9916bd79" data-max-width="570" alt="Відмінності між слабкими, м'якими, фантомними та звичайними посиланнями в Java - 2" src="https://cdn.javarush.com/images/article/accd1b65-d122-4f9e-aae0-b76f9916bd79/512.jpeg" style="width: 570px;">Ось і всі відмінності між weak і soft посиланнями <em>Java</em> . Також ми познайомабося з phantom посиланнями, класом <em>WeakHashMap</em> і <em>ReferenceQueue</em> . Правильне використання посилань допоможе при складанні сміття і в результаті ми отримаємо гнучкіше управління пам'яттю в <em>Java</em> . <a href="http://www.javacodegeeks.com/2014/03/difference-between-weakreference-vs-softreference-vs-phantomreference-vs-strong-reference-in-java.html" rel="nofollow">Оригінал статті</a>