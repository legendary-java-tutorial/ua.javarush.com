Як відбувається завантаження класів у JVM
<p>----------------------------------------</p>
Після того, як найскладніша частина в роботі програміста виконана і додаток «Hello World 2.0» написано, залишилося зібрати дистрибутив і передати його замовнику, чи хоча б у службу тестування. У дистрибутиві у нас все як належить і, запуска
<p>----------------------------------------</p>
Після того, як найскладніша частина в роботі програміста виконана і додаток «Hello World 2.0» написано, залишилося зібрати дистрибутив і передати його замовнику, чи хоча б у службу тестування. У дистрибутиві у нас все як належить і, запускаючи нашу програму, на сцену виходить Java Virtual Machine. Ні для кого не секрет, що віртуальна машина зчитує команди, представлені у class-файлух у вигляді байт-коду та транслює їх у вигляді інструкцій процесору. Пропоную трохи розібратися у схемі влучення байт-коду у віртуальну машину. 
<h2>Завантажувач класів</h2>Використовується для постачання в JVM скомпілюваного байт-коду, який, як правило, зберігається у файлух з розширенням <code class=" language-none">.class</code>, але може бути також отриманий з інших джерел, наприклад, завантажений по мережі або згенерований самим додатком. <img data-id="bc97dfa1-af2c-4c44-96fc-d0e0c05a2607" data-max-width="850" alt="Як відбувається завантаження класів у JVM - 1" src="https://cdn.javarush.com/images/article/bc97dfa1-af2c-4c44-96fc-d0e0c05a2607/800.jpeg" style="width: 850px;">Відповідно до специфікації Java SE для того, щоб отримати код, що працює в JVM, необхідно виконати три етапи: 
<ul>
 <li>
  <p><strong>завантаження байт-коду з ресурсів та створення екземпляра класу<code class=" language-none">Class</code></strong></p>
  <p>сюди входить пошук запитаного класу серед завантажених раніше, отримання байт-коду для завантаження та перевірка його коректності, створення екземпляра класу <code class=" language-none">Class</code>(для роботи з ним в runtime), завантаження батьківських класів. Якщо батьківські класи та інтерфейси були завантажені, те й аналізований клас вважається не завантаженим.</p></li>
 <li>
  <p><strong>зв'язування (або лінківка)</strong></p>
  <p>за специфікацією цей етап розбивається ще на три стадії:</p>
  <ul>
   <li><strong>Verification</strong> відбувається перевірка коректності отриманого байт-коду.</li>
   <li><strong>Preparation</strong> , Виділення оперативної пам'яті під статичні поля та ініціалізація їх значеннями за умовчанням (при цьому явна ініціалізація, якщо вона є, відбувається вже на етапі ініціалізації).</li>
   <li><strong>Resolution</strong> , дозвіл символьних посилань типів, полів та методів.</li>
  </ul></li>
 <li>
  <p><strong>ініціалізація отриманого об'єкта</strong></p>
  <p>тут, на відміну від попередніх пунктів, начебто все зрозуміло, що має відбуватися. Було б, звичайно, цікаво розібратися, як саме це відбувається.</p></li>
</ul><strong>Усі ці етапи виконуються послідовно з такими вимогами:</strong>
<ul>
 <li>Клас повинен бути повністю завантажений перш, ніж слинкований.</li>
 <li>Клас повинен бути повністю перевірений та підготовлений перш ніж проініціалізований.</li>
 <li>Помилки дозволу посилань відбуваються під час виконання програми, навіть якщо були виявлені на етапі лінківки.</li>
</ul>Як відомо, в Java реалізовано відкладене (або лінива) завантаження класів. А це означає, що завантаження класів посилальних полів класу, що завантажується, не буде виконуватися доти, поки в додатку не зустрінеться явне до них звернення. Іншими словами, дозвіл символьних посилань не є обов'язковим і за умовчанням не відбувається. Проте, у JVM може використовуватися і енергійна завантаження класів, тобто. всі символьні посилання мають бути враховані одразу. Ось для цього пункту і діє остання вимога. Ще варто зауважити, що роздільна здатність символьних посилань не прив'язана до жодного з етапів завантаження класу. Загалом кожен із цих етапів тягне на непогане таке дослідження, спробуємо розібратися з першим, а саме завантаженням байт-коду. 
<h2>Типи завантажувачів Java</h2>У Java існує три стандартні завантажувачі, кожен з яких здійснює завантаження класу з певного місця: 
<ol>
 <li>
  <p><strong>Bootstrap</strong> – базовий завантажувач, також називається Primordial ClassLoader.</p>
  <p>завантажує стандартні класи JDK із архіву rt.jar</p></li>
 <li>
  <p><strong>Extension ClassLoader</strong> – завантажувач розширень.</p>
  <p>завантажує класи розширень, які за умовчанням перебувають у каталозі jre/lib/ext, але можуть бути задані системною властивістю java.ext.dirs</p></li>
 <li>
  <p><strong>System ClassLoader</strong> – системний завантажувач.</p>
  <p>завантажує класи програми, визначені в змінному середовищі оточення CLASSPATH</p></li>
</ol>У Java використовується ієрархія завантажувачів класів, де кореневим є базовий. Далі слідує завантажувач розширень, а за ним вже системний. Звичайно, кожен завантажувач зберігає покажчик на батьківський для того, щоб змогти делегувати йому завантаження в тому випадку, якщо сам не зможе цього зробити. 
<h2>Анотація класу ClassLoader</h2>Кожен завантажувач, крім базового, є нащадком абстрактного класу <code class=" language-none">java.lang.ClassLoader</code>. Наприклад, реалізацією завантажувача розширень є клас <code class=" language-none">sun.misc.Launcher$ExtClassLoader</code>, а системного завантажувача - <code class=" language-none">sun.misc.Launcher$AppClassLoader</code>. Базовий завантажувач є нативним і його реалізація включена до JVM. Будь-який клас, який розширює <code class=" language-none">java.lang.ClassLoader</code>, може надати свій спосіб завантаження класів з блек-джеком та цими самими. І тому необхідно перевизначити відповідні методи, які зараз можу розглянути лише поверхово, т.к. не розбирався детально у цьому питанні. Ось вони: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">package</span></span> <span class="token namespace"><span class="token namespace">java<span class="token punctuation"><span class="token punctuation">.</span></span>lang</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">abstract</span></span> <span class="token keyword"><span class="token keyword">class</span></span> <span class="token class-name"><span class="token class-name">ClassLoader</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
    <span class="token keyword"><span class="token keyword">public</span></span> <span class="token class-name"><span class="token class-name">Class</span></span><span class="token generics"><span class="token punctuation"></span><span class="token generics"><span class="token punctuation"><span class="token punctuation">&lt;</span></span><span class="token operator"><span class="token operator">?</span></span><span class="token punctuation"><span class="token punctuation">&gt;</span></span></span><span class="token punctuation"></span></span> <span class="token function"><span class="token function">loadClass</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">String</span></span> name<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token keyword"><span class="token keyword">protected</span></span> <span class="token class-name"><span class="token class-name">Class</span></span><span class="token generics"><span class="token punctuation"></span><span class="token generics"><span class="token punctuation"><span class="token punctuation">&lt;</span></span><span class="token operator"><span class="token operator">?</span></span><span class="token punctuation"><span class="token punctuation">&gt;</span></span></span><span class="token punctuation"></span></span> <span class="token function"><span class="token function">loadClass</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">String</span></span> name<span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token keyword"><span class="token keyword">boolean</span></span> resolve<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token keyword"><span class="token keyword">protected</span></span> <span class="token keyword"><span class="token keyword">final</span></span> <span class="token class-name"><span class="token class-name">Class</span></span><span class="token generics"><span class="token punctuation"></span><span class="token generics"><span class="token punctuation"><span class="token punctuation">&lt;</span></span><span class="token operator"><span class="token operator">?</span></span><span class="token punctuation"><span class="token punctuation">&gt;</span></span></span><span class="token punctuation"></span></span> <span class="token function"><span class="token function">findLoadedClass</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">String</span></span> name<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">final</span></span> <span class="token class-name"><span class="token class-name">ClassLoader</span></span> <span class="token function"><span class="token function">getParent</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token keyword"><span class="token keyword">protected</span></span> <span class="token class-name"><span class="token class-name">Class</span></span><span class="token generics"><span class="token punctuation"></span><span class="token generics"><span class="token punctuation"><span class="token punctuation">&lt;</span></span><span class="token operator"><span class="token operator">?</span></span><span class="token punctuation"><span class="token punctuation">&gt;</span></span></span><span class="token punctuation"></span></span> <span class="token function"><span class="token function">findClass</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">String</span></span> name<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token keyword"><span class="token keyword">protected</span></span> <span class="token keyword"><span class="token keyword">final</span></span> <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">resolveClass</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">Class</span></span><span class="token generics"><span class="token punctuation"></span><span class="token generics"><span class="token punctuation"><span class="token punctuation">&lt;</span></span><span class="token operator"><span class="token operator">?</span></span><span class="token punctuation"><span class="token punctuation">&gt;</span></span></span><span class="token punctuation"></span></span> c<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre><code class=" language-none">loadClass(String name)</code>один із небагатьох публічних методів, який і є точкою входу для завантаження класів. Його реалізація зводиться до виклику іншого protected методу <code class=" language-none">loadClass(String name, boolean resolve)</code>, його необхідно перевизначити. Якщо подивитися Javadoc цього захищеного методу, можна зрозуміти приблизно таке – на вхід подаються два параметри. Один це бінарне ім'я класу (або цілком певне ім'я класу), який потрібно завантажити. Назва класу вказується з перерахуванням усіх пакетів. Другий параметр – це прапор, який визначає, чи потрібно виконувати процедуру вирішення символьних посилань. За умовчанням він дорівнює <em>false</em> , що означає використання лінивого завантаження класів. Далі, згідно з документацією, у реалізації методу за умовчанням відбувається виклик<code class=" language-none">findLoadedClass(String name)</code>, який перевіряє чи був клас вже завантажений раніше і якщо це так, поверне посилання на цей клас. Інакше буде викликано метод завантаження класу у батьківського завантажувача. Якщо жоден із завантажувачів не зміг знайти завантажений клас, кожен із них, слідуючи у зворотному порядку, спробує цей клас знайти та завантажити, перевизначаючи метод <code class=" language-none">findClass(String name)</code>. Докладніше про це буде розглянуто у розділі «Схема завантаження класів». І нарешті, в останню чергу, після того, як клас вдалося завантажити, залежно від прапора <em>resolve</em> буде вирішено, чи варто виконувати завантаження класів за символьними посиланнями. Явний приклад того, що стадія <em>Resolution</em> може бути викликана етапі завантаження класу. Відповідно, розширюючи клас<code class=" language-none">ClassLoader</code>і перевизначаючи його методи, завантажувач користувача може здійснювати свою логіку поставки байт-коду у віртуальну машину. Також Java підтримується поняття «поточного» завантажувача класів. Поточний завантажувач це той, який завантажив клас, який зараз виконується. Кожен клас знає, яким завантажувачем він був завантажений, і можна отримати цю інформацію, викликавши метод <code class=" language-none">String.class.getClassLoader()</code>. Для всіх класів програми "поточний" завантажувач, як правило, системний. 
<h2>Три принципи завантаження класів</h2>
<ul>
 <li>
  <p><strong>Делегування</strong></p>
  <p>Запит на завантаження класу передається батьківському завантажувачу, і спроба завантажити клас самостійно виконується, лише якщо батьківський завантажувач не зміг знайти та завантажити клас. Такий підхід дозволяє завантажувати класи завантажувачем, який максимально близько знаходиться до базового. Так досягається максимальна область видимості класів. Кожен завантажувач веде облік класів, які були завантажені саме ним, поміщаючи в свій кеш. Безліч цих класів і називається областю видимості.</p></li>
 <li>
  <p><strong>Видимість</strong></p>
  <p>Завантажувач бачить лише «свої» класи та класи «батька» і не має поняття про класи, які були завантажені його «нащадком».</p></li>
 <li>
  <p><strong>Унікальність</strong></p>
  <p>Клас може бути завантажений лише один раз. Механізм делегування дозволяє переконатися, що завантажувач, який ініціює завантаження класу, не перевантажить завантажений раніше JVM клас.</p></li>
</ul>Таким чином, при написанні завантажувача розробник повинен керуватися цими трьома принципами. 
<h2>Схема завантаження класів</h2>Коли відбувається завантаження будь-якого класу, відбувається пошук цього класу в кеші вже завантажених класів поточного завантажувача. Якщо бажаний клас ще завантажувався раніше, за принципом делегування управління передається батьківському завантажувачу, який перебуває за ієрархією на рівень вище. Батьківський завантажувач також намагається знайти бажаний клас у себе в кеші. Якщо клас вже був завантажений і завантажувач знає про його місцезнаходження, то буде повернуто об'єкт<code class=" language-none">Class</code>цього класу. Якщо ні, пошук буде продовжуватися доти, доки не дійде до базового завантажувача. Якщо і в базовому завантажувачі немає інформації про клас, що шукається (тобто він ще не був завантажений), буде виконано пошук байт-коду цього класу за розташуванням класів, про який знає даний завантажувач, і, якщо завантажити клас не вдасться, управління повернеться назад завантажувачу-нащадку, який намагатиметься виконати завантаження із відомих йому джерел. Як згадувалося вище, розташування класів для базового завантажувача це бібліотека rt.jar, для завантажувача розширень – каталог із розширеннями jre/lib/ext, для системного – CLASSPATH, для користувача це може бути щось своє. Таким чином, хід завантаження класів йде у зворотному напрямку – від кореневого завантажувача до поточного. Коли байт-код класу знайдено,<code class=" language-none">Class</code>. Як неважко помітити, описана схема завантаження схожа на наведену реалізацію методу <code class=" language-none">loadClass(String name)</code>. Нижче можна розглянути цю схему на діаграмі. 
<div class="row justify-content-center jr-image-wrap">
 <div class="col-12 col-sm-10 col-md-8">
  <img data-id="7a182c94-4445-4921-a82b-29be882f9600" data-max-width="710" alt="Як відбувається завантаження класів у JVM - 2" src="https://cdn.javarush.com/images/article/7a182c94-4445-4921-a82b-29be882f9600/512.jpeg" style="width: 710px;">
 </div>
</div>
<h2>Як висновок</h2>На перших кроках вивчення мови немає якоїсь особливої ​​необхідності у розумінні того, як відбувається завантаження класів у Java, але знання цих базових принципів дозволить не впадати у відчай, зустрівши такі помилки, як <code class=" language-none">ClassNotFoundException</code>або <code class=" language-none">NoClassDefFoundError</code>. Ну чи хоча б приблизно розуміти, у чому корінь проблеми. Так виняток <code class=" language-none">ClassNotFoundException</code>виникає при динамічному завантаженні класу під час виконання програми, коли завантажувачі не можуть знайти необхідний клас ні в кеші, ні шляхом знаходження класів. А ось помилка<code class=" language-none">NoClassDefFoundError</code>є критичнішою і виникає в тому випадку, коли під час компіляції шуканий клас був доступний, але не видно під час виконання програми. Це може статися, якщо в поставку програми забули увімкнути бібліотеку, яку вона використовує. Ну і сам факт розуміння принципів пристрою того інструменту, яким користуєшся в роботі (не обов'язково чітке і детальне занурення в його надра), додає деяку ясність у розумінні процесів, що протікають всередині цього механізму, що, у свою чергу, веде до впевненого використання цього інструменту. 
<h2>Джерела</h2><a href="http://javarevisited.blogspot.ru/2012/12/how-classloader-works-in-java.html" target="_blank" rel="nofollow">How ClassLoader Works in Java</a> Загалом дуже корисне джерело з доступним викладом інформації. <a href="http://java-online.ru/java-classloader.xhtml" target="_blank" rel="nofollow">Завантаження класів, ClassLoader</a> Досить об'ємна стаття, але з ухилом на те, як зробити свою реалізацію завантажувача з цими самими. <a href="http://dmitriymx.di9.ru/blog/classloader-dynamic-load-classes" target="_blank" rel="nofollow">ClassLoader: динамічне завантаження класів</a> На жаль, цей ресурс зараз недоступний, але там я знайшов найзрозумілішу діаграму зі схемою завантаження класів, тому не можу не додати. <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html" target="_blank" rel="nofollow">Java SE Specification: Chapter 5. Loading, Linking, and Initializing</a>