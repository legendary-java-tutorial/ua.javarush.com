Java 14: Що нового?
<p>----------------------------------------</p>
Світові проблеми — світові проблеми, а нова Java — за розкладом. Тобто рівно раз на півроку. Релізна версія Java 14 вийшла 17 березня і привнесла в мову кілька цікавих нововведень, орієнтованих на розробників. Серед них - експериментальна п
<p>----------------------------------------</p>
Світові проблеми — світові проблеми, а нова Java — за розкладом. Тобто рівно раз на півроку. Релізна версія Java 14 вийшла 17 березня і привнесла в мову кілька цікавих нововведень, орієнтованих на розробників. <img data-max-width="800" class="img-fluid" alt="Java 14: Що нового?  - 1" src="https://codegym-com.translate.goog/images/article/861cb809-1788-4a5b-99c5-40442df69a17/original.jpeg">Серед них - експериментальна підтримка ключового слова <span class="text-bold">record</span> , підтримка зіставлення зі зразком в операторі " <span class="text-bold">instanceof</span> ", більш дружньо налаштовані <span class="text-bold">NullPointerExceptions</span> , розширена "перев'язка" <span class="text-bold">текстових блоків</span> , оновлений <span class="text-bold">switch</span> за замовчуванням та багато іншого. Нагадаємо, всі нововведення в Java починаються з пропозицій щодо розширення ( <span class="text-bold">JEP, Java Enhancement Proposals</span>). Розробники пропонують зміни, їх розглядають офіційні батьки Java, а потім приймають деякі з цих змін, після чого ті стають частиною JDK. А тепер – про все по порядку. 
<h2><a href="https://openjdk.java.net/jeps/359" rel="nofollow" target="_blank">JEP 359: Records</a></h2>Записи, вони ж - Records доступні для JDK 14 в прев'ю-режимі, і це щось зовсім нове для Java. По суті перед нами новий тип, який був розроблений в ході проекту <a href="https://openjdk.java.net/projects/valhalla/" rel="nofollow" target="_blank">Valhalla</a> . Записи схожі на перерахування та дозволяють спростити код. По суті, вони замінюють класи, які мають стан, але немає поведінки. Простіше кажучи є поля, немає методів. У разі класів нам часом доводиться писати багато повторюваного не завжди потрібного коду: конструктори, методи доступу, <span class="text-bold">equals(), hashCode(), toString()</span> і т. д. Щоб уникнути цього коду, що повторюється, Java планується використовувати record. Ось класичний варіант: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">final</span></span> <span class="token keyword"><span class="token keyword">class</span></span> <span class="token class-name"><span class="token class-name">Triangle</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
 	<span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">final</span></span> <span class="token keyword"><span class="token keyword">int</span></span> x<span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">final</span></span> <span class="token keyword"><span class="token keyword">int</span></span> y<span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">final</span></span> <span class="token keyword"><span class="token keyword">int</span></span> z<span class="token punctuation"><span class="token punctuation">;</span></span>

    <span class="token keyword"><span class="token keyword">public</span></span> <span class="token class-name"><span class="token class-name">Triangle</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">int</span></span> x<span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token keyword"><span class="token keyword">int</span></span> y<span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token keyword"><span class="token keyword">int</span></span> z<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
         <span class="token keyword"><span class="token keyword">this</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>x <span class="token operator"><span class="token operator">=</span></span> x<span class="token punctuation"><span class="token punctuation">;</span></span>
         <span class="token keyword"><span class="token keyword">this</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>y <span class="token operator"><span class="token operator">=</span></span> y<span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token keyword"><span class="token keyword">this</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>z <span class="token operator"><span class="token operator">=</span></span> z<span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token punctuation"><span class="token punctuation">}</span></span>
    <span class="token comment"><span class="token comment">// equals, hashCode, toString</span></span></code></pre> Переходимо в Java 14 і використовуємо record: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">record</span></span> <span class="token class-name"><span class="token class-name">Triangle</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">int</span></span> x<span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token keyword"><span class="token keyword">int</span></span> y<span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token keyword"><span class="token keyword">int</span></span> z<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">{</span></span><span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> От і все. Врахуйте, що записи поки що існують у формі превью, тому щоб випробувати їх на практиці, потрібно завантажити jdk14 і ввести команду: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class="  language-java">javac —enable<span class="token operator"><span class="token operator">-</span></span>preview —release <span class="token number"><span class="token number">14</span></span> <span class="token class-name"><span class="token class-name">Triangle</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>java</code></pre> Записи - це класи, хай і з обмеженнями. Вони можуть розширювати інші класи чи оголошувати поля (крім private final які відповідають компонентам описи стану). Записи неявно final і не можуть бути абстрактними. Записи від звичайних класів тим, що вони можуть відокремити свій API від його представлення. Але втрата свободи компенсується підвищеною точністю. Компоненти запису також неявно final. 
<h2><a href="http://openjdk.java.net/jeps/305" rel="nofollow" target="_blank">JEP 305: Pattern Matching для instanceof (Preview)</a></h2>Фіча <span class="text-bold">Pattern Matching</span> , представлена ​​в Java 14 в прев'ю, покликана об'єднати в операторі <span class="text-bold">встановленняперевірку</span> типу об'єкта і його перетворення. Іншими словами до Java 14 був би, наприклад, такий код: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">Object</span></span> object <span class="token operator"><span class="token operator">=</span></span> <span class="token class-name"><span class="token class-name">Violin</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>

<span class="token keyword"><span class="token keyword">if</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span>object <span class="token keyword"><span class="token keyword">instanceof</span></span> <span class="token class-name"><span class="token class-name">Instrument</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
    <span class="token class-name"><span class="token class-name">Instrument</span></span> instrument <span class="token operator"><span class="token operator">=</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">Instrument</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> object<span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token class-name"><span class="token class-name">System</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>instrument<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">getMaster</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> Як бачимо, ми маємо привести об'єкт до класу, методи якого хочемо використовувати. Тепер Java 14 та підключеною фічею Pattern Matching дозволяє скоротити код до наступного: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">Object</span></span> object <span class="token operator"><span class="token operator">=</span></span> <span class="token class-name"><span class="token class-name">Violin</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>

<span class="token keyword"><span class="token keyword">if</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span>object <span class="token keyword"><span class="token keyword">instanceof</span></span> <span class="token class-name"><span class="token class-name">Instrument</span></span> instrument<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">{</span></span>
    <span class="token class-name"><span class="token class-name">System</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>instrument<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">getMaster</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre>
<h2><a href="http://openjdk.java.net/jeps/343" rel="nofollow" target="_blank">JEP 343: Packaging Tool (Incubator)</a></h2>У JDK 8 був інструмент <span class="text-bold">javapackager</span> , призначений для JavaFX. Однак після відокремлення JavaFX від Java разом з випуском JDK 11, популярний javapackager виявився більш недоступним. <span class="text-bold">Javapackager</span> був інструментом упаковки. Він дозволяв упаковувати програми Java таким чином, щоб їх можна було встановити, як і всі інші "нормальні" програми. Наприклад, створювати exe-файли для користувачів Windows і запускати Java-додаток по-людськи - подвійним клацанням миші. Зрозуміло, такого інструменту не вистачає, тому в <span class="text-bold">JEP 343</span> запропонували новий інструмент <span class="text-bold">jpackage</span>, який збирає Java-додаток у пакет для конкретної платформи, що містить усі необхідні залежності. Формати пакетів, що підтримуються, для конкретної платформи: 
<ul>
 <li>Linux: deb та rpm</li>
 <li>macOS: pkg та dmg</li>
 <li>Windows: MSI та EXE</li>
</ul>
<div class="table-container">
 <table class="table table--striped">
  <tbody>
   <tr>
    <td>Бажаєте дізнатися більше про те, як розвивалася Java? Читайте статті про попередні версії! <br><a href="https://codegym.cc/groups/posts/2353-java-13-novihe-vozmozhnosti" target="_blank">Java 13: нові можливості </a><br><a href="https://codegym.cc/groups/posts/2171-java-12-uzhe-zdesjh-chto-novogo" target="_blank">Java 12 вже тут: що нового? </a><br><a href="https://codegym.cc/groups/posts/1961-vihshla-java-11-novihe-fichi-i-vozmozhnosti-" target="_blank">Вийшла Java 11: нові фічі та можливості </a><br><a href="https://codegym.cc/groups/posts/2547-iz-8-v-13-polnihy-obzor-versiy-java-chastjh-1" target="_blank">З 8 до 13: повний огляд версій Java. Частина 1 </a><br><a href="https://codegym.cc/groups/posts/2549-iz-8-v-13-polnihy-obzor-versiy-java-chastjh-2" target="_blank">З 8 до 13: повний огляд версій Java. Частина 2</a></td>
   </tr>
  </tbody>
 </table>
</div>
<h2><a href="http://openjdk.java.net/jeps/345" rel="nofollow" target="_blank">JEP 345: NUMA-Aware Memory Allocation для G1</a></h2>JEP 345 є виключно для реалізації підтримки NUMA (Non-uniform memory access). Це архітектура з неоднорідним доступом до пам'яті, способом налаштування кластера мікропроцесора в багатопроцесорну систему, при якій пам'ять може бути розподілена локально: кожне ядро ​​процесора отримує невеликий обсяг локальної пам'яті, при цьому інші ядра мають до неї доступ. JEP 345 планує оснастити збирач сміття G1 можливістю раціонально використати такі архітектури. Крім того, такий підхід допомагає підвищити продуктивність на дуже потужних машинах. 
<h2><a href="https://openjdk.java.net/jeps/349" rel="nofollow" target="_blank">JEP 349: JFR Event Streaming</a></h2><span class="text-bold">Java Flight Recorder (JFR)</span> тепер є частиною OpenJDK і тому знаходиться у вільному доступі. У JDK 14 доданий API для відстеження на льоту подій JFR (JDK Flight Recorder), зокрема для організації безперервного моніторингу активних і неактивних додатків. Записуються ті ж події, що й для не-потокового варіанта, з накладними витратами менше ніж 1%. Таким чином, потокова передача подій здійснюватиметься одночасно з варіантом без потокової передачі. Однак JEP 349 не повинен дозволяти синхронні callback'и для відповідного споживача. Навіть дані із записів, що зберігаються в проміжній пам'яті, не повинні бути доступними. Технічно пакет jdk.jfr.consumer у модулі jdk.jfr буде розширено функціональністю для асинхронного доступу до подій. 
<h2><a href="https://openjdk.java.net/jeps/352" rel="nofollow" target="_blank">JEP 352: Non-Volatile Mapped Byte Buffers</a></h2>Як відомо, <span class="text-bold">Java NIO (New IO) File API</span> існує з JDK 1.4, а потім було представлено нове вдосконалення під назвою Path. Path - це інтерфейс, який замінює клас java.io.File як подання файлу чи каталогу, коли ми працюємо у Java NIO. JEP 352 розширює MappedByteBuffer для завантаження частини файлових даних в незалежну пам'ять (NVM). Ця пам'ять комп'ютера, дані в якій не будуть втрачені навіть у разі відключення живлення (її часто називають постійною пам'яттю), використовується для постійного зберігання даних. Ця пропозиція щодо поліпшення Java надає новий модуль і клас для JDK API: модуль jdk.nio.mapmode, пропонує нові режими (READ_ONLY_SYNC, WRITE_ONLY_SYNC) для створення байтових буферів, що відображаються (MappedByteBuffer), що посилаються на NVM. 
<h2><a href="https://openjdk.java.net/jeps/358" rel="nofollow" target="_blank">JEP 358: Helpful NullPointerExceptions</a></h2>Тепер винятки <span class="text-bold">NullPointerExceptions</span> будуть більш дружніми до програміста. У тому сенсі, що опис винятку буде набагато інформативнішим, ніж раніше. А все тому, що JVM навчабо більш точно аналізувати інструкції байт-коду програми, і вона може вказати яка саме змінна призводить до нульового значення. Допустимо, у нас є код: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class="  language-java">a<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">getMessage</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">getUserInfo</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">getName</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span></code></pre> У будь-якій з останніх Java ми отримаємо звичайний лог помилки, який не відповідає на запитання, хто саме null: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">Exception</span></span> in thread <span class="token string"><span class="token string">"main"</span></span> <span class="token class-name"><span class="token namespace"></span><span class="token class-name"><span class="token namespace"><span class="token namespace">java<span class="token punctuation"><span class="token punctuation">.</span></span>lang<span class="token punctuation"><span class="token punctuation">.</span></span></span><span class="token punctuation"></span></span>NullPointerException</span></span>
	at <span class="token class-name"><span class="token class-name">Main</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">main</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">Main</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>java<span class="token operator"><span class="token operator">:</span></span><span class="token number"><span class="token number">12</span></span><span class="token punctuation"><span class="token punctuation">)</span></span></code></pre> А ось що видасть Java 14, якщо ви наважитеся випробувати цю прев'ю-фічу: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">Exception</span></span> in thread <span class="token string"><span class="token string">"main"</span></span> <span class="token class-name"><span class="token namespace"></span><span class="token class-name"><span class="token namespace"><span class="token namespace">java<span class="token punctuation"><span class="token punctuation">.</span></span>lang<span class="token punctuation"><span class="token punctuation">.</span></span></span><span class="token punctuation"></span></span>NullPointerException</span></span><span class="token operator"><span class="token operator">:</span></span> <span class="token class-name"><span class="token class-name">Cannot</span></span> invoke <span class="token string"><span class="token string">"UserInfo().getName()"</span></span> because the <span class="token keyword"><span class="token keyword">return</span></span> value of <span class="token string"><span class="token string">"Message().getUserInfo()"</span></span> is <span class="token keyword"><span class="token keyword">null</span></span>
	at <span class="token class-name"><span class="token class-name">Main</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">main</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">Main</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>java<span class="token operator"><span class="token operator">:</span></span><span class="token number"><span class="token number">12</span></span><span class="token punctuation"><span class="token punctuation">)</span></span></code></pre> Такий ланцюжок набагато зрозуміліший, і дозволяє набагато швидше взятися за усунення помилки. 
<h2><a href="http://openjdk.java.net/jeps/361" rel="nofollow" target="_blank">JEP 361: Switch Expressions (Standard)</a></h2>Оновлений оператор Switch був доступний ще в попередніх Java 12 і 13, але тільки як прев'ю-функція, тобто вона не була включена за замовчуванням. Тепер у JDK 14 все працює "з коробки". Java 14 представляє нову спрощену форму блоку switch з мітками case L -&gt; .... Нова форма деяких випадках спрощує код. Ось кілька прикладів. Припустимо, що ми маємо enum, який описує дні тижня. Ми можемо написати класичний код (до Java 14): 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">switch</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span>day<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
    <span class="token keyword"><span class="token keyword">case</span></span> MONDAY<span class="token operator"><span class="token operator">:</span></span>
    <span class="token keyword"><span class="token keyword">case</span></span> FRIDAY<span class="token operator"><span class="token operator">:</span></span>
    <span class="token keyword"><span class="token keyword">case</span></span> SUNDAY<span class="token operator"><span class="token operator">:</span></span>
        <span class="token class-name"><span class="token class-name">System</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token number"><span class="token number">6</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token keyword"><span class="token keyword">break</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token keyword"><span class="token keyword">case</span></span> TUESDAY<span class="token operator"><span class="token operator">:</span></span>
        <span class="token class-name"><span class="token class-name">System</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token number"><span class="token number">7</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token keyword"><span class="token keyword">break</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token keyword"><span class="token keyword">case</span></span> THURSDAY<span class="token operator"><span class="token operator">:</span></span>
    <span class="token keyword"><span class="token keyword">case</span></span> SATURDAY<span class="token operator"><span class="token operator">:</span></span>
        <span class="token class-name"><span class="token class-name">System</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token number"><span class="token number">8</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token keyword"><span class="token keyword">break</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token keyword"><span class="token keyword">case</span></span> WEDNESDAY<span class="token operator"><span class="token operator">:</span></span>
        <span class="token class-name"><span class="token class-name">System</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token number"><span class="token number">9</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token keyword"><span class="token keyword">break</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> А ось варіант з використанням Java 14: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">switch</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span>day<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
    <span class="token keyword"><span class="token keyword">case</span></span> MONDAY<span class="token punctuation"><span class="token punctuation">,</span></span> FRIDAY<span class="token punctuation"><span class="token punctuation">,</span></span> SUNDAY <span class="token operator"><span class="token operator">-&gt;</span></span> <span class="token class-name"><span class="token class-name">System</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token number"><span class="token number">6</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token keyword"><span class="token keyword">case</span></span> TUESDAY                <span class="token operator"><span class="token operator">-&gt;</span></span> <span class="token class-name"><span class="token class-name">System</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token number"><span class="token number">7</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token keyword"><span class="token keyword">case</span></span> THURSDAY<span class="token punctuation"><span class="token punctuation">,</span></span> SATURDAY     <span class="token operator"><span class="token operator">-&gt;</span></span> <span class="token class-name"><span class="token class-name">System</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token number"><span class="token number">8</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token keyword"><span class="token keyword">case</span></span> WEDNESDAY              <span class="token operator"><span class="token operator">-&gt;</span></span> <span class="token class-name"><span class="token class-name">System</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token number"><span class="token number">9</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> Також можна писати багаторядкові блоки та повертати значення з новим ключовим словом yield: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">int</span></span> result <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">switch</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span>s<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
    <span class="token keyword"><span class="token keyword">case</span></span> <span class="token string"><span class="token string">"Working from Home"</span></span> <span class="token operator"><span class="token operator">-&gt;</span></span> <span class="token number"><span class="token number">1</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token keyword"><span class="token keyword">case</span></span> <span class="token string"><span class="token string">"Working from Office"</span></span> <span class="token operator"><span class="token operator">-&gt;</span></span> <span class="token number"><span class="token number">2</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token keyword"><span class="token keyword">default</span></span>    <span class="token operator"><span class="token operator">-&gt;</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
        <span class="token class-name"><span class="token class-name">System</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">"Neither Home nor Office… Cafe? Car? Park?..."</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token keyword"><span class="token keyword">yield</span></span> <span class="token number"><span class="token number">0</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token punctuation"><span class="token punctuation">}</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> Є ще кілька важливих речей, які потрібно мати на увазі при використанні нових <span class="text-bold">switch</span> . Зокрема, слід пам'ятати, що варіанти мають бути вичерпними. Тобто для всіх можливих значень має бути відповідна switch-мітка. Оскільки <span class="text-bold">yield</span> тепер є ключовим словом, клас з ім'ям yield — можливий Java 14. А взагалі, якщо хочете навчитися використовувати оновлені “свічі”, переходьте на <a href="https://openjdk.java.net/jeps/361" rel="nofollow" target="_blank">JEP 361</a> і вивчайте. Там багато цікавої інформації. 
<h2><a href="https://openjdk.java.net/jeps/362" rel="nofollow" target="_blank">JEP 362: Deprecate the Solaris and SPARC Ports</a></h2>Навряд чи багато наших читачів пам'ятають про операційну систему <span class="text-bold">Solaris</span> . Ця операційна база UNIX, створена батьками Java — компанією Sun Microsystems, використовувалася переважно для серверів на SPARC-архітектурі… Занадто багато незнайомих слів на квадратний сантиметр? Нічого страшного: JEP 362 припиняє підтримку платформ Solaris/SPARC, Solaris/x64 та Linux/SPARC. Тобто їхні порти тепер Deprecated, а в майбутньому вони, швидше за все, будуть видалені із OpenJDK. Однак старі версії Java (до JDK 14) щодо портів Solaris/SPARC, Solaris/x64 та Linux/SPARC мають працювати без змін. Якщо ви - любитель історії і цікавитесь технологіями не такого вже далекого минулого - гоу в "Вікіпедію" читати про архітектуру <a href="https://ru.wikipedia.org/wiki/SPARC" rel="nofollow" target="_blank">SPARС</a> . 
<h2><a href="https://openjdk.java.net/jeps/363" rel="nofollow" target="_blank">JEP 363: Remove the Concurrent Mark Sweep (CMS) Garbage Collector</a></h2>Складальник сміття CMS (Concurrent Mark Sweep) спрямований на видалення, оскільки ще два роки тому був помічений як застарілий і залишився без супроводу. Однак користувачі старих версій Java, які використовують CMS GC, можуть видихнути - мета цього JEP'а не в тому, щоб видалити збирач з попередніх випусків JDK. Крім того, оголошено застарілим застосування комбінації алгоритмів складання сміття ParallelScavenge та SerialOld (запуск із опціями "-XX:+UseParallelGC -XX:-UseParallelOldGC"). <a href="https://codegym.cc/welcome" target="_blank"><img id="click_banner1_articles" data-max-width="1024" data-id="238acc3b-7dc7-4e7b-8e2e-24b08505f341" class="img-fluid" alt="Java 14: Що нового?  - 2" src="https://cdn.javarush.com/images/article/238acc3b-7dc7-4e7b-8e2e-24b08505f341/1024.jpeg" style="width: 1024px;"></a>
<h2><a href="https://openjdk.java.net/jeps/364" rel="nofollow" target="_blank">JEP 364: ZGC on macOS</a> та <a href="https://openjdk.java.net/jeps/365" rel="nofollow" target="_blank">JEP 365: ZGC on Windows</a></h2>Є такий цікавий збирач сміття на ім'я <span class="text-bold">Z Garbage Collector (ZGC)</span> . Він працює в пасивному режимі і намагається максимально скоротити затримки через складання сміття: час зупинки при використанні ZGC не перевищує 10 мс. Він може працювати з маленькими купами (heap) та з гігантськими (тими, що займають багато терабайт). JEP 364 і JEP 365 - практично близнюки. JEP 364 переносить Z Garbage Collector на MacOS. Частина JEP також описує функціональність збирача для звільнення пам'яті пристрою, що не використовується, як зазначено в <a href="https://openjdk.java.net/jeps/351" rel="nofollow" target="_blank">JEP 351</a> , це відбувається з Java 13. Реалізація ZGC в macOS складається з двох частин: 
<ul>
 <li>Підтримка multi-mapping memory на macOS</li>
 <li>Підтримка в ZGC безперервного резервування пам'яті</li>
</ul>JEP 365 забезпечує підтримку ZGC вже на Windows і теж в експериментальному режимі. Вона полягає в наступному: 
<ul>
 <li>Підтримка multi-mapping memory</li>
 <li>Підтримка картки пам'яті на основі файлу підкачки в зарезервований адресаний простір</li>
 <li>Підтримка мапінгу та анмапінгу довільних частин купи</li>
 <li>Підтримка комміту та анкомміту довільних частин купи</li>
</ul>
<h2><a href="https://openjdk.java.net/jeps/366" rel="nofollow" target="_blank">JEP 366: Deprecate the ParallelScavenge + SerialOld GC Combination</a></h2>Цей JEP оголошує застарілим використання комбінації алгоритмів для збирання сміття Parallel Scavenge та Serial Old. Таку комбінацію потрібно було включати вручну за допомогою параметрів командного рядка – XX: + UseParallelGC – XX: – UseParallelOldGC. Автори вважають, що комбінація дуже специфічна, але потребує суттєвих зусиль з обслуговування. Отже, тепер опція -XX: UseParallelOldGC застаріла, і в разі використання буде з'являтися попередження. 
<h2><a href="http://openjdk.java.net/jeps/367" rel="nofollow" target="_blank">JEP 367: Remove the Pack200 Tools and API</a></h2><a href="https://docs.oracle.com/en/java/javase/13/docs/specs/pack-spec.html" rel="nofollow" target="_blank">Pack200</a> – це формат архіву, оптимізований для зберігання скомпільованих файлів Java-класів. Цей інструмент був позначений словом deprecated (застарілий) ще з часів Java 11. Тепер інструменти pack200, unpack200 і Pack200 API офіційно заявлені на видалення з <span class="text-bold">java.util.jar package</span> . Ця технологія була введена ще в Java 5, як засіб боротьби з обмеженою пропускною здатністю (модеми, страшно сказати і згадати, 56k) і недостатнім простором для зберігання на жорстких дисках. Якийсь час тому Java 9 були представлені нові схеми стиснення. Розробникам рекомендується використовувати <span class="text-bold">jlink</span> . 
<h2><a href="https://jaxenter.com/jep-368-text-blocks-second-preview-163817.html" rel="nofollow" target="_blank">JEP 368: Text Blocks (Second Preview)</a></h2><span class="text-bold">Текстові блоки</span> вперше з'явабося в Java 13. Це багаторядкові рядкові літерали, які запобігають необхідності більшості escape-послідовностей, автоматично форматують рядок, а також дозволяють розробнику форматувати рядок при необхідності. Тепер ця корисна функція доступна Java 14 (друга, попередня версія). Головне завдання текстових блоків - покращити роботу із заплутаними багаторядковими літералами. Це значно спрощує читання та написання SQL-запитів, HTML- і XML-коду, JSON. Приклад HTML без текстових блоків: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">String</span></span> html <span class="token operator"><span class="token operator">=</span></span> <span class="token string"><span class="token string">"&lt;html&gt;\n"</span></span> <span class="token operator"><span class="token operator">+</span></span>
              <span class="token string"><span class="token string">"    &lt;body&gt;\n"</span></span> <span class="token operator"><span class="token operator">+</span></span>
              <span class="token string"><span class="token string">"        &lt;p&gt;Hello, CodeGym Student&lt;/p&gt;\n"</span></span> <span class="token operator"><span class="token operator">+</span></span>
              <span class="token string"><span class="token string">"    &lt;/body&gt;\n"</span></span> <span class="token operator"><span class="token operator">+</span></span>
              <span class="token string"><span class="token string">"&lt;/html&gt;\n"</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> Як уявити те саме з текстовими блоками: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">String</span></span> html <span class="token operator"><span class="token operator">=</span></span> <span class="token triple-quoted-string string"><span class="token triple-quoted-string string">"""
              &lt;html&gt;
                  &lt;body&gt;
                      &lt;p&gt;Hello, CodeGym Student&lt;/p&gt;
                  &lt;/body&gt;
              &lt;/html&gt;
              """</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre><span class="text-bold">Відкриваючий роздільник</span> - це послідовність з трьох символів подвійних лапок (" " "), за якими слідують нуль або більше пробілів, а потім - роздільник рядка <span class="text-bold">.</span> лапок Вміст закінчується на останньому символі перед першою подвійною лапкою закриває роздільника <span class="text-bold">.</span>може безпосередньо вміщувати символи подвійних лапок, на відміну символів у рядковому літералі. Використання \ у текстовому блоці дозволено, але не обов'язково чи не рекомендується. Жирні роздільники (" "") були обрані таким чином, щоб символи могли відображатися без екранування, а також візуально відрізняти текстовий блок від рядкового літералу. На початку 2019 року в JEP 355 запропонували текстові блоки як продовження JEP 326 Пізніше в тому ж році, в JDK 13 представабо функцію попереднього перегляду текстового блоку, і тепер в Java 14 до неї додали дві нові escape-послідовності. для пробілу (single space), позначається /s Приклад використання символів нового рядка без текстових блоків: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">String</span></span> literal <span class="token operator"><span class="token operator">=</span></span> <span class="token string"><span class="token string">"This is major Tom to Ground Control "</span></span> <span class="token operator"><span class="token operator">+</span></span>
<span class="token string"><span class="token string">"I am stepping through the door... "</span></span> <span class="token operator"><span class="token operator">+</span></span>
<span class="token string"><span class="token string">"Wait… What???"</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> А тепер - з ескейп-послідовністю &lt;line-terminator&gt;: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">String</span></span> text <span class="token operator"><span class="token operator">=</span></span> <span class="token string"><span class="token string">""</span></span>"
                <span class="token class-name"><span class="token class-name">This</span></span> is major <span class="token class-name"><span class="token class-name">Tom</span></span> <span class="token keyword"><span class="token keyword">to</span></span> <span class="token class-name"><span class="token class-name">Ground</span></span> <span class="token class-name"><span class="token class-name">Control</span></span> \
                <span class="token class-name"><span class="token class-name">I</span></span> am stepping through the door<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token punctuation"><span class="token punctuation">.</span></span> \
                <span class="token class-name"><span class="token class-name">Wait</span></span>… <span class="token class-name"><span class="token class-name">What</span></span><span class="token operator"><span class="token operator">?</span></span><span class="token operator"><span class="token operator">?</span></span><span class="token operator"><span class="token operator">?</span></span>\
                <span class="token string"><span class="token string">""</span></span>"<span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> Ескейп-послідовність <span class="text-bold">використовується</span> для обліку завершальних пробілів, які за замовчуванням ігноруються компілятором. Він зберігає всі наявні перед ним прогалини. Приклад: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">String</span></span> text1 <span class="token operator"><span class="token operator">=</span></span> <span class="token triple-quoted-string string"><span class="token triple-quoted-string string">"""
               line1
               line2 \s
               line3
               """</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>

<span class="token class-name"><span class="token class-name">String</span></span> text2 <span class="token operator"><span class="token operator">=</span></span> <span class="token string"><span class="token string">"line1\nline2 \nline3\n"</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre><code class=" language-none">text1</code>та <code class=" language-none">text2</code>— ідентичні. 
<h2><a href="https://openjdk.java.net/jeps/370" rel="nofollow" target="_blank">JEP 370: Foreign-Memory Access API (Incubator)</a></h2>Багато популярних бібліотек і програм Java мають доступ до зовнішньої пам'яті. Наприклад, Ignite, MapDB, Memcached та Netty ByteBuf API. При цьому вони можуть уникнути витрат та непередбачуваності, пов'язаних зі складанням сміття (особливо при обслуговуванні великих кешів), спільно використовувати пам'ять між декількома процесами, а також серіалізувати та десеріалізувати вміст пам'яті шляхом зіставлення файлів у пам'яті (наприклад, за допомогою mmap). Однак Java API досі не отримала відповідного рішення для доступу до зовнішньої пам'яті. У JDK 14 можна підключити попередній варіант <span class="text-bold">API Foreign-Memory Access</span> , який дозволяє програмам Java безпечно та ефективно отримати доступ до областей пам'яті, поза купою віртуальної машини Java, за допомогою нових абстракцій MemorySegment, MemoryAddress та MemoryLayout. 
<h2>Висновки</h2>Ну як вам? У порівнянні з Java 13, нова Java 14 пропонує набагато більше важливих поліпшень у різних областях. Швидше за все, найбільш важливими для розробників будуть оновлені switch, розширені винятки NullPointerExceptions і records. Чи ні? Не забудьте випробувати нові фічі Java 14, це дуже корисно навіть для новачків. Успіхів у навчанні!