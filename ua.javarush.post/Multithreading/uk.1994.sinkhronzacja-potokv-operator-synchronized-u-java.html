Синхронізація потоків. Оператор synchronized у Java
<p>----------------------------------------</p>
Вітання! Сьогодні продовжимо розглядати особливості багатопотокового програмування та поговоримо про синхронізацію потоків. Що таке «синхронізація»? Поза областю програмування під цим мається на увазі налаштування, що дозволяє двом пристроя
<p>----------------------------------------</p>
Вітання! Сьогодні продовжимо розглядати особливості багатопотокового програмування та поговоримо про синхронізацію потоків. 
<div class="row justify-content-center jr-image-wrap">
 <div class="col-12 col-sm-10 col-md-8">
  <img data-id="0beefc45-51f9-4701-bcb9-797fb8760d31" data-max-width="710" alt="Синхронізація потоків.  Оператор synchronized - 1" src="https://cdn.javarush.com/images/article/0beefc45-51f9-4701-bcb9-797fb8760d31/512.jpeg" style="width: 710px;">
 </div>
</div> Що таке «синхронізація»? Поза областю програмування під цим мається на увазі налаштування, що дозволяє двом пристроям чи програмам працювати спільно. Наприклад, смартфон та комп'ютер можна синхронізувати з Google-акаунтом, особистий кабінет на сайті — з обліковцями в соціальних мережах, щоб логінуватися за їх допомогою. У синхронізації потоків схоже значення: це налагодження взаємодії потоків між собою. У попередніх лекціях наші потоки жабо та працювали окремо один від одного. Один щось вважав, другий спав, третій виводив щось на консоль, але вони не взаємодіяли. У реальних програмах такі ситуації рідкісні. Декілька потоків можуть активно працювати, наприклад, з тим самим набором даних і щось у ньому змінювати. Це створює проблеми. Уяви, що кілька потоків записують текст в те саме місце — наприклад, в текстовий файл або консоль. Цей файл чи консоль у разі стає загальним ресурсом. Потоки не знають про існування один одного, тому просто записують усе, що встигнуть за час, який планувальник потоків їм виділить. У недавній лекції курсу ми мали приклад, до чого це приведе, давай його згадаємо: <img data-id="d6ea3443-4a0c-4633-b39a-1f793d8c5620" data-max-width="850" alt="Синхронізація потоків.  Оператор synchronized - 2" src="https://cdn.javarush.com/images/article/d6ea3443-4a0c-4633-b39a-1f793d8c5620/800.jpeg" style="width: 850px;">Причина у тому, що потоки працювали із загальним ресурсом, консоллю, не узгоджуючи дії друг з одним. Якщо планувальник потоків виділив час Поток-1, той моментально пише все в консоль. Що там уже встигли чи не встигли написати інші потоки — не має значення. Результат, як бачиш, плачевний. Тому в багатопотоковому програмуванні ввели спеціальне поняття <strong>м'ютекс (від англ. Mutex, mutual exclusion - взаємний виняток)</strong> . <strong>Завдання мьютексу</strong>— забезпечити такий механізм, щоб доступ до об'єкта у певний час мав лише один поток. Якщо Потік-1 захопив м'ютекс об'єкта А, решта потоків не отримає до нього доступу, щоб щось у ньому змінювати. Доки м'ютекс об'єкта А не звільниться, інші потоки будуть змушені чекати. Приклад із життя: уяви, що ти та ще 10 незнайомих людей берете участь у тренінгу. Вам потрібно по черзі висловлювати ідеї та щось обговорювати. Але, оскільки один одного ви бачите вперше, щоб постійно не перебивати один одного і не скочуватися в гвалт, ви використовуєте правило з «м'ячиком, що говорить»: говорити може тільки одна людина — та, у кого в руках м'ячик. Так дискусія виходить адекватною та плідною. Так от м'ютекс, по суті, і є такий м'ячик. Якщо м'ютекс об'єкта знаходиться в руках одного потоку, інші потоки не зможуть отримати доступ до цього об'єкта. Не потрібно нічого робити, щоб створити м'ютекс: він уже вбудований у клас<code class=" language-none">Object</code>, а значить, є у кожного об'єкта Java. 
<h2>Як працює оператор synchronized у Java</h2>Давай познайомимося з новим ключовим словом – <strong>synchronized</strong> . Їм позначається певний шматок нашого коду. Якщо блок коду позначений ключовим словом synchronized, це означає, що блок може виконуватися лише одним потоком одночасно. Синхронізацію можна реалізувати по-різному. Наприклад, створити цілий синхронізований метод: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">synchronized</span></span> <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">doSomething</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>

   <span class="token comment"><span class="token comment">//...логіка методу</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> Або ж написати блок коду, де синхронізація здійснюється за якимось об'єктом: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">class</span></span> <span class="token class-name"><span class="token class-name">Main</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>

   <span class="token keyword"><span class="token keyword">private</span></span> <span class="token class-name"><span class="token class-name">Object</span></span> obj <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">Object</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>

   <span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">doSomething</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>

       <span class="token comment"><span class="token comment">//...якась логіка, доступна всім потоків</span></span>

       <span class="token keyword"><span class="token keyword">synchronized</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span>obj<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>

           <span class="token comment"><span class="token comment">// Логіка, яка одночасно доступна тільки для одного потоку</span></span>
       <span class="token punctuation"><span class="token punctuation">}</span></span>
   <span class="token punctuation"><span class="token punctuation">}</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> Сенс простий. Якщо один потік зайшов усередину блоку коду, який позначений словом synchronized, він моментально захоплює м'ютекс об'єкта, і всі інші потоки, які спробують зайти в цей же блок або метод, змушені чекати, поки попередній потік не завершить свою роботу і не звільнить монітор. <img data-id="f05403cc-d388-4dec-ac7f-4370fbabd4d0" data-max-width="850" alt="Синхронізація потоків.  Оператор synchronized - 3" src="https://cdn.javarush.com/images/article/f05403cc-d388-4dec-ac7f-4370fbabd4d0/800.jpeg" style="width: 850px;">До речі! У лекціях курсу ти вже бачив приклади synchronized, але вони виглядали інакше: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">swap</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
<span class="token punctuation"><span class="token punctuation">{</span></span>
   <span class="token keyword"><span class="token keyword">synchronized</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">this</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
   <span class="token punctuation"><span class="token punctuation">{</span></span>
       <span class="token comment"><span class="token comment">//...логіка методу</span></span>
   <span class="token punctuation"><span class="token punctuation">}</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> Тема для тебе нова, і плутанина із синтаксисом, само собою, спочатку буде. Тому запам'ятай одразу, щоб не плутатися потім у способах написання. Ці два способи запису означають те саме: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">swap</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>

   <span class="token keyword"><span class="token keyword">synchronized</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">this</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
   <span class="token punctuation"><span class="token punctuation">{</span></span>
       <span class="token comment"><span class="token comment">//...логіка методу</span></span>
   <span class="token punctuation"><span class="token punctuation">}</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span>


<span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">synchronized</span></span> <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">swap</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>

   <span class="token punctuation"><span class="token punctuation">}</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> У першому випадку створюєш синхронізований блок коду відразу ж при вході до методу. Він синхронізується за об'єктом <code class=" language-none">this</code>, тобто за поточним об'єктом. А в другому прикладі вішаєш слово synchronized на весь метод. Тут немає потреби явно вказувати якийсь об'єкт, яким здійснюється синхронізація. Якщо словом позначений цілий метод, цей метод автоматично буде синхронізованим для всіх об'єктів класу. Не заглиблюватимемося в міркування, який спосіб кращий. Поки вибирай те, що більше подобається :) Головне пам'ятай: оголосити метод синхронізованим можна тільки тоді, коли вся логіка всередині нього виконується одним потоком одночасно. Наприклад, у цьому випадку зробити метод <code class=" language-none">doSomething()</code>синхронізованим буде помилкою: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">class</span></span> <span class="token class-name"><span class="token class-name">Main</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>

   <span class="token keyword"><span class="token keyword">private</span></span> <span class="token class-name"><span class="token class-name">Object</span></span> obj <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">Object</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>

   <span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">doSomething</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>

       <span class="token comment"><span class="token comment">//...якась логіка, доступна всім потоків</span></span>

       <span class="token keyword"><span class="token keyword">synchronized</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span>obj<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>

           <span class="token comment"><span class="token comment">// Логіка, яка одночасно доступна тільки для одного потоку</span></span>
       <span class="token punctuation"><span class="token punctuation">}</span></span>
   <span class="token punctuation"><span class="token punctuation">}</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> Як бачиш, шматочок методу містить логіку, для якої синхронізація не є обов'язковою. Код у ньому можуть виконувати кілька потоків одночасно, а всі критично важливі місця виділені в окремий блок synchronized. І ще один момент. Давай розглянемо «під мікроскопом» наш приклад із лекції з обміном іменами: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">swap</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
<span class="token punctuation"><span class="token punctuation">{</span></span>
   <span class="token keyword"><span class="token keyword">synchronized</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">this</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
   <span class="token punctuation"><span class="token punctuation">{</span></span>
       <span class="token comment"><span class="token comment">//...логіка методу</span></span>
   <span class="token punctuation"><span class="token punctuation">}</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre><em>Зверніть увагу:</em> синхронізація проводиться по <code class=" language-none"><strong>this</strong></code>. Тобто щодо конкретного об'єкту <code class=" language-none">MyClass</code>. Уяви, що у нас є 2 потоки ( <code class=" language-none">Thread-1</code>і <code class=" language-none">Thread-2</code>) і всього один об'єкт <code class=" language-none">MyClass myClass</code>. У разі, якщо <code class=" language-none">Thread-1</code>викличе метод <code class=" language-none">myClass.swap()</code>, м'ютекс об'єкта буде зайнятий, і <code class=" language-none">Thread-2</code>за спробі викликати <code class=" language-none">myClass.swap()</code>повисне чекаючи, коли мьютекс звільниться. Якщо ж ми матимемо 2 потоки і 2 об'єкти <code class=" language-none">MyClass</code>— <code class=" language-none">myClass1</code>і <code class=" language-none">myClass2</code>— на різних об'єктах наші потоки спокійно зможуть одночасно виконувати синхронізовані методи. Перший потік виконує: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class="  language-java">myClass1<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">swap</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> Другий виконує: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class="  language-java">myClass2<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">swap</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> У цьому випадку ключове слово synchronized усередині методу <code class=" language-none">swap()</code>не вплине на роботу програми, оскільки синхронізація здійснюється за конкретним об'єктом. А в останньому випадку об'єктів у нас 2. Тому потоки не створюють один одного проблем. Адже два об'єкти мають 2 різні м'ютекси, і їх захоплення не залежить один від одного.
<h2>Особливості синхронізації у статичних методах</h2>А що робити, якщо необхідно синхронізувати статичний метод? 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">class</span></span> <span class="token class-name"><span class="token class-name">MyClass</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
   <span class="token keyword"><span class="token keyword">private</span></span> <span class="token keyword"><span class="token keyword">static</span></span> <span class="token class-name"><span class="token class-name">String</span></span> name1 <span class="token operator"><span class="token operator">=</span></span> <span class="token string"><span class="token string">"Оля"</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
   <span class="token keyword"><span class="token keyword">private</span></span> <span class="token keyword"><span class="token keyword">static</span></span> <span class="token class-name"><span class="token class-name">String</span></span> name2 <span class="token operator"><span class="token operator">=</span></span> <span class="token string"><span class="token string">"Ліна"</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>

   <span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">static</span></span> <span class="token keyword"><span class="token keyword">synchronized</span></span> <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">swap</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
       <span class="token class-name"><span class="token class-name">String</span></span> s <span class="token operator"><span class="token operator">=</span></span> name1<span class="token punctuation"><span class="token punctuation">;</span></span>
       name1 <span class="token operator"><span class="token operator">=</span></span> name2<span class="token punctuation"><span class="token punctuation">;</span></span>
       name2 <span class="token operator"><span class="token operator">=</span></span> s<span class="token punctuation"><span class="token punctuation">;</span></span>
   <span class="token punctuation"><span class="token punctuation">}</span></span>

<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> Незрозуміло, що виконуватиме роль м'ютексу в цьому випадку. Адже ми вже визначабося, що кожен об'єкт має м'ютекс. Але проблема в тому, що для виклику статичного методу <code class=" language-none">MyClass.swap()</code>нам не потрібні об'єкти: метод статичний! І що далі? :/ Насправді проблеми в цьому немає. Творці Java про все подбали :) Якщо метод, у якому міститься критично важлива «багатопотокова» логіка, статичний, синхронізація буде здійснюватися за класом. Для більшої ясності наведений вище код можна переписати так: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">class</span></span> <span class="token class-name"><span class="token class-name">MyClass</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
   <span class="token keyword"><span class="token keyword">private</span></span> <span class="token keyword"><span class="token keyword">static</span></span> <span class="token class-name"><span class="token class-name">String</span></span> name1 <span class="token operator"><span class="token operator">=</span></span> <span class="token string"><span class="token string">"Оля"</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
   <span class="token keyword"><span class="token keyword">private</span></span> <span class="token keyword"><span class="token keyword">static</span></span> <span class="token class-name"><span class="token class-name">String</span></span> name2 <span class="token operator"><span class="token operator">=</span></span> <span class="token string"><span class="token string">"Ліна"</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>

   <span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">static</span></span> <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">swap</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>

       <span class="token keyword"><span class="token keyword">synchronized</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">MyClass</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token keyword"><span class="token keyword">class</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
           <span class="token class-name"><span class="token class-name">String</span></span> s <span class="token operator"><span class="token operator">=</span></span> name1<span class="token punctuation"><span class="token punctuation">;</span></span>
           name1 <span class="token operator"><span class="token operator">=</span></span> name2<span class="token punctuation"><span class="token punctuation">;</span></span>
           name2 <span class="token operator"><span class="token operator">=</span></span> s<span class="token punctuation"><span class="token punctuation">;</span></span>
       <span class="token punctuation"><span class="token punctuation">}</span></span>
   <span class="token punctuation"><span class="token punctuation">}</span></span>

<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> У принципі, ти міг до цього додуматися самостійно: якщо об'єктів немає, значить механізм синхронізації має бути якось «зашитий» у самі класи. Так воно і є: за класами також можна синхронізуватися.