Оповідь про двох ітераторів: стратегії конкурентної модифікації в Java
<p>----------------------------------------</p>
Серед найбільш популярних питань на співбесідах з мови Java є й такий: Максимально спрощена відповідь: Хоча це звучить досить свідомо, залишається незрозумілим, що інтерв'юер розуміє під fail-safe? Специфікації мови Java не визначають цей т
<p>----------------------------------------</p>
<em>Автор нотатки — Гжегож Мірек — розробник програмного забезпечення із Кракова (Польща). Він зайнявся розробкою на Java близько 6 років тому, ще в університеті, і з цього часу невпинно шліфує свою майстерність у цій сфері. Його особливо цікавить питання продуктивності JVM та оптимізації, про що він, в основному, і пише у своєму <a href="http://performantcode.com/concurrency/a-tale-of-two-iterators/" target="_blank">блозі</a> .</em>
<div class="row justify-content-center jr-image-wrap">
 <div class="col-12 col-sm-10 col-md-8">
  <img data-id="964fc369-68d3-4507-9bb1-6f407882491f" data-max-width="600" alt="Сказ про двох ітераторів: стратегії конкурентної модифікації в Java - 1" src="https://cdn.javarush.com/images/article/964fc369-68d3-4507-9bb1-6f407882491f/512.jpeg" style="width: 600px;">
 </div>
</div>Серед найбільш популярних питань на співбесідах з мови Java є й такий: <em>У чому різниця між fail-fast та fail-safe ітераторами? </em> Максимально спрощена відповідь: <em>Fail-fast ітератор генерує виняток ConcurrentModificationException, якщо колекція змінюється під час ітерації, а fail-safe – ні. </em> Хоча це звучить досить свідомо, залишається незрозумілим, що інтерв'юер розуміє під fail-safe? Специфікації мови Java не визначають цей термін щодо ітераторів. Проте є чотири стратегії конкурентної модифікації. 
<h2>Конкурентна модифікація</h2>По-перше, давайте визначимося, що таке конкурентна (або паралельна) модифікація. Припустимо, у нас є колекція і при активному ітераторі відбуваються будь-які її зміни, що не виходять від даного ітератора. У такому разі ми отримуємо конкурентну модифікацію. Наведу найпростіший приклад: припустимо, ми маємо кілька ниток. Перша нитка виконує ітерації, а друга вставляє елементи у колекцію чи видаляє їх із неї. Однак ми можемо отримати виняток <strong>ConcurrentModificationException</strong> і під час роботи в однопотоковій середовищі: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> cities <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cities<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>“<span class="token class-name">Warsaw</span>”<span class="token punctuation">)</span><span class="token punctuation">;</span>
cities<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>“<span class="token class-name">Prague</span>”<span class="token punctuation">)</span><span class="token punctuation">;</span>
cities<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>“<span class="token class-name">Budapest</span>”<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> cityIterator <span class="token operator">=</span> cities<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cityIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cities<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cityIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// генерирует ConcurrentModificationException</span></code></pre>
<h2>Fail-fast</h2>Наведений вище фрагмент коду - приклад<strong> fail-fast</strong> ітератора. Як ви можете бачити, при спробі вилучення другого елемента з ітератора було згенеровано виняток <strong>ConcurrentModificationException</strong> . Звідки ітератор дізнається, що колекцію було модифіковано після його створення? Наприклад, у колекції може бути мітка дати/часу, скажімо, <strong>lastModified</strong> . При створенні ітератора вам слід скопіювати це поле та зберегти його в об'єкті ітератора. Потім, при кожному виклик методу <strong>next()</strong> , потрібно буде просто порівняти значення <strong>lastModified</strong> з колекції з копією з ітератора. Дуже близький підхід використовується, наприклад, для реалізації класу <strong>ArrayList</strong> . У ньому є змінна екземпляра<strong>modCount</strong> , в якій зберігається кількість модифікацій списку: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>
       <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre> Важливо відзначити, що <strong>fail-fast</strong> ітератори працюють на основі принципу "у міру можливості", тобто не дається жодних гарантій генерації виключення <strong>ConcurrentModificationException</strong> у разі конкурентної модифікації. Тож покладатися на це не варто – скоріше їх слід використовувати для виявлення помилок. Більшість неконкурентних колекцій пропонують <strong>fail-fast</strong> ітератори. 
<h2>Слабка узгодженість</h2>Більшість конкурентних колекцій з пакету <strong>java.util.concurrent</strong> (наприклад, <strong>ConcurrentHashMap</strong> і більшість <strong>Queue</strong> ) надають слабо узгоджені ітератори. Сенс цього терміна дуже добре пояснюється в <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html#Weakly" target="_blank">документації</a> : 
<ul>
 <li>Вони можуть оброблятися конкурентно з іншими операціями</li>
 <li>Вони ніколи не генерують виключення <strong>ConcurrentModificationException</strong></li>
 <li>Вони гарантовано обходять існували на момент створення ітератора елементи рівно один раз, і можуть (але не зобов'язані) відображати такі модифікації.</li>
</ul>
<h2>Знімок стану</h2>За такої стратегії ітератор пов'язується із станом колекції на момент його створення – це і є знімок стану (снепшот) колекції. Будь-які зроблені над вихідною колекцією зміни призводять до створення нової версії структури даних, що нижче лежить. При цьому наш знімок стану залишається незмінним, тому він не відображає зміни в колекції, які відбулися після створення ітератора. <strong>Це стара добра методика копіювання при записі (copy-on-write, COW)</strong> . Вона повністю вирішує проблему конкурентних модифікацій, тому виняток <strong>ConcurrentModificationException</strong>за такого підходу не генерується. З іншого боку, ітератори не підтримують операції, які змінюють елементи. Колекції з копіюванням при записі зазвичай вимагають надто великих витрат ресурсів при використанні, але є сенс скористатися ними, якщо зміни відбуваються набагато рідше, ніж обходи ітераторів. Прикладами можуть бути класи <strong>CopyOnWriteArrayList</strong> і <strong>CopyOnWriteArraySet</strong> . 
<h2>Невизначена поведінка</h2>Невизначена поведінка може зустрітися вам у застарілих успадкованих типах колекцій, таких як <strong>Vector</strong> та <strong>Hashtable</strong> . В обох є стандартні <strong>fail-fast</strong> ітератори, але крім цього вони дозволяють використовувати реалізації інтерфейсу <strong>Enumeration</strong> , а вони не знають, як поводитися у разі конкурентної модифікації. Ви можете зіткнутися з тим, що деякі елементи повторюються або виявляються пропущеними, а то й зовсім побачите якісь дивні винятки. Краще з ними не грати! 
<div class="table-container">
 <table>
  <tbody>
   <tr>
    <th>Що ще почитати?</th>
   </tr>
   <tr>
    <td>
     <p><a href="https://codegym.cc/groups/posts/392-kak-v-java-napechatatjh-chisla-ot-1-do-100-bez-ciklov-i-usloviy-" target="_blank">Як у Java надрукувати числа від 1 до 100 без циклів та умов?</a></p>
     <p><a href="https://codegym.cc/groups/posts/366-top-10-bibliotek-java-kotorihe-pomogut-sehkonomitjh-vremja-" target="_blank">Топ-10 бібліотек Java, які допоможуть заощадити час</a></p></td>
   </tr>
  </tbody>
 </table>
</div>