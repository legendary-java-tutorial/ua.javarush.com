Управління потоками. Ключове слово volatile та метод yield()
<p>----------------------------------------</p>
Вітання! Ми продовжуємо вивчення багатопоточності, і сьогодні познайомимося з новим ключовим словом – volatile та методом yield(). Давай розберемося, що це таке :) Під час створення багатопотокових програм ми можемо зіткнутися з двома серйо
<p>----------------------------------------</p>
Вітання! Ми продовжуємо вивчення багатопоточності, і сьогодні познайомимося з новим ключовим словом – volatile та методом yield(). Давай розберемося, що це таке :)
<h2>Ключове слово volatile</h2>Під час створення багатопотокових програм ми можемо зіткнутися з двома серйозними проблемами. <strong>По-перше, у процесі роботи багатопотокового додатку різні потоки можуть кешувати значення змінних</strong> (докладніше про це поговоримо <a href="https://codegym.cc/quests/lectures/questmultithreading.level06.lecture04" target="_blank">в лекції «Застосування volatile»</a> ). Можлива ситуація, коли один потік змінив значення змінної, а другий не побачив цієї зміни, тому що працював зі своєю кешованою копією змінної. Звичайно, наслідки можуть бути серйозними. Уяви, що це не просто якась «змінна», а, наприклад, баланс твоєї банківської картки, який раптом почав рандомно сякати сюди-туди :) Не дуже приємно, так? <strong>По-друге, Java операції читання і запису полів всіх типів, крім <code class=" language-none">long</code>і <code class=" language-none">double</code>, є атомарними.</strong> Що таке атомарність? Ну, наприклад, якщо ти в одному потоці змінюєш значення змінної <code class=" language-none">int</code>, а в іншому потоці читаєш значення цієї змінної, ти отримаєш або її старе значення, або нове - те, що вийшло після зміни в потоці 1. Ніяких «проміжних варіантів» там з'явитися не може. Однак і <code class=" language-none">long</code>це <code class=" language-none">double</code>не працює. Чому? Через кросплатформність. Пам'ятаєш, ми ще на перших рівнях говорабо, що принцип Java – «написано одного разу – працює скрізь»? Це і є кросплатформність. Тобто Java-додаток запускається на абсолютно різних платформах. Наприклад, на операційних системах Windows, різних варіантах Linux або MacOS, і скрізь ця програма стабільно працюватиме. <code class=" language-none">long</code>і<code class=" language-none">double</code>— «найважкіші» примітиви в Java: вони важать по 64 біти. І в деяких 32-бітових платформах просто не реалізовано атомарність читання та запису 64-бітних змінних. Такі змінні читаються та записуються у дві операції. Спочатку в змінну записуються перші 32 біти, потім ще 32. Відповідно, у цих випадках може виникнути проблема. Один потік записує якесь 64-бітове значення змінну<code class=" language-none">Х</code>, і робить він це «в два заходи». У той же час другий потік намагається прочитати значення цієї змінної, причому робить це якраз посередині, коли перші 32 біти вже записані, а другі ще немає. У результаті він читає проміжне, некоректне значення і виходить помилка. Наприклад, якщо на такій платформі ми спробуємо записати в змінну кількість - 9223372036854775809 - воно займатиме 64 біти. У двійковій формі воно буде виглядати так: 1000000000000000000000000000000000000000000000000000000000000001 Перший потік почне запис цього числа000000 000000000000000000 а потім другі 32: 000000000000000000000000000001 І в цей проміжок може вклинитися другий потік, і прочитати проміжне значення змінної - 10000000000000000 32 біти, які вже було записано. У десятковій системі це число дорівнює 2147483648. Тобто ми всього лише хотіли записати число 9223372036854775809 в змінну, але через те, що ця операція на деяких платформах є не атомарною, у нас з нізвідки виникло «ліве»8, непотрібне4 і невідомо, як воно вплине на роботу програми. Другий потік просто прочитав значення змінної до того, як воно остаточно записалося, тобто перші 32 біти він побачив, а другі 32 біти — ні. Ці проблеми, звичайно, виникли не вчора, і в Java вони вирішуються за допомогою всього одного ключового слова. у нас звідки виникло «ліве», непотрібне нам число 2147483648, і невідомо як воно вплине на роботу програми. Другий потік просто прочитав значення змінної до того, як воно остаточно записалося, тобто перші 32 біти він побачив, а другі 32 біти — ні. Ці проблеми, звичайно, виникли не вчора, і в Java вони вирішуються за допомогою всього одного ключового слова. у нас звідки виникло «ліве», непотрібне нам число 2147483648, і невідомо як воно вплине на роботу програми. Другий потік просто прочитав значення змінної до того, як воно остаточно записалося, тобто перші 32 біти він побачив, а другі 32 біти — ні. Ці проблеми, звичайно, виникли не вчора, і в Java вони вирішуються за допомогою всього одного ключового слова.<strong>volatile</strong> . Якщо ми оголошуємо у нашій програмі якусь змінну, зі словом volatile… 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">class</span></span> <span class="token class-name"><span class="token class-name">Main</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>

   <span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">volatile</span></span> <span class="token keyword"><span class="token keyword">long</span></span> x <span class="token operator"><span class="token operator">=</span></span> <span class="token number"><span class="token number">2222222222222222222L</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>

   <span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">static</span></span> <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">main</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">String</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> args<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>

   <span class="token punctuation"><span class="token punctuation">}</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> …це означає, що: 
<ol>
 <li>Вона завжди буде атомарно читатись і записуватись. Навіть якщо це 64-біт <code class=" language-none">double</code>або <code class=" language-none">long</code>.</li>
 <li>Java-машина не поміщатиме її в кеш. Тому ситуація, коли 10 потоків працюють зі своїми локальними копіями виключена.</li>
</ol>Ось так дві дуже серйозні проблеми вирішуються одним словом:) 
<h2>Метод yield()</h2>Ми розглянули вже багато методів класу <code class=" language-none">Thread</code>, але є один важливий, який буде тобі новим. Це <strong>метод yield()</strong> . З англійської перекладається як «поступатися». І це те, що метод робить! <img data-id="a32c882a-5fe9-4219-a1df-1488ed9954b1" data-max-width="850" alt="Управління потоками.  Ключове слово volatile та метод yield() - 2" src="https://cdn.javarush.com/images/article/a32c882a-5fe9-4219-a1df-1488ed9954b1/800.jpeg" style="width: 850px;">Коли ми викликаємо метод yield біля потоку, він фактично говорить іншим потокам: «Так, хлопці, я нікуди особливо не поспішаю, тому якщо комусь із вас важливо отримати час процесора — беріть, мені не терміново». Ось простий приклад того, як це працює: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">class</span></span> <span class="token class-name"><span class="token class-name">ThreadExample</span></span> <span class="token keyword"><span class="token keyword">extends</span></span> <span class="token class-name"><span class="token class-name">Thread</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>

   <span class="token keyword"><span class="token keyword">public</span></span> <span class="token class-name"><span class="token class-name">ThreadExample</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
       <span class="token keyword"><span class="token keyword">this</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">start</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
   <span class="token punctuation"><span class="token punctuation">}</span></span>

   <span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">run</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>

       <span class="token class-name"><span class="token class-name">System</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">Thread</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">currentThread</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">getName</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token operator"><span class="token operator">+</span></span> <span class="token string"><span class="token string">"поступається своїм місцем іншим"</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
       <span class="token class-name"><span class="token class-name">Thread</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token keyword"><span class="token keyword">yield</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
       <span class="token class-name"><span class="token class-name">System</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">Thread</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">currentThread</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">getName</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token operator"><span class="token operator">+</span></span> <span class="token string"><span class="token string">" has finished executing."</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
   <span class="token punctuation"><span class="token punctuation">}</span></span>

   <span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">static</span></span> <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">main</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">String</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> args<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
       <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">ThreadExample</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
       <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">ThreadExample</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
       <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">ThreadExample</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
   <span class="token punctuation"><span class="token punctuation">}</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> Ми послідовно створюємо та запускаємо три потоки — <code class=" language-none">Thread-0</code>, <code class=" language-none">Thread-1</code>і <code class=" language-none">Thread-2</code>. <code class=" language-none">Thread-0</code>запускається першим і відразу поступається місцем іншим. Після нього запускається <code class=" language-none">Thread-1</code>, і теж поступається. Після — запускається <code class=" language-none">Thread-2</code>, який теж поступається. Більше потоків у нас немає, і після того, як <code class=" language-none">Thread-2</code>останнім поступився своїм місцем, планувальник потоків дивиться: «Так, нових потоків більше немає, хто там у черзі? Хто поступався своїм місцем останнім, перед <code class=" language-none">Thread-2</code>? Здається, це був <code class=" language-none">Thread-1</code>? Окей, отже, нехай він і виконується». <code class=" language-none">Thread-1</code>виконує свою роботу до кінця, після чого планувальник потоків продовжує координацію: Окей, Thread-1 виконався. Чи є у нас хтось ще в черзі?». У черзі є Thread-0: він поступався своїм місцем відразу до Thread-1. Тепер дійшло до нього, і він виконується до кінця. Після чого планувальник закінчує координацію потоків: «Гаразд, Thread-2, ти поступився місцем іншим потокам, вони всі вже відпрацювали. Ти поступався місцем останнім, так що тепер твоя черга». Після цього відпрацьовує остаточно потік Thread-2. Висновок у консоль буде виглядати так: <em>Thread-0 поступається своїм місцем іншим Thread-1 поступається своїм місцем іншим Thread-2 поступається своїм місцем іншим Thread-1 закінчив виконання. Thread-0 закінчив виконання. Thread-2 закінчив виконання.</em> p align="justify"&gt; Планувальник потоків, звичайно, може запустити потоки в іншому порядку (наприклад, 2-1-0 замість 0-1-2), але сам принцип незмінний. 
<h2>Правила "happens-before"</h2>Останнє, чого ми торкнемося сьогодні, це принципи " <strong>happens before</strong> ". Як ти вже знаєш, у Java основну частину роботи з виділення часу та ресурсів потоків для виконання їхніх завдань виконує планувальник потоків. Також ти не раз бачив, як потоки виконуються у довільному порядку, і найчастіше передбачити його неможливо. Та й взагалі, після «послідовного» програмування, яким ми займалися до цього, багатопотоковість виглядає рандомною штукою. Як ти вже переконався, хід багатопоточної програми можна контролювати за допомогою цілого набору методів. Але на додачу до багатопоточності Java існує ще один «острівець стабільності» — 4 правила під назвою « <strong>happens-before</strong>». Дослівно з англійської це перекладається як «відбувається перед», або «відбувається раніше, ніж». Зрозуміти зміст цих правил досить просто. Уяви, що ми маємо два потоки — <code class=" language-none">A</code>і <code class=" language-none">B</code>. Кожен із цих потоків може виконувати операції <code class=" language-none">1</code>та <code class=" language-none">2</code>. І коли в кожному з правил ми говоримо " <em>A happens-before B</em> ", це означає, що всі зміни, виконані потоком <code class=" language-none">A</code>до моменту операції <code class=" language-none">1</code>та зміни, які спричинила ця операція, видно потоку <code class=" language-none">B</code>в момент виконання операції <code class=" language-none">2</code>та після виконання цієї операції. Кожне з цих правил дає гарантію, що при написанні багатопотокової програми одні події у 100% випадків відбуватимуться раніше, ніж інші, і що потік <code class=" language-none">B</code>у момент виконання операції<code class=" language-none">2</code>завжди буде в курсі змін, які потік <code class=" language-none">А</code>зробив під час операції <code class=" language-none">1</code>. Давай розглянемо їх. 
<h3>Правило 1.</h3>Звільнення м'ютексу <em>happens before</em> відбувається раніше захоплення цього ж монітора іншим потоком. Ну, тут начебто все зрозуміло. Якщо м'ютекс об'єкта чи класу захоплений одним потоком, наприклад, потоком <code class=" language-none">А</code>, інший потік (потік <code class=" language-none">B</code>) неспроможна у цей час його захопити. Потрібно почекати, доки м'ютекс не звільниться. 
<h3>Правило 2</h3>Метод <code class=" language-none">Thread.start()</code> <em>happens before</em> <code class=" language-none">Thread.run()</code> . Теж нічого складного. Ти вже знаєш: щоб почав виконуватися код усередині методу <code class=" language-none">run()</code>, необхідно викликати у потоку метод <code class=" language-none">start()</code>. Саме його, а не сам метод <code class=" language-none">run()</code>! Це правило гарантує, що встановлені до запуску <code class=" language-none">Thread.start()</code>значення всіх змінних будуть видні всередині методу, що почав виконання <code class=" language-none">run()</code>. 
<h3>Правило 3</h3>Завершення методу <code class=" language-none">run()</code> <em>happens before</em> вихід із методу <code class=" language-none">join()</code>. Повернемося до наших двох потоків - <code class=" language-none">А</code>і <code class=" language-none">B</code>. Ми викликаємо метод <code class=" language-none">join()</code>таким чином, щоб потік <code class=" language-none">B</code>обов'язково дочекався завершення <code class=" language-none">A</code>, перш ніж виконувати свою роботу. Це означає, що метод <code class=" language-none">run()</code>об'єкта A обов'язково відпрацює до кінця. І всі зміни в даних, які відбудуться в методі <code class=" language-none">run()</code>потоку, <code class=" language-none">A</code>стовідсотково будуть видні в потоці <code class=" language-none">B</code>, коли він дочекається завершення <code class=" language-none">A</code>і почне роботу сам. 
<h3>Правило 4</h3>Запис у volatile мінливу <em>happens-before</em> читання з тієї ж змінної. При використанні ключового слова volatile ми фактично завжди будемо отримувати актуальне значення. Навіть у випадку з <code class=" language-none">long</code>і <code class=" language-none">double</code>, про проблеми з якими йшлося раніше. Як ти вже зрозумів, зміни, зроблені в одних потоках, далеко не завжди видно іншим потокам. Але, звичайно, дуже часто трапляються ситуації, коли подібна поведінка програми нас не влаштовує. Припустимо, в потоці <code class=" language-none">A</code>ми надали значення змінної: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">int</span></span> z<span class="token punctuation"><span class="token punctuation">;</span></span>

…<span class="token punctuation"><span class="token punctuation">.</span></span>

z<span class="token operator"><span class="token operator">=</span></span> <span class="token number"><span class="token number">555</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> Якщо наш потік <code class=" language-none">B</code>повинен вивести значення змінної <code class=" language-none">z</code>на консоль, він може вивести 0, тому що не знає про присвоєне їй значення. Так ось, Правило 4 гарантує нам: якщо оголосити змінну <code class=" language-none">z</code>як volatile, зміни її значень в одному потоці завжди буде видно в іншому потоці. Якщо ми додамо до попереднього коду слово volatile... 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">volatile</span></span> <span class="token keyword"><span class="token keyword">int</span></span> z<span class="token punctuation"><span class="token punctuation">;</span></span>

…<span class="token punctuation"><span class="token punctuation">.</span></span>

z<span class="token operator"><span class="token operator">=</span></span> <span class="token number"><span class="token number">555</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> ...ситуація, коли потік <code class=" language-none">B</code>виведе в консоль 0, виключена. Запис у volatile-змінні відбувається раніше, ніж читання з них.