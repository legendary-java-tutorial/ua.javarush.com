Кава-брейк #65. 5 корисних порад щодо підтримки чужого коду. Java Collection та відповіді на найпоширеніші питання на співбесідах
<p>----------------------------------------</p>
Джерело: З вашої команди хтось йде? Вам передають застарілий код? Ви змінюєте місце роботи? Це лише деякі причини, через які розробники можуть зіткнутися із завданням підтримки чужого коду.Робота з кодом, який писав хтось інший, може призве
<p>----------------------------------------</p>
<h2>5 корисних порад щодо підтримки чужого коду</h2>Джерело: <a href="https://dev.to/funbeedev/5-effective-tips-for-maintaining-code-written-by-someone-else-821" rel="nofollow" target="_blank">Dev.to</a> З вашої команди хтось йде? Вам передають застарілий код? Ви змінюєте місце роботи? Це лише деякі причини, через які розробники можуть зіткнутися із завданням підтримки чужого коду.<img data-max-width="800" data-id="b01904d2-31a4-4398-86d6-bf2e98f31595" alt="Кава-брейк #65.  5 корисних порад щодо підтримки чужого коду.  Java Collection та відповіді на найпоширеніші питання на співбесідах - 1" src="https://cdn.javarush.com/images/article/b01904d2-31a4-4398-86d6-bf2e98f31595/800.jpeg" style="width: 800px;">Робота з кодом, який писав хтось інший, може призвести до деяких проблем. Код може відноситися до незнайомої вам технології. Можливо, цей код потребує доопрацювання. Або може виникнути потреба терміново виправити баг, виявлений у старій кодовій базі. Щоб краще справлятися з такими завданнями, важливо знати про можливі проблеми та мати систематичний спосіб їх вирішення. Якщо ви професійний розробник, ви вже напевно стикалися з подібними ситуаціями. Але якщо ні – повірте мені, це лише питання часу! У цій статті ми розглянемо кілька порад, які можуть полегшити роботу з legacy-кодом.
<h3>1. Проведіть сеанс передачі коду з автором</h3>Якщо у вас ще є контакт із людиною, яка написала цей код, проведіть з ним сеанс передачі. Або два! А може, навіть і три. Використовуйте ці сеанси передачі як спосіб прискорити ознайомлення з кодовою базою. Інакше вам доведеться розумітися на всьому самостійно, а це займе більше часу. Розробник, який створив цей код, може розповісти вам про його логіку, а також вказати на приховані секрети. Перед сеансом передачі обов'язково самі перегляньте код і запишіть питання, які у вас виникли. Так, під час спільного перегляду коду з його автором ви не забудете прояснити всі потрібні деталі. Зрозуміло, що під час спільних сеансів ведіть записи. Передача коду з його автором - ймовірно, найшвидший спосіб познайомитися з новою для вас кодовою базою. Тому, якщо у вас ще є можливість звернутися до цього розробника, Обов'язково нею скористайтеся. Якщо ваш колега збирається залишити компанію, подбайте про те, щоб передача коду пройшла до його відходу. Бувають і інші ситуації, коли корисно пройтися кодовою базою разом з кимось, хто її добре знає. Наприклад, якщо ви змінабо команду, потрібно, щоб хтось із нових колег розповів вам про структуру коду. Це прискорить ваше знайомство з новим кодом.
<h3>2. Прочитайте всю доступну документацію</h3>Документація — це всі доступні документи щодо проекту, для якого було написано код. Специфікації проекту? Специфікація програми? Файли README? Прочитайте це все. Час, витрачений на читання цих документів, ви заощадите у майбутньому. Замість витрачати величезну кількість часу на спроби з'ясувати, чому код був реалізований саме так, просто прочитайте README. Замість того, щоб намагатися самостійно зрозуміти призначення розділів коду, все це можна дізнатися у специфікаціях програмного забезпечення. Читати документацію важливо, навіть якщо ви провели сеанс передачі коду з його автором. Усі ці документи написані не так. А сеанси передачі навряд чи можуть охопити все. Читання документації є особливо важливим для застарілого програмного забезпечення. Йдеться про випадки, коли у вас немає шансу зустрітись з автором коду. Оскільки сеанс передачі неможливий, все, що у вас є, це вихідний код і будь-яка доступна документація. Остання порада з цього приводу: пам'ятайте, що файли README не дарма називаються README (прочитай мене).
<h3>3. Запустіть програму та попрацюйте з нею</h3>Цю пораду треба розуміти буквально. Запустіть код і спробуйте використати програму так, як задумано. Тож ви зможете краще зрозуміти, що воно робить. Це може здатися очевидним, але практика показує, що багато хто ігнорує цей етап. Багато розробників роблять помилку, складаючи уявлення про програму лише за її кодом. Обов'язково запустіть програму та оцініть її як звичайний користувач. Так ви отримаєте загальне розуміння того, що насправді робить додаток, а також уявлення про його функції та обмеження. В результаті вам буде простіше розібратися у коді. Це також стосується і софту, написаного для певного обладнання або платформ. Отримайте доступ до всього необхідного та запустіть програму на цих платформах. Якщо ви намагаєтеся виправити помилку, запуск коду стане для вас логічним першим кроком у процесі налагодження.
<h3>4. Тестуйте, тестуйте, тестуйте!</h3>Якщо ви маєте справу з незнайомою кодовою базою, перш ніж вносити будь-які зміни, перевірте наявність тестів для перевірки працездатності програми. Тести допоможуть підтвердити, що після внесення змін нічого не зламалося. Безпечно внести зміни буває набагато складніше, ніж просто ознайомитися з чужим кодом. І якщо припустити, що вам передали код лише для виправлення багів та внесення покращень, то наявність тестів має вирішальне значення. Якщо тестів немає, спробуйте їх написати самостійно. Це можуть бути модульні випробування, димові, ручні або автоматизовані. Будь-яке тестування зазвичай краще, ніж його відсутність.
<h3>5. Прийміть виклик</h3>Взявшись за підтримку чужого коду, спробуйте прийняти це як особистий виклик. По-перше, ви вдосконалите навички читання та інтерпретації чужого коду. Це дозволить вам краще вловлювати ідеї інших розробників. Завдяки практиці ви зможете легше справлятися із завданнями підтримки програм. По-друге, підтримуючи чужий код, ви зможете запозичити корисні методи та прийоми, які покращать ваш власний код. Читання незнайомого коду вважатимуться методом непрямого навчання. Тільки будьте обережні - вибирайте лише ті методи, які вважаються передовими, і уникайте не дуже добрих. Усвідомлення того, що зрештою ви отримаєте вигоду від цього досвіду, має вас мотивувати. Тож не бійтеся і приймайте кинутий вам виклик!
<h3>Висновок</h3>Підтримка коду, написаного кимось іншим, безумовно, пов'язана з багатьма проблемами. Але це лише одна сторона роботи розробника, з якою нам усім коли-небудь доведеться зіткнутися. І ви зможете куди краще підготуватися до роботи з чужим кодом, якщо не тільки слідуватимете порадам з цієї статті, але й розробите власні систематичні методи при роботі з незнайомою кодовою базою.
<h2>Java Collection та відповіді на найпоширеніші питання на співбесідах</h2>Джерело: <a href="https://dzone.com/articles/top-java-collection-interview-questions-for-2021" rel="nofollow" target="_blank">DZone</a> Щоб закріпити ваші знання в Java, давайте пригадаємо Java Collection і відповімо на деякі питання, які ставлять новачкам на технічних співбесідах.
<h3>Collections в Java</h3>Java Collection – це структура, яка підтримує архітектуру зберігання та керування групами об'єктів. Структура колекцій із класами та інтерфейсами визначена в JDK 1.2. Двома основними інтерфейсами класів Java Collection є інтерфейс Collection (java.util.Collection) та інтерфейс Map (java.util.Map). Колекції Java можуть виконувати операції з даними, такі як пошук, сортування, вставка, маніпулювання тощо. Java Collection Framework надає такі інтерфейси, як Set, List, Queue, Deque, та класи, такі як ArrayList, Vector, LinkedList, HashSet, PriorityQueue, TreeSet та LinkedHashSet.
<h4>Необхідність в окремій структурі колекцій</h4>Якщо ми не використовуємо структуру колекцій, стандартними методами групування об'єктів Java є масиви, вектори або хеш-таблиці. Усі вони мають спільного інтерфейсу. Усі реалізації визначаються незалежно, і з-поміж них немає кореляції. Таким чином, дуже важко запам'ятати всі різні методи, синтаксис і конструктори, присутні в різних класах. Наприклад, щоб додати елемент у вектор, ми використовуємо функцію <span class="code">addElement()</span> , тоді як додавання елемента до Hashtable ми використовуємо функцію <span class="code">put()</span> . <span class="text-bold">Переваги системи колекцій:</span>
<ul>
 <li>Знижує навантаження в процесі програмування: розробник може зосередитися більше на найкращому використанні колекції, а не на дизайні колекції. Це допомагає у реалізації абстракції.</li>
 <li>Покращує швидкість виконання програми: колекції забезпечують високопродуктивну реалізацію структур даних, що підвищує продуктивність.</li>
</ul><span class="text-bold">Оскільки Java є широко використовуваною мовою програмування, безліч компаній створюють свої продукти саме цією мовою. Тому давайте пройдемося за відповідями на питання базового рівня Java, які допоможуть вам успішно пройти співбесіду.</span>
<h3>Деякі питання, що часто ставляться на співбесіді для новачків</h3>
<h4>Питання 1. Що таке фреймворк Java?</h4><span class="text-bold">Відповідь:</span> Фреймворк (структура) – це набір класів та інтерфейсів, що підтримують готову архітектуру. Оптимальний об'єктно-орієнтований дизайн завжди включає фреймворк з набором класів, тому всі класи виконують однакові завдання.
<h4>Запитання 2. Що таке фреймворк колекцій у Java?</h4><span class="text-bold">Відповідь:</span> Java Collections Framework – це набір інтерфейсів та класів, які допомагають ефективно зберігати та обробляти дані. Java Collection Framework має такі інтерфейси, як Set, List, Queue, Deque, та класи, такі як ArrayList, Vector, LinkedList, HashSet, PriorityQueue, TreeSet та LinkedHashSet.
<h4>Питання 3: Які відмінності між ArrayList і Vector Java Collection Framework?</h4><span class="text-bold">Відповідь:</span> ArrayList:
<ul>
 <li>Чи не синхронізується.</li>
 <li>Може збільшити розмір на 50% від розміру масиву.</li>
 <li>Чи не потокобезпечний (thread-safe).</li>
 <li>Чи не є успадкованим класом (legacy class).</li>
</ul>Vector:
<ul>
 <li>Синхронізується.</li>
 <li>Може вдвічі збільшити розмір.</li>
 <li>Потокобезпечний.</li>
 <li>Успадкований клас.</li>
</ul>
<h4>Питання 4. У чому відмінність між Iterator і Enumeration?</h4><span class="text-bold">Відповідь:</span> Iterator:
<ul>
 <li>Може працювати як із застарілими, так і з незастарілими елементами.</li>
 <li>Він повільніший, ніж Enumeration.</li>
 <li>Він може виконувати операції remove при обході колекції.</li>
 <li>Він безвідмовний.</li>
</ul>Enumeration (Перелічуваний тип):
<ul>
 <li>Може переміщатися лише за застарілими елементами.</li>
 <li>Він швидший, ніж ітератор.</li>
 <li>Він може виконувати з колекцією тільки операції traverse.</li>
 <li>Він не безвідмовний.</li>
</ul>
<h4>Питання 5. У чому різниця між LinkedList та ArrayList?</h4><span class="text-bold">Відповідь:</span> ArrayList:
<ul>
 <li>Цей клас продає інтерфейс списку.</li>
 <li>Цей клас використовує динамічний масив для зберігання елементів.</li>
 <li>Операції вставки та видалення дорівнюють O (1) у кращому випадку та O (n) у гіршому випадку. Операція пошуку (тобто доступ до елемента за певним індексом) займає час O(1).</li>
 <li>ArrayList краще працює при зберіганні даних та доступі до них.</li>
</ul>LinkedList:
<ul>
 <li>Цей клас реалізує як інтерфейс списку, і інтерфейс двосторонньої черги.</li>
 <li>Цей клас використовує двозв'язковий список для зберігання елементів.</li>
 <li>Операції вставки та видалення дають продуктивність O(1). Операція пошуку (тобто доступ до елемента за певним індексом) займає O(n) часу.</li>
 <li>LinkedList краще працює при маніпулюванні збереженими даними.</li>
</ul>
<h4>Питання 6. Поясніть різницю між poll() та remove() у методі інтерфейсу черги (Queue).</h4><span class="text-bold">Відповідь:</span> Обидва методи повертають та видаляють заголовок черги. Вони відрізняються своєю поведінкою лише тоді, коли черга порожня; <span class="code">remove()</span> видає виняток, тоді як <span class="code">poll()</span> повертає null для порожньої черги.
<h4>Питання 7. У чому різниця між Comparable і Comparator.</h4><span class="text-bold">Відповідь:</span> Comparable:
<ul>
 <li>Надає метод <span class="code">compareTo()</span> для сортування елементів.</li>
 <li>Є в пакеті java.lang.</li>
 <li>Логіка сортування має бути у тому класі, чий об'єкт ми хочемо відсортувати.</li>
 <li>Він забезпечує єдину послідовність сортування.</li>
 <li>Фактичний клас змінено.</li>
</ul>Comparator:
<ul>
 <li>Надає метод <span class="code">compare()</span> для сортування елементів.</li>
 <li>Є у пакеті java.util.</li>
 <li>Логіка сортування має бути у іншому класі, щоб писати різні сортування з урахуванням різних атрибутів об'єктів.</li>
 <li>Він забезпечує кілька послідовностей сортування.</li>
 <li>Фактичний клас не змінюється.</li>
</ul>
<h4>Питання 8. Що таке стек з погляду комп'ютерної пам'яті?</h4><span class="text-bold">Відповідь:</span> Стек — це особлива область пам'яті комп'ютера, де зберігаються тимчасові змінні, створені функцією. У стеку змінні оголошуються, зберігаються та ініціалізуються під час виконання.
<h4>Запитання 9. Складіть список із уявлень колекції в інтерфейсі Map.</h4><span class="text-bold">Відповідь:</span> Методи представлення колекції дозволяють переглядати map як колекцію трьома способами:
<ul>
 <li>Key-set view: Набір ключів, що містяться в Map.</li>
 <li>Value-set view: Колекція значень, що містяться в Map. Ця колекція не є набором, тому що кілька ключів можуть відображатися в тому самому значенні.</li>
 <li>Entry-set view: набір пар "ключ-значення", що містяться в Map. Інтерфейс Map надає невеликий вкладений інтерфейс під назвою Map.Entry тип елементів у цьому наборі.</li>
</ul>
<h4>Запитання 10. Дайте визначення EnumSet.</h4><span class="text-bold">Відповідь:</span> Це реалізація набору (Set), яку можна використовувати з типами, що перераховуються. Всі елементи повинні відбуватися з одного типу, що перераховується, зазначеного явно або неявно. Чи не синхронізується. Ключі NULL не допускаються.
<h4>Питання 11. Які методи роблять збирання потокобезпечним?</h4><span class="text-bold">Відповідь:</span> Методи:
<ul>
 <li>Collections.synchronizedList (list);</li>
 <li>Collections.synchronizedMap (map);</li>
 <li>Collections.synchronizedSet (set).</li>
</ul>
<h4>Питання 12. У чому різниця між Queue і Deque?</h4><span class="text-bold">Відповідь:</span> Queue:
<ul>
 <li>Також відома як одностороння черга.</li>
 <li>Елементи у черзі (Queue) додаються або видаляються з одного кінця.</li>
 <li>Менш універсальна.</li>
</ul>Deque:
<ul>
 <li>Також відома як двостороння черга.</li>
 <li>Елементи в черзі додаються з будь-якого кінця і можуть додаватися та видалятися з обох кінців.</li>
 <li>Більш універсальна.</li>
</ul>
<h4>Питання 13. У чому різниця між hashmap і hashtable?</h4><span class="text-bold">Відповідь:</span> Hashmap:
<ul>
 <li>Несинхронізована, не потокобезпечна.</li>
 <li>Успадковує клас <span class="code">AbstractMap</span> .</li>
 <li>Допускає один ключ null і кілька значень null.</li>
 <li>Обходить iterator.</li>
</ul>Hashtable:
<ul>
 <li>Синхронізований, потокобезпечний.</li>
 <li>Успадковує клас <span class="code">Dictionary</span> .</li>
 <li>Не дозволяється використовувати ключ null або значення null.</li>
 <li>Проходить enumerator та iterator.</li>
</ul>
<h4>Запитання 14. Що таке iterator?</h4><span class="text-bold">Відповідь:</span> Iterator() — це інтерфейс, який дає методи для перебору Collection. Він надає загальний спосіб обходу з використанням елементів колекції та реалізації шаблону проектування ітератора.
<h4>Запитання 15. Що таке Navigable Map?</h4><span class="text-bold">Відповідь:</span> Інтерфейс NavigableMap входить до Java Collection Framework та належить пакету java.util. Це підінтерфейс SortedMap, який надає зручні методи навігації, такі як lowerKey, floorKey, ceilingKey, and higherKey. Він також допомагає створити ще один Map із існуючого Map.
<h4>Запитання 16. Що таке peek() в інтерфейсі queue?</h4><span class="text-bold">Відповідь:</span> <span class="text-bold"> Peek()</span> повертає початок Queue. Він не видаляє жодних елементів. Він повертає null, коли черга порожня.