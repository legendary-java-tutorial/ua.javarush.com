Кава-брейк #177. Детальний посібник з Java Stream в Java 8
<p>----------------------------------------</p>
Джерело: Потоки Java (Streams), що представлені як частина Java 8, використовуються для роботи з колекціями даних. Самі собою вони не є структурою даних, але можуть використовуватися для введення інформації з інших структур даних шляхом упо
<p>----------------------------------------</p>
Джерело:<a href="https://hackernoon.com/an-in-depth-guide-on-java-streams-in-java-8" rel="nofollow" target="_blank"> Hackernoon</a> <em> У цій публікації викладено докладний посібник з роботи з Java Stream разом із прикладами коду та поясненнями.</em> <img data-max-width="800" data-id="f5e7af6e-aab4-4aa1-a255-9789c1a20b39" alt="Кава-брейк #177.  Детальний посібник з Java Stream в Java 8 - 1" src="https://cdn.javarush.com/images/article/f5e7af6e-aab4-4aa1-a255-9789c1a20b39/800.jpeg" style="width: 800px;">
<h2>Введення в потоки Java в Java 8</h2>Потоки Java (Streams), що представлені як частина Java 8, використовуються для роботи з колекціями даних. Самі собою вони не є структурою даних, але можуть використовуватися для введення інформації з інших структур даних шляхом упорядкування та конвеєрної обробки для отримання остаточного результату. <em>Примітка: Важливо не плутати Stream та Thread, оскільки в російській мові обидва терміни часто згадуються в однаковому перекладі “потік”. Stream позначає об'єкт виконання операцій (найчастіше передача даних чи його накопичення), тоді як Thread (дослівний переклад — нитка) позначає об'єкт, який дозволяє виконати певний програмний код паралельно коїться з іншими гілками коду.</em> Оскільки Stream — це окрема структура даних, вона будь-коли змінює джерело даних. Потоки Java мають такі особливості:
<ol>
 <li>
  <p>Java Stream можна використовувати за допомогою пакета java.util.stream. Його можна імпортувати в скрипт за допомогою коду:</p>
  <pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>stream<span class="token punctuation">.</span></span><span class="token operator">*</span> <span class="token punctuation">;</span></code></pre>
  <p>Використовуючи цей код, ми також можемо легко реалізувати кілька вбудованих функцій Java Stream.</p></li>
 <li>
  <p>Java Stream може приймати вхідні дані з колекцій даних, таких як колекції та масиви Java.</p></li>
 <li>
  <p>Java Stream не потребує зміни структури вхідних даних.</p></li>
 <li>
  <p>Java Stream не змінює джерело. Натомість він генерує вихідні дані за допомогою відповідних конвеєрних методів.</p></li>
 <li>
  <p>Java Stream піддаються проміжним та термінальним операціям, які ми обговоримо у наступних розділах.</p></li>
 <li>
  <p>У Java Stream проміжні операції конвеєризовані та відбуваються у форматі відкладених чи “лінивих” обчислень (lazy evaluation). Вони завершуються термінальними функціями. Це формує базовий формат використання Java Stream.</p></li>
</ol>У наступному розділі ми розглянемо різні способи, що використовуються Java 8 для створення Java Stream в міру необхідності. 
<h2>Створення Java Stream у Java 8</h2>Потоки Java можна створювати кількома способами: 
<h3>1. Створення порожнього потоку з допомогою методу Stream.empty()</h3>Можна створити порожній потік для використання на пізніших етапах коду. Якщо використовувати метод <span class="code">Stream.empty()</span> , то буде згенеровано порожній потік, який не містить значень. Цей порожній потік може стати в нагоді, якщо ми хочемо пропустити виключення нульового покажчика під час виконання. Для цього можна використати таку команду: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> str <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Наведений вище оператор згенерує порожній потік з ім'ям <span class="code">str</span> без будь-яких елементів усередині нього. Щоб переконатися в цьому, достатньо перевірити кількість або розмір потоку за допомогою терміна <span class="code">str.count()</span> . Наприклад, 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> В результаті отримаємо на виведенні <span class="code">0</span> . 
<h3>2. Створення потоку за допомогою методу Stream.builder() з екземпляром Stream.Builder</h3>Ми також можемо використовувати <span class="code">Stream Builder</span> для створення потоку за допомогою шаблону проектування Builder. Він призначений для покрокової побудови об'єктів. Погляньмо, як ми можемо створити екземпляр потоку за допомогою <span class="code">Stream Builder</span> . 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token class-name">Stream<span class="token punctuation">.</span>Builder</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> numBuilder <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

numBuilder<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> numStream <span class="token operator">=</span> numBuilder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Використовуючи цей код, можна створити потік з ім'ям <span class="code">numStream</span> , що містить елементи <span class="code">int</span> . Все виконується досить швидко завдяки екземпляру <span class="code">Stream.Builder</span> під ім'ям <span class="code">numBuilder</span> , який створюється першим. 
<h3>3. Створення потоку із зазначеними значеннями за допомогою методу Stream.of()</h3>Ще один спосіб створення потоку передбачає використання методу <span class="code">Stream.of()</span> . Це простий спосіб створення потоку із заданими значеннями. Він оголошує, і навіть ініціалізує потік. Приклад використання методу <span class="code">Stream.of()</span> для створення потоку: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> numStream <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Цей код створить потік, що містить елементи <span class="code">int</span> як ми вже зробабо в попередньому методі з використанням <span class="code">Stream.Builder</span> . Тут ми безпосередньо створабо потік, використовуючи <span class="code">Stream.of()</span> із заздалегідь заданими значеннями <span class="code">[1, 2 та 3]</span> . 
<h3>4. Створення потоку з існуючого масиву за допомогою методу Arrays.stream()</h3>Інший поширений метод створення потоку передбачає використання масивів Java. Потік створюється з існуючого масиву за допомогою методу <span class="code">Arrays.stream()</span> . Усі елементи масиву перетворюються на елементи потоку. Ось наочний приклад: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class=" language-java"><span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> numStream <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Цей код буде генерувати потік <span class="code">numStream</span> , що містить вміст масиву з ім'ям arr, який являє собою цілий масив (integer array). 
<h3>5. Об'єднання двох існуючих потоків за допомогою методу Stream.concat()</h3>Ще один метод, який можна використовувати для створення потоку, це метод <span class="code">Stream.concat()</span> . Він використовується для поєднання двох потоків з метою створення єдиного потоку. Обидва потоки поєднуються по порядку. Це означає, що першим йде перший потік, за яким слідує другий потік, і так далі. Приклад такої конкатенації має такий вигляд: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> numStream1 <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> numStream2 <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> combinedStream <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span> numStream1<span class="token punctuation">,</span> numStream2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Наведений вище оператор створить остаточний потік з ім'ям <span class="code">combinedStream</span> , що містить один за одним елементи першого потоку <span class="code">numStream1</span> та другого потоку <span class="code">numStream2</span> . 
<h2>Типи операцій із Java Stream</h2>Як згадувалося, з Java Stream в Java 8 можна виконувати два типи операцій: проміжні (intermediate) і термінальні (terminal). Розглянемо кожну їх докладніше. 
<h3>Проміжні операції</h3>Проміжні операції генерують вихідний потік (output stream) та виконуються тільки при зустрічі з термінальною операцією. Це означає, що проміжні операції виконуються "ліниво", конвеєрно і можуть бути завершені лише термінальною операцією. Про ліниве обчислення та конвеєрну обробку ви дізнаєтеся трохи пізніше. Прикладами проміжних операцій є такі методи: <span class="code">filter()</span> , <span class="code">map()</span> , <span class="code">different()</span> , <span class="code">peek()</span> , <span class="code">sorted()</span> та деякі інші. 
<h3>Термінальні операції</h3>Термінальні операції завершують виконання проміжних операцій, і навіть повертають остаточні результати вихідного потоку. Оскільки термінальні операції сигналізують про завершення лінивого виконання та конвеєрної обробки, цей потік не можна використовувати знову після того, як він зазнав термінальної операції. Прикладами термінальних операцій є такі методи: <span class="code">forEach()</span> , <span class="code">collect()</span> , <span class="code">count()</span> , <span class="code">reduce()</span> тощо. 
<h2>Приклади операцій із Java Stream</h2>
<h3>Проміжні операції</h3>Ось кілька прикладів деяких проміжних операцій, які можна застосовувати до Java Stream: 
<h4><span class="code">filter()</span></h4>Цей метод використовується для фільтрації елементів з потоку, які відповідають певному предикату Java. Потім ці фільтровані елементи становлять новий потік. Погляньмо на приклад, щоб краще зрозуміти краще. 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> numStream <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">43</span><span class="token punctuation">,</span> <span class="token number">65</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token number">63</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> even <span class="token operator">=</span> numStream<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>n <span class="token operator">-&gt;</span> n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>even<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Висновок: 
<div class="terminal">
 [98]
</div> Пояснення: У цьому прикладі видно, що парні елементи (діляться на 2) фільтруються за допомогою методу <span class="code">filter()</span> і зберігаються в списку <span class="code">numStream</span> , зміст якого друкується пізніше. Оскільки 98 - єдине парне ціле число потоці, воно друкується у висновку. 
<h4><span class="code">map()</span></h4>Цей метод використовується створення нового потоку шляхом виконання зіставлених функцій над елементами вихідного вхідного потоку. Можливо новий потік має інший тип даних. Приклад виглядає так: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> numStream <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">43</span><span class="token punctuation">,</span> <span class="token number">65</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token number">63</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> d <span class="token operator">=</span> numStream<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>n <span class="token operator">-&gt;</span> n<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Висновок: 
<div class="terminal">
 [86, 130, 2, 196, 126]
</div> Пояснення: Тут бачимо, що метод <span class="code">map()</span> використовується простого подвоєння кожного елемента потоку <span class="code">numStream</span> . Як очевидно з висновку, кожен із елементів у потоці успішно подвоєний. 
<h4><span class="code">distinct()</span></h4>Цей метод використовується для отримання лише окремих елементів у потоці шляхом фільтрації дублікатів. Приклад того ж виглядає так: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> numStream <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">43</span><span class="token punctuation">,</span><span class="token number">65</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">98</span><span class="token punctuation">,</span><span class="token number">63</span><span class="token punctuation">,</span><span class="token number">63</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> numList <span class="token operator">=</span> numStream<span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>numList<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Висновок: 
<div class="terminal">
 [43, 65, 1, 98, 63]
</div> Пояснення: У цьому випадку <span class="code">numStream</span> використовується метод <span class="code">different()</span> . Він отримує всі окремі елементи в списку <span class="code">numList</span> шляхом видалення дублікатів з потоку. Як видно з вивідних даних, дублікатів немає, на відміну від вхідного потоку, який спочатку мав два дублікати (63 та 1). 
<h4><span class="code">peek()</span></h4>Цей метод використовується для відстеження проміжних змін перед виконанням термінальної операції. Це означає, що <span class="code">peek()</span> можна використовувати для виконання операції над кожним елементом потоку для створення потоку, над яким можуть виконуватись подальші проміжні операції. 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> numStream <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">43</span><span class="token punctuation">,</span> <span class="token number">65</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token number">63</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> nList <span class="token operator">=</span> numStream<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>n <span class="token operator">-&gt;</span> n<span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span>n<span class="token operator">-&gt;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Mapped: "</span><span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>nList<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Висновок: 
<div class="terminal">
 Mapped: 430 Mapped: 650 Mapped: 10 Mapped: 980 Mapped: 630 [430, 650, 10, 980, 630]
</div> Пояснення: Тут метод <span class="code">peek()</span> використовується для створення проміжних результатів, оскільки метод <span class="code">map()</span> застосовується до елементів потоку. Тут ми можемо помітити, що навіть до застосування термінальної операції <span class="code">collect()</span> для друку остаточного вмісту списку оператора <span class="code">print</span> результат для кожного зіставлення елемента потоку друкується послідовно заздалегідь. 
<h4><span class="code">sorted()</span></h4>Метод <span class="code">sorted()</span> використовується сортування елементів потоку. За умовчанням він сортує елементи у порядку зростання. Також можна вказати конкретний порядок сортування як параметр. Приклад реалізації цього методу виглядає так: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> numStream <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">43</span><span class="token punctuation">,</span> <span class="token number">65</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token number">63</span><span class="token punctuation">)</span><span class="token punctuation">;</span> numStream<span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>n <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Висновок: 
<div class="terminal">
 1 43 ​​63 65 98
</div> Пояснення: Тут метод <span class="code">sorted()</span> використовується для сортування елементів потоку в порядку зростання за умовчанням (оскільки конкретний порядок не вказано). Можна побачити, що елементи, надруковані у виводі, упорядковані у порядку, що зростає. 
<h3>Термінальні операції</h3>Ось кілька прикладів деяких термінальних операцій, які можна застосовувати до потоків Java: 
<h4><span class="code">forEach()</span></h4>Метод <span class="code">forEach()</span> використовується для перебору всіх елементів потоку та виконання функції для кожного елемента один за одним. Це діє як альтернатива операторам циклу, таким як <span class="code">for</span> , <span class="code">while</span> та іншим. Приклад: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> numStream <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">43</span><span class="token punctuation">,</span> <span class="token number">65</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token number">63</span><span class="token punctuation">)</span><span class="token punctuation">;</span> numStream<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>n <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Висновок: 
<div class="terminal">
 43 65 1 98 63
</div> Пояснення: Тут метод <span class="code">forEach()</span> використовується для друку кожного елемента потоку один за одним. 
<h4><span class="code">count()</span></h4>Метод <span class="code">count()</span> використовується для отримання загальної кількості елементів, присутніх у потоці. Він нагадує метод <span class="code">size()</span> , який часто використовується визначення загальної кількості елементів у колекції. Приклад використання методу <span class="code">count()</span> з Java Stream виглядає так: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> numStream <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">43</span><span class="token punctuation">,</span> <span class="token number">65</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token number">63</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>numStream<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Висновок: 
<div class="terminal">
 5
</div> Пояснення: Оскільки потік <span class="code">numStream</span> містить 5 цілих елементів, то при використанні для нього методу <span class="code">count()</span> висновок буде 5. 
<h4><span class="code">collect()</span></h4>Метод <span class="code">collect()</span> використовується для виконання змінних скорочень елементів потоку. Його можна використовувати для видалення вмісту потоку після завершення обробки. Для проведення редукцій він використовує клас <span class="code">Collector</span> . 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> numStream <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">43</span><span class="token punctuation">,</span> <span class="token number">65</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token number">63</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> odd <span class="token operator">=</span> numStream<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>n <span class="token operator">-&gt;</span> n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>odd<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Висновок: 
<div class="terminal">
 [43, 65, 1, 63]
</div> Пояснення: У цьому прикладі всі непарні елементи в потоці фільтруються і збираються/скорочуються до списку з ім'ям <span class="code">odd</span> (непарні). Наприкінці друкується список непарних. 
<h4><span class="code">min()</span> та <span class="code">max()</span></h4>Метод <span class="code">min()</span> , як випливає з назви, може використовуватися в потоці для пошуку мінімального елемента. Так само метод <span class="code">max()</span> можна використовуватиме пошуку максимального елемента в потоці. Спробуймо зрозуміти, як їх можна використовувати, на прикладі: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> numStream <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">43</span><span class="token punctuation">,</span> <span class="token number">65</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token number">63</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> smallest <span class="token operator">=</span> numStream<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Smallest element: "</span> <span class="token operator">+</span> smallest<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java">numStream <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">43</span><span class="token punctuation">,</span> <span class="token number">65</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token number">63</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> largest <span class="token operator">=</span> numStream<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Largest element: "</span> <span class="token operator">+</span> largest<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Висновок: 
<div class="terminal">
 Smallest element: 1 Largest element: 98
</div> Пояснення: У цьому прикладі ми надрукували найменший елемент у потоці <span class="code">numStream</span> за допомогою методу <span class="code">min()</span> та найбільший елемент за допомогою методу <span class="code">max()</span> . Зверніть увагу, що перед застосуванням методу <span class="code">max()</span> ми знову додали елементи в потік <span class="code">numStream</span> . Це пов'язано з тим, що <span class="code">min()</span> є термінальною операцією і знищує вміст вихідного потоку, повертаючи лише остаточний результат (який у даному випадку був цілим “smallest”). 
<h4><span class="code">findAny()</span> та <span class="code">findFirst()</span></h4><span class="code">findAny()</span> повертає будь-який елемент потоку як <span class="code">Optional</span> . Якщо потік порожній (empty), він поверне значення <span class="code">Optional</span> , яке буде порожнім. <span class="code">findFirst()</span> повертає перший елемент потоку як <span class="code">Optional</span> . Як і у випадку з методом <span class="code">findAny()</span> , <span class="code">findFirst()</span> також повертає порожній параметр <span class="code">Optional</span> , якщо відповідний потік порожній. Погляньмо на наступний приклад, заснований на цих методах: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> numStream <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">43</span><span class="token punctuation">,</span> <span class="token number">65</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token number">63</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> opt <span class="token operator">=</span> numStream<span class="token punctuation">.</span><span class="token function">findFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>opt<span class="token punctuation">)</span><span class="token punctuation">;</span> numStream <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> opt <span class="token operator">=</span> numStream<span class="token punctuation">.</span><span class="token function">findAny</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>opt<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Висновок: 
<div class="terminal">
 Optional[43] Optional.empty
</div> Пояснення: Тут у першому випадку метод <span class="code">findFirst()</span> повертає перший елемент потоку як <span class="code">Optional</span> . Потім, коли потік перепризначається як порожній потік, <span class="code">findAny()</span> метод повертає порожній <span class="code">Optional</span> . 
<h4><span class="code">allMatch()</span> , <span class="code">anyMatch()</span> і <span class="code">noneMatch()</span></h4>Метод <span class="code">allMatch()</span> використовується для перевірки того, чи відповідають всі елементи в потоці певного предикату, і повертає логічне значення <em>true</em> якщо це так, в іншому випадку повертається <em>false</em> . Якщо потік порожній, він повертає <em>true</em> . Метод <span class="code">anyMatch()</span> використовується для перевірки того, чи відповідає якийсь із елементів у потоці певному предикату. Він повертає <em>true</em> , якщо це так, і <em>false</em> інакше. Якщо потік порожній, він повертає <em>false</em> . Метод <span class="code">noneMatch()</span> повертає <em>true</em> , якщо жоден елемент потоку не відповідає предикату, та <em>false</em>в іншому випадку. Приклад, що ілюструє це, виглядає так: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> numStream <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">43</span><span class="token punctuation">,</span> <span class="token number">65</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token number">63</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> numStream<span class="token punctuation">.</span><span class="token function">allMatch</span><span class="token punctuation">(</span>n <span class="token operator">-&gt;</span> n1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span> numStream <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">43</span><span class="token punctuation">,</span> <span class="token number">65</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token number">63</span><span class="token punctuation">)</span><span class="token punctuation">;</span> flag <span class="token operator">=</span> numStream<span class="token punctuation">.</span><span class="token function">anyMatch</span><span class="token punctuation">(</span>n <span class="token operator">-&gt;</span> n1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span> numStream <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">43</span><span class="token punctuation">,</span> <span class="token number">65</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token number">63</span><span class="token punctuation">)</span><span class="token punctuation">;</span> flag <span class="token operator">=</span> numStream<span class="token punctuation">.</span><span class="token function">noneMatch</span><span class="token punctuation">(</span>n <span class="token operator">-&gt;</span> n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Висновок: 
<div class="terminal">
 false true false
</div> Пояснення: Для потоку <span class="code">numStream</span> , що містить 1 як елемент, метод <span class="code">allMatch()</span> повертає <em>false</em> , тому що всі елементи не дорівнюють 1, а тільки один з них. Метод <span class="code">anyMatch()</span> повертає <em>true</em> , оскільки хоча один із елементів дорівнює 1. Метод <span class="code">noneMatch()</span> повертає <em>false</em> , оскільки 1 дійсно існує як елемент у цьому потоці. 
<h2>Lazy Evaluations (ліниві обчислення) у Java Stream</h2>Ліниві обчислення призводять до оптимізації при роботі з Java Streams в Java 8. Вони в основному пов'язані із затримкою виконання проміжних операцій доти, доки не зустрінеться термінальна операція. Ліниві обчислення відповідають за запобігання непотрібній витраті ресурсів на обчислення доти, доки результат справді не знадобиться. Вихідний потік, отриманий у результаті проміжних операцій, генерується лише після виконання термінальної операції. Ліниві обчислення працюють з усіма проміжними операціями в потоках Java. Дуже корисне застосування лінивих обчислень проявляється під час роботи з нескінченними потоками (infinite streams). У цьому випадку запобігає багато непотрібної обробки. 
<h2>Конвеєри в Java Stream</h2>Конвеєр (pipeline) в Java Stream включає вхідний потік, нуль або кілька проміжних операцій, збудованих одна за одною, і, нарешті, термінальну операцію. Проміжні операції в Java Streams виконуються "ліниво". Це робить конвеєрні проміжні операції неминучими. За допомогою конвеєрів, які в основному є проміжні операції, об'єднані по порядку, ліниве виконання стає можливим. Конвеєри допомагають відстежувати проміжні операції, які потрібно виконати після того, як нарешті зустрінеться термінальна операція. 
<h2>Висновок</h2>Давайте тепер підіб'ємо підсумок того, що ми сьогодні вивчабо. В цій статті:
<ol>
 <li>Ми коротко розглянули, що таке потоки Java (Java Stream).</li>
 <li>Потім ми дізналися про безліч різних методів створення потоків Java в Java 8.</li>
 <li>Ми вивчабо два основні типи операцій (проміжні операції та термінальні операції), які можна виконувати з потоками Java.</li>
 <li>Потім ми докладно розглянули кілька прикладів як проміжних, і термінальних операцій.</li>
 <li>У результаті ми докладніше дізналися про ліниві обчислення і, нарешті, вивчабо конвеєрну обробку в потоках Java.</li>
</ol>