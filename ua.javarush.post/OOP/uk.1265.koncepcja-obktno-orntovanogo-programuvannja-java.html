Концепція об'єктно-орієнтованого програмування JAVA
<p>----------------------------------------</p>
JAVA ґрунтується на концепціях об'єктно-орієнтованого програмування, що дозволяє перейти на вищий рівень абстракції, щоб вирішити будь-яку проблему реалістичним шляхом. Об'єктно-орієнтований підхід концептуалізує вирішення проблеми у площин
<p>----------------------------------------</p>
JAVA ґрунтується на концепціях об'єктно-орієнтованого програмування, що дозволяє перейти на вищий рівень абстракції, щоб вирішити будь-яку проблему реалістичним шляхом. Об'єктно-орієнтований підхід концептуалізує вирішення проблеми у площині об'єктів реального світу, які легше повторно використовувати у додатку. Наприклад, <code class=" language-none">Chair</code>(стілець), <code class=" language-none">Fan</code>(вентилятор), <code class=" language-none">Dog</code>(Собака),<code class=" language-none">Computer</code>(комп'ютер) тощо. В JAVA клас є макет, шаблон або прототип, який визначає загальну поведінку об'єкта даного типу. Примірник - це окрема реалізація класу, і всі екземпляри класу мають однакові властивості, які описані у визначенні класу. Наприклад, ви можете визначити клас з ім'ям House (будинок) з кількістю кімнат як атрибут і створити екземпляри класу, такі як будинок з двома кімнатами, будинок з трьома кімнатами і так далі. <img data-id="08ebf159-c1bd-4a0c-a421-e3517694b7f5" data-max-width="850" alt="Концепції об'єктно-орієнтованого програмування JAVA-1" src="https://cdn.javarush.com/images/article/08ebf159-c1bd-4a0c-a421-e3517694b7f5/800.jpeg" style="width: 850px;"><strong>Переваги:</strong> ​​Нижче наведено деякі плюси об'єктно-орієнтованої розробки програмного забезпечення (ПЗ). 
<ul>
 <li>Зниження витрат за підтримку ПЗ, в основному за рахунок того, що вона здійснюється модульно.</li>
 <li>Удосконалене повторне використання коду завдяки таким якостям, як успадкування, і, як результат, швидше розробка ПЗ.</li>
 <li>Підвищена надійність та гнучкість коду.</li>
 <li>Легкість розуміння внаслідок моделювання реального світу.</li>
 <li>Найкраща абстракція на рівні об'єкта.</li>
 <li>Зменшення складності переходу від однієї фази розробки до іншої.</li>
</ul>Є чотири основні характеристики ООП: 
<ul>
 <li>Інкапсуляція</li>
 <li>успадкування</li>
 <li>Поліморфізм</li>
 <li>Абстракція</li>
</ul>
<h2>Інкапсуляція</h2>Інкапсуляція виступає договором для об'єкта, що він повинен приховати, а відкрити для доступу іншими об'єктами. У JAVA ми використовуємо модифікатор доступу <code class=" language-none">private</code>для того, щоб приховати метод та обмежити доступ до змінної із зовнішнього світу. JAVA також має різні модифікатори доступу: <code class=" language-none">public</code>, за замовчуванням, <code class=" language-none">protected</code>, <code class=" language-none">private</code>, які використовуються для обмеження видимості на різних рівнях. Але кінцевою метою є інкапсуляція тих речей, які повинні бути змінені. Найкраще працює підхід, у якому, у класу має лише одна причина зміни, і інкапсулювання втілює у реальність проектування цієї “однієї причини”. Правильним в інкапсуляції вважається приховування речей, що часто змінюються, щоб уникнути пошкодження інших класів. <strong>Переваги:</strong> Нижче наведено деякі переваги інкапсуляції: 
<ul>
 <li>Ми можемо захистити внутрішній стан об'єкта за допомогою приховування його атрибутів.</li>
 <li>Це покращує модульну побудову коду, оскільки запобігає взаємодії об'єктів несподіваними способами.</li>
 <li>Підвищується практичність коду.</li>
 <li>Це підтримує договірні відносини конкретного об'єкта.</li>
 <li>Інкапсуляція полегшує підтримку програмного забезпечення.</li>
 <li>Зміни в коді можуть проводитись незалежно один від одного.</li>
</ul>
<h2>Поліморфізм</h2>Поліморфізм у програмуванні — це здатність надавати той самий інтерфейс для різних базових форм (типів даних). Це означає, що класи, що мають різну функціональність, спільно використовують той самий інтерфейс і можуть бути динамічно викликані передачею параметрів за посиланням. Класичний приклад - це клас <code class=" language-none">Shape</code>(фігура) і всі класи, що успадковуються від нього: <code class=" language-none">square</code>(квадрат), <code class=" language-none">circle</code>(коло), <code class=" language-none">dodecahedron</code>(додекаедр), <code class=" language-none">irregular polygon</code>(неправильний багатокутник), <code class=" language-none">splat</code>(ляпка) і так далі. У цьому прикладі кожен клас матиме власний метод <code class=" language-none">Draw()</code>і клієнтський код може просто робити: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">Shape</span></span> shape <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">Shape</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre><code class=" language-none">Shape.area()</code>Щоб отримати коректну поведінку будь-якої фігури Краса поліморфізму полягає в тому, що код, працюючи з різними класами, не повинен знати, який клас він використовує, тому що всі вони працюють за одним принципом. Процес, застосовуваний об'єктно-ориентированными мовами програмування реалізації динамічного поліморфізму, називається динамічним зв'язуванням. <em>Примітка:</em> Поліморфізм – це здатність вибирати більш конкретні методи виконання залежно від об'єкта. Поліморфізм здійснюється тоді, коли задіяні абстракні класи. <strong>Переваги:</strong>
<ul>
 <li>Створення повторно використовуваного коду. Тобто, як тільки клас створений, реалізований і протестований, може вільно використовуватися без турботи у тому, що у ньому написано.</li>
 <li>Це забезпечує більш універсальний і слабопов'язаний код.</li>
 <li>Знижується час компіляції, що прискорює розробку.</li>
 <li>Динамічний зв'язування.</li>
 <li>Один і той же інтерфейс може бути використаний для створення методів із різними реалізаціями.</li>
 <li>Вся реалізація може бути замінена за допомогою використання однакових методів сигнатури.</li>
</ul><strong>Перевизначення методів як частину поліморфізму. </strong>Перевизначення взаємодіє з двома методами: методом батьківського класу та методом похідного класу. Ці методи мають поодинокі ім'я та сигнатури. Перевизначення дозволяє вам робити ту саму операцію різними шляхами для різних типів об'єктів. Наприклад: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">while</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>it<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">hasNext</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
<span class="token class-name"><span class="token class-name">Shape</span></span> s <span class="token operator"><span class="token operator">=</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">Shape</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> it<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">next</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
totalArea <span class="token operator"><span class="token operator">+=</span></span> s<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">area</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>dim<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span> <span class="token comment"><span class="token comment">//будет применен полиморфизм и вызван нужный метод для каждого об'єкта.</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre><img data-id="154d8a21-3ca0-4ee8-9934-f4819c4cda5e" data-max-width="850" alt="Концепції об'єктно-орієнтованого програмування JAVA-2" src="https://cdn.javarush.com/images/article/154d8a21-3ca0-4ee8-9934-f4819c4cda5e/800.jpeg" style="width: 850px;"><strong>Перезавантаження методів або ad-hoc поліморфізм або статичний поліморфізм</strong> Перезавантаження взаємодіє з кількома методами одного класу, які однаково названі, але мають різні методи сигнатури. Перезавантаження дозволяє вам описати ту саму операцію різними шляхами для різних даних. Іноді її називають статичним поліморфізмом, але фактично поліморфізм вона не є. Це ніщо інше як просто наявність двох методів з однаковими іменами, але різним списком аргументів. Перезавантаження немає нічого спільного з наслідуванням і поліморфізмом. І перезавантажений метод зовсім не те саме, що перевизначений метод. <strong>Параметричний поліморфізм через узагальнення у JAVA</strong> При оголошенні класу поле імені може асоціюватися з різними типами, а ім'я методу може асоціюватися з різними параметрами та типами, що повертаються. JAVA підтримує параметричний поліморфізм, застосовуючи узагальнення (дженерики). 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">List</span></span><span class="token generics"><span class="token punctuation"></span><span class="token generics"><span class="token punctuation"><span class="token punctuation">&lt;</span></span><span class="token class-name"><span class="token class-name">String</span></span><span class="token punctuation"><span class="token punctuation">&gt;</span></span></span><span class="token punctuation"></span></span> list <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">ArrayList</span></span><span class="token generics"><span class="token punctuation"></span><span class="token generics"><span class="token punctuation"><span class="token punctuation">&lt;</span></span><span class="token class-name"><span class="token class-name">String</span></span><span class="token punctuation"><span class="token punctuation">&gt;</span></span></span><span class="token punctuation"></span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre><strong>Чому ми не можемо перевизначити статичний метод у JAVA?</strong> Перевизначення залежить від наявності екземпляра класу. Ідея поліморфізму полягає в тому, що ви можете створити підклас, і об'єкти, що реалізуються тими підкласами, поводитимуться по-іншому з тими самими методами батьківського класу (перевизначеними в підкласах). Статичний метод не асоціюється до жодних екземплярів класу, таким чином, сама концепція перевизначення не може бути застосована. Творцями JAVA керували дві міркування, які вплинули такий підхід. По-перше, це проблеми виконання коду: лилося дуже багато критики на адресау Smalltalk через повільну роботу (збирач сміття та поліморфізм були частиною цієї проблеми), і в проектуванні JAVA намагалися цього уникнути. Другим міркуванням було рішення, що цільовою аудиторією JAVA стануть С++ розробники. Те, що статичні методи працюють саме таким чином, було дуже знайоме C++ програмістам, а також прискорювало роботу, оскільки не було необхідності проходити вгору по ієрархії класів, щоб з'ясувати, який метод викликати. Ви йдете прямо до класу та викликаєте конкретний метод. 
<h2>успадкування</h2>Спадкування - це включення поведінки (тобто методів) і стану (тобто змінних) базового класу до похідного класу, таким чином вони стають доступними в цьому похідному класі. Головна перевага успадкування в тому, що воно забезпечує формальний механізм повторного використання коду та уникає дублювання. Успадкований клас розширює функціональність програми завдяки копіюванню поведінки батьківського класу та додавання нових функцій. Це робить код дуже пов'язаним. Якщо ви захочете змінити суперклас, вам доведеться знати всі деталі підкласів, щоб не зруйнувати код. Спадкування — це форма повторного використання програмного забезпечення, коли з вже існуючого класу (суперкласу) створюється новий клас (підклас), який розширює свою функціональність і використовує деякі властивості суперкласу. <strong>Переваги:</strong>
<ul>
 <li>Удосконалене повторне використання коду.</li>
 <li>Встановлюється логічне ставлення «is a» (є кимось, чимось). Наприклад: <u>Dog</u> is a <em>n </em> <u>animal</u> . (Собака є твариною).</li>
 <li>Модуляризація коду.</li>
 <li>Виключаються повторення.</li>
</ul><strong>Недолік:</strong>
<ul>
 <li><strong>Сильна пов'язаність:</strong> підклас залежить від батьківського класу, що робить код сильно пов'язаним.</li>
</ul>
<div class="table-container">
 <table>
  <tbody>
   <tr>
    <th>Що ще почитати:</th>
   </tr>
   <tr>
    <td>
     <p><a href="https://codegym.cc/groups/java-developer" target="_blank"><em><strong>Група Java Developer:</strong></em></a></p>
     <ul>
      <li>
       <p><a href="https://codegym.cc/groups/posts/1880--principih-oop" target="_blank">Принципи ООП</a></p></li>
     </ul></td>
   </tr>
  </tbody>
 </table>
</div>
<h2>Абстракція</h2>Абстракція означає розробку класів виходячи з їх інтерфейсів та функціональності, не беручи до уваги реалізацію деталей. Абстрактний клас є інтерфейси без включення фактичної реалізації. Він відрізняє реалізацію об'єкта з його поведінки. Абстракція полегшує код, приховуючи несуттєві деталі. <strong>Переваги:</strong>
<ul>
 <li>Застосовуючи абстракцію, ми можемо відокремити те, що може бути згруповано за будь-яким типом.</li>
 <li>Часто змінювані властивості та методи можуть бути згруповані в окремий тип, таким чином основний тип не буде змінюватися. Це посилює принцип ОВП: <em>«Код має бути відкритим для Розширення, але закритим для Змін»</em> .</li>
 <li>Абстракція полегшує представлення доменних моделей.</li>
</ul><strong>Відмінність між абстракцією та інкапсуляцією</strong> Інкапсуляція – це стратегія, яка використовується як частина абстракції. Інкапсуляція відноситься до структури об'єкта: об'єкти інкапсулюють свої властивості та приховують їх від доступу ззовні. Користувачі класу взаємодіють із ним з допомогою його методів, але мають доступу безпосередньо до структури класу. Отже клас абстрагує деталі реалізації, які стосуються його будову. Абстракція є загальнішим терміном. Вона також може досягатись серед іншого за допомогою підкласів. Наприклад, клас <code class=" language-none">List</code>(список) у стандартній бібліотеці є абстракцією для послідовності елементів, проіндексованих відповідно до їх місця у списку. Конкретними прикладами списку <code class=" language-none">List</code>є <code class=" language-none">ArrayList</code>або <code class=" language-none">LinkedList</code>. Код, який взаємодіє зі списком<code class=" language-none">List</code>абстрагується від деталей, який саме список він використовує. Часто абстракція неможлива без приховування основного стану за допомогою інкапсуляції. Якщо клас розкриває свою внутрішню структуру, він може змінити свої внутрішні операції, отже, неспроможна абстрагуватися. <strong>Що таке абстрактний клас та абстрактний метод? </strong> Трапляється, що під час розробки ви хочете, щоб базовий клас представляв лише інтерфейс для його похідних класів. Тобто ви не хочете, щоб будь-хто створював екземпляри базового класу. Вам необхідно використовувати інтерфейс таким чином, щоб тільки приводити до нього об'єкти (це неявне приведення, яке забезпечує поліморфну ​​поведінку). Це досягається шляхом створення даного класу абстрактним за допомогою ключового слова<code class=" language-none">abstract</code>. Це накладає деякі обмеження, такі як неможливість створювати екземпляри абстрактного класу, під час використання абстрактного класу необхідно реалізовувати абстрактні методи. Цим забезпечується поліморфізм. Абстрактний клас може містити і абстрактні та конкретні методи. Якщо хоч один метод у класі оголошений абстрактним, весь клас має бути оголошений абстрактним. Тим не менш, у зворотний бік правило не повинно дотримуватися. Якщо клас оголошений абстрактним, може і містити абстрактні методи. Метод, який лише визначає свої сигнатури і не забезпечує реалізацію, називається абстрактним. Фактична його реалізація залишена його підкласами, які розширюють абстрактний клас. Абстрактний метод може бути використаний об'єктом, лише інший клас може його розширити. <strong>Коли потрібно використовувати абстрактний клас? </strong> Абстрактні класи дозволяють визначити певну поведінку за замовчуванням і змусити підкласи забезпечити будь-яку конкретну поведінку. Наприклад: <code class=" language-none">List</code>(список) є інтерфейсом, у свою чергу <code class=" language-none">AbstractList</code>визначає основну поведінку Списку, яке може бути використане як є або уточнено в підкласі, наприклад, <code class=" language-none">ArrayList</code>(списковий масив). <strong>Що таке інтерфейс? </strong> У концепції інтерфейсу лежить абстрактний клас, але інтерфейс (визначається ключовим словом<code class=" language-none">interface</code>) ступив далі. Він запобігає взагалі будь-якій реалізації методу або функції. Ви можете лише оголошувати метод або функцію, але не забезпечувати їхню реалізацію. Клас, який реалізує даний інтерфейс, повинен таки подбати про фактичну реалізацію. Інтерфейси дуже корисні та повсюдно використовуються в ОВП. Так як вони поділяють сам інтерфейс та реалізацію, вони надають багато переваг свого використання: 
<ol>
 <li><strong>Множинне успадкування</strong> .</li>
 <li><strong>Слабка пов'язаність</strong> . Відбувається абстракція операції, така як поділ на рівні, а конкретною реалізацією може бути будь-що: JDBC, JPA, JTA і т.д.</li>
 <li><strong>Програма-інтерфейс не реалізується</strong> .</li>
 <li><strong>Поліморфізм з динамічним зв'язуванням</strong> : розкривається програмний інтерфейс об'єкта без розкриття його фактичної реалізації.</li>
 <li><strong>Абстрактні рівні</strong> , поділ функціональностей.</li>
</ol><strong>Різниця між інтерфейсом та абстрактним класом.</strong>
<ul>
 <li>Інтерфейс - це договірні відносини з класами, які цей інтерфейс реалізують, про те, що реалізація відбувається шляхом позначеного інтерфейсом. Це порожня оболонка із оголошеними методами.</li>
 <li>Абстрактний клас визначає деяку загальну поведінку та просить свої підкласи визначити нетипову чи конкретну поведінку для свого класу.</li>
 <li>Способи та члени абстрактного класу може бути позначені будь-яким модифікатором доступу, своєю чергою всі способи інтерфейсу мали бути зацікавленими відкритими (public).</li>
 <li>Коли відбувається успадкування абстрактного класу, клас-спадкоємець повинен визначити абстрактні методи, тоді як інтерфейс може успадковувати інший інтерфейс і навіть не обов'язково визначати його методи.</li>
 <li>Клас-спадкоємець може розширювати лише один абстрактний клас, а інтерфейс може розширювати або клас може реалізовувати безліч інших інтерфейсів.</li>
 <li>Клас-спадкоємець може визначати абстрактні методи з тим же менш обмеженим модифікатором доступу, при цьому клас, що реалізує інтерфейс, повинен визначати методи з тим же рівнем видимості.</li>
 <li>Інтерфейс не містить конструктори, у той час як вони є в абстрактному класі.</li>
 <li>Змінні, оголошені в інтерфейсі Java за замовчуванням є final. Анотація клас може містити змінні, які не є final.</li>
 <li>Всі учасники Java-інтерфейсу за промовчанням є <code class=" language-none">public</code>. Учасники абстрактного класу можуть дозволити собі бути <code class=" language-none">public</code>, <code class=" language-none">protected</code>та ін.</li>
</ul>
<h2>Композиція</h2>Повторне використання коду може бути досягнуто за допомогою успадкування, так і композиції. Але при цьому задіяння композиції забезпечує більш високий рівень інкапсуляції, ніж успадкування, тому що зміни в класі back-end не обов'язково торкнуться код, який відноситься до front-end класу. Композиція - це техніка проектування, що застосовує у класах відносини типу "has-a" (має, включає в себе). Для повторного використання коду можуть застосовуватися як успадкування java, так і композиція об'єкта. Суть композиції полягає у вираженні відносини "has a" між об'єктами. Подумайте про стільці. У стільця є (has a) сидіння. У випорожнення є (has a) спинка. У випорожнення є (has a) певна кількість ніжок. Фраза ”has a” / “є” передбачає відносини, у яких стілець має чи, як мінімум, використовує інший об'єкт. <strong>Переваги:</strong>
<ul>
 <li>Контроль видимості</li>
 <li>Реалізація може бути замінена під час виконання (run-time)</li>
 <li>Слабка пов'язаність, оскільки клас-інтерфейс залежить від реалізації.</li>
</ul><strong>Відмінності між композицією та успадкуванням</strong>
<div class="table-container">
 <table>
  <tbody>
   <tr>
    <th>№</th>
    <th>Композиція (has a / має)</th>
    <th>Спадкування (is a / є)</th>
   </tr>
   <tr>
    <td>1</td>
    <td>Підтримує поліморфізм та повторне використання коду.</td>
    <td>Підтримує поліморфізм та повторне використання коду.</td>
   </tr>
   <tr>
    <td>2</td>
    <td>Об'єкт під час виконання (run-time) вже створено.</td>
    <td>Об'єкт створюється динамічно під час компіляції.</td>
   </tr>
   <tr>
    <td>3</td>
    <td>Реалізація може бути замінена під час виконання (run-time).</td>
    <td>Реалізація може бути замінена під час компіляції.</td>
   </tr>
   <tr></tr>
   <tr>
    <td>4</td>
    <td>Підклас залежить від класу-батька, що сприяє слабкому зв'язування (особливо під керівництвом інтерфейсу).</td>
    <td>Підклас є завізистом від реалізації класу-батька, тому зв'язування вважається сильним.</td>
   </tr>
   <tr>
    <td>5</td>
    <td>Використання: у Будинку є Ванна кімната. Неправильно говорити, що Будинок – це Ванна кімната.</td>
    <td>Спадкування є односпрямованим: Будинок – це Будівля. Але будівля не є домівкою.</td>
   </tr>
  </tbody>
 </table>
</div><em>Примітка:</em> Не використовуйте успадкування лише для того, щоб забезпечити повторне використання коду. Якщо немає відношень “is a“ (є), для цих цілей використовується композиція. <strong>Різниця між композицією та агрегацією у відносинах об'єктів. </strong> <em>Агрегація</em> — це взаємозв'язок, коли один клас вписується в колекцію. Це частина цілого відношення, де частина може бути без цілого. Такі відносини набагато слабші. Немає циклічної залежності. Наприклад: замовлення та продукт. <em>Композиція</em>— це взаємозв'язок, коли один клас вписується в колекцію. Це частина цілого відношення, коли частина не може існувати без цілого. Якщо ціле знищується, всі його складові також будуть знищені. Це сильніші стосунки. Наприклад: багатокутник та його вершини, замовлення та його компонент.