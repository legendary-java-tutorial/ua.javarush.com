Пекельне завдання: приступаємо до рефакторингу успадкованого коду
<p>----------------------------------------</p>
Надійний комплексний набір тестів значно спрощує рефакторинг коду. Але що робити, коли таких тестів було проведено мало, чи вони не виконувались взагалі? Якщо узагальнити, під рефакторингом розуміють реорганізацію коду зміни його поведінки.
<p>----------------------------------------</p>
Надійний комплексний набір тестів значно спрощує рефакторинг коду. Але що робити, коли таких тестів було проведено мало, чи вони не виконувались взагалі? 
<h2>Що таке рефакторинг?</h2>Якщо узагальнити, під рефакторингом розуміють реорганізацію коду зміни його поведінки. Тобто, ми ставимо в основу поведінку: нам потрібно гарантувати, що, виконуючи рефакторинг, ми його не змінимо. 
<div class="row justify-content-center jr-image-wrap">
 <div class="col-12 col-sm-10 col-md-8">
  <img data-id="5f1153d9-565d-492f-ab2d-b7c3985c60f5" data-max-width="710" alt="Пекельне завдання: приступаємо до рефакторингу успадкованого коду - 1" src="https://cdn.javarush.com/images/article/5f1153d9-565d-492f-ab2d-b7c3985c60f5/512.jpeg" style="width: 710px;">
 </div>
</div> Як це можна забезпечити? Відповідь проста: тести. Саме тести підтверджують, що наша система чи компонент поводиться так, як очікувалося, за заданих умов. За наявності тестів процес рефакторингу істотно спрощується, оскільки у нас є засіб перевірки (валідації). Але код, добре покритий тестами - це ідеальний випадок, і насправді зустрічається рідко. Давайте поглянемо на випадок складніший і реалістичніший. 
<h2>Жах кошмар на ім'я «Legacy-проекти»</h2>Розглянемо якийсь сценарій із життя рядового (чи не дуже) програміста. Уявіть, що менеджер кидає вас на проект із legacy-кодом (тобто, успадкованим, не дуже новим і найчастіше – дуже заплутаним кодом). Ніхто не в курсі, як цей код працює, документації катастрофічно не вистачає, а ту, що є, писав невідомий непрямий іноземець, який побажав залишитися невідомим. 
<div class="row justify-content-center jr-image-wrap">
 <div class="col-12 col-sm-10 col-md-8">
  <img data-id="8a2d4912-a77e-4da5-93b5-840a22c94bfd" data-max-width="710" alt="Пекельне завдання: приступаємо до рефакторингу успадкованого коду - 2" src="https://cdn.javarush.com/images/article/8a2d4912-a77e-4da5-93b5-840a22c94bfd/512.jpeg" style="width: 710px;">
 </div>
</div> Що тепер робити? Не звільнятися ж, зрештою! Хоча після пари-трійки годин копання в нетрях legacy, цей варіант здасться вам привабливим. Але здаватися зарано! Насправді, все, що від нас вимагається – забезпечити незмінність поведінки. В умовах нестачі інформації це завдання нетривіальне. З чого почати? Писати випробування. Тести, тести, і ще раз тести. 
<h2>Крок 1. «Димові» тести</h2>Перший тип тестів, яким ми скористаємося, – це звані «димові» тести (англ. smoke testing). Під цим терміном розуміють мінімальний набір тестів на помилки. "Димовий" тест зазвичай виконується самим програмістом. Програму, що не проходила цей тест, не має сенсу віддавати на більш глибоке тестування. «Димові» тести відмінно підходять для демонстрації того, що найважливіша частина системи веде себе адекватно та передбачувано. Тобто ми додаємо "димові" тести до нашого конвеєра розгортання (створіть його, якщо ще не створабо) на кроці перевірки складання. Після виконання "димових" тестів ми можемо бути впевнені, що нічого не порушабо критично. Крім того, на додачу до цього чудового ефекту ми отримуємо знання: після створення "димових" тестів, ми починаємо набагато краще розуміти систему. 
<h2>Крок 2. Модульне тестування</h2>Наша наступна стратегія – модульне тестування. Модульне або юніт-тестування (англ. unit testing) - процес у програмуванні, що дозволяє перевірити на коректність окремі модулі вихідного коду програми. Ідея полягає в тому, щоб писати тести для кожної нетривіальної функції чи методу. Цей підхід використовується у Java-програмуванні повсюдно. Реалізація модульного тестування – набагато складніше завдання. Цей процес має бути покроковим. Неможливо написати модульні тести для кожного компонента, та й сенсу в цьому особливого немає, оскільки вам все одно незабаром буде рефакторинг. Отже, потрібно переконатися, що хоча б основні компоненти поводяться як належить. Отже, виберіть один із основних компонентів та почніть його тестувати. Написання модульних тестів автоматично призведе до невеликого рефакторингу успадкованого коду. До того ж, ви почнете розуміти внутрішній пристрій проекту набагато краще. 
<h2>Підсумки</h2>Після реалізації цих стратегій, у вас не залишиться не протестованого коду, і туман легаси-коду стане набагато менш щільним. Зрозуміло, що в команді може знайтися людина, яка скаже, що на тестування немає часу. Постарайтеся переконати його, що навпаки, відмова від тестування призведе до набагато більших тимчасових втрат у довгостроковій перспективі. А, отже, слід зробити тестування найпершим і найбільш пріоритетним завданням, перш ніж приступати до будь-якого серйозного рефакторингу. Якщо вас відмовляють від тестування - сперечайтеся, відстоюйте свою думку. Інакше вся команда зазнає невдачі. Якщо уникнути зустрічі з успадкованим кодом неможливо, перш ніж розпочинати рефакторинг, протестуйте його. Кращої стратегії просто не існує. Відмова від тестування – запорука майбутньої поразки. 
<div class="table-container">
 <table>
  <tbody>
   <tr>
    <th>
     <p>Що ще почитати:</p></th>
   </tr>
   <tr>
    <td>
     <p><a href="https://codegym.cc/groups/posts/278-samihe-rasprostranjennihe-problemih-tekh-kto-nachinaet-uchitjh-java" target="_blank">Найпоширеніші проблеми тих, хто починає вивчати Java</a></p>
     <p><a href="https://codegym.cc/groups/posts/305-sozdanie-prosteyshego-web-proekta-v-intellij-idea-enterprise-edition-poshagovo-s-kartinkami" target="_blank">Створення найпростішого веб-проекту в IntelliJ Idea Enterprise. Покроково, з картинками</a></p>
     <p><a href="https://codegym.cc/groups/posts/244-vopros-otvet-kak-v-java-praviljhno-konvertirovatjh-string-v-int--" target="_blank">Питання-відповідь: як у Java правильно конвертувати String в int?</a></p></td>
   </tr>
  </tbody>
 </table>
</div>