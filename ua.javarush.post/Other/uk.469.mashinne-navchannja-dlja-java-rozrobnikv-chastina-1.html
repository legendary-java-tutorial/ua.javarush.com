Машинне навчання для Java-розробників, частина 1
<p>----------------------------------------</p>
Автомобілі з автономним керуванням, системи розпізнавання осіб та голосові помічники – всі вони розроблені на базі технологій та фреймворків машинного навчання. І це лише перша хвиля. За наступні 10 років нове покоління продуктів перетворит
<p>----------------------------------------</p>
<em>Налаштуйте алгоритм машинного навчання та розробте свою першу функцію прогнозування за допомогою Java. </em> Автомобілі з автономним керуванням, системи розпізнавання осіб та голосові помічники – всі вони розроблені на базі технологій та фреймворків машинного навчання. І це лише перша хвиля. За наступні 10 років нове покоління продуктів перетворить наш світ, породжуючи нові підходи до розробки програм, продуктів та додатків. <img data-id="b6df46c9-8663-4210-ac3a-2bfbf900aec5" data-max-width="850" alt="Машинне навчання для Java-розробників, частина 1 - 1" src="https://cdn.javarush.com/images/article/b6df46c9-8663-4210-ac3a-2bfbf900aec5/800.jpeg" style="width: 850px;">Як Java-програміст ви хочете зловити цю хвилю прямо зараз, коли технологічні компанії починають серйозно інвестувати у машинне навчання. Те, що ви вивчите сьогодні, ви зможете використати протягом наступних п'яти років. Тільки ось із чого почати? Ця стаття покликана відповісти на це запитання. Ви отримаєте перші враження про принципи машинного навчання, дотримуючись нашої невеликої інструкції з реалізації та підготовки алгоритму машинного навчання. Після вивчення структури алгоритму навчання та можливостей, які ви можете використовувати для тренування, оцінки та вибору функції, що забезпечує найкращу точність прогнозів, ви отримаєте уявлення про використання фреймворку для JVM (Weka) для побудови рішень на базі машинного навчання. Ця стаття фокусується на контрольованому машинному навчанні, 
<h3>Машинне навчання та штучний інтелект</h3>Машинне навчання еволюціонувало в галузі штучного інтелекту, мета якої — створення машин, здатних наслідувати людський інтелект. Хоча термін «машинне навчання» з'явився в інформатиці, штучний інтелект не є новою галуззю науки. <em><strong>Тест Тьюринга</strong></em> , розроблений математиком Аланом Тьюрингом на початку п'ятдесятих років 20-го століття, є одним із перших тестів, призначених для визначення наявності справжнього інтелекту у обчислювальної машини. Згідно з тестом Тьюринга, обчислювальна машина доводить наявність людського інтелекту тим, що видає себе за людину, і останній не здогадується, що говорить із машиною. 
<div class="row justify-content-center jr-image-wrap">
 <div class="col-12 col-sm-10 col-md-8">
  <img data-id="46c2ec6b-45c2-4e3e-9613-693147384956" data-max-width="710" alt="Машинне навчання для Java-розробників, частина 1 - 2" src="https://cdn.javarush.com/images/article/46c2ec6b-45c2-4e3e-9613-693147384956/512.jpeg" style="width: 710px;">
 </div>
</div>Багато популярних сьогодні підходів у машинному навчанні базуються на ідеях, яким уже десятки років. Але остання декада у обчислювальній техніці (і розподілених обчислювальних платформах) привнесла достатні потужності застосування алгоритмів машинного навчання. Більшість із них вимагають величезної кількості операцій множення матриць та інших математичних обчислень. Двадцять років тому обчислювальні технології, що дозволяють здійснити такі обчислення, просто не існували, а зараз вони вже стали реальністю. Алгоритми машинного навчання дозволяють програмам виконувати процес покращення якості та розширювати свої можливості без участі людини. Програма, розроблена з використанням машинного навчання, здатна самостійно оновлювати чи розширювати власний код. 
<h3>Контрольоване навчання vs неконтрольоване навчання</h3>
<div class="table-container">
 <table>
  <tbody>
   <tr>
    <td><a href="https://codegym.cc/groups/posts/309-deep-learning-iskusstvennihy-intellekt-i-mashinnoe-obuchenie-dlja-chaynikov-obhhjasnenie-na-prim" target="_blank">Deep Learning, штучний інтелект та машинне навчання для чайників: пояснення на прикладі</a></td>
   </tr>
  </tbody>
 </table>
</div>Контрольоване та неконтрольоване навчання є двома найбільш популярними підходами до машинного навчання. Для обох варіантів потрібно давати машині безліч записів даних для побудови співвідношень і навчання. Такі зібрані дані зазвичай називають <em><strong>"вектором ознак"</strong></em> . Наприклад, у нас є якийсь житловий будинок. У такому разі вектор ознак може містити такі ознаки, як: загальна площа будинку, кількість кімнат, рік будівництва будинку тощо. <em><strong>При контрольованому навчанні</strong></em>алгоритм машинного навчання готується для відповіді на питання, пов'язані з векторами ознак. Для тренування алгоритму йому «годують» набір векторів ознак і пов'язаних міток. Пов'язану мітку надає людина (вчитель), і вона містить правильну відповідь на задане запитання. Алгоритм навчання аналізує вектори ознак та правильні мітки для пошуку внутрішньої структури та взаємовідносин між ними. Таким чином, машина вчиться правильно відповідати на запитання. Як приклад можна розглянути інтелектуальний додаток для торгівлі нерухомістю. Його можна натренувати за допомогою вектора ознак, що включає розмір, кількість кімнат і рік будівлі для набору будинків. Людина повинна привласнити кожному будинку мітку з правильною ціною будинку, базуючись на цих факторах. Аналізуючи ці дані, 
<div class="table-container">
 <table>
  <tbody>
   <tr>
    <td>Цікаво читати про Java? Вступайте до групи <a href="https://codegym.cc/groups/java-developer" target="_blank">Java Developer</a> !</td>
   </tr>
  </tbody>
 </table>
</div>Після того, як процес підготовки закінчено, нові вхідні дані вже не маркуються. Машина повинна бути здатна правильно відповідати на питання, навіть для невідомих, не промаркованих ознак векторів. При неконтрольованому навчанні алгоритм будується таким чином щоб передбачати відповіді без маркування людиною (або навіть без питань). Замість визначення маркування чи результату алгоритми неконтрольованого навчання використовують великі масиви даних та обчислювальні потужності для виявлення раніше не відомих взаємин. Наприклад, у маркетингу споживчих продуктів можна використовувати неконтрольоване навчання визначення прихованих взаємозв'язків чи групування клієнтів, що зрештою допоможе удосконалити маркетингову програму чи створити нову. У цій статті ми зосередимося на контрольованому машинному навчанні; Нині цей підхід використовується найчастіше. 
<h3>Контрольоване машинне навчання</h3>Будь-яке машинне навчання базується на даних. Для проекту з контрольованого машинного навчання, потрібно відзначити маркерами дані таким чином, щоб отримати осмислені відповіді на запитання. Нижче в Таблиці-1 кожен запис інформації про будинок має мітку «ціна будинку». Виявляючи взаємозв'язок між даними записів та ціною будинку, алгоритм у результаті має бути здатним передбачити ринкову ціну для будинків, що не входять до цього списку. (Зверніть увагу, площа будинку вказана у квадратних метрах, а вартість будинку у євро). 
<div class="table-container">
 <table>
  <thead>
   <tr>
    <td colspan="4">
     <center>
      Таблиця 1. Список будинків
     </center></td>
   </tr>
   <tr>
    <th>Ознака</th>
    <th>Ознака</th>
    <th>Ознака</th>
    <th>Мітка</th>
   </tr>
   <tr>
    <th>Площа будинку</th>
    <th>Кількість кімнат</th>
    <th>Вік будинку</th>
    <th>Очікувана ціна будинку</th>
   </tr>
  </thead>
  <tbody>
   <tr>
    <td>90 m2 / 295 ft</td>
    <td>2 кімнати</td>
    <td>23 роки</td>
    <td>249,000 €</td>
   </tr>
   <tr>
    <td>101 m2/331 ft</td>
    <td>3 кімнати</td>
    <td>n/a</td>
    <td>338,000 €</td>
   </tr>
   <tr>
    <td>1330 m2/4363 ft</td>
    <td>11 кімнат</td>
    <td>12 років</td>
    <td>6,500,000 €</td>
   </tr>
  </tbody>
 </table>
</div>На ранніх етапах ви, швидше за все, маркуватимете дані вручну, але врешті-решт ви навчите вашу програму робити це самостійно. Ви, ймовірно, вже бачабо, як працює такий підхід з клієнтами електронної пошти, коли для переміщення листа до папки «Спам» ви відповідаєте на запитання «Чи є цей лист не бажаним?». Коли ви відповідаєте, ви навчаєте програму розпізнавати листи, які ви не бажаєте бачити. Спам-фільтр програми навчається маркувати листи з того ж джерела, або містить такий самий контент і керувати ними відповідно до відповідних правил. Марковані набори даних необхідні лише для підготовки та тестування. Після закінчення цього етапу алгоритм машинного навчання працює з немаркованими даними. Наприклад, 
<h3>Як машина навчається передбачати</h3>Складність контрольованого машинного навчання -- у пошуку відповідної функції передбачення певного питання. Математично складність полягає в тому, щоб знайти функцію, яка отримує на вхід змінну <code class=" language-none">х</code>і повертає передбачене значення <code class=" language-none">у</code>. Ця функція гіпотез <code class=" language-none">(hθ)</code>є наслідком процесу підготовки. Часто функція гіпотез також називається цільовою функцією чи функцією передбачення. 
<center>
 <big><big><big><em><mark>y = h <sub>θ</sub> (x)</mark></em></big></big></big>
</center> У більшості випадків <code class=" language-none">х</code>є масивом даних. У нашому прикладі - це двомірний масив з елементів, що визначають будинок, що складається з кількості кімнат та площі будинку. Масив таких значень вектор ознак. Задавши конкретну цільову функцію, ми можемо використовувати її передбачення кожного вектора ознак <code class=" language-none">х</code>. Щоб передбачити ціну будинку, ви повинні викликати цільову функцію, використовуючи вектор ознак <code class=" language-none">{101.0, 3.0}</code>, що складається з площі будинку та кількості кімнат: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token comment"><span class="token comment">// целевая функция h (результат процесса обучения)</span></span>
<span class="token class-name"><span class="token class-name">Function</span></span><span class="token operator"><span class="token operator">&lt;</span></span><span class="token class-name"><span class="token class-name">Double</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token class-name"><span class="token class-name">Double</span></span><span class="token operator"><span class="token operator">&gt;</span></span> h <span class="token operator"><span class="token operator">=</span></span> <span class="token punctuation"><span class="token punctuation">.</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>

<span class="token comment"><span class="token comment">// определяем целевой вектор с площадью дома=101 и количеством комнат=3</span></span>
<span class="token class-name"><span class="token class-name">Double</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> x <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">Double</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span> <span class="token number"><span class="token number">101.0</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token number"><span class="token number">3.0</span></span> <span class="token punctuation"><span class="token punctuation">}</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>

<span class="token comment"><span class="token comment">// и предсказываем цену дома (метка)</span></span>
<span class="token keyword"><span class="token keyword">double</span></span> y <span class="token operator"><span class="token operator">=</span></span> h<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">apply</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>x<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> У вихідному коді з прикладу-1, значення масиві <code class=" language-none">х</code>представляють вектор ознак будинку. Значення <code class=" language-none">у</code>, яке повертається цільовою функцією, - це передбачена ціна будинку. Метою машинного навчання є визначення цільової функції, яка працюватиме максимально точно за невідомих вхідних параметрів. У машинному навчанні цільова функція <code class=" language-none">(hθ)</code>іноді називається моделлю. Ця модель є наслідком процесу навчання. 
<div class="row justify-content-center jr-image-wrap">
 <div class="col-12 col-sm-10 col-md-8">
  <img data-id="5c49aabd-0f5f-48c6-939b-4ce569b9f401" data-max-width="710" alt="Машинне навчання для Java-розробників, частина 1 - 3" src="https://cdn.javarush.com/images/article/5c49aabd-0f5f-48c6-939b-4ce569b9f401/512.jpeg" style="width: 710px;">
 </div>
</div>Базуючись на маркованих тренувальних зразках, алгоритм навчання шукає структури чи шаблони у тренувальних даних. Таким чином, він будує модель, яка в цілому хороша для цих даних. Як правило, процес навчання має дослідницький характер. Здебільшого процес повторюють багаторазово з використанням різних варіантів алгоритмів навчання та конфігурацій. У результаті всі моделі оцінюються на основі метрик продуктивності, серед яких вибирається найкраща. І ця модель використовується для обчислення передбачуваних значень майбутніх не маркованих даних. 
<h3>Лінійна регресія</h3>Щоб навчити машину «думати», спочатку потрібно вибрати алгоритм навчання, який ви використовуватимете. Наприклад, лінійну регресію. Це – один із найпростіших та найпопулярніших алгоритмів контрольованого машинного навчання. Алгоритм передбачає, що відношення між вхідними ознаками та маркерами результату – лінійно. Загальна функція лінійної регресії, наведена нижче, повертає передбачене значення шляхом підсумовування всіх елементів вектора ознак, помножених на параметр <code class=" language-none">θ</code> <em>(тета)</em> . Цей параметр використовується в процесі навчання для адаптації або підстроювання функції регресії на основі тренувальних даних. 
<center>
 <big><big><big><em><mark>h <sub>θ</sub> (x) = θ <sub>0</sub> * 1 + θ <sub>1</sub> * x <sub>1</sub> + ... θ <sub>n</sub> * x <sub>n</sub></mark></em></big></big></big>
</center> У функції лінійної регресії параметр тіта та параметри ознак пронумеровані підрядковими індексами. Підрядковий індекс визначає позицію параметра <code class=" language-none">(θ)</code>та параметра ознаки <code class=" language-none">(х)</code>у векторі. Зверніть увагу, що ознака x <sub>0</sub> є постійним елементом зсуву та має значення <code class=" language-none">1</code>для обчислювальних цілей. В результаті індекс значущих параметрів, таких як площа будинку, починається з x <sub>1</sub> . Так, якщо x <sub>1</sub> присвоєно перше значення вектора ознак (площа будинку), то x <sub>2</sub> прийматиме наступне значення (кількість кімнат) і таке інше. Приклад-2 демонструє Java-реалізацію функції лінійної регресії, що математично позначається як h <sub>θ</sub>(x). Для простоти обчислення виконуються з використанням типу даних <code class=" language-none">double</code>. У методі <code class=" language-none">apply()</code>передбачено, що перший елемент масиву дорівнюватиме 1.0 і буде встановлений за межами цієї функції. <em>Приклад 2. Лінійна регресія Java</em>
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">class</span></span> <span class="token class-name"><span class="token class-name">LinearRegressionFunction</span></span> <span class="token keyword"><span class="token keyword">implements</span></span> <span class="token class-name"><span class="token class-name">Function</span></span><span class="token operator"><span class="token operator">&lt;</span></span><span class="token class-name"><span class="token class-name">Double</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token class-name"><span class="token class-name">Double</span></span><span class="token operator"><span class="token operator">&gt;</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
 <span class="token keyword"><span class="token keyword">private</span></span> <span class="token keyword"><span class="token keyword">final</span></span> <span class="token keyword"><span class="token keyword">double</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> thetaVector<span class="token punctuation"><span class="token punctuation">;</span></span>

 <span class="token class-name"><span class="token class-name">LinearRegressionFunction</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">double</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> thetaVector<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
 <span class="token keyword"><span class="token keyword">this</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>thetaVector <span class="token operator"><span class="token operator">=</span></span> <span class="token class-name"><span class="token class-name">Arrays</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">copyOf</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>thetaVector<span class="token punctuation"><span class="token punctuation">,</span></span> thetaVector<span class="token punctuation"><span class="token punctuation">.</span></span>length<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
 <span class="token punctuation"><span class="token punctuation">}</span></span>

 <span class="token keyword"><span class="token keyword">public</span></span> <span class="token class-name"><span class="token class-name">Double</span></span> <span class="token function"><span class="token function">apply</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">Double</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> featureVector<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
 <span class="token comment"><span class="token comment">// с целью упрощения вычислений первый элемент должен быть дорівнює 1.0</span></span>
 <span class="token keyword"><span class="token keyword">assert</span></span> featureVector<span class="token punctuation"><span class="token punctuation">[</span></span><span class="token number"><span class="token number">0</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> <span class="token operator"><span class="token operator">==</span></span> <span class="token number"><span class="token number">1.0</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>

 <span class="token comment"><span class="token comment">// простое последовательное сложение</span></span>
 <span class="token keyword"><span class="token keyword">double</span></span> prediction <span class="token operator"><span class="token operator">=</span></span> <span class="token number"><span class="token number">0</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
 <span class="token keyword"><span class="token keyword">for</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">int</span></span> j <span class="token operator"><span class="token operator">=</span></span> <span class="token number"><span class="token number">0</span></span><span class="token punctuation"><span class="token punctuation">;</span></span> j <span class="token operator"><span class="token operator">&lt;</span></span> thetaVector<span class="token punctuation"><span class="token punctuation">.</span></span>length<span class="token punctuation"><span class="token punctuation">;</span></span> j<span class="token operator"><span class="token operator">++</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
 prediction <span class="token operator"><span class="token operator">+=</span></span> thetaVector<span class="token punctuation"><span class="token punctuation">[</span></span>j<span class="token punctuation"><span class="token punctuation">]</span></span> <span class="token operator"><span class="token operator">*</span></span> featureVector<span class="token punctuation"><span class="token punctuation">[</span></span>j<span class="token punctuation"><span class="token punctuation">]</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
 <span class="token punctuation"><span class="token punctuation">}</span></span>
 <span class="token keyword"><span class="token keyword">return</span></span> prediction<span class="token punctuation"><span class="token punctuation">;</span></span>
 <span class="token punctuation"><span class="token punctuation">}</span></span>

 <span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">double</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> <span class="token function"><span class="token function">getThetas</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
 <span class="token keyword"><span class="token keyword">return</span></span> <span class="token class-name"><span class="token class-name">Arrays</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">copyOf</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>thetaVector<span class="token punctuation"><span class="token punctuation">,</span></span> thetaVector<span class="token punctuation"><span class="token punctuation">.</span></span>length<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
 <span class="token punctuation"><span class="token punctuation">}</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> Щоб створити новий екземпляр <code class=" language-none">LinearRegressionFunction</code>, потрібно встановити параметр <code class=" language-none">θ</code>. Цей параметр або вектор використовується для адаптації загальної функції лінійної регресії до тренувальних даних, що лежать в основі. Параметр <code class=" language-none">θ</code>, що використовується у програмі, буде налаштований у процесі навчання, базуючись на прикладах тренувань. Якість навченої цільової функції залежатиме від якості підготовлених для навчання даних. У прикладі нижче ми використовуємо <code class=" language-none">LinearRegressionFunction</code>для ілюстрації прогнозування ціни, базуючись на розмірі будинку. Зважаючи на те, що x <sub>0</sub> має бути константою зі значенням 1.0, цільова функція ініціалізується, використовуючи два параметри<code class=" language-none">θ</code>, у своїй є результатом процесу навчання. Після створення нового прикладу, ціна будинку площею 1330 квадратних метрів передбачатиметься як показано нижче: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token comment"><span class="token comment">// тета вектор, используемый в этом примере, является результатом процесса обучения</span></span>
<span class="token keyword"><span class="token keyword">double</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> thetaVector <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token keyword"><span class="token keyword">double</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span> <span class="token number"><span class="token number">1.004579</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token number"><span class="token number">5.286822</span></span> <span class="token punctuation"><span class="token punctuation">}</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token class-name"><span class="token class-name">LinearRegressionFunction</span></span> targetFunction <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">LinearRegressionFunction</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>thetaVector<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>

<span class="token comment"><span class="token comment">// создание вектора признаков со значениями x0=1 (для удобства вычислений) и //x1=площадь дома</span></span>
<span class="token class-name"><span class="token class-name">Double</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> featureVector <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">Double</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span> <span class="token number"><span class="token number">1.0</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token number"><span class="token number">1330.0</span></span> <span class="token punctuation"><span class="token punctuation">}</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>

<span class="token comment"><span class="token comment">// выполняем расчеты</span></span>
<span class="token keyword"><span class="token keyword">double</span></span> predictedPrice <span class="token operator"><span class="token operator">=</span></span> targetFunction<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">apply</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>featureVector<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> На малюнку нижче можна бачити графік цільової функції передбачень (синя лінія). Він отриманий шляхом обчислення цільової функції всім значень площі будинку. Графік також містить пари ціна-площа, що використовуються для навчання. 
<div class="row justify-content-center jr-image-wrap">
 <div class="col-12 col-sm-10 col-md-8">
  <img data-id="f412d9a1-3a85-4992-9cec-a2fa1b98c2ce" data-max-width="710" alt="Машинне навчання для Java-розробників, частина 1 - 4" src="https://cdn.javarush.com/images/article/f412d9a1-3a85-4992-9cec-a2fa1b98c2ce/512.jpeg" style="width: 710px;">
 </div>
</div>Зараз графік прогнозів виглядає досить добре. Координати графіка (положення та нахил) визначаються вектором <code class=" language-none">θ { 1.004579, 5.286822 }</code>. Але як визначити, що саме цей <code class=" language-none">θ</code>-вектор найкраще підходить для вашого застосування? Чи буде функція відповідатиме краще, якщо ви зміните перший або може бути другий параметр? Для визначення найбільш відповідного вектора тета вам потрібна функція корисності, яка буде оцінювати наскільки добре цільова функція справляється з цим завданням. <em><strong><a href="https://codegym.cc/groups/posts/536-mashinnoe-obuchenie-dlja-java-razrabotchikov-chastjh-2" target="_blank">ПРОДОВЖЕННЯ СЛІД </a></strong></em> <em><strong><a href="https://www.javaworld.com/article/3224505/application-development/machine-learning-for-java-developers.html" target="_blank">Переклад</a> з англійської. Автор - Грегор Рот (Gregor Roth), Software Architect, JavaWorld.</strong></em>
<table>
 <tbody>
  <tr>
   <th>Що ще почитати:</th>
  </tr>
  <tr>
   <td>
    <p><a href="https://codegym.cc/groups/posts/254-top-5-bibliotek-mashinnogo-obuchenija-dlja-java" target="_blank">Топ 5 бібліотек машинного навчання для Java</a></p>
    <p><a href="https://codegym.cc/groups/posts/463-5-tekhnologicheskikh-tendenciy-dlja-postroenija-uspeshnoy-karjherih-v-2018" target="_blank">5 технологічних тенденцій для побудови успішної кар'єри у 2018</a></p>
    <p><a href="https://codegym.cc/groups/posts/402-ne-pereocenivaem-li-mih-mashinnoe-obuchenie-" target="_blank">Чи не переоцінюємо ми машинне навчання?</a></p></td>
  </tr>
 </tbody>
</table>