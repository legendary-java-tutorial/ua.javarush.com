Серіалізація як вона є. Частина 2
<p>----------------------------------------</p>
Як я вже казав, стандартна серіалізація працює через Reflection API. Що означає, що для серіалізації береться клас об'єкта, що серіалізується, у нього береться список полів, по всіх полях у циклі перевіряються різні умови ( чи ні, якщо об'є
<p>----------------------------------------</p>
<h4>Продуктивність</h4> Як я вже казав, стандартна серіалізація працює через Reflection API. Що означає, що для серіалізації береться клас об'єкта, що серіалізується, у нього береться список полів, по всіх полях у циклі перевіряються різні умови ( <strong>transient</strong> чи ні, якщо об'єкт, то <strong>Externalizable</strong> або <strong>Serializable</strong> ), значення пишуться в потік, причому дістаються з полів теж через <strong>reflection</strong> ... Загалом, ситуація зрозуміла. На противагу цьому методу, вся процедура при використанні розширеної серіалізації контролюється самим розробником. Залишилося з'ясувати, які переваги це дає за швидкістю. Отже, умови тестування. Об'єкт довільної структури. Два варіанти – один <strong>Serializable</strong> , другий <strong>Externalizable</strong>. Деяка кількість об'єктів обох варіантів ініціалізується довільними (ідентичними для кожної пари об'єктів) даними, після чого міститься в контейнері. Контейнер теж в одному випадку <strong>Serializable</strong> , в іншому <strong>Externalizable</strong> . Далі контейнери будуть серіалізовані та десеріалізовані із вимірами часу. Повний код тесту разом з <strong>build</strong> -файлом для ant можна знайти тут - serialization.zip (завантажити можна з сайту-першоджерела). У тексті я наводитиму лише уривки. Об'єкт, що серіалізується, містить наступний набір полів: <code class=" language-none">private int fieldInt; private boolean fieldBoolean; private long fieldLong; private float fieldFloat; private double fieldDouble; private String fieldString;</code> Тест містить три реалізації <strong>Externalizable</strong> контейнерів. Перша з них, <strong>ContainerExt1</strong> , найпростіша. Це просто серіалізація містить об'єкти <strong>java.util.List</strong>: Друга реалізація <strong>ContainerExt2</strong> серіалізує послідовно всі наявні об'єкти, передуючи їх кількістю:<code class=" language-none">public void writeExternal(ObjectOutput out) throws IOException { out.writeObject(items); } public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { items = (List<itemext>
  )in.readObject(); }
 </itemext></code><strong></strong><cut>
 <code class=" language-none">public void writeExternal(ObjectOutput out) throws IOException { out.writeInt(items.size()); for(Externalizable ext : items) out.writeObject(ext); } public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { int count = in.readInt(); for(int i=0; i<count; i++){="" itemext="" ext="(ItemExt)in.readObject();" items.add(ext);="" }="" }<="" code="">
   Третья реализация, 
   <strong>ContainerExt3</strong>, использует 
   <strong>externalizable</strong>-методы об'єктов: 
   <code>public void writeExternal(ObjectOutput out) throws IOException { out.writeInt(items.size()); for(Externalizable ext : items) ext.writeExternal(out); } public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { int count = in.readInt(); for(int i=0; i<count; i++){="" itemext="" ext="new" itemext();="" ext.readexternal(in);="" items.add(ext);="" }="" }<="" code="">
     Запускается тест с помощью команды ant (поскольку задача run запускается по умолчанию). В build-файле задано количество создаваемых об'єктов – 100000. Другое количество может быть задано с помощью параметра командной строки -Dobjcount=
     <value>
      . Итак, яковы результаты выполнения теста? На 100000 создаваемых об'єктов (результаты могут незначительно отличаться от запуска к запуску): 
      <code>Creating 100000 objects Serializable: written in 3516ms, readed in 3235 Externalizable1: written in 4046ms, readed in 3234 Externalizable2: written in 3875ms, readed in 2985 Externalizable3: written in 235ms, readed in 297</code> И размеры сериализованных данных (размеры файлов на диске): 
      <code>cont.ser 5 547 955 contExt1.ser 5 747 884 contExt2.ser 5 747 846 contExt3.ser 4 871 461</code> Що мы видим? Первый способ реализации 
      <strong>Externalizable</strong> даже несколько хуже стандартной сериализации. Сериализация занимает немного больше времени, десериализация сравнима. Размеры файлов тоже немного в пользу стандартной сериализации. Вывод – простейшая сериализация контейнера преимуществ не дает: +15% при сериализации, десериализация отличается на доли процента, причем як в одну, так и в другую сторону. Второй способ реализации 
      <strong>Externalizable</strong> по характеристикам практически идентичен первому. Чуть быстрее сериализация, но все равно проигрывает стандартной, десериализация чуть выигрывает. Размер файлу практически идентичен первому способу (разница – 38 байт). Выигрыша по сравнению со стандартной сериализацией нет – +10% при сериализации, -8% при десериализации. Третий способ реализации 
      <strong>Externalizable</strong>. Вот тут есть на что посмотреть! Сериализация быстрее в 15 раз! Естественно, плюс-минус, но тем не менее – разница на порядок! Десериализация быстрее практически в 11 раз! Різниця тоже на порядок! Опять же плюс-минус, но мне не удавалось получить разницу меньше, нежели в 5 раз. Ну и разница в размере файлу -13%. Как маленькое, но приятное дополнение. Думаю, комментарии излишни. Получаемые от грамотной реализации 
      <strong>Externalizable</strong> преимущества в скорости с лихвой компенсируют затраты на эту самую реализацию. Грамотной – в смысле, целиком и повністю реализованной самостоятельно, без использования имеющихся механизмов сериализации целых об'єктов (в основном это методы writeObject/readObject). Использование же имеющихся механизмов и/або смешивание со стандартной сериализацией способно свести скоростные преимущества 
      <strong>Externalizable</strong> на нет. Однако есть и ... 
      <h4>Обратная сторона медали</h4> И прежде всего это нарушение цілісності графа. Поскольку протокол сериализации не используется – контроль цілісності остается на самом разработчике. И об этом следует помнить, ибо в некоторых случаях можно легко убить все преимущества. Если, к примеру, необходимо сериализовать очень много экземпляров класса A, каждый из которых ссылается на единственный экземпляр класса B, то при неумелом использовании 
      <strong>Externalizable</strong> может получиться так, что экземпляр B будет сериализован по разу на каждый экземпляр A, что даст потерю як в скорости, так и в объеме сериализованных данных. А при десериализации мы вообще получим кучу экземпляров B замість одного! Що намного хуже. Поэтому, да и не только, 
      <strong>Externalizable</strong> следует использовать обдуманно. Как, впрочем, и любую другую возможность. Если необходимо сериализовать достаточно сложные графы – пожалуй, лучше все-таки воспользоваться имеющимися механизмами. Если же объемы данных большие, но сложность невелика – можно немного поработать и получить солидный выигрыш в скорости. В любом случае лучше написать небольшой прототип и уже на нем оценивать реальную швидкість и сложность реализации цілісності. Перейдем к следующему вопросу, связанному с сериализацией. 
      <h4>Безопасность данных</h4> Есть такое правило: проверять входящие данные (входные параметры функций и т.п.) на "правильность" – соответствие определенным требованиям. Причем это не столько правило хорошего тона, сколько правило выживания програми. Ибо если этого не сделать, то при передаче неверных параметров в лучшем случае (действительно – в лучшем!) приложение просто "упадет". В худшем случае оно тихо примет предложенные данные и может нанести значительно больший урон. Про это правило худо-бедно, но помнят. Однако конструкторы и открытые методы – не единственный способ поставки данных об'єкту. Точно так же об'єкт может быть создан с помощью десериализации. И вот тут о контроле внутреннего состояния полученного об'єкта, як правило, забывают. Между тем, создать поток для получения из него об'єкта с неверным внутренним состоянием не легко, а очень легко. Пример номер один. Объект с двумя полями типа 
      <strong>java.util.Date</strong>. Одно поле – начало интервала времени, другое – конец. Следовательно, между ними должно существовать определенное соотношение (конец должен быть не раньше начала). Однако любой человек, знающий байткод, сумеет отредактировать сериализованный об'єкт так, что после десериализации конец интервала будет раньше начала. К чему приведет появление в системе такого об'єкта – предугадать сложно. В любом случае, ничего хорошего ждать не приходится. Потому, примите для себя... 
      <blockquote>
       Правило 1. После десериализации об'єкта необходимо проверить его внутреннее состояние (инварианты) на правильность, точно так же, як и при создании с помощью конструктора. Если об'єкт не прошел такую проверку, необходимо инициировать исключение <strong>java.io.InvalidObjectException</strong>.
      </blockquote> Пример номер два. Объект класса A содержит в себе 
      <strong>private</strong>-поле типа 
      <strong>java.util.Date</strong>. Для изменения снаружи об'єкта это поле недоступно. Однако возможна следующая операция: к потоку дописывается некоторая информация. Потом, после десериализации из этого потока об'єкта класса 
      <strong>A</strong> производится десериализация еще одного об'єкта, но уже типа 
      <strong>Date</strong>. Как мы уже видели в примере ранее, можно создать такой поток (в примере он создавался легально), что при десериализации этот второй об'єкт в действительности будет лишь ссылкой на экземпляр 
      <strong>Date</strong>, казалось бы так надежно спрятанный внутри об'єкта класса 
      <strong>A</strong>. Соответственно, с этим экземпляром можно делать все, что заблагорасудится. 
      <blockquote>
       Не буду вдаваться в подробности. Описание этого приема есть в книге Джошуа Блох. Java. Эффективное программирование, в статье 56. Скажу только, что достаточно к потоку дописать 5 байт, чтобы добиться желаемого.
      </blockquote> Щобы этого избежать, необходимо следовать следующему правилу: 
      <blockquote>
       Правило 2. Если в составе класса A присутствуют об'єкты, которые не должны быть доступными для изменения извне, то при десериализации экземпляра класса A необходимо замість этих об'єктов создать и сохранить их копии.
      </blockquote> Приведенные выше примеры показывают возможные "дыры" в безопасности. Следование упомянутым правилам, разумеется, не спасает от проблем, но может существенно снизить их количество. Советую по этому поводу почитать книгу Джошуа Блох. Java. Эффективное программирование, статью 56. Ну и последняя тема, которой я хотел бы коснуться – 
      <h4>Сериализация об'єктов Singleton</h4> Тех, кто не в курсе, что такое 
      <strong>Singleton</strong>, отсылаю к 
      <a href="http://www.skipy.ru/technics/singleton.html" rel="nofollow">отдельной статье</a>. В чем проблема сериализации 
      <strong>Singleton</strong>-ов? А проблема в уже упомянутом мной факте – после десериализации мы получим другой об'єкт. Это видно в результатах первого из тестов в этой статье – ссылки на исходный и десериализованный об'єкты не совпадают. Таким образом, сериализация дает возможность создать Singleton еще раз, что нам совсем не нужно. Можно, конечно, запретить сериализовать 
      <strong>Singleton</strong>-ы, но это, фактически, уход от проблемы, а не ее решение. Решение же заключается в следующем. В классе определяется метод со следующей сигнатурой 
      <code>ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException</code> Модификатор доступа может быть 
      <strong>private</strong>, 
      <strong>protected</strong> и по умолчанию 
      <strong>(default)</strong>. Можно, наверное, сделать его и public, но смысла я в этом не вижу. Назначення этого метода – возвращать замещающий об'єкт замість об'єкта, на котором он вызван. Приведу простой пример: 
      <code>public class Answer implements Serializable{ private static final String STR_YES = "Yes"; private static final String STR_NO = "No"; public static final Answer YES = new Answer(STR_YES); public static final Answer NO = new Answer(STR_NO); private String answer = null; private Answer(String answer){ this.answer = answer; } private Object readResolve() throws ObjectStreamException{ if (STR_YES.equals(answer)) return YES; if (STR_NO.equals(answer)) return NO; throw new InvalidObjectException("Unknown value: " + answer); } }</code> Класс, приведенный выше – простейший перечислимый тип. Всего два значения – 
      <strong>Answer.YES</strong> и 
      <strong>Answer.NO</strong>. Соответственно, именно эти два значения и должны фигурировать после десериализации. Що делается в методе readResolve? Он вызывается на десериализованном об'єкте. И возвращать он должен уже существующий экземпляр класса, соответствующий внутреннему состоянию десериализованного об'єкта. В данном примере – проверяется значення поля 
      <strong>answer</strong>. Если об'єкт, соответствующий внутреннему состоянию, не найден... На мой взгляд, это зависит от ситуации. В приведенном примере стоит инициировать исключение. Возможно, в яких-то ситуациях будет полезно вернуть 
      <strong>this</strong>. Примером этого, например, является реализация 
      <strong>java.util.logging.Level</strong>. Существует и обратный метод – 
      <strong>writeReplace</strong>, который, як вы, наверное, уже догадались, позволяет выдать замещающий об'єкт замість текущего, для сериализации. Мне, честно сказать, трудно представить себе ситуации, в которых это может понадобиться. Хотя в недрах кода Sun он як-то используется. Оба метода, як 
      <strong>readResolve</strong>, так и 
      <strong>writeReplace</strong>, вызываются при использовании стандартных средств сериализации (методов readObject и writeObject), вне зависимости от того, объявлен ли сериализуемый класс як 
      <strong>Serializable</strong> або 
      <strong>Externalizable</strong>. Самое интересное, что, похоже, из этих методов можно возвращать не только экземпляр класса, в котором этот метод определен, но и экземпляр другого класса. Я видел подобные примеры в глубинах библиотек Sun, во всяком случае, для writeReplace – точно видел. Но по яким принципам можно это делать – не берусь пока судить. Вообще, советую интересующимся просмотреть исходники J2SE 5.0, причем полные. Они доступны по лицензии JRL. Там есть много интересных примеров использования этих методов. Исходники можно взять тут – 
      <a href="http://www.oracle.com/technetwork/java/index.html" rel="nofollow">http://java.sun.com/j2se/jrl_download.html</a>. Правда, требуется регистрация, но она, естественно, бесплатна. Отдельно хочу коснуться сериализации перечислений (enum), появившихся в Java 5.0. Поскольку при сериализации в поток пишется ім'я елемента и его порядковый номер в определении в классе, можно было бы ожидать проблем при десериализации в случае изменения порядкового номера (что может случиться очень легко – достаточно поменять элементы местами). Однако, к счастью, таких проблем нет. Десериализация об'єктов типа enum контролируется для обеспечения соответствия десериализуемых экземпляров уже имеющимся у виртуальной машины. Фактически, это то, что делает обычно метод 
      <strong>readResolve</strong>, но реализовано где-то существенно глубже. Сопоставление об'єктов осуществляется по имени. Разработчикам версии 5.0 – респект! * * * Наверное, на текущий момент это все, что я хотел рассказать о сериализации. Думаю, теперь она не кажется такой простой, якой казалась до прочтения этой статьи. И хорошо. Пребывание в блаженном неведении к добру не приводит. Ссылка на первоисточник: http://www.skipy.ru/technics/serialization.html
     </value>
    </count;></code>
  </count;></code>
</cut>