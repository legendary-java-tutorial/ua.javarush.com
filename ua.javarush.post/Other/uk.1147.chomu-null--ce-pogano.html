Чому NULL – це погано?
<p>----------------------------------------</p>
Ось простий приклад використання NULL Java: Що не так з цим методом? Він може повернути NULL замість об'єкта – що не так. Використання NULL – жахлива практика в ОВП, і це варто уникати всіма способами. Щодо цього питання вже опубліковано до
<p>----------------------------------------</p>
<h4>Чому NULL – це погано?</h4> Ось простий приклад використання NULL Java: <code class=" language-none">public Employee getByName(String name) { int id = database.find(name); if (id == 0) { return null; } return new Employee(id); } </code> Що не так з цим методом? Він може повернути NULL замість об'єкта – що не так. Використання NULL – жахлива практика в ОВП, і це варто уникати всіма способами. Щодо цього питання вже опубліковано досить різних думок, у тому числі презентація Tony Hoare <a href="http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare" rel="nofollow">«Нульові посилання: Помилка на мільярд доларів»</a> та ціла книга David West <a href="http://www.amazon.com/gp/product/0735619654/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0735619654&amp;linkCode=as2&amp;tag=yegor256com-20&amp;linkId=NQQHJZPHOKM6BTCT" rel="nofollow">«Об'єктно орієнтоване мислення». </a> Тут я спробую підсумувати всі докази та показати приклади того, як можна уникнути використання NULL, замінивши його відповідними об'єктно-орієнтованими конструкціями. Спочатку розглянемо дві можливі альтернативи NULL.<cut>
 Перша – це патерн проектування 
 <a href="http://en.wikipedia.org/wiki/Null_Object_pattern" rel="nofollow">«Нульовий Об'єкт»</a> (найкраще реалізовувати його за допомогою константи): 
 <code class=" language-none">public Employee getByName(String name) { int id = database.find(name); if (id == 0) { return Employee.NOBODY; } return Employee(id); } </code> Друга можлива альтернатива – 
 <a href="http://martinfowler.com/ieeeSoftware/failFast.pdf" rel="nofollow">«швидка поразка»</a> через викидання винятку у разі, якщо повернути об'єкт неможливо: 
 <code class=" language-none">public Employee getByName(String name) { int id = database.find(name); if (id == 0) { throw new EmployeeNotFoundException(name); } return Employee(id); } </code> А тепер давайте познайомимося з доводами проти використання NULL. посту я познайомився, крім вищезгаданих презентації Tony Hoare І книги David West, з цілим рядом публікацій. Це 
 <a href="http://www.amazon.com/dp/0132350882/" rel="nofollow">"Чистий код"</a> Robert Martin, 
 <a href="http://www.amazon.com/dp/0735619670/" rel="nofollow">"Довершений код"</a> Steve McConnell, 
 <a href="http://elegantcode.com/2010/05/01/say-no-to-null/" rel="nofollow">"Скажіть "Ні" NULL"</a> John Sonmez і дискусією на StackOverflow під назвою 
 <a href="http://stackoverflow.com/questions/1274792/is-returning-null-bad-design" rel="nofollow">"Повертати NULL - погана практика?"</a>
 <h5>Обробка помилок вручну</h5> Щоразу, коли ви на вході отримуєте об'єкт, ви повинні перевіряти, чи є він посиланням на дійсний об'єкт або NULL'ом. Якщо ви забудете перевірити, вашу програму можна перервати прямо під час виконання викинутим 
 <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/NullPointerException.html" rel="nofollow">NullPointerExeption</a> (NPE). Через це ваш код починає наповнюватися численними перевірками та розгалуженнями if/then/else. 
 <code class=" language-none">// this is a terrible design, don't reuse Employee employee = dept.getByName("Jeffrey"); if (employee == null) { System.out.println("can't find an employee"); System.exit(-1); } else { employee.transferTo(dept2); } </code> Саме так виняткові ситуації повинні оброблятись в 
 <a href="http://en.wikipedia.org/wiki/C_%28programming_language%29" rel="nofollow">С</a> та інших строго процедурних мовах програмування. В ООП 
 <a href="http://en.wikipedia.org/wiki/Exception_handling" rel="nofollow">обробка винятків</a>введена головним чином саме для того, щоб позбутися вручну написаних блоків обробки. В ООП ми дозволяємо виключенням спливати доки вони не досягнуть обробника помилок усієї програми, і завдяки цьому наш код стає набагато чистішим і коротшим: 
 <code class=" language-none">dept.getByName("Jeffrey").transferTo(dept2); </code> Вважайте NULL посилання пережитками процедурного стилю програмування і використовуйте 1) Нульові Об'єкти або 2) Винятки замість них. 
 <h5>Неоднозначне розуміння</h5> Щоб точно передати в назві зміст того, що відбувається, метод 
 <code class=" language-none">getByName()</code> має бути перейменований на 
 <code class=" language-none">getByNameOrNullIfNotFound()</code>. Те саме потрібно зробити для кожного методу, який повертає об'єкт або NULL, інакше при читанні коду не уникнути неоднозначності. Таким чином, щоб назви методів були точні, ви повинні давати методам більш довгі імена. Щоб уникнути неоднозначності, завжди повертайте реальний об'єкт, нульовий об'єкт або викидайте виняток. Хтось може заперечити, що іноді нам просто необхідно повернути NULL щоб досягти потрібного результату. Наприклад, метод 
 <code class=" language-none">get()</code>інтерфейсу 
 <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Map.html" rel="nofollow">Map</a> Java повертає NULL, коли в Map немає більше об'єктів. 
 <code class=" language-none">Employee employee = employees.get("Jeffrey"); if (employee == null) { throw new EmployeeNotFoundException(); } return employee; </code> Завдяки використанню NULL у Map цьому коду вистачає лише одного циклу пошуку для отримання результату. Якщо ми перепишемо Map таким чином, щоб метод get() викидав виняток у випадку, якщо нічого не знайдено, наш код буде виглядати так: Очевидно, 
 <code class=" language-none">if (!employees.containsKey("Jeffrey")) { // first search throw new EmployeeNotFoundException(); } return employees.get("Jeffrey"); // second search </code> що цей метод вдвічі повільніший, ніж вихідний. Що ж робити? В інтерфейсі Map (без наміру образити розробників) є недолік проектування. Його метод get() мав би повертати Iterator, і тоді наш код виглядав би так: 
 <code class=" language-none">Iterator found = Map.search("Jeffrey"); if (!found.hasNext()) { throw new EmployeeNotFoundException(); } return found.next(); </code> До речі, саме так спроектований метод STL 
 <a href="http://en.cppreference.com/w/cpp/container/map/find" rel="nofollow">map::find()</a> С++. 
 <h5>Комп'ютерне мислення проти об'єктно-орієнтованого</h5> Рядок коду 
 <code class=" language-none">if (employee == null)</code> цілком зрозумілий тому, хто знає, що об'єкт у Java – це покажчик на структуру даних, а NULL – це покажчик на ніщо (у процесорах Intel x86 – 0x00000000). Однак якщо ви почнете мислити в об'єктному стилі, цей рядок стає набагато менш осмисленим. Ось як наш код виглядає з об'єктної точки зору: 
 <blockquote>
  - Здрастуйте, це відділ розробки ПЗ? - Так. - Будьте ласкаві, запитіть до телефону вашого співробітника Джефрі. - Зачекайте хвабонку... - Здрастуйте. - Ви NULL?
 </blockquote> Останнє питання звучить трохи дивно, чи не так? Якщо замість цього після вашого прохання запитити до телефону Джефрі на тому кінці просто повісять слухавку, це викличе для нас певні складнощі (Виняток). У цьому випадку ми можемо спробувати передзвонити або доповімо нашому начальнику про те, що ми не змогли поговорити з Джефрі, і завершимо своє основне завдання. Крім цього, на тій стороні вам можуть запропонувати поговорити з іншою людиною, яка, хоч і не є Джефрі, може допомогти вам з більшістю ваших питань, або відмовитися допомагати, якщо нам потрібно дізнатися щось, що знає тільки Джефрі (Нульовий Об'єкт). ). 
 <h5>Повільний провал</h5> Замість 
 <a href="http://martinfowler.com/ieeeSoftware/failFast.pdf" rel="nofollow">швидкого завершення роботи</a>, код вище намагається померти повільно, вбиваючи інших на своєму шляху. Замість того, щоб дати всім зрозуміти, що щось пішло не так і потрібно негайно розпочинати обробку виняткової події, він намагається приховати свій провал від клієнта. Це дуже схоже на ручну обробку винятків, про яку ми говорабо вище. Робити свій код якомога крихкішим і дозволяти йому перериватися, якщо це потрібно – хороша практика. Робіть свої методи дуже вимогливими до даних, з якими вони працюють. Дозволяйте їм скаржитися, викидаючи винятки, якщо даних, які їм надали, недостатньо, або дані просто не підходять для використання в цьому методі за задуманим сценарієм. В іншому випадку повертайте Нульовий Об'єкт, який веде себе якимось загальноприйнятим способом і викидає винятки у всіх інших випадках. 
 <code class=" language-none">public Employee getByName(String name) { int id = database.find(name); Employee employee; if (id == 0) { employee = new Employee() { @Override public String name() { return "anonymous"; } @Override public void transferTo(Department dept) { throw new AnonymousEmployeeException( "I can't be transferred, I'm anonymous" ); } }; } else { employee = Employee(id); } return employee; } </code>
 <h5>Змінювані та незавершені об'єкти</h5> Взагалі 
 <a href="http://www.yegor256.com/2014/06/09/objects-should-be-immutable.html" rel="nofollow">суворо рекомендується</a> проектувати об'єкти так, щоб вони були незмінними. Це означає, що об'єкт повинен отримати всі необхідні дані при його створенні і ніколи не змінювати свого стану протягом усього життєвого циклу. Значення NULL дуже часто використовуються в патерні проектування 
 <a href="http://en.wikipedia.org/wiki/Lazy_loading" rel="nofollow">«Лінива завантаження»</a> для того, щоб зробити об'єкти незавершеними та змінними. Приклад: 
 <code class=" language-none">public class Department { private Employee found = null; public synchronized Employee manager() { if (this.found == null) { this.found = new Employee("Jeffrey"); } return this.found; } } </code> Незважаючи на те, що ця технологія поширена, для ООП вона є антипаттерном. І головним чином тому, що змушує об'єкт відповідати за проблеми з продуктивністю у обчислювальної платформи, а це саме те, про що об'єкт Employee не може бути обізнаний. Замість того, щоб керувати своїм станом і вести себе таким чином, об'єкт змушений дбати про кешування своїх власних результатів – ось до чого призводить «лінива завантаження». Адже кешування - це зовсім не те, чим займається співробітник в офісі, чи не так? Вихід? Не використовуйте «ліниве завантаження» таким примітивним способом, як у наведеному вище прикладі. Натомість перемістіть кешування проблем на інший рівень своєї програми. Наприклад, у Java можна використовувати можливості аспектно-орієнтованого програмування. Наприклад, в
 <a href="http://aspects.jcabi.com/" rel="nofollow">jcabi-aspects</a> є інструкція 
 <a href="http://aspects.jcabi.com/annotation-cacheable.html" rel="nofollow">@Cacheable</a> , яка кешує значення, що повертається способом. 
 <code class=" language-none">import com.jcabi.aspects.Cacheable; public class Department { @Cacheable(forever = true) public Employee manager() { return new Employee("Jacky Brown"); } } </code> Сподіваюся, цей аналіз був досить переконливий, щоб ви припинабо обнулювати свій код :) Оригінал статті 
 <a href="http://www.yegor256.com/2014/05/13/why-null-is-bad.html#ambiguous-semantic" rel="nofollow">тут</a> . Вам також можуть бути цікаві такі теми як: • 
 <a href="http://www.yegor256.com/2014/10/03/di-containers-are-evil.html" rel="nofollow">DI Containers are Code Polluters</a> • 
 <a href="http://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html" rel="nofollow">Getters/Setters. Evil. Період. </a> • 
 <a href="http://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html" rel="nofollow">Anti-Patterns in OOP</a> • 
 <a href="http://www.yegor256.com/2014/06/19/avoid-string-concatenation.html" rel="nofollow">Avoid String Concatenation</a> • 
 <a href="http://www.yegor256.com/2014/06/09/objects-should-be-immutable.html" rel="nofollow">Objects Should Be Immutable</a>
</cut>