Правила написання коду: від створення системи до роботи з об'єктами
<p>----------------------------------------</p>
Усім доброго дня: сьогодні мені хотілося б поговорити з вами про правильне написання коду. Коли я тільки починав програмувати, ніде не було чітко написано, що так писати можна, а якщо ось так напишеш, я знайду тебе і…. У результаті в голові
<p>----------------------------------------</p>
Усім доброго дня: сьогодні мені хотілося б поговорити з вами про правильне написання коду. Коли я тільки починав програмувати, ніде не було чітко написано, що так писати можна, а якщо ось так напишеш, я знайду тебе і…. У результаті в голові я мала велику кількість питань: а як правильно писати, яких принципів варто дотримуватися в тій чи іншій ділянці програми і т.д. <img alt="Правила написання коду: від створення системи до роботи з об'єктами." src="https://codegym-com.translate.goog/images/article/790a7792-f7d3-4638-acaa-9a967cb71a7f/original.png">Ну, не всім ось так відразу хочеться вгризатися в книги типу Clean Code, тому що написано в них багато, а спочатку мало зрозуміло. Та й доки дочитаєш, все бажання кодувати можна відбити. Тому виходячи зі всього вищесказаного, сьогодні я хочу надати вам невеликий посібник (зведення невеликих рекомендацій) для написання більш високорівневого коду. У цій статті пройдемося за основними правилами та концепціями, які стосуються створення системи, роботи з інтерфейсами, класами та об'єктами. Прочитання цього матеріалу не займе у вас багато часу і, сподіваюся, не дасть нудьгувати. Я піду “згори донизу”, тобто від загальної структури додатка до більш вузьконаправлених деталей. <img alt="Правила написання коду: від створення системи до роботи з об'єктами." src="https://codegym-com.translate.goog/images/article/5046de52-1296-44e7-9d79-da8f4f610957/original.jpg">
<h2>Система</h2>Загальні бажані <span>характеристики системи</span> такі: 
<ul>
 <li><span>мінімальна складність</span> – необхідно уникати надто ускладнених проектів. Головне - це простота та зрозумілість (краще = просте);</li>
 <li><span>простота супроводу</span> - при створенні додатка необхідно пам'ятати, що його потрібно буде підтримувати (навіть якщо це не ви), тому код повинен бути зрозумілим і очевидним;</li>
 <li><span>слабке сполучення</span> – це мінімальна кількість зв'язків між різними частинами програми (максимальне використання принципів ОВП);</li>
 <li><span>можливість перевикористання</span> - проектування системи з можливістю перевикористовувати її фрагменти в інших додатках;</li>
 <li><span>портованість</span> - система повинна бути легко адаптована до іншого середовища;</li>
 <li>єдиний стиль — проектування системи у єдиному стилі у її фрагментах;</li>
 <li><span>розширюваність (масштабованість)</span> — покращення системи без порушення її базової структури (якщо додати або змінити якийсь фрагмент, це не повинно впливати на інші).</li>
</ul>Побудувати програму, яка не потребує доробок, без додавання функціоналу, — фактично неможливо. Нам завжди потрібно буде вводити нові елементи, щоб наше дітище могло йти в ногу з часом. І тут на сцену виходить <span>масштабованість</span> . <span>Маштабованість</span> - це по суті розширення програми, додавання нового функціоналу, робота з великою кількістю ресурсів (або, по-іншому, з більшим навантаженням). Тобто ми повинні дотримуватись деяких правил, таких як зменшення зв'язаності системи за рахунок збільшення модульності, щоб було простіше додавати нову логіку. 
<h3>Етапи проектування системи</h3>
<ol>
 <li><span>Програмна система</span> - проектування програми у загальному вигляді.</li>
 <li><span>Поділ на підсистеми/пакети</span> - визначення частин, що логічно розділяються, і визначення правил взаємодії між ними.</li>
 <li><span>Поділ підсистем на класи</span> — поділ частин системи, на конкретні класи та інтерфейси, і навіть визначення взаємодії з-поміж них.</li>
 <li><span>Поділ класів на методи</span> - повне визначення необхідних методів для класу, виходячи із завдання цього класу. Проектування методів – детальне визначення функціональності окремих методів.</li>
</ol>Зазвичай проектуванням і займаються рядові розробники, а тими пунктами, що описані вище, — архітектор програми. 
<h3>Основні принципи та концепції проектування системи</h3><span>Ідіома відкладеної ініціалізації</span> Програма не витрачає час на створення об'єкта до моменту його безпосереднього використання, що прискорює процес ініціалізації та зменшує завантаження збирача сміття. Але свою чергу, з цим не варто перегинати, оскільки це може призвести до порушення модульності. Можливо, варто перенести всі моменти конструювання в певну частину, наприклад, main, або в клас, що працює за <a href="https://codegym.cc/groups/posts/2370-pattern-proektirovanija-factory" target="_blank" rel="nofollow">принципом фабрики</a> . Один з аспектів якісного коду - відсутність шаблонного коду, що часто повторюється. Як правило, такий код виноситься до окремого класу, щоб його можна було викликати в потрібний момент. <span>АОП</span> Окремо хотілося б відзначити <span>аспектно орієнтоване програмування</span>. Це програмування шляхом впровадження наскрізної логіки, тобто код, що повторюється, виноситься в класи — аспекти, і викликається при досягненні певних умов. Наприклад, при зверненні до методу із певною назвою або звернення до змінної певного типу. Іноді аспекти можуть плутати, оскільки не відразу зрозуміло, звідки викликається код, проте це дуже корисний функціонал. Зокрема, при кешуванні чи логуванні: ми навішуємо цей функціонал, при цьому не додаючи додаткову логіку до звичайних класів. Почитати більше про оап можна <a href="https://habr.com/ru/post/114649/" target="_blank" rel="nofollow">тут</a> . <span>4 правила проектування простої архітектури Згідно з Кентом Беком</span>
<ol>
 <li><span>Виразність</span> - необхідність чітко вираженої мети класу, досягається шляхом правильного іменування, невеликого розміру та дотримання принципу single responsibility (трохи нижче розглянемо докладніше).</li>
 <li><span>Мінімум класів і методів</span> - у своєму прагненні розбити класи на якомога дрібніші і односпрямовані можна зайти занадто далеко (антипатерн - стрілянина дробом). Цей принцип закликає все ж таки зберігати компактність системи і не заходити занадто далеко, створюючи за класом на кожен чих.</li>
 <li><span>Відсутність дублювання</span> - зайвий код, який плутає, - ознака не кращого проектування системи, що виноситься в окреме місце.</li>
 <li><span>Виконання всіх тестів</span> - система, що пройшла всі тести, контрольована, оскільки будь-яка зміна може спричинити падіння тестів, що може показати нам - зміна внутрішньої логіки методу потягнула і зміна очікуваної поведінки.</li>
</ol><span>SOLID</span> При проектуванні системи варто враховувати й загальновідомі принципи SOLID: <span>S – single responsibility</span> – принцип єдиної відповідальності; <span>O - open-closed</span> - принцип відкритості/закритості; <span>L - Liskov substitution</span> - принцип підстановки Барбари Лисков; <span>I - interface segregation</span> - принцип поділу інтерфейсу; <span>D - dependency inversion</span> - принцип інверсії залежностей; Саме на кожному принципі зупинятися не будемо (це трохи виходить за межі цієї статті, але <a href="https://codegym.cc/groups/posts/osnovnye-principy-dizajna-klassov-solid-v-java" target="_blank" rel="nofollow">тут</a> можна ознайомитися докладніше 
<h2>Interface</h2>Мабуть, один із найважливіших етапів створення адекватного класу — це створення адекватного інтерфейсу, який представлятиме хорошу абстракцію, що приховує деталі реалізації класу, і при цьому представлятиме групу методів, які чітко узгоджуються між собою. Розглянемо докладніше один із принципів SOLID - <span>interface segregation</span> : клієнти (класи) не повинні реалізовувати непотрібні методи, які вони не будуть використовувати. Тобто, якщо йдеться про побудову інтерфейсів з мінімальною кількістю методів, спрямованих на виконання єдиного завдання цього інтерфейсу (як на мене, дуже схоже з <span>single responsibility</span>), краще замість одного роздутого інтерфейсу створити пару дрібніших. Добре, що клас може реалізовувати не один інтерфейс, як у випадку з успадкуванням. Також потрібно пам'ятати про правильне іменування інтерфейсів: назва повинна якнайточніше відображати його завдання. І, звичайно, чим воно буде коротшим, тим менше плутанини викличе. Саме на рівні інтерфейсів зазвичай пишуть <span>коментарі для документації</span> , які, у свою чергу, допомагають нам докладно описати, що метод повинен робити, які аргументи приймає і що він поверне. 
<h2>Клас</h2><img alt="Правила написання коду: від створення системи до роботи з об'єктами." src="https://codegym-com.translate.goog/images/article/016d670a-a878-49a2-acac-b376bef9833e/original.png">Розгляньмо внутрішню організацію класів. А точніше, деякі погляди та правила, яких варто дотримуватись при побудові класів. Як правило, клас повинен починатися зі списку змінних, розташованих у визначеному порядку: 
<ol>
 <li>public static константи;</li>
 <li>private static константи;</li>
 <li>private змінні екземпляра.</li>
</ol>Далі йдуть різноманітні конструктори в порядку від меншої кількості аргументів до більшого. Після них випливають методи від більш відкритого доступу до найбільш закритих: як правило приватні методи, що приховують реалізацію деякого функціоналу, який ми хочемо обмежити, стоять у самому низу. 
<h3>Розмір класу</h3>Тепер хотілося б поговорити про розмір класу. <img alt="Правила написання коду: від створення системи до роботи з об'єктами." src="https://codegym-com.translate.goog/images/article/8e7f2859-599f-486b-9c2b-ec6cd5cd805e/original.jpg">Згадаймо один із принципів SOLID - <span>single responsibility</span> . <span>Single responsibility</span> - принцип єдиної відповідальності. Він свідчить, що з кожного об'єкта є лише одне мета (відповідальність), і логіка всіх його методів спрямовано її забезпечення. Тобто виходячи з цього, ми повинні уникати великих, роздутих класів (що за своєю природою – антипатерн – «божественний об'єкт»), і якщо у нас дуже багато методів різноманітної, різнотипної логіки в класі, потрібно замислитися над тим, щоб розбити його на кілька логічних елементів (класів). Це, у свою чергу, підвищить читаність коду, тому що нам не потрібно багато часу, щоб зрозуміти мету методу, якщо ми знаємо зразкове призначення даного класу. Також потрібно і<span>стежити за ім'ям класу</span>: воно повинно відображати логіку, що міститься в ньому. Скажімо, якщо у нас клас, на ім'я якого 20+ слів, потрібно подумати про рефакторинг. У кожного класу, що поважає себе, має бути не така вже й велика кількість внутрішніх змінних. Фактично кожен метод працює з однією з них або з декількома, що викликає велику пов'язаність усередині класу (що і власне і має бути, тому що клас має бути як єдине ціле). Як результат, підвищення пов'язаності класу призводить до зменшення його як такого, та й, ясна річ, у нас збільшується кількість класів. Деяких це напружує, так треба більше ходити по класах, щоб побачити, як працює конкретне велике завдання. Крім того, кожен клас - це невеликий модуль, який повинен бути мінімально пов'язаний з іншими. Подібна ізольованість зменшує кількість змін, 
<h2>Об'єкти</h2><img alt="Правила написання коду: від створення системи до роботи з об'єктами." src="https://codegym-com.translate.goog/images/article/2b4c7260-ec49-4b23-9cfb-64d6af5453cd/original.png">
<h3>Інкапсуляція</h3>Тут ми насамперед поговоримо про один із принципів ОВП — <span>інкапсуляцію</span> . Отже, приховування реалізації не зводиться до створення прошарку методу між змінними (бездумне обмеження доступу через одиночні методи, гетери та сеттери, що не є добре, тому що весь сенс інкапсулювання втрачається). Приховування доступу спрямоване формування абстракцій, тобто клас надає загальні конкретні методи, з яких ми працюємо з нашими даними. А знати, як саме ми працюємо з цими даними, користувачеві не обов'язково працює та й добре. 
<h3>Закон Деметри</h3>Також можна розглянути закон «Деметри»: це невеликий набір правил, який допомагає в управлінні складністю на рівні класів та методів. Отже, припустимо, що у нас є об'єкт <code class=" language-none">Car</code>, і у нього є метод <code class=" language-none">move(Object arg1, Object arg2)</code>. Відповідно до закону Деметри, цей метод обмежується викликом: 
<ul>
 <li>методів самого об'єкта <code class=" language-none">Car</code>(інакше кажучи – this);</li>
 <li>методів об'єктів, створених у <code class=" language-none">move</code>;</li>
 <li>методів переданих об'єктів як аргументи - <code class=" language-none">arg1</code>, <code class=" language-none">arg2</code>;</li>
 <li>методів внутрішніх об'єктів <code class=" language-none">Car</code>(той же цей).</li>
</ul> Інакше кажучи, <span>закон «Деметри»</span> — це щось подібне до дитячого правила — <span>розмовляти можна з друзями, але не з чужинцями</span> . 
<h3>Структура даних</h3>Структура даних – це набір пов'язаних елементів. Під час розгляду об'єкта як структури даних — набір елементів даних, із якими працюють методи, існування яких мається на увазі неявно. Тобто це об'єкт, метою якого є зберігання та робота (обробка) даних, що зберігаються. Ключова відмінність від звичайного об'єкта полягає в тому, що об'єкт - це набір методів, які працюють з елементами даних, існування яких мається на увазі неявно. Розумієте? У звичайному об'єкті головним аспектом є методи, і внутрішні змінні спрямовані на їхню правильну роботу, а в структурі даних навпаки: методи підтримують, допомагають працювати з елементами, які тут і є головними. Один із різновидів структур даних — <span>Data Transfer Object (DTO)</span>. Це клас з відкритими змінними та без методів (або тільки методами для читання/запису), які передають дані при роботі з базами даних, працюють з парсингом повідомлень із сокетів тощо. Зазвичай у таких об'єктах дані довго не зберігаються і майже відразу конвертуються по суті, з якою і працює наша програма. Сутність, у свою чергу, теж виходить структурою даних, але її призначення — брати участь у бізнес-логіці на різних рівнях програми, а DTO — транспортувати дані в/з програми. Приклад DTO: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token annotation punctuation"><span class="token annotation punctuation">@Setter</span></span>
<span class="token annotation punctuation"><span class="token annotation punctuation">@Getter</span></span>
<span class="token annotation punctuation"><span class="token annotation punctuation">@NoArgsConstructor</span></span>
<span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">class</span></span> <span class="token class-name"><span class="token class-name">UserDto</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
    <span class="token keyword"><span class="token keyword">private</span></span> <span class="token keyword"><span class="token keyword">long</span></span> id<span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token keyword"><span class="token keyword">private</span></span> <span class="token class-name"><span class="token class-name">String</span></span> firstName<span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token keyword"><span class="token keyword">private</span></span> <span class="token class-name"><span class="token class-name">String</span></span> lastName<span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token keyword"><span class="token keyword">private</span></span> <span class="token class-name"><span class="token class-name">String</span></span> email<span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token keyword"><span class="token keyword">private</span></span> <span class="token class-name"><span class="token class-name">String</span></span> password<span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> Все як би відомо, але тут ми дізнаємося про існування гібридів. <span>Гібриди</span> – це об'єкти, які містять методи для обробки важливої ​​логіки та зберігають внутрішні елементи та методи доступу до них (get/set). Подібні об'єкти сумбурні і ускладнюють додавання нових методів. Не варто використовувати їх, тому що незрозуміло, для чого вони призначені для зберігання елементів або виконання якоїсь логіки. Про можливі типи об'єктів можна почитати <a href="http://www.matools.com/lang-ru/blog/190399818" target="_blank" rel="nofollow">тут</a> . 
<h3>Принципи створення змінних</h3><img alt="Правила написання коду: від створення системи до роботи з об'єктами." src="https://codegym-com.translate.goog/images/article/b65b3716-4304-4939-a9d8-e688fa3dced7/original.png">Давайте трохи поміркуємо на тему змінних, а точніше подумаємо: які можуть бути принципи їх створення: 
<ol>
 <li>В ідеалі необхідно оголошувати та ініціалізувати змінну безпосередньо перед її використанням (а не створабо, і забули про неї).</li>
 <li>По можливості оголошувати змінні як final, щоб запобігти зміні значення після ініціалізації.</li>
 <li>Не забувати про змінні-лічильники (зазвичай ми їх використовуємо в якомусь циклі <code class=" language-none">for</code>, тобто потрібно не забувати їх обнулити, інакше це може зламати нам всю логіку).</li>
 <li>Потрібно намагатися ініціалізувати змінні у конструкторі.</li>
 <li>Якщо існує вибір між використанням об'єкта з посиланням або без ( <code class=" language-none">new SomeObject()</code>), робіть вибір на користь <span>без</span> , оскільки цей об'єкт після використання видаляється під час наступного складання сміття і не використовуватиме ресурси даремно.</li>
 <li>Робіть час життя змінних якомога коротше (відстань між створенням змінної та останнім зверненням).</li>
 <li>Ініціалізуйте змінні, що використовуються у циклі, безпосередньо перед циклом, а не на початку методу, що містить цикл.</li>
 <li>Починайте завжди з обмеженої області видимості і розширюйте її лише за необхідності (потрібно намагатися робити змінну якомога локальнішої).</li>
 <li>Використовуйте кожну змінну лише з однією метою.</li>
 <li>Уникайте змінних із прихованим змістом (змінна розривається між двома завданнями, отже, для вирішення однієї з них її тип не підходить).</li>
</ol><a href="https://codegym.cc/welcome" target="_blank" rel="nofollow"><img width="800" height="500" data-id="008ddced-700d-41ca-be65-f2c6e741cf7b" alt="Правила написання коду: від створення системи до роботи з об'єктами - 7" src="https://cdn.javarush.com/images/article/008ddced-700d-41ca-be65-f2c6e741cf7b/1080.jpeg"></a>
<h3>Методи</h3><img alt="Правила написання коду: від створення системи до роботи з об'єктами." src="https://codegym-com.translate.goog/images/article/287158e9-beac-4ed3-ad2b-26a9f56ad5ba/original.jpg">Перейдемо безпосередньо до реалізації нашої логіки, а саме до методів. 
<ol>
 <li>
  <p><span>Перше правило – це компактність. </span>В ідеалі один метод не повинен перевищувати 20 рядків, тому якщо, скажімо, public метод значно "розбухне", потрібно задуматися про винесення логіки, що відокремлюється, в приватні методи.</p></li>
 <li>
  <p><span>Друге правило - блоки в командах <code class=" language-none">if</code>, <code class=" language-none">else</code>, <code class=" language-none">while</code>і так далі, не повинні мати велику вкладеність:</span> це значно знижує читання коду. В ідеалі вкладеність має бути не більше двох блоків <code class=" language-none">{}</code>.</p>
  <p>Код у цих блоках теж бажано робити компактним та простим.</p></li>
 <li>
  <p><span>Третє правило - метод повинен виконувати лише одну операцію. </span>Тобто, якщо метод виконує складну різноманітну логіку, ми б'ємо його на підметоди. У результаті сам спосіб буде фасадом, мета якого — виклик решти операцій у правильному порядку.</p>
  <p>Але якщо операція здається занадто простою для створення окремого методу? Так, іноді це може здатися пальбою з гармати по горобцях, але невеликі методи забезпечують ряд переваг:</p>
  <ul>
   <li>полегшене читання коду;</li>
   <li>методи мають властивість ускладнюватися з розробкою, і якщо метод спочатку був простим, ускладнення його функціоналу буде трохи простіше;</li>
   <li>приховування деталей реалізації;</li>
   <li>полегшення повторного використання коду;</li>
   <li>вищу надійність коду.</li>
  </ul></li>
 <li>
  <p><span>Правило зниження</span> - код повинен читатися зверху вниз: чим нижче - тим більше поглиблення в логіку, і навпаки, чим вище - тим абстрактніші методи. Наприклад, команди switch досить-таки некомпактні і небажані, але якщо без використання перемикача ніяк, потрібно постаратися винести його якнайнижче, в найнижчерівневі методи.</p></li>
 <li>
  <p><span>Аргументи методу</span> - яка їх кількість ідеальна? В ідеалі їх зовсім нема)) Але хіба так буває? Однак потрібно намагатися мати їх якнайменше, адже чим їх менше, тим простіше використовувати цей метод і легше його протестувати. Якщо сумніваєшся, спробуй вгадати всі сценарії використання методу з великою кількістю аргументів.</p></li>
 <li>
  <p>Окремо хотілося б виділити методи, що мають вхідним аргументом якийсь <span>boolean прапор</span> , оскільки це само собою передбачає, що даний метод реалізує більше однієї операції (якщо true то одна, false - інша). Як я писав вище, це не є добре і по можливості цього слід уникати.</p></li>
 <li>
  <p>Якщо метод має <span>велику кількість вхідних аргументів</span> (крайнє значення — 7, але варто замислюватися вже після 2-3), необхідно згрупувати деякі аргументи в окремому об'єкті.</p></li>
 <li>
  <p>Якщо <span>є кілька схожих методів (перевантажених)</span> , то схожі параметри необхідно передавати в тому самому порядку: це підвищує читаність і зручність використання.</p></li>
 <li>
  <p>Коли ви передаєте в метод параметри, ви повинні бути впевнені, що всі вони будуть використані, інакше навіщо потрібен цей аргумент? Випиляйте його з інтерфейсу та й усе.</p></li>
 <li>
  <p><span><code class=" language-none">try/catch</code></span>виглядає за своєю природою не дуже красиво, тому непоганим ходом було б винести його в окремий проміжний метод (метод для обробки винятків):</p>
  <pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">exceptionHandling</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">SomeObject</span></span> obj<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
    <span class="token keyword"><span class="token keyword">try</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
        <span class="token function"><span class="token function">someMethod</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>obj<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token punctuation"><span class="token punctuation">}</span></span> <span class="token keyword"><span class="token keyword">catch</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">IOException</span></span> e<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
        e<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">printStackTrace</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token punctuation"><span class="token punctuation">}</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre></li>
</ol>Щодо повторюючого коду я говорив вище, але додам і тут: Якщо у нас є пара методів з частинами коду, що повторюються, необхідно винести його в окремий метод, що підвищить компактність як методу, так і класу. І не варто забувати про правильні найменування. Деталі правильного іменування класів, інтерфейсів, методів та змінних я розповім у наступній частині статті. А нам у мене сьогодні все. <img alt="Правила написання коду: від створення системи до роботи з об'єктами." src="https://codegym-com.translate.goog/images/article/53561c00-66ea-45d6-a346-393b6c05929a/original.png"><a href="https://codegym.cc/groups/posts/2610-pravila-napisanija-koda-sila-praviljhnihkh-imenovaniy-khoroshie-i-plokhie-kommentarii" target="_blank" rel="nofollow">Правила написання коду: сила правильних імен, хороші та погані коментарі</a>