Різниця між патернами Стан та Стратегія в Java
<p>----------------------------------------</p>
Для того, щоб правильно використовувати патерни та в ядрі Java додатків, важливо для Java програмістів чітко розуміти різницю між ними. Хоча обидва шаблони, Стан і Стратегія, мають схожу структуру, і обидва засновані на принципі відкритості
<p>----------------------------------------</p>
Для того, щоб правильно використовувати патерни <strong>Стан</strong> та <strong>Стратегія</strong> в ядрі Java додатків, важливо для Java програмістів чітко розуміти різницю між ними. Хоча обидва шаблони, Стан і Стратегія, мають схожу структуру, і обидва засновані на принципі відкритості/закритості, що представляють ”O” у <a href="http://javarevisited.blogspot.com/2012/03/10-object-oriented-design-principles.html" rel="nofollow">SOLID принципах</a> , вони зовсім різні за <em>намірами</em> . <img data-id="77ec83f7-ee44-4010-aab3-2f3357adb723" data-max-width="850" alt="Різниця між патернами Стан та Стратегія в Java - 1" src="https://cdn.javarush.com/images/article/77ec83f7-ee44-4010-aab3-2f3357adb723/800.jpeg" style="width: 850px;">Паттерн <strong>Стратегія</strong> Java <em>використовується для інкапсуляції</em> пов'язаних наборів алгоритмів для забезпечення гнучкості виконання для клієнта. Клієнт може вибрати будь-який алгоритм під час виконання без зміни контексту класу, який використовує об'єкт <code class=" language-none">Strategy</code>. Деякі популярні приклади патерну <strong>Стратегія</strong>– це написання коду, який використовує алгоритми, наприклад, шифрування, стискування або сортування. З іншого боку, патерн Стан дозволяє об'єкту поводитися по-різному у різному стані. Оскільки в реальному світі об'єкт часто має статки, і він веде себе по-різному в різних станах, наприклад, торговий автомат продає товари тільки якщо він в змозі, він не продає до тих пір, поки ви не покладете в нього монету <code class=" language-none">hasCoin</code>. Зараз ви можете ясно бачити різницю між патернами Стратегія та Стан, це різні наміри. <a href="http://java67.blogspot.sg/2012/09/top-10-java-design-pattern-interview-question-answer.html" rel="nofollow">Паттерн Стан</a>допомагає об'єкту керувати станом, тоді як патерн Стратегія дозволяє вибрати клієнту іншу поведінку. Ще одна відмінність, яку не так легко побачити, це хтось керує зміною в поведінці. У випадку патерна Стратегія, це клієнт, який надає різні стратегії до контексту, у патерні Стан переходом управляє контекст чи стан об'єкта самостійно. Крім того, якщо ви керуєте змінами станів в об'єкті Стан самостійно, має бути посилання на контекст, наприклад, у торговому автоматі має бути можливість викликати метод <code class=" language-none">setState()</code>зміни поточного стану контексту. З іншого боку, об'єкт Стратегія ніколи не містить посилання на контекст, клієнт передає Стратегію свого вибору в контекст. Різниця між патернами Стан та Стратегія один з<a href="http://javarevisited.blogspot.sg/2012/06/20-design-pattern-and-software-design.html" rel="nofollow">популярних питань про патерни Java на інтерв'ю</a> , у цій статті про патерни Java ми докладніше розглянемо це. Ми будемо досліджувати деякі подібності та відмінності між патернами Стратегія та Стан у Java, які допоможуть вам покращити ваше розуміння цих патернів. 
<h2>Подібності між патернами Стан та Стратегія</h2>Якщо ви подивитеся на UML-діаграму патернів Стан та Стратегія, можна помітити, що обидва виглядають схожими один на одного. Об'єкт, який використовує Стан зміни своєї поведінки відомий як <code class=" language-none">Context</code>-об'єкт, аналогічно об'єкт, який використовує Стратегію, щоб змінити свою поведінку згадується як <code class=" language-none">Context</code>-об'єкт. Запам'ятайте, що клієнт взаємодіє з <code class=" language-none">Context</code>об'єктом. У разі патерну Стан контекст делегує методи виклику об'єкту Стан, який утримується у вигляді поточного об'єкта, а у разі патерну Стратегія контекст використовує об'єкт Стратегії як параметр або надається під час створення контексту об'єкта. <em>UML діаграма патерну Стан у Java</em> <img data-id="860d8aa3-4234-40e4-bbd3-e8245e68c06e" data-max-width="1016" alt="Різниця між патернами Стан та Стратегія в Java - 2" src="https://cdn.javarush.com/images/article/860d8aa3-4234-40e4-bbd3-e8245e68c06e/800.jpeg" style="width: 1016px;">Ця UML діаграма для патерну Стан зображує класичну проблему створення об'єктно-орієнтованого дизайну торгового апарату в Java. Ви можете бачити, що стан торгового апарату представлено з використанням інтерфейсу, який має реалізацію для представлення конкретного стану. Кожен стан також має посилання на контекст об'єкта, щоб зробити перехід в інший стан у результаті дій, викликаних у контексті. <em>UML діаграма патерна Стратегія Java</em> <img data-id="9cea0830-1212-4ab7-9b8e-fdc94bee1ca1" data-max-width="1098" alt="Різниця між патернами Стан та Стратегія в Java - 3" src="https://cdn.javarush.com/images/article/9cea0830-1212-4ab7-9b8e-fdc94bee1ca1/1080.jpeg" style="width: 1098px;"> Ця UML діаграма для патерна Стратегія містить функціональні реалізації сортувань. Оскільки є багато алгоритмів сортування, цей шаблон проектування дозволяє клієнту вибрати алгоритм сортування об'єктів. Насправді <em>Java Collection framework</em> використовує цей патерн реалізуючи метод<code class=" language-none">Collections.sort()</code>, який використовується для сортування об'єктів у Java. Єдина різниця в тому, що замість дозволу клієнту вибирати алгоритм сортування, він дозволяє йому вказати стратегію порівняння передаючи екземпляр <a href="http://javarevisited.blogspot.sg/2011/06/comparator-and-comparable-in-java.html" rel="nofollow">інтерфейсу Comparator або Comparable в Java</a> . Давайте подивимося на кілька подібностей між цими двома основними шаблонами проектування Java: 
<ol>
 <li>Обидва патерни, Стан та Стратегія, роблять нескладним додавання нового стану та стратегії не торкаючись контексту об'єкта, який використовує їх.</li>
 <br>
 <li>Обидва з них підтримують ваш код у відповідності до <a href="http://javarevisited.blogspot.sg/2011/11/great-example-of-open-closed-design.html" rel="nofollow">принципу відкритості/закритості</a> , тобто дизайн буде відкритий для розширень, але закритий для модифікації. У випадку патернів Стан та Стратегія контекст об'єкта закритий для модифікацій, введень нових Стан або нових Стратегій, або ви не потребуєте модифікації контексту іншого стану, або мінімальних змін.</li>
 <br>
 <li>Також як контекст об'єкта починається зі стану ініціалізації об'єкта в патерні Стан, контекст об'єкта також має стандартну стратегію у випадку патерну Стратегія в Java.</li>
 <br>
 <li>Паттерн Стан представляє різні поведінки у вигляді різних станів об'єкта, тоді як патерн Стратегія представляє різне поведінка як різних стратегій об'єкта.</li>
 <br>
 <li>Обидва патерни, Стратегія та Стан, залежать від підкласів реалізації поведінки. Кожна конкретна стратегія розширює Абстрактну Стратегію, кожен стан є підкласом <a href="http://javarevisited.blogspot.sg/2013/05/difference-between-abstract-class-vs-interface-java-when-prefer-over-design-oops.html" rel="nofollow">інтерфейсу або абстрактного класу</a> , який використовується для припинення Стану.</li>
</ol>
<h2>Відмінності між патернами Стратегія та Стан у Java</h2>Отже, тепер ми знаємо, що патерни Стан і Стратегія схожі структурою, які наміри різні. Давайте розглянемо деякі ключові різницю між цими шаблонами проектування. 
<ol>
 <li>Паттерн Стратегія інкапсулює набір пов'язаних алгоритмів, і дозволяє клієнту використовувати взаємозамінні поведінки, незважаючи на склад і делегування під час виконання, з іншого боку, патерн Стан допомагає класу демонструвати різні поведінки в різних станах.</li>
 <br>
 <li>Наступна різниця між патернами Стан та Стратегія полягає в тому, що Стан <a href="http://javarevisited.blogspot.sg/2012/03/what-is-encapsulation-in-java-and-oops.html" rel="nofollow">інкапсулює</a> стан об'єкта, тоді як патерн Стратегія інкапсулює алгоритм або стратегію. Оскільки стан пов'язані з об'єктом воно може бути повторно використано, але відокремлюючи стратегію чи алгоритм з контексту ми можемо використовувати його повторно.</li>
 <br>
 <li>У патерні Стан особистий стан може містити посилання на контекст для реалізації переходів між станами, але Стратегія не містить посилання на контекст, де вона використовується.</li>
 <br>
 <li>Реалізація Стратегії може бути передана як параметр об'єкту, який використовуватиме її, наприклад, Collection.sort() приймає <a href="http://javarevisited.blogspot.sg/2014/01/java-comparator-example-for-custom.html" rel="nofollow">Comparator</a> , який є стратегією. З іншого боку, стан є частиною самого контексту об'єкта, і протягом тривалого часу контекст об'єкта переходить із одного стану до іншого.</li>
 <br>
 <li>Хоча і Стратегія і Стан дотримуються принципу відкритості/закритості, Стратегія також слідує Принципу Єдиного Обов'язку, оскільки кожна Стратегія містить індивідуальний алгоритм, різні стратегії незалежні одна від одної. Зміна однієї стратегії не потребує зміни іншої стратегії.</li>
 <br>
 <li>Ще одна теоретична відмінність між патернами Стратегія і Стан полягає в тому, що творець визначає частину об'єкта "Як", наприклад, "Як" об'єкт сортування сортує дані, з іншого боку патерн Стан визначає частини "що" і "коли" в об'єкті, наприклад , що може об'єкт коли він перебуває у певному стані.</li>
 <br>
 <li>Порядок переходу стану добре визначений у патерні Стан такої вимоги немає до патерну Стратегія. Клієнт вільний у виборі будь-якої реалізації Стратегії з його вибір.</li>
 <br>
 <li>Деякі із загальних прикладів патерну Стратегія – це інкапсуляція алгоритмів, наприклад алгоритми сортування, шифрування або алгоритм стиснення. Якщо ви бачите, що ваш код повинен використовувати різні види пов'язаних алгоритмів, слід подумати про використання патерну Стратегія. З іншого боку, розпізнати можливість використання патерну Стан досить легко, якщо вам потрібно керувати станом та переходами між станами без великої кількості вкладених умовних операторів патерн. Стан – потрібний патерн для використання.</li>
 <br>
 <li>Остання, але одна з найважливіших відмінностей між патернами Стан та Стратегія полягає в тому, що зміна Стратегії виконується Клієнтом, а зміна Стану може бути виконана контекстом або станом об'єкта самостійно.</li>
 <br>
</ol>Це все про <strong>різницю між патернами Стан та Стратегія в Java</strong> . Як я сказав, обидва виглядають схоже у своїх класах та UML діаграмах, обидва забезпечують відкрито/закритий принцип та інкапсулюють поведінку. Використовуйте патерн Стратегія для інкапсулювання алгоритму або стратегії, який надається контексту під час виконання, можливо як параметр або складовий об'єкт і використовуйте патерн Стан для керування переходами між станами Java. Оригінал <a href="http://javarevisited.blogspot.sg/2014/04/difference-between-state-and-strategy-design-pattern-java.html" rel="nofollow">тут</a>