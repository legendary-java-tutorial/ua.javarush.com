Посібник із загального стилю програмування
<p>----------------------------------------</p>
Стаття є частиною академічного курсу "Advanced Java" ("Java для удосконалюваних") Цей курс створений, щоб допомогти вам навчитися ефективно використовувати особливості Java. Матеріал охоплює "просунуті" теми, як створення об'єктів, конкурен
<p>----------------------------------------</p>
Стаття є частиною академічного курсу "Advanced Java" ("Java для удосконалюваних") Цей курс створений, щоб допомогти вам навчитися ефективно використовувати особливості Java. Матеріал охоплює "просунуті" теми, як створення об'єктів, конкуренцію, серіалізацію, рефлексію та ін. Курс навчить ефективно володіти прийомами Java. Подробиці <a href="http://www.javacodegeeks.com/2015/09/advanced-java.html" rel="nofollow">тут</a> . <cut>
 <h6>Зміст</h6>
 <em>1. Вступ 2. Область видимості змінних 3. Поля класу та локальні змінні 4. Аргументи методу та локальні змінні 5. Упаковка та розпакування 6. Інтерфейси 7. Рядки 8. Угоди про імена 9. Стандартні бібліотеки 10. Незмінність 1. Далі... 13. Завантаження вихідного коду</em>
 <h6>1. Введення</h6> У цій частині керівництва продовжимо обговорення загальних принципів хорошого стилю програмування та гнучкого дизайну Java. Деякі з цих принципів ми вже бачабо в попередніх розділах керівництва, проте багато практичних порад буде дано з метою покращення кваліфікації Java-розробника. 
 <h6>2. Область видимості змінних</h6> У третій частині ("Як проектувати класи та інтерфейси") ми обговорабо як видимість і доступність можуть бути застосовані до членів класів та інтерфейсів з огляду на обмеження в області видимості. Однак ми поки не обговорабо локальні змінні, які використовуються в реалізації методів. У мові Java, кожна локальна змінна, одного разу оголошена, має область видимості. Ця змінна стає видимою з місця, де вона оголошена, до місця завершення виконання методу (або коду блоку). Як правило, необхідно дотримуватися єдиного правила: оголошувати локальну змінну якомога ближче до місця, де вона використовуватиметься. Пропоную поглянути на типовий приклад: 
 <code class=" language-none"> for( final Locale locale: Locale.getAvailableLocales() ) { // блок кода } try( final InputStream in = new FileInputStream( "file.txt" ) ) { // блока кода }</code> В обох фрагментах коду область видимості змінних обмежена блоками виконання, де ці оголошені. Після завершення блоку область видимості закінчується і змінна стає невидимою. Це виглядає більш зрозуміло, проте з випуском Java 8 та введенням у лямбди, безліч відомих ідіом мови з використанням локальних змінних стають застарілими. Наведу приклад із попереднього прикладу з використанням лямбд замість циклу: 
 <code class=" language-none"> Arrays.stream( Locale.getAvailableLocales() ).forEach( ( locale ) -&gt; { // блок кода } ); </code> Видно, що локальна змінна стала аргументом функції, переданої, у свою чергу, як аргумент методу 
 <em>forEach</em> . 
 <h6>3. Поля класу та локальні змінні</h6> Кожен метод Java належить певному класу (або, у випадку Java8, інтерфейсу, де даний метод оголошений як метод за замовчуванням). Між локальними змінними полями класу чи які у реалізації методів, існує як така ймовірність конфлікту імен. Компілятор Java вміє вибирати правильну змінну з низки наявних, незважаючи на те, що цю змінну має намір використовувати не один розробник. Сучасні Java IDE виконують величезну роботу, щоб підказати розробнику, коли такі конфлікти мають місце, шляхом попереджень компілятора, підсвічуванням змінних. Але все ж таки краще подумати про подібні речі під час написання коду. Приклад 
 <code class=" language-none"> public class LocalVariableAndClassMember { private long value; public long calculateValue( final long initial ) { long value = initial; value *= 10; value += value; return value; } }</code> виглядає цілком легким, проте це пастка. Метод 
 <em>calculateValue</em>вводить локальну змінну 
 <em>value</em> та оперуючи їй, ховає поле класу з таким самим ім'ям. У рядку 
 <code class=" language-none">value += value;</code> має бути сума значення поля класу та локальної змінної, проте замість цього виконується щось інше. Правильна реалізація буде виглядати ось так (з використанням ключового слова this): 
 <code class=" language-none"> public class LocalVariableAndClassMember { private long value; public long calculateValue( final long initial ) { long value = initial; value *= 10; value += this.value; return value; } }</code> У певному роді даний приклад наївний, але він демонструє важливий момент, при якому в деяких випадках можуть знадобитися години на налагодження і виправлення. 
 <h6>4. Аргументи методу та локальні змінні</h6> Інша пастка, куди часто потрапляють недосвідчені Java-розробники, це використання аргументів методу локальних змінних. Java дозволяє переприсвоїти значення аргументам не є константами (проте, це не має жодного ефекту на початкове значення): 
 <code class=" language-none"> public String sanitize( String str ) { if( !str.isEmpty() ) { str = str.trim(); } str = str.toLowerCase(); return str; }</code> Фрагмент коду вище не є елегантним, але він цілком гарний для розкриття проблеми: аргументу 
 <em>str</em> присвоєно інше значення (і в основному використовується як локальна змінна) . У всіх випадках (без жодного виключення) можна і слід обійтися без цього прикладу (наприклад, оголошуючи аргументи як константи). Наприклад: 
 <code class=" language-none"> public String sanitize( final String str ) { String sanitized = str; if( !str.isEmpty() ) { sanitized = str.trim(); } sanitized = sanitized.toLowerCase(); return sanitized; }</code> Дотримуючись цього простого правила, цей код легше відстежувати та знаходити в ньому джерело проблеми, навіть при введенні локальних змінних. 
 <h6>5. Упаковка та розпакування</h6> Упаковка та розпакування - назва техніки, що використовується в Java для конвертації примітивних типів ( 
 <em>int, long, double та ін.</em> ) до відповідних обгорток типів ( 
 <em>Integer, Long, Double</em> та ін.). У 4-ій частині керівництва "Як і коли використовувати дженерики", ви вже зустрічали це в дії, коли я розповідав про обгортки примітивних типів як параметри типу дженериків. Незважаючи, що компілятор Java намагається зробити все можливе в приховуванні подібних конвертацій виконанням автоупаковки, іноді це виходить гірше за очікуване і призводить до несподіваних результатів. Поглянемо з прикладу: 
 <code class=" language-none"> public static void calculate( final long value ) { // блок кода } final Long value = null; calculate( value );</code> Фрагмент коду вище відмінно скомпілюється. Однак, він викине виняток 
 <em>NullPointerException</em> на рядку, 
 <code class=" language-none"> // блок</code> де буде виконуватися конвертація між
 <em>Long</em> і 
 <em>long</em> . Порада для такого випадку - бажано використовувати примітивні типи (проте, ми вже знаємо, що це не завжди можливо). 
 <h6>6. Інтерфейси</h6> У третій частині керівництва "Як проектувати класи та інтерфейси", ми обговорабо інтерфейси та програмування за контрактом, загострюючи увагу на те, що інтерфейси повинні віддавати перевагу конкретним класам там, де можливо. Мета цього розділу - переконати вас знову брати до уваги спочатку інтерфейси, демонструючи це на реальних прикладах. Інтерфейси не прив'язані до певної імплементації (за винятком методів за промовчанням). Вони тільки контракти і, як приклад, вони забезпечують багато свободи та гнучкості у способі, де контракти могли бути виконані. Ця гнучкість стає більш важливою, коли імплементація спричиняє зовнішні системи чи сервіси. Подивимося на приклад простого інтерфейсу та його можливої ​​реалізації: 
 <code class=" language-none"> public interface TimezoneService { TimeZone getTimeZone( final double lat, final double lon ) throws IOException; } public class TimezoneServiceImpl implements TimezoneService { @Override public TimeZone getTimeZone(final double lat, final double lon) throws IOException { final URL url = new URL( String.format( "http://api.geonames.org/timezone?lat=%.2f&amp;lng=%.2f&amp;username=demo", lat, lon ) ); final HttpURLConnection connection = ( HttpURLConnection )url.openConnection(); connection.setRequestMethod( "GET" ); connection.setConnectTimeout( 1000 ); connection.setReadTimeout( 1000 ); connection.connect(); int status = connection.getResponseCode(); if (status == 200) { // Do something here } return TimeZone.getDefault(); } }</code> Фрагмент коду зверху демонструє типовий шаблон інтерфейсу та його реалізації. Ця реалізація використовує зовнішній HTTP-сервіс ( 
 <em>http://api.geonames.org/</em> ) для тимчасової зони певної місцевості. Проте, т.к. Договор залежить від інтерфейсу, дуже легко ввести ще одну реалізацію інтерфейсу, застосовуючи, наприклад, базу даних або навіть звичайний плоский файл. З ними інтерфейси дуже добре допоможуть спроектувати код, що тестується. Наприклад, не завжди практично викликати зовнішні сервіси на кожен тест, що натомість має сенс виконати альтернативну, найпростішу реалізацію (наприклад, заглушку): 
 <code class=" language-none"> public class TimezoneServiceTestImpl implements TimezoneService { @Override public TimeZone getTimeZone(final double lat, final double lon) throws IOException { return TimeZone.getDefault(); } }</code> Ця реалізація може бути використана в будь-якому місці, де інтерфейс 
 <em>TimezoneService</em>обов'язковий, ізолюючи сценарій тесту залежно від зовнішніх компонентів. Багато відмінних прикладів ефективного використання таких інтерфейсів інкапсульовано всередині стандартної бібліотеки Java. Колекції, списки, множини - ці інтерфейси мають кілька реалізацій, які можуть бути плавно замінені і можуть бути взаємозамінними, коли контракти користуються перевагою. Наприклад: 
 <code class=" language-none"> public static&lt; T &gt; void print( final Collection&lt; T &gt; collection ) { for( final T element: collection ) { System.out.println( element ); } } print( new HashSet&lt; Object &gt;( /* ... */ ) ); print( new ArrayList&lt; Integer &gt;( /* ... */ ) ); print( new TreeSet&lt; String &gt;( /* ... */ ) );</code>
 <h6>7. Рядки</h6> Рядки одні з найбільш використовуваних типів як Java, так і в інших мовах програмування. Мова Java спрощує безліч рутинних операцій із рядками, підтримуючи операції конкатенації та порівняння "прямо з коробки". До того ж, стандартна бібліотека містить безліч класів, що роблять операції з рядками ефективними. Це саме те, що збираємось обговорити у цій секції. Java рядки є незмінними об'єктами, представленими в кодуванні UTF-16. Щоразу, коли ви поєднуєте рядки (або виконуєте будь-яку операцію, яка змінює вихідний рядок), створюється новий екземпляр класу 
 <em>String</em> . Через це операція об'єднання може стати дуже неефективною, викликаючи створення багатьох проміжних екземплярів класу 
 <em>String</em>(Створює сміття, загалом кажучи). Але стандартна бібліотека Java містить два дуже корисні класи, мета яких - зробити зручними маніпуляції з рядками. Це - 
 <em>StringBuilder</em> і 
 <em>StringBuffer</em> (єдина різниця між ними, що 
 <em>StringBuffer</em> є потокобезпечним, коли 
 <em>StringBuilder</em> навпаки). Поглянемо на пару прикладів використовуваних один із цих класів: 
 <code class=" language-none"> final StringBuilder sb = new StringBuilder(); for( int i = 1; i &lt;= 10; ++i ) { sb.append( " " ); sb.append( i ); } sb.deleteCharAt( 0 ); sb.insert( 0, "[" ); sb.replace( sb.length() - 3, sb.length(), "]" );</code> Незважаючи на те, що використання 
 <em>StringBuilder / StringBuffer</em> - рекомендований спосіб для маніпуляції рядків, він може виглядати зайвим у найпростішому сценарії об'єднання двох або трьох рядків, так що замість цього може використовуватися звичайний оператор додавання ( "+"), наприклад: 
 <code class=" language-none">String userId = "user:" + new Random().nextInt( 100 );</code> Часто найкраща альтернатива для спрощення об'єднання - використання форматування рядків і стандартної бібліотеки Java, щоб допомогти забезпечити статичний метод хелпера 
 <em>String.format</em> . Це підтримує багатий набір специфікаторів формату, включаючи числа, символи, дату/час та ін. (Для отримання повної інформації зверніться до довідкової документації) 
 <code class=" language-none">String.format( "%04d", 1 ); -&gt; 0001 String.format( "%.2f", 12.324234d ); -&gt; 12.32 String.format( "%tR", new Date() ); -&gt; 21:11 String.format( "%tF", new Date() ); -&gt; 2014-11-11 String.format( "%d%%", 12 ); -&gt; 12%</code> Метод 
 <em>String.format</em> забезпечує чистий та легкий підхід до утворення рядків з різних типів даних. Варто зауважити, що сучасні Java IDE можуть аналізувати специфікацію формату з аргументів, переданих методу 
 <em>String.format</em> , і попереджати розробників у разі виявлених розбіжностей. 
 <h6>8. Угоди про імена</h6> Java - мова, яка не змушує розробників суворо дотримуватися будь-якої угоди про імена, проте спільнота розробила набір простих правил, які роблять вигляд Java-коду рівним як у стандартній бібліотеці, так і будь-яких інших проектах Java: 
 <ul>
  <li>імена пакетів зазначаються в нижньому регістрі: <em>org.junit, com.fasterxml.jackson, javax.json</em></li>
  <li>імена класів, перерахувань, інтерфейсів, анотацій пишуться з великої літери: <em>StringBuilder, Runnable, @Override</em></li>
  <li>імена полів або методів (за винятком <em>static final</em> ) вказуються у верблюжій нотації: <em>isEmpty, format, addAll</em></li>
  <li>статичні фінальні поля чи імена констант перечеслений вказані у верхньому регістрі, розділеними знаком нижнього підкреслення ("_"): <em>LOG, MIN_RADIX, INSTANCE.</em></li>
  <li>локальні змінні або аргументи методів набрані у верблюжій нотації: <em>str, newLength, minimumCapacity</em></li>
  <li>імена типів параметрів у дженериків представлені однією літерою у верхньому регістрі: <em>T, U, E</em></li>
  <li></li>
 </ul> Дотримуючись цих простих угод, код, який ви пишете, буде виглядати коротким і невиразним за своїм стилем від коду іншої бібліотеки або фреймворку, і вселятиме відчуття, що був розроблений однією і тією ж людиною (один з тих рідкісних моментів, коли угоди дійсно працюють ). 
 <h6>9. Стандартні бібліотеки</h6> Неважливо, над яким видом Java-проекту ви працюєте, стандартні бібліотеки Java – ваші найкращі друзі. Так, складно не погодитися, що у них є деякі шорсткості і дивні рішення з дизайну, проте в 99% це високоякісний код, написаний експертами. Це варте того, щоб вивчити. Кожен Java-реліз несе багато нових особливостей у існуючі бібліотеки (з деякими можливо спірними моментами зі старими особливостями), а також додає багато нових бібліотек. Java 5 приніс нову 
 <em>concurrency</em> бібліотеку у складі пакету 
 <em>java.util.concurrent</em> . Java 6 надав (цей момент менш відомий) підтримку написання скриптів ( 
 <em>javax.script</em> пакет) та 
 <em>API</em> Java-компілятора (у складі пакету 
 <em>javax.tools</em>). Java 7 приніс багато поліпшень в 
 <em>java.util.concurrent</em> , ввів нову бібліотеку введення-виводу в пакеті 
 <em>java.nio.file</em> і підтримку динамічних мов 
 <em>java.lang.invoke</em> . І нарешті, Java 8 додали довгоочікуваний 
 <em>date/time</em> в пакеті 
 <em>java.time</em>. Java як платформа розвивається і їй дуже важливо прогресувати поряд із зазначеними змінами. Щоразу, коли ви враховуєте включення сторонньої бібліотеки або фреймворку до вашого проекту, переконайтеся, що необхідна функціональність ще не міститься в стандартних бібліотеках Java (звичайно, є багато спеціалізованих та високопродуктивних реалізацій алгоритмів, які випереджають алгоритми зі стандартних бібліотек, але в більшості випадків дійсно вони не потрібні). 
 <h6>10. Незмінність</h6> Незмінність у всьому керівництві і в цій частині залишається як нагадування: будь ласка, поставтеся до неї з усією серйозністю. Якщо клас, який ви проектуєте або метод, який ви реалізуєте, може забезпечити гарантію незмінності, він може бути використаний здебільшого скрізь без страху одночасної модифікації. Це полегшить ваше життя розробника (і, сподіваюся, життя колег із вашої команди). 
 <h6>11. Тестування</h6> Практика розробки через тестування ("Test-driven development" - TDD) надпопулярна в Java-спільноті, піднімаючи планку якості коду. З усіма вигодами, які надає TDD, сумно бачити, що стандартна бібліотека Java на сьогодні не включає фреймворку для проведення тестів або допоміжних засобів. Проте тестування стало необхідною частиною сучасної Java-розробки і в цьому розділі ми поглянемо на кілька базових прийомів з використанням фреймфорка 
 <a href="https://codegym.cc/groups/posts/605-junit" target="_blank">JUnit</a> . У JUnit, суттєво, кожен тест - набір тверджень про очікуваний стан або поведінку об'єкта. Секрет написання відмінних тестів - писати їх простими і короткими, тестуючи одну річ за раз. Як вправу, давайте напишемо набір тестів, щоб перевірити, що 
 <em>String.format</em>- Функція з розділу рядків, що повертає бажаний результат. 
 <code class=" language-none"> package com.javacodegeeks.advanced.generic; import static org.junit.Assert.assertThat; import static org.hamcrest.CoreMatchers.equalTo; import org.junit.Test; public class StringFormatTestCase { @Test public void testNumberFormattingWithLeadingZeros() { final String formatted = String.format( "%04d", 1 ); assertThat( formatted, equalTo( "0001" ) ); } @Test public void testDoubleFormattingWithTwoDecimalPoints() { final String formatted = String.format( "%.2f", 12.324234d ); assertThat( formatted, equalTo( "12.32" ) ); } }</code> Обидва тести виглядають дуже читаними та їх виконання – це екземпляри. На сьогоднішній день середній Java-проект містить сотні тест-кейсів, що дають розробнику швидкий фідбек у процесі розробки за регресією або особливостями. 
 <h6>12. Далі</h6> Ця частина керівництва завершує серію обговорень, пов'язаних з практикою програмування на Java та посібниками до цієї мови програмування. Наступного разу ми повернемося до особливостей мови досліджуючи світ Java в частині винятків, їх типів, як і коли використовувати їх. 
 <h6>13. Завантаження вихідного коду</h6> Це був урок із загальних принципів розробки з курсу Advanced Java. Вихідний код до заняття можна завантажити 
 <a href="http://a3ab771892fd198a96736e50.javacodegeeks.netdna-cdn.com/wp-content/uploads/2015/09/advanced-java-part-7.zip" rel="nofollow">тут</a> .
</cut>