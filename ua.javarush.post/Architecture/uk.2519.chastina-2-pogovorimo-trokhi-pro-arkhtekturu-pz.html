Частина 2. Поговоримо трохи про архітектуру ПЗ
<p>----------------------------------------</p>
Цей матеріал - частина циклу " ". Перша частина про мережу - . Архітектура програмного забезпечення - структура, на базі якої створюється програма, взаємодіють модулі та компоненти всієї програми. За створення гарної архітектури програмісти
<p>----------------------------------------</p>
Цей матеріал - частина циклу " <span class="text-bold">Введення в Enterprise-розробку</span> ". Перша частина про мережу - <a href="https://codegym.cc/groups/posts/2514-vvedenie-v-enterprise-razrabotku" target="_blank">тут</a> . <img data-max-width="850" alt="Частина 2. Поговоримо трохи про архітектуру ПЗ - 1" src="https://cdn.javarush.com/images/article/983160cf-f53c-483e-ba50-4736ef2f7bca/original.jpeg">Архітектура програмного забезпечення - структура, на базі якої створюється програма, взаємодіють модулі та компоненти всієї програми. За створення гарної архітектури програмісти взялися ще дуже давно, тому не дивно, що наразі нам відомо чимало архітектурних шаблонів. Розбиратися в них потрібно: коли пишеш веб-додаток, проблема архітектури стає гострою, адже в ній компонентів та модулів більше, ніж у звичайному додатку. <span class="text-bold">Архітектурний шаблон</span>— це вже вигаданий спосіб вирішення якогось завдання з проектування програмного забезпечення. Ти вже, напевно, стикався з такими патернами проектування як фабричний метод (Factory Method), абстрактна фабрика (Abstract Factory), будівельник (Builder), прототип (Prototype), одинак ​​(Singleton) і, можливо, іншими. Вони використовуються при простому написанні коду, створенні класів та плануванні їхньої взаємодії. Архітектурні шаблони задіяні на вищому рівні абстракції - при плануванні взаємодії користувача програми із сервером, даними та іншими компонентами проекту. Давай відразу розглянемо деякі шаблони та те, як їх використовувати. 
<h2>Клієнт-серверна архітектура</h2>З назви складається враження, що з цією темою все й зрозуміло. Але давай уточнимо деякі моменти, щоб приступивши до вивчення умовного Спрингу ти точно розумів, про що йдеться. Допустимо, ти написав чат, і ви з приятелем починаєте його використовувати. Тут можливий простий варіант - ви відправляєте повідомлення один одному безпосередньо через інтернет за IP-адресаами, які ви знаєте: <img data-max-width="800" data-id="f6f82190-e5a4-4cd0-9707-f1e77215ebad" class="img-fluid" alt="Частина 2. Поговоримо трохи про архітектуру ПЗ - 2" src="https://cdn.javarush.com/images/article/f6f82190-e5a4-4cd0-9707-f1e77215ebad/800.jpeg" style="width: 800px;">Спочатку може здатися, що все добре працює, поки не виникає ще один ваш друг з питанням: "А чому ви не додасте мене до свого чату?". І ось коли ти вирішуєш додати спільного друга в чат, ти стикаєшся з архітектурною проблемою: кожному користувачеві чату потрібно оновити інформацію про кількість користувачів, додати IP-адресау нового користувача. А ще під час відправлення повідомлення воно має доставлятися всім учасникам. Це найочевидніші проблеми з тих, що виникнуть. Ще купа проблем буде захована у самому коді. Щоб уникнути їх, потрібно використовувати <span class="text-bold">сервер</span>, який зберігатиме всю інформацію про користувачів, знати їх адресаи. Повідомлення потрібно буде надіслати лише на сервер. А він, своєю чергою, розішле повідомлення всім адресаатам. Коли ти вирішиш додати серверну частину до свого чату, ти почнеш будувати клієнт-серверну архітектуру. 
<h2>Складові клієнт-серверної архітектури</h2>Давай розберемося, що вона є. <span class="text-bold">Клієнт-серверна архітектура</span> — шаблон проектування, основа створення веб-додатків. Ця архітектура складається з трьох компонентів: <img data-max-width="850" alt="Частина 2. Поговоримо трохи про архітектуру ПЗ - 3" src="https://cdn.javarush.com/images/article/03864835-058e-4e09-b596-d2435f69bdd8/original.jpeg">
<ol>
 <li>
  <p>Клієнт з назви стає зрозуміло, що це користувач сервісу (веб-програми), який звертається до сервера для отримання якоїсь інформації.</p></li>
 <li>Сервер — місце, де знаходиться твоя веб-додаток або його серверна частина. Він володіє необхідною інформацією про користувачів або може її вимагати. Також при зверненні клієнта сервер повертає йому запитувану інформацію.
  <p></p></li>
 <li>
  <p>Мережа – все просто: забезпечує обмін інформацією між клієнтом та сервером.</p></li>
</ol>Сервер може обробляти безліч запитів від різних користувачів. Тобто клієнтів може бути багато, а якщо їм потрібно обмінятися інформацією між собою, робити це доведеться через сервер. Таким чином, сервер отримує ще одну додаткову функцію – контроль трафіку. Якщо йдеться про створений нами розрахований на багато користувачів чат, весь програмний код складатиметься з двох модулів: 
<ul>
 <li>
  <p>клієнтського - містить графічний інтерфейс для авторизації, відправлення/отримання повідомлень;</p></li>
 <li>
  <p>серверного — веб-додаток, який розміщується на сервері та приймає повідомлення від користувачів, обробляє їх, а потім надсилає адресаатам.</p></li>
</ul><img data-max-width="850" alt="Частина 2. Поговоримо трохи про архітектуру ПЗ - 4" src="https://cdn.javarush.com/images/article/4e631129-5583-4856-b4cc-5eb7ea9d895f/original.jpeg">Коли ми хочемо подивитися корисну (або не дуже корисну) інформацію в інтернеті, ми відкриваємо браузер, у рядку пошуку вводимо запит, і у відповідь отримуємо інформацію від пошукової системи. У цьому ланцюжку браузер – це наш клієнт. Він надсилає запит з інформацією про те, що ми шукаємо серверу. Сервер обробляє запит, знаходить найбільш релевантні результати, пакує їх у зрозумілий для браузера (клієнта) формат і відправляє назад. У таких складних сервісах як пошукові системи серверів може бути багато. Наприклад, сервер авторизації, сервер пошуку інформації, сервер формування відповіді. Але клієнт про це нічого не знає: для нього сервер є єдиним. Клієнт знає тільки про точку входу, тобто адресау сервера, якому потрібно надіслати запит. Згадаймо про додаток, який ми розглядали у <a href="https://codegym.cc/groups/posts/2514-vvedenie-v-enterprise-razrabotku" target="_blank">попередній частині</a>— моніторинг середньої температури повітря в усіх країнах у режимі реального часу. Його архітектура буде виглядати приблизно так: <img data-max-width="1024" alt="Частина 2. Поговоримо трохи про архітектуру ПЗ - 5" src="https://cdn.javarush.com/images/article/f7d657e1-af21-4b14-b9f8-681403e30468/original.jpeg">Наш додаток розташовується на сервері. Скажімо, кожні п'ять секунд воно надсилає запити на сервери локальних гідрометцентрів, отримує інформацію про температуру в конкретній країні, зберігає цю інформацію. Коли клієнт звертається до нас із запитом “дивитись поточну температуру повітря у світі”, ми повертаємо останню збережену інформацію, розсортовану країнами. Таким чином наша програма одночасно і сервер (коли обробляє запити користувачів), і клієнт (коли отримує інформацію в інших серверів). 
<div class="table-container">
 <table class="table table--striped">
  <tbody>
   <tr>
    <td>Важливо: поняття <span class="text-bold">сервер — не про конкретний комп'ютер, а про взаємини абонентів мережі</span> .</td>
   </tr>
  </tbody>
 </table>
</div>Проста клієнт-серверна архітектура застосовується дуже рідко і лише для дуже простих програм. Для справді великих та складних проектів використовуються різні типи архітектур, з якими ти ще познайомишся у майбутньому. Зараз же розглянемо модель, дуже схожу на клієнт-серверну. 
<h2>Трирівнева архітектура</h2>Це архітектурний шаблон, де з'являється <span class="text-bold">третій учасник — сховище даних</span> . При використанні цього шаблону три рівні прийнято називати шарами: <img data-max-width="850" alt="Частина 2. Поговоримо трохи про архітектуру ПЗ - 6" src="https://cdn.javarush.com/images/article/73e74fea-a56a-4896-93a8-ce59adf542ec/original.jpeg">
<ol>
 <li>
  <p>Клієнтський шар – інтерфейс користувача. Це може бути веб-браузер, якому надсилаються HTML-сторінки, або графічна програма, написана за допомогою JavaFX. Головне, щоб за його допомогою користувач міг надсилати запити на сервер та обробляти його відповіді.</p></li>
 <li>
  <p>Шар логіки – сервер, на якому відбувається обробка запитів/відповідей. Часто його називають серверним шаром. Також тут відбуваються всі логічні операції: математичні розрахунки, операції з даними, звернення до інших сервісів або сховищ даних.</p></li>
 <li>
  <p>Шар даних – сервер баз даних: до нього звертається наш сервер. У цьому шарі зберігається вся необхідна інформація, якою користується програма під час роботи.</p></li>
</ol>Таким чином, наш сервер бере на себе всі зобов'язання щодо звернення до даних, не даючи можливості користувачеві звернутися до них безпосередньо. <a href="https://codegym.cc/welcome" target="_blank"><img id="click_banner1_articles" data-id="e086d858-e47a-49ad-a398-609ab9064547" data-max-width="1080" alt="Частина 2. Поговоримо трохи про архітектуру ПЗ - 7" src="https://cdn.javarush.com/images/article/e086d858-e47a-49ad-a398-609ab9064547/1080.jpeg" style="width: 1080px;"></a>
<h2>Переваги трирівневої архітектури</h2>Використовуючи таку архітектуру, ми отримуємо чимало плюсів, серед яких: 
<ol>
 <li>
  <p>Можливість побудувати захист від SQL-ін'єкцій - це атака на сервер, при якій передається SQL-код, і при виконанні цього коду зловмисник може вплинути на нашу базу даних.</p></li>
 <li>
  <p>Розмежування даних, до яких ми хочемо регулювати доступ користувача.</p></li>
 <li>
  <p>Можливість модифікувати дані перед надсиланням клієнту.</p></li>
 <li>
  <p>Масштабованість - можливість розширити наш додаток на кілька серверів, які будуть використовувати одну і ту ж базу даних.</p></li>
 <li>
  <p>Найменші вимоги до якості з'єднання користувача. Формуючи відповідь на сервері, ми часто беремо з бази даних багато різної інформації, форматуємо її, залишаючи тільки те, що потрібно користувачеві. Таким чином ми скорочуємо обсяг інформації, яку відправимо як відповідь клієнту.</p></li>
</ol>
<div class="email-subscription">
 <iframe frameborder="0" src="https://secure.esputnik.com.ua/4Q0Ef6d2SOs" width="100%" height="200" scrolling="no" data-savepage-key="0-2"></iframe>
</div>
<h2>Як часто потрібно використовувати архітектурні шаблони?</h2>Якщо ти знайомий, скажімо, з патерном проектування <a href="https://codegym.cc/groups/posts/2372--patternih-proektirovanija-factorymethod" target="_blank">,</a> ти напевно замислювався, коли його варто використовувати. Іноді важко визначитися, що робити: створити об'єкт за допомогою оператора new або використавши фабричний метод. Але згодом розуміння приходить. З архітектурними шаблонами справи трохи інакше. Enterprise-фреймворки розраховані те що, що програміст з допомогою створює проект на основі якогось загальноприйнятого патерна. Тому перед вивченням Spring Framework тобі обов'язково потрібно розуміти, що таке клієнт-серверна архітектура, трирівнева архітектура та MVC-архітектура. Не хвилюйся: про MVC-архітектуру ми ще поговоримо. <a href="https://codegym.cc/groups/posts/2514-vvedenie-v-enterprise-razrabotku" target="_blank">Частина 1. Що потрібно знати перед вивченням Spring та JavaEE </a> <a href="https://codegym.cc/groups/posts/2521-chastjh-3-protokolih-httphttps" target="_blank">Частина 3. Протоколи HTTP/HTTPS </a> <a href="https://codegym.cc/groups/posts/2523-chastjh-4osnovih-maven" target="_blank">Частина 4. Основи Maven</a> <a href="https://codegym.cc/groups/posts/2529-chastjh-5-servletih-pishem-prostoe-veb-prilozhenie" target="_blank">Частина 5. Сервлети. Пишемо просте веб-додаток </a> <a href="https://codegym.cc/groups/posts/2533-chastjh-6-konteynerih-servletov" target="_blank">Частина 6. Контейнери сервлетів </a> <a href="https://codegym.cc/groups/posts/2536-chastjh-7-znakomstvo-s-patternom-mvc-model-view-controller" target="_blank">Частина 7. Знайомство з патерном MVC (Model-View-Controller) </a> <a href="https://codegym.cc/groups/posts/2537-chastjh-8-pishem-neboljhshoe-prilozhenie-na-spring-boot" target="_blank">Частина 8. Пишемо невелику програму на spring-boot</a>