Інтерфейси – маркери
<p>----------------------------------------</p>
Інтерфейси – маркери – це такий шаблон проектування з перевіркою типів під час виконання, який дозволяє пов'язати інтерфейс та клас. Щоб зрозуміти для чого це може бути потрібно розглянемо приклад маркування класу Serializible маркером. При
<p>----------------------------------------</p>
Інтерфейси – маркери – це такий шаблон проектування з перевіркою типів під час виконання, який дозволяє пов'язати інтерфейс та клас. Щоб зрозуміти для чого це може бути потрібно розглянемо приклад маркування класу Serializible маркером. Припустимо, нам знадобилося зберегти стан об'єкта у пам'яті, та був ще й мати можливість розшифрувати те, що ми зберегли. Тоді, скажіть, можна перевести наш об'єкт у набір бітів. Правильно. Ми можемо використовувати простий спосіб запису у файл за допомогою FileInputStream, але це зручно тільки якщо об'єктів мало, а якщо їх багато? Для цього є чудовий інструмент серіалізації. Головне правило, коли ви ним користуєтеся - об'єкт, що серіалізується, повинен містити в собі всі дані, а не посилатися на інші об'єкти. Дивіться свій клас " Ага, то викидається виняток NotSerializableException, а якщо ні-все акуратно пишеться в пам'ять. Створимо клас BigObject, екземпляри якого серіалізуватимемо то викидається виняток NotSerializableException, а якщо ні-все акуратно пишеться в пам'ять. Створимо клас BigObject, екземпляри якого серіалізуватимемо <code class=" language-none"> package post1; import java.io.Serializable; public class BigObject implements Serializable { private int id; public void setId(final int id){ this.id = id; } public int getId() { return id; } }</code> Клас BigObject вже позначений як Serializable. Він має одне поле id і супутні методи get/set. <code class=" language-none"> package post1; import post1.BigObject; import java.io.*; public class InterfaceMarker { public static void main(String[] args) throws IOException, ClassNotFoundException { int originalId = 12; BigObject objectOriginal = new BigObject(); objectOriginal.setId(originalId); ByteArrayOutputStream writeBuffer = new ByteArrayOutputStream(); ObjectOutputStream outputStream = new ObjectOutputStream(writeBuffer); outputStream.writeObject(objectOriginal); outputStream.close(); byte[] buffer = writeBuffer.toByteArray(); ByteArrayInputStream readBuffer = new ByteArrayInputStream(buffer); ObjectInputStream inputStream = new ObjectInputStream(readBuffer); BigObject objectCopy = (BigObject)inputStream.readObject(); if (objectCopy.getId() == originalId) System.out.println( "originalId equals copiedId"); } } </code>
<h4>Запис об'єкту</h4> Спочатку створюємо об'єкт серіалізованого класу BigObject, потім готуємо під нього буфер даних - місце куди всі бантики складатимемо ByteArrayOutputStream. Потім готуємо вже згаданий ObjectOutputStream і передаємо йому буфер. Записуємо наш об'єкт у потік та закриваємо його. 
<h4>Читання об'єкта</h4> Підготуємо буфер запису readBuffer, передамо вputStream, прочитаємо readObject(). Тепер об'єкт відновлено. Завдяки тому, що поле `id` не було посиланням, ми змогли помітити Serializable клас, який повністю містить свої дані. Замість того, щоб додавати функції перевірки всередині нашого класу, маркери дозволяють спростити процедуру валідації класів.