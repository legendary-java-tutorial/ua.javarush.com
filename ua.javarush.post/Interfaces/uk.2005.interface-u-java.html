Interface у Java
<p>----------------------------------------</p>
Що це? Приклад лістингу інтерфейсу (з generics): Поширена круд (від CRUD: Create, Read, Update, Delete) інтерфейс. Позначається public, тому що має реалізовуватись (implements) класом. Що означає ? Все дуже просто: він має розписати у собі 
<p>----------------------------------------</p>
<em>Я поганий оповідач, якщо я не маю мети пояснити щось незрозуміле комусь із конкретним запитом, тому розбираюся в простому, ну і за одне напишу про це тут. Я не дотримуюсь прикладу навчання CodeGym, як те, що спочатку поставити питання, а потім розповідати, як це робити. Я прихильник спочатку розповісти, а потім питати, як і під час розповіді, спочатку показати, а потім пояснювати.</em>
<div class="row justify-content-center jr-image-wrap">
 <div class="col-12 col-sm-10 col-md-8">
  <img data-id="a3f07efa-2ced-412c-96cd-eeba28c0958b" data-max-width="710" alt="Interface в Java - 1" src="https://cdn.javarush.com/images/article/a3f07efa-2ced-412c-96cd-eeba28c0958b/512.jpeg" style="width: 710px;">
 </div>
</div><em>BS: Дії == поведінка, сприймайте як синоніми, просто дії правильно розуміються, це завжди щось активне, а поведінка може нічого не показувати.</em>
<h2>interface - інтерфейс</h2>Що це? Приклад лістингу інтерфейсу (з generics): 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Store</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> ID<span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">,</span> <span class="token class-name">ID</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token class-name">ID</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">T</span> <span class="token function">findOne</span><span class="token punctuation">(</span><span class="token class-name">ID</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre> Поширена круд (від CRUD: Create, Read, Update, Delete) інтерфейс. <em>Не лякайтеся, все досить просто. Цей інтерфейс означає, що робота з багатьма базами даних будується за таким принципом: потрібно додати запис, оновити запис, видалити і знайти всі записи. Ви ще 100 разів це зустрінете і самі стільки ж разів напишете майже такий самий інтерфейс. </em> Позначається public, тому що має реалізовуватись (implements) класом. Що означає <strong>реалізовуватися класом</strong> ? Все дуже просто: він має розписати у собі всі методи інтерфейсу. Найпростіший приклад реалізації у класі: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">void</span> add <span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	bookstore<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre> Замість T t буде підставлятися якийсь дженерик. У двох словах це тип змінної, тому і позначається найчастіше як T = Type. У нашому прикладі, скажімо, може бути такий: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">void</span> add <span class="token punctuation">(</span><span class="token class-name">Book</span> book<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	bookstore<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>book<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre> Звичайно, на місце Book book ви можете підставити будь-яку змінну, яка вам потрібна для вашої реалізації. Для розуміння можна теоретично уявити, що T = Object, а оскільки Java все є Object, можна визначити туди також будь-який ваш клас/змінну. Єдиний трабл виникатиме потім — ексепшени, якщо клас нульовий тощо. Своїми словами — програмна структура, що визначає відносини між об'єктами, за допомогою поділу їх на деякі поведінкові частини. Мета інтерфейсу - визначення функціоналу для реалізації його класом. Тобто опис сигнатур методів. Усередині інтерфейсу знаходяться назви методів, що повертають та вхідні значення, і все. Ну ще можна позначити там якісь змінні, але вони відразу стають неявно public static final, і можуть бути доступні з будь-якої частини програми. Інтерфейс визначає події, тому у ньому перебувають ці самі події, тобто. функції чи методи. <strong>Навіщо це потрібно? Що це спрощує чи які дає переваги? </strong> Спрощення опису дій, поведінки. Ми говоримо, що робити, а як це робити, кожен клас реалізує сам. Економія часу у великих проектах. Інтерфейси створюються в ситуаціях, коли ми знаємо, що потрібно виконати деяке завдання, але як це зробити може відрізнятися. Інтерфейс визначає назви дій - це просто як напрямок певної абстракції. Хоча можуть зустрічатися і інтерфейси без методів та полів, такі як маркери, типу Cloneable, Remote тощо. Візьмемо всіма улюблений приклад із автомобілем. Інтерфейс у ньому описуватиме можливі дії машини, поворот керма чи напрямок руху, набір швидкості, залишок бензину тощо. Тобто ті самі дії, які можуть бути у будь-якого автомобіля. Іншими словами, ми опускаємося в нетрі деградації на найнижчий рівень створення найпершого автомобіля і своїми мізками додумуємо, як він створювався і що він мав. Звичайно, ми описуємо це абстрактно і тільки для дій. Що було у найпершого авто? Кермо було? Був, значить кудись повертався, напрямок керма/руху. Колеса були? Так, значить їхав із якоюсь швидкістю, зміна швидкості. Ось і весь інтерфейс. Але загалом інтерфейси створюються під якусь реалізацію деяких процесів. Тобто. ми пишемо програму для більш конкретних, ніж для всього, що тільки можна придумати. Тому і самі інтерфейси будуть містити більш чіткі та конкретні методи. Звичайно ж, вони будуть настільки абстрактні, наскільки це можливо. Інтерфейси можуть бути успадковані один від одного як класи. ми описуємо це абстрактно і лише дій. Що було у найпершого авто? Кермо було? Був, значить кудись повертався, напрямок керма/руху. Колеса були? Так, значить їхав із якоюсь швидкістю, зміна швидкості. Ось і весь інтерфейс. Але загалом інтерфейси створюються під якусь реалізацію деяких процесів. Тобто. ми пишемо програму для більш конкретних, ніж для всього, що тільки можна придумати. Тому і самі інтерфейси будуть містити більш чіткі та конкретні методи. Звичайно ж, вони будуть настільки абстрактні, наскільки це можливо. Інтерфейси можуть бути успадковані один від одного як класи. ми описуємо це абстрактно і лише дій. Що було у найпершого авто? Кермо було? Був, значить кудись повертався, напрямок керма/руху. Колеса були? Так, значить їхав із якоюсь швидкістю, зміна швидкості. Ось і весь інтерфейс. Але загалом інтерфейси створюються під якусь реалізацію деяких процесів. Тобто. ми пишемо програму для більш конкретних, ніж для всього, що тільки можна придумати. Тому і самі інтерфейси будуть містити більш чіткі та конкретні методи. Звичайно ж, вони будуть настільки абстрактні, наскільки це можливо. Інтерфейси можуть бути успадковані один від одного як класи. Ось і весь інтерфейс. Але загалом інтерфейси створюються під якусь реалізацію деяких процесів. Тобто. ми пишемо програму для більш конкретних, ніж для всього, що тільки можна придумати. Тому і самі інтерфейси будуть містити більш чіткі та конкретні методи. Звичайно ж, вони будуть настільки абстрактні, наскільки це можливо. Інтерфейси можуть бути успадковані один від одного як класи. Ось і весь інтерфейс. Але загалом інтерфейси створюються під якусь реалізацію деяких процесів. Тобто. ми пишемо програму для більш конкретних, ніж для всього, що тільки можна придумати. Тому і самі інтерфейси будуть містити більш чіткі та конкретні методи. Звичайно ж, вони будуть настільки абстрактні, наскільки це можливо. Інтерфейси можуть бути успадковані один від одного як класи. 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token keyword">interface</span> <span class="token class-name">MyInterface</span> <span class="token keyword">extends</span> <span class="token class-name">NotMyinterface</span><span class="token punctuation">;</span></code></pre> Інтерфейси реалізовуються у класах. Реалізувати можна скільки завгодно інтерфейсів. На відміну від спадкування, успадковуватись тільки від одного. 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token keyword">class</span> <span class="token class-name">NewClass</span> <span class="token keyword">extends</span> <span class="token class-name">OldClass</span> <span class="token keyword">implements</span> <span class="token class-name">MyInterface</span><span class="token punctuation">,</span> <span class="token class-name">NotMyinterface</span><span class="token punctuation">;</span></code></pre> Тобто. ми придумали якісь дії, придумали їм назви, вхідні дані, дані, що повертаються, написали все це в інтерфейсі, потім створабо клас і додали наш інтерфейс до цього класу, тобто. реалізували наш інтерфейс у цьому класі. Далі всі описані в інтерфейсі методи/функції повинні обов'язково мати реалізацію. Її можна зробити безпосередньо в самому інтерфейсі, додавши слово default перед методом і написавши реалізацію прямо в методі, подібно до класу. Це стало можливим із 8-ї версії Java. Також її можна зробити у класі, який реалізовуватиме цей інтерфейс. Ну ось, інтерфейс написали, заімплементували у клас, накотабо реалізацію у класі, можна запускати та тестувати. Також можна почитати в інтерфейсах про: 
<ul>
 <li>Статичні способи.</li>
 <li>Приватні методи. (повтор коду)</li>
 <li>Змінні/Константи.</li>
 <li>Вкладені інтерфейси.</li>
</ul>Але це вже краще пізніше, та й зайвим забивати голову теж шкідливо. Цікаве питання, що таке Volvo? Class or Interface? 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class=" language-java">line1<span class="token operator">:</span> <span class="token class-name">Volvo</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VolvoV2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
line2<span class="token operator">:</span> <span class="token class-name">Volvo</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VolvoV3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Крім інтерфейсів, варто продовжити про абстрактні класи і класи. Може потім, коли буде ще кілька годин вільних. ))) <em>PS: Хлопці, всю критику прошу під постом або в ЛЗ, я чудово розумію, що вона є у всіх))) і мені завжди цікаво її почути, тому що це привід стати трохи кращим і знову таки продовжувати рухатися вперед. На цьому всім Вам велике спасибі та удачі у програмуванні. )))</em>