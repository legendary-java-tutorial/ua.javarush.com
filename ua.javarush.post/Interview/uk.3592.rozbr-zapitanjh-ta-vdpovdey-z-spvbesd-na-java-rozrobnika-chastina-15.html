Розбір запитань та відповідей із співбесід на Java-розробника. Частина 15
<p>----------------------------------------</p>
Привіт привіт! Як багато потрібно знати Java розробнику? Можна довго сперечатися з цього питання, але правда в тому, що на співбесіді вас ганятимуть з теорії на повне зростання. Навіть за тими областями знань, які вам не доведеться скориста
<p>----------------------------------------</p>
Привіт привіт! Як багато потрібно знати Java розробнику? Можна довго сперечатися з цього питання, але правда в тому, що на співбесіді вас ганятимуть з теорії на повне зростання. Навіть за тими областями знань, які вам не доведеться скористатися в роботі. <img data-max-width="800" data-id="71f4a571-2d7b-416e-95c4-be2e18eefa10" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 15 - 1" src="https://cdn.javarush.com/images/article/71f4a571-2d7b-416e-95c4-be2e18eefa10/800.jpeg" style="width: 800px;">Ну а якщо ви новачок, за вашими теоретичними знаннями пройдуть дуже серйозно. Якщо досвіду і великих досягнень ще немає, залишається лише перевірити міцність бази знань. Сьогодні ми продовжимо займатися зміцненням цієї бази, розбираючи найпопулярніші питання на співбесідах для Java-розробників. Полетіли! 
<h3>Java Core</h3>
<h4>9. У чому різниця між статичним та динамічним зв'язуванням у Java?</h4>На це питання я вже відповів у <a href="https://codegym.cc/groups/posts/3252-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-2" target="_blank">цій статті</a> у 18 питанні про статичний та динамічний поліморфізм, раджу ознайомитись. 
<h4>10. Чи можна використовувати private чи protected змінні в interface?</h4>Ні, не можна. Так як коли ви оголошує інтерфейс, компілятор Java автоматично додає ключові слова <span class="code">public</span> і <span class="code">abstract</span> перед методами інтерфейсу та ключові слова <span class="code">public</span> , <span class="code">static</span> та <span class="code">final</span> перед членами даних. Власне, якщо ви додасте <span class="code">private</span> або <span class="code">protected</span> , виникне конфлікт, і компілятор лаятиметься на модифікатор доступу повідомленням: "Modifier '&lt;вибраний модифікатор&gt;' not allowed here" Чому ж компілятор додає <span class="code">public</span> , <span class="code">static</span> і <span class="code">final</span> змінним в інтерфейсі? Давайте розберемося:
<ul>
 <li><span class="code">public</span> – інтерфейс надає можливість клієнту взаємодіяти з об'єктом. Якби змінні не були загальнодоступними, клієнти не мали б до них доступу.</li>
 <li><span class="code">static</span> — інтерфейси неможливо створити (а точніше, їх об'єкти), тому змінна статична.</li>
 <li><span class="code">final</span> — так як інтерфейс використовується для досягнення 100% абстракції, змінна має кінцевий вигляд (і не буде змінена).</li>
</ul>
<h4>11. Що таке Classloader і навіщо використовується?</h4><span class="text-bold">Classloader</span> або Завантажувач класів забезпечує завантаження класів Java. Точніше, забезпечують завантаження його спадкоємці — конкретні завантажувачі класів, т.к. сам <span class="code">ClassLoader</span> абстрактний. Щоразу, коли завантажується будь-який .class-файл, наприклад, після звернення до конструктора або статичного методу відповідного класу, цю дію виконує один із спадкоємців класу <span class="code">ClassLoader</span> . Є три види спадкоємців:
<ol>
 <li>
  <p><span class="text-bold">Bootstrap ClassLoader</span> - базовий завантажувач, реалізований на рівні JVM і не має зворотного зв'язку із середовищем виконання, оскільки є частиною ядра JVM і написаний у машинному коді. Цей завантажувач є батьківським елементом для всіх інших екземплярів ClassLoader.</p> В основному відповідає за завантаження внутрішніх класів JDK, зазвичай <em>rt.jar</em> та інших основних бібліотек, розташованих у каталозі <em>$JAVA_HOME/jre/lib</em> . У різних платформ можуть бути різні реалізації цього класу завантажувача.
  <p></p></li>
 <li>
  <p><span class="text-bold">Extension Classloader</span> - завантажувач розширень, нащадок класу базового завантажувача. Дбає про завантаження розширення стандартних базових класів Java. Завантажується з каталогу розширень JDK, зазвичай <em>$ JAVA_HOME / lib / ext</em> або будь-якого іншого каталогу, згаданого в системній властивості java.ext.dirs (за допомогою цієї опції можна керувати завантаженням розширень).</p></li>
 <li>
  <p><span class="code">System ClassLoader</span> - системний завантажувач, реалізований на рівні JRE, який піклується про завантаження всіх класів рівня програми JVM. Він завантажує файли, знайдені у змінному оточенні класів <em>-classpath</em> або <em>-cp</em> опції командного рядка.</p></li>
</ol><img data-max-width="512" data-id="55679f3e-baa9-4442-8715-929d8c44d598" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 15 - 2" src="https://cdn.javarush.com/images/article/55679f3e-baa9-4442-8715-929d8c44d598/512.jpeg" style="width: 512px;">Завантажувачі класів - це частина середовища виконання Java. Коли JVM запитує клас, завантажувач класів намагається знайти клас і завантажити визначення класу в середу виконання, використовуючи повне ім'я класу. Метод <span class="code">java.lang.ClassLoader.loadClass()</span> відповідає за завантаження визначення класу під час виконання. Він намагається завантажити клас на основі повного імені. Якщо клас не завантажений, він делегує запит завантажувачу батьківського класу. Цей процес відбувається рекурсивно виглядає так:
<ol>
 <li>
  <p>System Classloader намагається знайти клас у своєму кеші.</p>
  <ul style="list-style: none;">
   <li>
    <p>1.1. Якщо клас знайдено, завантаження успішно завершено.</p></li>
   <li>
    <p>1.2. Якщо клас не знайдено, завантаження делегується до Extension Classloader.</p></li>
  </ul></li>
 <li>
  <p>Extension Classloader намагається знайти клас у власному кеші.</p>
  <ul style="list-style: none;">
   <li>
    <p>2.1. Якщо клас знайдено – успішно завершено.</p></li>
   <li>
    <p>2.2. Якщо клас не знайдено, завантаження делегується Bootstrap Classloader.</p></li>
  </ul></li>
 <li>
  <p>Bootstrap Classloader намагається знайти клас у власному кеші.</p>
  <ul style="list-style: none;">
   <li>
    <p>3.1. Якщо клас знайдено, завантаження успішно завершено.</p></li>
   <li>
    <p>3.2. Якщо клас не знайдено, базовий Bootstrap Classloader спробує завантажити його.</p></li>
  </ul></li>
 <li>
  <p>Якщо завантаження:</p>
  <ul style="list-style: none;">
   <li>
    <p>4.1. Пройшла успішно - завантаження класу завершено.</p></li>
   <li>
    <p>4.2. Не пройшла успішно – керування передається до Extension Classloader.</p></li>
  </ul></li>
 <li>
  <p>5. Extension Classloader намагається завантажити клас, і якщо завантаження:</p>
  <ul style="list-style: none;">
   <li>
    <p>5.1. Пройшла успішно - завантаження класу завершено.</p></li>
   <li>
    <p>5.2. Не пройшла успішно – керування передається до System Classloader.</p></li>
  </ul></li>
 <li>
  <p>6. System Classloader намагається завантажити клас, і якщо завантаження:</p>
  <ul style="list-style: none;">
   <li>
    <p>6.1. Пройшла успішно - завантаження класу завершено.</p></li>
   <li>
    <p>6.2. Не пройшла успішно – генерується виняток – ClassNotFoundException.</p></li>
  </ul></li>
</ol>Тема завантажувачів класів велика і не варто нехтувати. Щоб ознайомитися з нею докладніше, раджу прочитати <a href="https://codegym.cc/groups/posts/646-kak-proiskhodit-zagruzka-klassov-v-jvm" target="_blank">цю статтю</a> , а ми не затримуватимемося і підемо далі. 
<h4>12. Що таке Run-Time Data Areas?</h4><span class="text-bold">Run-Time Data Ares</span> - області даних середовища виконання JVM. JVM визначає деякі області даних часу виконання, необхідні під час виконання програми. Одні з них створюються під час запуску JVM. Інші локальні по відношенню до потоків і створюються тільки при створенні потоку (і знищуються, коли потік знищується). Області даних середовища виконання JVM виглядають так: <img data-max-width="512" data-id="0fd344e9-cc14-4d88-b544-2735144da82f" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 15 – 3" src="https://cdn.javarush.com/images/article/0fd344e9-cc14-4d88-b544-2735144da82f/512.jpeg" style="width: 512px;">
<ul>
 <li>
  <p>PC Register – регістр ПК – локальний для кожного потоку та містить адресау інструкції JVM, яку потік виконує в даний момент.</p></li>
 <li>
  <p>JVM Stack — це область пам'яті, яка використовується як сховище для локальних змінних і часових результатів. Кожен поток має свій окремий стек: як тільки потік завершується, цей стек також знищується. Варто відзначити, що перевагою stack над heap є продуктивність, у той час як heap безумовно має перевагу в масштабі сховища.</p></li>
 <li>
  <p>Native Method Stack — область даних кожному потоку, у якій зберігаються елементи даних, аналогічні стеку JVM, до виконання власних (не Java) методів.</p></li>
 <li>
  <p>Heap - використовується всіма потоками як сховище, яке містить об'єкти, метадані класів, масиви і т. д., які створюються під час виконання. Ця область створюється під час запуску JVM і знищується після завершення її роботи.</p></li>
 <li>
  <p>Method area — область методу — ця область часу виконання загальна всім потоків і створюється під час запуску JVM. Він зберігає структури кожного класу, такі як пул констант (Runtime Constant Pool — пул для зберігання констант), код для конструкторів і методів, дані методу тощо.</p></li>
</ul>
<h4>13. Що таке immutable object?</h4>У <a href="https://codegym.cc/groups/posts/3252-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-2" target="_blank">цій частині</a> статті в 14 і 15 питанні вже є відповідь на це питання, тому ознайомлюєтеся не марнуючи часу. 
<h4>14. У чому особливість класу String?</h4>Раніше у розборі ми неодноразово говорабо про ті чи інші особливості <span class="code">String</span> (для цього був окремий розділ). Зараз підіб'ємо підсумок по особливостям <span class="code">String</span> :
<ol>
 <li>
  <p>Це найпопулярніший об'єкт Java, який застосовують для різноманітних цілей. За частотою використання не поступається навіть примітивним типам.</p></li>
 <li>
  <p>Об'єкт даного класу можна створити без використання ключового слова new безпосередньо через лапки <span class="code">String str = "рядок"; </span>.</p></li>
 <li>
  <p><span class="code">String</span> - це <span class="code">immutable</span> клас: при створенні об'єкта даного класу його дані не можна змінити (коли ви до деякого рядка додаєте + "інший рядок", як результат ви отримаєте новий, третій рядок). Незмінність класу String робить його безпечним.</p></li>
 <li>
  <p>Клас <span class="code">String</span> фіналізований (має модифікатор <span class="code">final</span> ), тому його успадкування неможливе.</p></li>
 <li>
  <p>String має свій пул рядків, область пам'яті в heap, яка кешує створювані рядкові значення <span class="code">. </span><a href="https://codegym.cc/groups/posts/3386-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-7" target="_blank">У цій частині серії</a> , у 62 питанні, я описував рядковий пул.</p></li>
 <li>
  <p>У Java присутні аналоги <span class="code">String</span> , також призначені для роботи з рядками - <span class="code">StringBuilder</span> і <span class="code">StringBuffer</span> , але з тією відмінністю, що вони змінюються. Докладніше про них ви можете почитати <a href="https://codegym.cc/groups/posts/2351-znakomstvo-so-string-stringbuffer-i-stringbuilder-v-java" target="_blank">у цій статті</a> .</p></li>
</ol><img data-max-width="512" data-id="2f6121e7-eaf3-41ea-956e-b0dc604d3137" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 15 – 4" src="https://cdn.javarush.com/images/article/2f6121e7-eaf3-41ea-956e-b0dc604d3137/512.jpeg" style="width: 512px;">
<h4>15. Що таке підступність типів?</h4>Для розуміння підступності ми розглянемо приклад. Припустимо, у нас є клас тварини: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
 <span class="token keyword">void</span> <span class="token function">voice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"*тишина*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre> І деякий розширюючий його клас <span class="code">Dog</span> : 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>

 <span class="token annotation punctuation">@Override</span>
 <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">voice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Гав, гав, гав!!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre> Як ми пам'ятаємо, батьківському типу ми можемо без проблем надавати об'єкти типу спадкоємця: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">Animal</span> animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Це в нас буде ніщо інше, як поліморфізм. Зручно, чи не так? Ну а у випадку зі списком тварин? Чи зможемо ми задати список з дженериком <span class="code">Animal</span> список з об'єктами <span class="code">Dog</span> ? 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class=" language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Dog</span><span class="token punctuation">&gt;</span></span> dogs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Animal</span><span class="token punctuation">&gt;</span></span> animals <span class="token operator">=</span> dogs<span class="token punctuation">;</span></code></pre> У разі рядок присвоєння списку тварин списку собак буде підкреслено червоним, тобто. компілятор не пропустить цей код. Незважаючи на те, що як це привласнення дуже логічно (адже змінної типу <span class="code">Animal</span> ми можемо привласнити об'єкт <span class="code">Dog</span> ) його зробити не можна. Це відбувається тому, що якби це було припустимо, у список, який спочатку призначений для <span class="code">Dog</span> , ми зможемо покласти об'єкт <span class="code">Animal</span> , при цьому думаючи, що в списку у нас тільки <span class="code">Dogs</span> . І потім, наприклад, візьмемо за допомогою методу <span class="code">get()</span> об'єкт у того списку <span class="code">dogs</span> , думаючи, що це собака, і викличемо у нього деякий метод об'єкта <span class="code">Dog</span> , якого немає у<span class="code">Animal</span> . І як ви розумієте, це неможливо – впаде помилка. Але, на щастя, компілятор не пропускає цієї логічної помилки з присвоєнням списку нащадків, списку батьків (і навпаки). У Java можливе присвоєння об'єктів списків лише змінним спискам з дженериками, що збігаються. Це називається інваріацією. Якби могли це зробити, це називалося б і називалося підступом. Тобто, <span class="text-bold">коваріація</span> - це якби ми могли змінної типу <span class="code">List&lt;Animal&gt;</span> задати об'єкт типу <span class="code">ArrayList&lt;Dog&gt;</span> . Виходить що Java варіантність не підтримується? Як би не так! <img data-max-width="512" data-id="413b8861-5d64-40ee-af3c-48fd5019fb00" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 15 – 5" src="https://cdn.javarush.com/images/article/413b8861-5d64-40ee-af3c-48fd5019fb00/512.jpeg" style="width: 512px;">Але це робиться своїм особливим шляхом. Для цього використовується конструкція <span class="code">? extends Animal</span>. Вона ставиться дженериком змінної, якою хочемо задати об'єкт списку, з дженериком нащадка. Ця конструкція дженерика означає, що підійде будь-який тип, який є нащадком типу <span class="code">Animal</span> (і тип <span class="code">Animal</span> також підпадає під це узагальнення). У свою чергу, <span class="code">Animal</span> може бути не тільки класом, але і інтерфейсом (і нехай вас не вводить в оману ключове слово <span class="code">extends</span> ). Наше попереднє присвоєння ми можемо виконати так: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class=" language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Dog</span><span class="token punctuation">&gt;</span></span> dogs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">&gt;</span></span> animals <span class="token operator">=</span> dogs<span class="token punctuation">;</span></code></pre> В результаті ви побачите в IDE, що компілятор не лаятиметься на цю конструкцію. Давайте перевіримо працездатність цієї конструкції. Припустимо, ми маємо метод, який змушує всіх переданих йому тварин видати звуки: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">animalsVoice</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">&gt;</span></span> animals<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Animal</span> animal <span class="token operator">:</span> animals<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   animal<span class="token punctuation">.</span><span class="token function">voice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre> Передамо йому список із собаками: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Dog</span><span class="token punctuation">&gt;</span></span> dogs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
dogs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
dogs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
dogs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">animalsVoice</span><span class="token punctuation">(</span>dogs<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> У консолі ми побачимо наступний висновок: 
<div class="terminal">
 Гав гав гав!!! Гав гав гав!!! Гав гав гав!!!
</div> А отже, цей підхід до підступності успішно працює. Зазначу, що в список з цим дженеріком <span class="code">? extends Animal</span> ми не можемо вставити нові дані ніякого типу: ні типу <span class="code">Dog</span> , ні навіть типу <span class="code">Animal</span> : 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Dog</span><span class="token punctuation">&gt;</span></span> dogs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">&gt;</span></span> animals <span class="token operator">=</span> dogs<span class="token punctuation">;</span>
animals<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
dogs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Власне, в останніх двох рядках компілятор підкреслюватиме червоним вставку об'єктів. Це пов'язано з тим, що ми не можемо бути повністю впевнені, перелік з об'єктами якого типу буде присвоєний переліку з даних дженеріком <span class="code">&lt;? extends Animal&gt;</span> . <img data-max-width="512" data-id="62799392-36c0-4d2e-a9ad-ec23bef457ca" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 15 – 6" src="https://cdn.javarush.com/images/article/62799392-36c0-4d2e-a9ad-ec23bef457ca/512.jpeg" style="width: 512px;">Хотілося б ще розповісти про <span class="text-bold">контраваріантність</span> , тому що зазвичай це поняття завжди йде разом з підступністю, і як правило запитують про них разом. Це — деяка протилежність ковариантности, оскільки даної конструкції використовується тип спадкоємця. Припустимо, нам потрібен список, якому можна буде присвоїти список з типом об'єктів, які не є предками об'єкта <span class="code">Dog</span>. При цьому ми не знаємо, що це будуть за конкретні типи. У такому разі нас може виручити конструкція виду <span class="code">? super Dog</span> , для якої підходять всі типи - прабатьки класу <span class="code">Dog</span> : 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Animal</span><span class="token punctuation">&gt;</span></span> animals <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">Dog</span><span class="token punctuation">&gt;</span></span> dogs <span class="token operator">=</span> animals<span class="token punctuation">;</span>
dogs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
dogs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Ми можемо сміливо додавати до списку з таким дженериком об'єкти типу <span class="code">Dog</span> , адже у нього в будь-якому випадку є всі реалізовані методи будь-якого його прабатька. Але ми не зможемо додати об'єкт типу <span class="code">Animal</span> , тому що немає впевненості, що всередині будуть саме об'єкти цього типу, а не, наприклад, <span class="code">Dog</span> . Адже ми можемо запитати у елемента даного списку метод класу <span class="code">Dog</span> , якого не буде в наявності у <span class="code">Animal</span> . У разі виникне помилка компіляції. Також, якби ми захотіли реалізувати попередній метод, але вже з цим дженериком: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">animalsVoice</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">Dog</span><span class="token punctuation">&gt;</span></span> dogs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Dog</span> dog <span class="token operator">:</span> dogs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   dog<span class="token punctuation">.</span><span class="token function">voice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre> ми отримали помилку компіляції в циклі <span class="code">for</span> , оскільки ми можемо бути впевнені, що список містить об'єкти типу <span class="code">Dog</span> і вільно використовувати його методи. Якщо цей перелік ми викличемо метод <span class="code">dogs.get(0); </span> - Ми отримаємо об'єкт типу <span class="code">Object</span> . Тобто для роботи методу <span class="code">animalsVoice()</span> нам як мінімум потрібно додати невеликі маніпуляції із звуженням даних виду: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">animalsVoice</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">Dog</span><span class="token punctuation">&gt;</span></span> dogs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> obj <span class="token operator">:</span> dogs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Dog</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token class-name">Dog</span> dog <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Dog</span><span class="token punctuation">)</span> obj<span class="token punctuation">;</span>
     dog<span class="token punctuation">.</span><span class="token function">voice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><img data-max-width="512" data-id="28e6b9f8-0d5b-4133-86b5-8e1590f8a083" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 15 – 7" src="https://cdn.javarush.com/images/article/28e6b9f8-0d5b-4133-86b5-8e1590f8a083/512.jpeg" style="width: 512px;">
<h4>16. Які методи в класі Object?</h4>У <a href="https://codegym.cc/groups/posts/3252-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-2" target="_blank">цій частині</a> серії, в 11 пункті, я вже відповів на це питання, тому настійно раджу ознайомитися, якщо ви досі цього не зробабо. На цьому сьогодні й закінчимо. До зустрічі у наступній частині! <img data-max-width="512" data-id="66ee3014-ef50-479f-8890-a8d6fd0b3a1a" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 15 – 8" src="https://cdn.javarush.com/images/article/66ee3014-ef50-479f-8890-a8d6fd0b3a1a/512.jpeg" style="width: 512px;">
<div class="table-container">
 <table>
  <tbody>
   <tr>
    <th>Інші матеріали серії:</th>
   </tr>
   <tr>
    <td>
     <ul>
      <li><a href="https://codegym.cc/groups/posts/3243-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-1" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 1</a></li>
      <li><a href="https://codegym.cc/groups/posts/3252-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-2" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 2</a></li>
      <li><a href="https://codegym.cc/groups/posts/3273-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-3" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 3</a></li>
      <li><a href="https://codegym.cc/groups/posts/3284-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-4" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 4</a></li>
      <li><a href="https://codegym.cc/groups/posts/3296-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-5" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 5</a></li>
      <li><a href="https://codegym.cc/groups/posts/3341-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-6" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 6</a></li>
      <li><a href="https://codegym.cc/groups/posts/3386-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-7" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 7</a></li>
      <li><a href="https://codegym.cc/groups/posts/3415-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-8" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 8</a></li>
      <li><a href="https://codegym.cc/groups/posts/3434-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-9" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 9</a></li>
      <li><a href="https://codegym.cc/groups/posts/3452-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-10" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 10</a></li>
      <li><a href="https://codegym.cc/groups/posts/3464-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-11" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 11</a></li>
      <li><a href="https://codegym.cc/groups/posts/3475-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-12" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 12</a></li>
      <li><a href="https://codegym.cc/groups/posts/3507-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-13" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 13</a></li>
      <li><a href="https://codegym.cc/groups/posts/3558-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-14" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 14</a></li>
      <li><a href="https://codegym.cc/groups/posts/3621-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-16" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 16</a></li>
     </ul></td>
   </tr>
  </tbody>
 </table>
</div><a href="https://codegym.cc/login/signup" target="_blank"><img data-max-width="1080" id="click_banner5_articles" data-id="45b146ac-f14c-450e-990e-a2b24253c9e6" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 15 – 9" src="https://cdn.javarush.com/images/article/45b146ac-f14c-450e-990e-a2b24253c9e6/1080.jpeg" style="width: 1080px;"></a>