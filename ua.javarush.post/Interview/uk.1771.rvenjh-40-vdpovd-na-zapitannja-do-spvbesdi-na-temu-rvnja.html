Рівень 40. Відповіді на запитання до співбесіди на тему рівня
<p>----------------------------------------</p>
Власне, такі питання були на цьому рівні:
<p>----------------------------------------</p>
<img data-id="fddb43a0-d92d-48c7-9fac-f0f94258b684" data-max-width="850" alt="Рівень 40. Відповіді на запитання до співбесіди на тему рівня - 1" src="https://cdn.javarush.com/images/article/fddb43a0-d92d-48c7-9fac-f0f94258b684/800.jpeg" style="width: 850px;">Власне, такі питання були на цьому рівні: 
<ol>
 <li>Що таке IP-адресаа?</li>
 <li>У чому відмінність host і domain?</li>
 <li>Які методи в HTTP ви знаєте</li>
 <li>Чим відрізняються методи GET, POST та HEAD?</li>
 <li>Що таке REST?</li>
 <li>Навіщо потрібен клас Calendar Java?</li>
 <li>Як перетворити дату Java на потрібний формат?</li>
 <li>У чому відмінність URI та URL?</li>
 <li>Що таке сокети?</li>
 <li>Відмінність класів Socket та URL?</li>
</ol><strong>А ось мої відповіді:</strong>
<ol>
 <li>
  <p><strong>IP-адресаа</strong> – це унікальна мережна адресаа вузла в комп'ютерній мережі, побудованій на стеку протоколів TCP/IP. У мережі Інтернет потрібна глобальна унікальність адресаи; у разі роботи в локальній мережі потрібна унікальність адресаи в межах мережі. У версії протоколу IPv4 IP-адресаа має довжину 4 байти, а у версії протоколу IPv6 IP-адресаа має довжину 16 байт. Зазвичай IP-адресаа у версії протоколу IPv4 записують у вигляді чотирьох десяткових чисел зі значеннями від 0 до 255, розділених точкою, наприклад, 192.168.0.3.</p></li>
 <li>
  <p><strong>Домен</strong> — це адресаа сайту або певна зона, яка має своє ім'я, не схоже на інше ім'я в системі доменних імен. Домени бувають першого рівня, другого рівня, третього рівня тощо. Зазвичай, домен першого рівня не доступний звичайним користувачам для реєстрації (приклади доменів першого рівня - ".ru", ".com", ".net"). Зазвичай домени третього та наступних рівнів називають субдоменами. <br><strong>Хост</strong> — це певний комп'ютер чи сервер, підключений до локальної чи глобальної мережі. Хост має унікальну адресау в середовищі сервісів TCP/IP (IP-адресаою).</p></li>
 <li>
  <p>GET, POST, PUT, DELETE, OPTIONS, HEAD, PATCH, TRACE, LINK, UNLINK, CONNECT.</p></li>
 <li>
  <div class="table-container">
   <table>
    <tbody>
     <tr>
      <th></th>
      <th>GET</th>
      <th>POST</th>
      <th>HEAD</th>
     </tr>
     <tr>
      <td>Тіло запиту</td>
      <td>Ні</td>
      <td>Є</td>
      <td>Ні</td>
     </tr>
     <tr>
      <td>Тіло Відповіді</td>
      <td>Так</td>
      <td>Так</td>
      <td>Ні</td>
     </tr>
     <tr>
      <td>Кешування результату запиту</td>
      <td>Так</td>
      <td>Ні</td>
      <td>Так, заголовки</td>
     </tr>
     <tr>
      <td>Ідемопотентність</td>
      <td>Так</td>
      <td>Ні</td>
      <td>Так</td>
     </tr>
    </tbody>
   </table>
  </div>
  <p>Метод <strong>GET</strong> використовується для запиту на вміст вказаного ресурсу. Метод <strong>POST</strong> застосовується передачі користувачів даних заданому ресурсу. Метод <strong>HEAD</strong> зазвичай застосовується для отримання метаданих, перевірки наявності ресурсу (валідація URL) і щоб дізнатися, чи не змінився він з моменту останнього звернення. Метод HEAD аналогічний методу GET, крім того, що у відповіді сервера відсутнє тіло. Метод GET вважає спрощеною версією POST, тому що метод GET не передбачає повноцінного запиту, тільки URL як такий.</p></li>
 <li>
  <p><strong>REST</strong> – це архітектурний стиль взаємодії компонентів розподіленої програми у мережі. Термін був запроваджений Роєм Філдінгом у 2000 році. Також їм було введено вимоги, яким має задовольняти розподілений додаток, щоб відповідати архітектурі REST (такі програми ще називають RESTful). Ось ці вимоги:</p>
  <ol>
   <li>Модель "Клієнт-Сервер" (означає, що мережа повинна складатися з клієнта та сервера; сервер - це той, хто має ресурси, клієнт - той, який їх запитує)</li>
   <li>Відсутність стану (означає, що клієнт, ні сервер не відстежують стану одне одного)</li>
   <li>Кешування (клієнти та проміжні вузли можуть кешувати результати запитів; відповідно, відповіді сервера повинні мати явне або неявне позначення, що вони кешуються або не кешуються)</li>
   <li>Одноманітність інтерфейсу (означає, що між клієнтами та серверами існує спільна мова взаємодії, яка дозволяє їм бути замінюваними або змінюваними, без порушення цілісності системи):
    <ul>
     <li>Визначення ресурсу (означає, що кожен ресурс має бути позначений постійним ідентефікатором)</li>
     <li>Управління ресурсами через уявлення (означає, що клієнт зберігає ресурс у вигляді його уявлення, і за бажання зміни ресурсу він відправляє серверу інформацію у тому, як він хотів би бачити цей ресурс; сервер ж розглядає цей як запит як пропозицію, і сам вирішує , що робити йому зі збереженим ресурсом)</li>
     <li>Самодостатні повідомлення (кожне повідомлення містить достатньо інформації, щоб зрозуміти, як його обробляти)</li>
     <li>Гіпермедіа (означає, що клієнти змінюють стан системи лише через дії, які динамічно визначені у гіпермедіа на сервер)</li>
     <li>Система шарів (означає, що в системі може бути більше двох шарів (клієнт і сервер), і при цьому кожен такий шар знає тільки про свої сусідні шари, і не знає про інші шари, і взаємодіє тільки з сусідніми шарами)</li>
     <li>Код на вимогу (означає, що функціональність клієнта може бути розширена за рахунок завантаження коду з сервера у вигляді аплетів або сценаріїв)</li>
    </ul>
    <p>Задоволення цим вимогам дозволяє досягти наступного:</p>
    <ul>
     <li>Надійність</li>
     <li>Продуктивність</li>
     <li>Масштабованість</li>
     <li>Прозорість взаємодії</li>
     <li>Простота інтерфейсів</li>
     <li>Портативність компонентів</li>
     <li>Легкість внесення змін</li>
     <li>Здатність еволюціонувати, пристосовуючись до нових вимог</li>
    </ul></li>
  </ol></li>
 <li>Він потрібний для зручнішої роботи з датою та часом. Він дозволяє працювати з датою в рамках календаря, тобто дозволяє додавати та забирати дні від якоїсь конкретної дати, причому враховуватимуть і високосні роки. Крім того, він дозволяє уявити час мілісекундах у зручному вигляді - рік, місяць, день, години, хвабони, секунди. Також є багато методів для встановлення та отримання різних параметрів дати та часу, наприклад: день тижня, день місяця, день у році, номер тижня на місяці, номер тижня на рік.</li>
 <li>
  <p>Для цього існує зручний клас <code class=" language-none">SimpleDateFormat</code>. Примірнику цього класу можна передати шаблон подання дати, і тоді він у такому вигляді повертатиме дату (у форматі рядка <code class=" language-none">String</code>), або зчитувати дату (з рядка <code class=" language-none">String</code>). Виглядає все так:</p>
  <pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">Date</span></span> date <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">Date</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span> <span class="token comment"><span class="token comment">// получаем текущую дату</span></span>
<span class="token class-name"><span class="token class-name">SimpleDateFormat</span></span> formatter <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">SimpleDateFormat</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">"d-MM-yy HH:mm:ss"</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span> <span class="token comment"><span class="token comment">//создаём экземпляр класса SimpleDateFormat</span></span>
         								<span class="token comment"><span class="token comment">//и передаём ему шаблон представления даты и времени</span></span>
<span class="token class-name"><span class="token class-name">String</span></span> dateAsString <span class="token operator"><span class="token operator">=</span></span> formatter<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">format</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>date<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span> <span class="token comment"><span class="token comment">//преобразуем дату в строку заданного формата</span></span>

<span class="token class-name"><span class="token class-name">Date</span></span> dateAfterConversion <span class="token operator"><span class="token operator">=</span></span> formatter<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">parse</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>dateAsString<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span> <span class="token comment"><span class="token comment">//преобразуем строку обратно в дату</span></span></code></pre></li>
 <li>
  <p><strong>URI</strong> розшифровується як Uniform Resource Identifier і переводиться як "уніфікований ідентифікатор ресурсу". URI – це послідовність символів, що ідентифікує абстрактний чи фізичний ресурс. URL розшифровується як Uniform Resource Locator. Тобто це якийсь уніфікований покажчик на ресурс, що однозначно визначає його місцезнаходження. URL служить стандартизованим способом запису адресаи ресурсу в Інтернеті. <br>
    Їх відмінності в тому, що <strong>URI</strong> – це певний ідентифікатор ресурсу, який дозволяє цей ресурс якось ідентифікувати, а <strong>URL</strong> – це покажчик ресурсу, він дає інформацію про те, де знаходиться ресурс. Таким чином URL - це URI, який, крім ідентифікації ресурсу, дає інформацію про його місцезнаходження.</p></li>
 <li>
  <p><strong>Сокети</strong> – це зв'язка <em>IP-адресаа + порт</em> , що дозволяє із зовнішньої мережі однозначно ідентифікувати програму на комп'ютері чи сервері. У Java для роботи з сокетами є два класи <code class=" language-none">Socket</code>та <code class=" language-none">ServerSocket</code>. Примірники першого класу грають роль клієнта, екземпляри другого – роль сервера. Клієнт може надсилати та приймати повідомлення через сокет. Сервер постійно відстежує запити користувачів і відповідає на них. <br>
    Для того, щоб відправити дані через сокет, у класі <code class=" language-none">Socket</code>існує клас <code class=" language-none">getOutnputStream()</code>, що повертає вихідний потік, з яким вже можна працювати як завжди. Для прийому інформацію потрібно скористатися методом<code class=" language-none">getInputStream()</code>, який повертає вхідний потік. Далі з цим потоком можна працювати як із зазвичай після введення. Також варто відзначити, що при створенні клієнтського сокету (примірника класу <code class=" language-none">Socket</code>) в конструктор потрібно передати ip-адресау сервера та порт, на якому він працює приймаюча програма-сервер. <br>
    При створенні серверного сокету (екземпляра класу <code class=" language-none">ServerSocket</code>) потрібно вказувати лише порт, через який буде працювати програма. Після цього викликається метод <code class=" language-none">accept()</code>. Цей метод чекає підключення клієнта, а потім повертає екземпляр класу <code class=" language-none">Socket</code>, необхідний для взаємодії з цим клієнтом. Далі працювати йде з екземпляром класу <code class=" language-none">Socket</code>, як у першому випадку (у разі клієнта).</p></li>
 <li>Головна відмінність у тому, що клас <strong>URL</strong> призначений для роботи з URL-рядком (парсинг URL-рядка), а <strong>Socket</strong> використовується для з'єднання з віддаленим сервером та відправки інформації на сервер та/або прийому інформації від сервера (хоча, використовуючи клас URL, можна отримати доступ до ресурсу, на який вказує URL, але робиться це не безпосередньо, а через об'єкт класу URLConnection). Також, якщо дивитися загалом, Socket використовується для зв'язку з сервером (іншою програмою), а URL - для доступу до ресурсу (наприклад, до файлу). Крім того, URL та URLConnection орієнтовані в основному на роботу з HTTP, тоді як Socket може працювати з будь-якими протоколами.</li>
</ol>