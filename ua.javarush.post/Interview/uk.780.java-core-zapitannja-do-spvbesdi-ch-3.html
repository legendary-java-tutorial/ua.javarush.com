Java Core. Запитання до співбесіди, ч. 3
<p>----------------------------------------</p>
У попередніх двох статтях ми обговорили деякі важливі питання, які Вам найчастіше ставлять на співбесідах. Настав час продовжити та розглянути решту питань. Точною копією оригіналу є його клон. Java це означає можливість створювати об'єкт з
<p>----------------------------------------</p>
У попередніх двох статтях ми обговорабо деякі важливі питання, які Вам найчастіше ставлять на співбесідах. Настав час продовжити та розглянути решту питань. 
<div class="row justify-content-center jr-image-wrap">
 <div class="col-12 col-sm-10 col-md-8">
  <img data-id="0f9866ac-00cf-4322-8a00-b09432e1b5a6" data-max-width="710" alt="Java Core.  Запитання до співбесіди, ч. 3 - 1" src="https://cdn.javarush.com/images/article/0f9866ac-00cf-4322-8a00-b09432e1b5a6/512.jpeg" style="width: 710px;">
 </div>
</div>
<h2>Глибоке копіювання та поверхневе копіювання</h2>Точною копією оригіналу є його клон. Java це означає можливість створювати об'єкт з аналогічною структурою, як і у вихідного об'єкта. Метод <code class=" language-none">clone()</code>забезпечує цю функціональність. Поверхне копіювання копіює настільки малу частину інформації, наскільки це можливо. За умовчанням, клонування Java є поверховим, тобто. <code class=" language-none">Object class</code>не знає про структуру класу, яку він копіює. При клонуванні, JVM робить такі речі: 
<ol>
 <li>Якщо клас має лише члени примітивних типів, то буде створено абсолютно нову копію об'єкта та повернуто посилання на цей об'єкт.</li>
 <li>Якщо клас містить як члени примітивних типів, а й іншого типу класу, тоді копіюються посилання об'єкти цих классов. Отже, обидва об'єкти матимуть однакові посилання.</li>
</ol>Глибоке копіювання дублює все. Глибоке копіювання – це дві колекції, до однієї з яких дублюються всі елементи оригінальної колекції. Ми хочемо зробити копію, при якій внесення змін до будь-якого елемента копії не торкнеться оригінальної колекції. <strong>Глибоке клонування вимагає виконання таких правил:</strong>
<ol>
 <li>Немає потреби копіювати окремо примітивні дані;</li>
 <li>Усі класи-члени в оригінальному класі мають підтримувати клонування. Для кожного члена класу повинен викликатись <code class=" language-none">super.clone()</code>при перевизначенні методу <code class=" language-none">clone()</code>;</li>
 <li>Якщо якийсь член класу не підтримує клонування, то методі клонування необхідно створити новий екземпляр цього класу і скопіювати кожен його член з усіма атрибутами в новий об'єкт класу, по одному.</li>
</ol><a href="https://howtodoinjava.com/java/cloning/a-guide-to-object-cloning-in-java/" rel="nofollow">Дізнайтесь більше про клонування тут</a>
<h2>Що таке синхронізація? Блокування на рівні об'єкта та блокування на рівні класу?</h2><strong>Синхронізація</strong> відноситься до багатопоточності. Синхронізований блок коду може виконуватися одночасно лише одним потоком. Java дозволяє обробляти одночасно кілька потоків. Це може призвести до того, що два або більше потоку хочуть отримати доступ до одного поля. Синхронізація дозволяє уникнути помилок пам'яті, які виникають у разі неправильного використання ресурсів пам'яті. Коли метод оголошений як синхронізований, нитка утримує монітор. Якщо інша нитка намагається в цей час отримати доступ до синхронізованого методу, то потік блокується, і чекає на звільнення монітора. Синхронізація в Java здійснюється спеціальним ключовим словом <strong>synchronized</strong>. Ви можете помічати таким чином окремі блоки чи методи у вашому класі. Ключове слово synchronized не може бути використане разом із змінними чи атрибутами класу. <strong>Блокування на рівні об'єкта</strong> – механізм, коли ви хочете синхронізувати non-static метод чи non-static блок коду таким чином, що тільки один потік зможе виконати блок коду в даному екземплярі класу. Це потрібно завжди робити, щоб зробити екземпляр класу потокобезпечним. <strong>Блокування на рівні класу</strong>запобігає входу кількох потоків у синхронізований блок для всіх доступних екземплярів класу. Наприклад, якщо є 100 екземплярів класу DemoClass, то лише 1 потік зможе виконати demoMethod() використовуючи одну із змінних у певний момент часу. Це має бути завжди зроблено, щоб забезпечити безпеку статичного потоку. <a href="https://howtodoinjava.com/java/multi-threading/object-vs-class-level-locking/" rel="nofollow">Дізнайтеся більше про синхронізацію тут.</a>
<h2>Яка різниця між sleep() та wait()?</h2><code class=" language-none">Sleep()</code>це метод, який використовується, щоб затримати процес на кілька секунд. У випадку з <code class=" language-none">wait()</code>, нитка знаходиться в стані очікування, поки ми не викличемо метод <code class=" language-none">notify()</code>або <code class=" language-none">notifyAll()</code>. Основна відмінність полягає в тому, що <code class=" language-none">wait()</code>знімає блокування монітора, тоді як <code class=" language-none">sleep()</code>не звільняє блокування. <code class=" language-none">Wait()</code>використовується для багатострумових додатків, <code class=" language-none">sleep()</code>використовують просто для паузи виконання нитки. <code class=" language-none">Thread.sleep()</code>ставить поточний потік в "Not Runnable" стан на певну кількість часу. Нитка зберігає стан монітора, який був до виклику даного методу. Якщо ж інша нитка викликає <code class=" language-none">t.interrupt()</code>, нитка яка "заснула" - прокинеться. Зверніть увагу, що<code class=" language-none">sleep()</code>є статичним методом, що означає, що він завжди впливає на поточний потік (той, що виконує метод <code class=" language-none">sleep()</code>). Поширеною помилкою є виклик <code class=" language-none">t.sleep()</code>, де <code class=" language-none">t</code>є іншим потоком; навіть тоді, коли поточна нитка, яка викликала метод <code class=" language-none">sleep()</code>, не є <code class=" language-none">t</code>ниткою. <code class=" language-none">Object.wait()</code>посилає поточний потік в "Not Runnable" стан на деякий час, так само як і <code class=" language-none">sleep()</code>, але все ж таки з деяким нюансом. <code class=" language-none">Wait()</code>викликається для об'єкта, а чи не для нитки; ми називаємо цей об'єкт “lock object”. Перед викликом <code class=" language-none">lock.wait()</code>поточна нитка має бути синхронізована з “lock object”;<code class=" language-none">wait()</code>після цього знімає це блокування і додає нитку в ”wait list” пов'язаний з цим блокуванням. Пізніше інша нитка може бути синхронізована з тим самим lock object і викликати метод <code class=" language-none">lock.notify()</code>. Цей метод «розбудить» оригінальну нитку, яка все ще чекає. У принципі, <code class=" language-none">wait()</code>/ <code class=" language-none">notify()</code>можна порівняти з <code class=" language-none">sleep()</code>/ <code class=" language-none">interrupt()</code>, тільки активної нитки не потрібен прямий покажчик на нитку, що спить, потрібно тільки знати загальний lock object. <a href="https://howtodoinjava.com/java/multi-threading/sleep-vs-wait/" rel="nofollow">Читайте детальну різницю тут.</a>
<h2>Чи можна присвоїти null до цієї посилальної змінної?</h2>Ні, не можна. У Java ліва частина оператора присвоювання має бути змінною. This - це спеціальне ключове слово, яке завжди дає поточний екземпляр класу. Це не будь-яка змінна. Так само, null не можна привласнити змінної, використовуючи ключове слово “super” або будь-яке інше. 
<h2>Яка різниця між &amp;&amp; &amp;?</h2><code class=" language-none">&amp;</code>- Побітова а <code class=" language-none">&amp;&amp;</code>- логічно. 
<ol>
 <li><code class=" language-none">&amp;</code>оцінює обидві сторони операції;</li>
 <li><code class=" language-none">&amp;&amp;</code>оцінює ліву сторону операції. Якщо вона true, він продовжує оцінити праву сторону.</li>
</ol><a href="https://en.wikipedia.org/wiki/Bitwise_operation" rel="nofollow">Подивіться тут для глибшого розуміння.</a>
<h2>Як перевизначити equals() та hachCode() методи?</h2><code class=" language-none">hashCode()</code>та <code class=" language-none">equals()</code>методи визначені в класі <code class=" language-none">Object</code>, який є батьківським класом для об'єктів Java. З цієї причини, всі об'єкти Java успадковують реалізацію за промовчанням для методів. Метод <code class=" language-none">hashCode()</code>використовується для отримання унікального цілого числа цього об'єкта. Це ціле число використовується для визначення розташування об'єкта, коли цей об'єкт необхідно зберегти, наприклад <code class=" language-none">HashTable</code>. За замовчуванням <code class=" language-none">hashCode()</code>повертає <code class=" language-none">integer</code>подання адресаи осередку пам'яті, де зберігається об'єкт. Метод <code class=" language-none">equls()</code>, як і випливає з його імені, використовується, щоб просто перевірити рівність двох об'єктів. Реалізація за замовчуванням перевіряє посилання на об'єкти щодо їх рівності. Нижче наведено важливі рекомендації для перезавантаження цих методів: 
<ol>
 <li>Завжди використовуйте однакові атрибути об'єктів при генерації <code class=" language-none">hashCode()</code>та <code class=" language-none">equals()</code>;</li>
 <li>Симетричність. Тобто. якщо для будь-яких об'єктів <code class=" language-none">x</code>і <code class=" language-none">y</code> <code class=" language-none">x.equals(y)</code>повертає true, то й <code class=" language-none">y.equals(x)</code>має повертати true;</li>
 <li>Рефлексивність. Для будь-якого об'єкта <code class=" language-none">x</code> <code class=" language-none">x.equals(x)</code>має повертати true;</li>
 <li>Постійність. Для будь-яких об'єктів <code class=" language-none">x</code>і <code class=" language-none">y</code> <code class=" language-none">x.equals(y)</code>повертає те саме, якщо інформація, використовувана у порівняннях, не змінюється;</li>
 <li>Транзитивність. Для будь-яких об'єктів <code class=" language-none">x</code>, <code class=" language-none">y</code>і <code class=" language-none">z</code>якщо <code class=" language-none">x.equals(y)</code>поверне true і <code class=" language-none">y.equals(z)</code>поверне true, то і <code class=" language-none">x.equals(z)</code>повинен повернути true;</li>
 <li>Щоразу, коли метод викликається в одного й того ж об'єкта під час виконання програми, він повинен повертати те саме число, якщо використовувана інформація не змінюється. <code class=" language-none">hashCode</code>може повертати різні значення для ідентичних об'єктів у різних екземплярах програми;</li>
 <li>Якщо два об'єкти рівні, відповідно до <code class=" language-none">equals</code>, то їх <code class=" language-none">hashCode</code>повинні повертати однакові значення;</li>
 <li>Зворотна вимога необов'язкова. Два нерівні об'єкти можуть повертати однаковий hashCode. Однак для підвищення продуктивності краще, щоб різні об'єкти повертали різні коди.</li>
</ol><a href="https://howtodoinjava.com/java/basics/java-hashcode-equals-methods/" rel="nofollow">Цікаві факти про ці методи читайте тут.</a>
<h2>Розкажіть про модифікатори доступу</h2>Класи Java, поля, конструктори та методи можуть мати один з чотирьох різних модифікаторів доступу: <strong>private</strong> Якщо метод або змінна позначені як <strong>private</strong> , то тільки код усередині одного класу може отримати доступ до змінної, або викликати метод. Код усередині підкласів не може отримати доступ до змінної або методу, так само як і не може отримати доступ із будь-якого іншого класу. Модифікатор private доступу найчастіше використовується для конструкторів, методів і змінних. <strong>default</strong> Модифікатор доступу <strong>default</strong>оголошується у тому випадку, якщо модифікатор не вказано взагалі. Даний модифікатор означає, що доступ до полів, конструкторів та методів даного класу може отримати код усередині самого класу, код усередині класів у тому самому пакеті. Підкласи не можуть отримати доступ до методів і змінних - членів суперкласу, якщо вони оголошені як <strong>default</strong> , якщо підклас не знаходиться в тому пакеті, що і суперклас. <strong>protected</strong> Модифікатор <strong>protected</strong> працює так само, як і <strong>default</strong> , за винятком того, що підкласи так само можуть отримати доступ до захищених методів та змінних суперкласу. Це твердження є правильним, навіть якщо підклас не знаходиться в тому ж пакеті, що і суперклас. <strong>public</strong> Модифікатор доступу<strong>public</strong> означає, що весь код може отримати доступ до класу, його змінних, конструкторів або методів незалежно від того, де розташований цей код. <img data-id="e5c27468-c562-4184-af75-b075049e657f" data-max-width="420" alt="Java Core.  Запитання до співбесіди, ч. 3 - 2" src="https://cdn.javarush.com/images/article/e5c27468-c562-4184-af75-b075049e657f/256.jpeg" style="width: 420px;">
<h2>Що таке збирач сміття? Чи можемо ми викликати його?</h2>Збір сміття є функцією автоматичного керування пам'яттю у багатьох сучасних мовах програмування, таких як Java та мови в NET.Framework. Мови, які використовують збирання сміття, часто інтерпретують збирання сміття у віртуальній машині, такій як JVM. Збір сміття має дві мети: будь-яка невикористана пам'яті повинна бути звільнена, і пам'ять не повинна бути звільнена, якщо програма ще її використовуватиме. Чи можете ви запустити збирання сміття вручну? Ні, <code class=" language-none">System.gc()</code>надає вам такий великий доступ, як можна. Найкращим варіантом є виклик способу <code class=" language-none">System.gc()</code>, який натякне збирачеві сміття про необхідність запуску. Немає жодного способу запустити його негайно, оскільки збирач сміття є недетермінованим. Крім того, згідно з документацією,<code class=" language-none">OutOfMemoryError</code>не буде прокинуто, якщо віртуальній машині не вдалося звільнити пам'ять після повного складання сміття. <a href="https://howtodoinjava.com/java/garbage-collection/revisiting-memory-management-and-garbage-collection-mechanisms-in-java/" rel="nofollow">Дізнайтесь більше про збирача сміття тут.</a>
<h2>Що означає ключове слово native? Поясніть у деталях</h2>Ключове слово <strong>native</strong> застосовується, щоб вказати, що метод реалізований над файлі Java, але іншою мовою програмування. <strong>Нативні</strong> методи використовувалися в минулому. У поточних версіях Java це потрібно рідше. В даний час природні методи необхідні, коли: 
<ol>
 <li>Ви повинні викликати бібліотеку з Java, яка написана іншою мовою.</li>
 <li>Вам потрібен доступ до системних або апаратних ресурсів, до яких можна отримати доступ, використовуючи іншу мову (як правило, С). Насправді, багато системних функцій, які взаємодіють з реальним комп'ютером (наприклад диски або мережеві дані) можуть бути викликані лише нативним методом.</li>
</ol>Недоліки використання бібліотек <strong>нативних</strong> методів теж значні: 
<ol>
 <li>JNI/JNA можуть дестабілізувати JVM, особливо якщо ви спробуєте зробити щось складне. Якщо ваш природний метод робить щось неправильно, є ймовірність аварійного завершення JVM. Також, неприємні речі можуть статися, якщо ваш природний метод викликається з декількох ниток. І так далі.</li>
 <li>Програму з <strong>native</strong> кодом складніше дебажити.</li>
 <li>Native код вимагає окремої побудови фреймворків, що може створити проблеми з перенесенням на інші платформи.</li>
</ol>
<h2>Що таке серіалізація?</h2>У комп'ютерних науках, у тих зберігання і передачі, серіалізація – це процес перекладу структури даних чи стану об'єкта у формат, який може бути збережений і відновлений потім у інший комп'ютерної середовищі. Після прийому серії бітів вони перераховуються відповідно до формату серіалізації, і можуть бути використані для створення семантично ідентичного клону вихідного об'єкта. Java надає автоматичну серіалізацію, яка вимагає, щоб об'єкт реалізував інтерфейс<code class=" language-none">java.io.Serializable</code>. Реалізація інтерфейсу позначає клас як «серіалізується». В інтерфейсі java.io.Serializable немає методів серіалізації, але клас, що серіалізується, може додатково визначити методи, які будуть викликані як частина процесу серіалізації/дисеріалізації. При внесенні змін до класів необхідно враховувати, які з них будуть сумісні та не сумісні із серіалізацією. Ви можете прочитати повну інструкцію тут. Найголовніші пункти я наведу: <strong>Несумісні зміни:</strong>
<ol>
 <li>Видалення поля;</li>
 <li>Переміщення класу вгору чи вниз ієрархією;</li>
 <li>Зміна non-static поля на static або non-transient на transient;</li>
 <li>Зміна оголошеного типу примітивних даних;</li>
 <li>Зміна методу <code class=" language-none">WriteObject</code>або <code class=" language-none">ReadObject</code>так, що вони більше не пишуть або не читають стандартні поля;</li>
 <li>Зміна класу <code class=" language-none">Serializable</code>на <code class=" language-none">Externalizable</code>чи навпаки;</li>
 <li>Зміна класу <strong>enum</strong> на <strong>non-enum</strong> чи навпаки;</li>
 <li>Видалення <code class=" language-none">Serializable</code>або <code class=" language-none">Externalizable</code>;</li>
 <li>Додавання <code class=" language-none">writeReplace</code>чи <code class=" language-none">readResolve</code>методу до класу.</li>
</ol><strong>Сумісні зміни:</strong>
<ol>
 <li>Додавання полів;</li>
 <li>Додавання/видалення класів;</li>
 <li>Додавання методів <code class=" language-none">WriteObject/ReadObject</code>[методи <code class=" language-none">defaultReadObject</code>або <code class=" language-none">defaultWriteObject</code>повинні бути викликані на початку];</li>
 <li>Видалення методів <code class=" language-none">WriteObject/ReadObject</code>;</li>
 <li>Додавання <code class=" language-none">java.io.Serializable</code>;</li>
 <li>Зміна доступу до поля;</li>
 <li>Зміна <strong>static</strong> поля на <strong>non-static</strong> або <strong>transient</strong> на <strong>non-transient</strong> .</li>
</ol>Посилання до попередніх частин: <a href="https://codegym.cc/groups/posts/765-java-core-voprosih-k-sobesedovaniju-ch-1" target="_blank">Java Core. Запитання до співбесіди, ч. 1 </a> <a href="https://codegym.cc/groups/posts/764-java-core-voprosih-k-sobesedovaniju-ch-2" target="blank">Java Core. Запитання до співбесіди, ч. 2. </a> <em><a href="https://howtodoinjava.com/interview-questions/core-java-interview-questions-series-part-3/" rel="nofollow">Оригінал статті </a> <strong>Щасливого навчання!</strong></em>