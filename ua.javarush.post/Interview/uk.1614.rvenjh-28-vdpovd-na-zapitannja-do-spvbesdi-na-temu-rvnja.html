Рівень 28. Відповіді на запитання до співбесіди на тему рівня
<p>----------------------------------------</p>
Які пріоритети ниток бувають? Відповідь це питання є у лекціях JavaRush. Для оптимізації паралельної роботи ниток у Java можна встановлювати пріоритети ниток. Нитки з пріоритетом мають перевагу в отриманні часу процесора перед нитками з ниж
<p>----------------------------------------</p>
<img data-id="383e01a9-01b9-4093-8fcf-3d7a3a73391c" data-max-width="850" alt="Рівень 28. Відповіді на запитання до співбесіди на тему рівня - 1" src="https://cdn.javarush.com/images/article/383e01a9-01b9-4093-8fcf-3d7a3a73391c/800.jpeg" style="width: 850px;">
<ol>
 <li><strong>Які пріоритети ниток бувають?</strong>
  <p></p>
  <p>Відповідь це питання є у лекціях CodeGym.</p>
  <p>Для оптимізації паралельної роботи ниток у Java можна встановлювати пріоритети ниток. Нитки з пріоритетом мають перевагу в отриманні часу процесора перед нитками з нижчим пріоритетом.</p>
  <p>Робота з пріоритетами забезпечується такими методами класу <code class=" language-none">Thread</code>:</p>
  <p><code class=" language-none"><strong>public final void setPriority(int newPriority)</strong></code></p>
  <p>Встановлює пріоритет нитки.</p>
  <p><code class=" language-none"><strong>public final int getPriority()</strong></code></p>
  <p>Дозволяє дізнатися пріоритет нитки.</p>
  <p>Значення параметра в методі <code class=" language-none">setPriority</code>не може бути довільним. Воно має бути в межах від MIN_PRIORITY до MAX_PRIORITY . При створенні нитка має пріоритет NORM_PRIORITY .</p>
  <p>MIN_PRIORITY = 1. <br>
    NORM_PRIORITY = 5. <br>
    MAX_PRIORITY = 10.</p></li>
 <li>
  <p><strong>Чи можна зупинити нитку, зменшивши її пріоритет до 0?</strong></p>
  <p>Відповідь у статті: «Топ 50 питань на співбесіді. Тема: Багатопотоковість (Multithreading)»</p>
  <p>Знайшов на форумі.</p>
  <p>Є варіант цієї статті англійською мовою: <a href="https://www.javacodegeeks.com/2014/07/top-50-java-thread-interview-questions-answers-for-freshers-experienced-programmers.html" rel="nofollow" target="_blank">Java Thread Interview Questions</a></p>
  <p>Java надає багаті API для всього, але за іронією долі не надає зручних способів зупинки нитки. У JDK 1.0 було кілька керуючих методів, наприклад <code class=" language-none">stop()</code>, <code class=" language-none">suspend()</code>і <code class=" language-none">resume()</code>, які були помічені як <em>deprecated</em> в майбутніх релізах через потенційні загрози взаємного блокування, з тих пір розробники Java API не зробабо спроб представити стійкий, нитко-безпечний і елегантний спосіб зупинки ниток. Програмісти в основному покладаються на факт того, що нитка зупиняється сама, як тільки закінчує виконувати методи <code class=" language-none">run()</code>або <code class=" language-none">call()</code>. Для зупинки вручну програмісти користуються перевагою <code class=" language-none">volatile boolean</code>змінної і перевіряють її значення в кожній ітерації, якщо в методі <code class=" language-none">run()</code>є цикли, або переривають нитки методом<code class=" language-none">interrupt()</code>для раптового скасування завдань.</p>
  <p>Саме з питання: Ніде не бачив, щоб хтось пріоритет виставляв у 0.</p>
  <p>Якщо хтось знає про це щось, то напишіть у коментарях.</p></li>
 <li>
  <p><strong>Навіщо потрібен клас <code class=" language-none">ThreadGroup</code>?</strong></p>
  <p><code class=" language-none">ThreadGroup</code>являє собою набір ниток, які можуть містити в собі інші групи потоків. Група ниток утворює дерево, де кожна інша група ниток має батька (крім вихідної). Потік має право доступу до даних зі своєї групи ниток, але не має такого доступу до інших груп або батьківської групи потоків.</p></li>
 <li>
  <p><strong>У якій групі ниток полягає <code class=" language-none">main-thread</code>?</strong></p>
  <p>Ніде не знайшов)) Підкажіть де це є))</p></li>
 <li>
  <p><strong>Що таке патерн <code class=" language-none">ThreadPool</code>?</strong></p>
  <p>На це є витяг зі статті на вікіпедії:</p>
  <p>У комп'ютерному програмуванні, ліміт полів pattern (також помічений робітників або роботодавець-модель) є тим, що число дій є створеним для виконання числа дій, які є зазвичай організовані в кліті. Результати від дій можуть бути виконані засобом або бути placed in queue, або дії можливі повернення не результат (для прикладу, якщо дія є для animation). Typically, there are many more tasks than threads. Як деякий час, як загрожують його завдання, це буде потреба в наступній ході від неповноцінних всіх рішень, які повинні бути виконані. Підліток може бути виконаний, або sleep until є нові tasks available.</p>
  <p>Число threads used is a parametr that can be tuned to provide best performance. До того ж, число threads може бути dynamic based on the number of waiting tasks. Для прикладу, веб-сервер може підтримувати сторінки, якщо багато веб-сторінок повідомлень проходять і можуть керувати треками, коли ці потреби перевищують. Спосіб має велику thread pool is increased resource usage. algoritm, який використовується для визначення, коли створюється або позбавиться threads буде мати impact on overall performance:</p>
  <ul>
   <li>create too many threads, and resources are wasted and time also wasted creating any unused threads</li>
   <li>destroy too many threads and more time will be spent later creating them again</li>
   <li>створення threads too slowly might result in poor client performance (long wait times)</li>
  </ul>
  <p>У комп'ютерному програмуванні є модель пула потоків, де кілька потоків створюється до виконання цілого ряду завдань, які зазвичай організовуються у черзі. Результати від виконаних завдань також можуть бути поміщені в чергу або завдання можуть не повертати жодного результату (наприклад, якщо завдання для анімації).</p>
  <p>Як правило, є набагато більше завдань, ніж потоків. Як тільки потік завершить своє завдання, він вимагатиме наступне завдання з черги, поки всі завдання не будуть завершені. Потік може потім перерватися чи заснути. Кількість потоків, що використовуються, це параметр, який може бути налаштований, для забезпечення найкращої продуктивності. Крім того, число потоків може бути динамічним на основі кількості завдань, що виникають. Наприклад, веб-сервер може додавати потоки, якщо запити численних веб-сторінок надходять і може видалити потоки, коли цих запитів стає менше. Зі збільшенням розміру пулу потоків збільшується використання ресурсів комп'ютера. Алгоритм, який використовується для визначення того, коли створювати чи знищувати потоки, матиме вплив на загальну продуктивність:</p>
  <p>Знищення занадто багато потоків і більше часу буде витрачено пізніше знову для їх створення - Створення потоків занадто повільно може призвести до зниження продуктивності клієнта.</p></li>
 <li>
  <p><strong>Навіщо потрібен клас <code class=" language-none">ThreadPoolExecutor</code>?</strong></p>
  <p><code class=" language-none"><strong>public class ThreadPoolExecutor extends AbstractExecutorService</strong></code></p>
  <p><code class=" language-none">ExecutorService</code>це виконує кожну подану задачу, використовуючи один можливо з декількох об'єднаних в пул потоків, зазвичай налаштоване використання <code class=" language-none">Executors</code>методи фабрики.</p>
  <p>Пули потоків розглядають дві різні проблеми: вони зазвичай забезпечують покращену продуктивність, виконуючи великі кількості асинхронних завдань, через зменшені витрати виклику на завдання, і вони забезпечують засіб обмеження та управління ресурсами, включаючи потоки, використані, виконуючи набір завдань. Кожен <code class=" language-none">ThreadPoolExecutor</code>також підтримує трохи основної статистики, як-от число завершених завдань.</p>
  <p>Щоб бути корисним через широкий діапазон контекстів, цей клас забезпечує багато параметрів, що коригуються, і важелів розширюваності. Проте, програмістів переконують використовувати зручніше <code class=" language-none">Executors</code>методи фабрики <code class=" language-none">Executors.newCachedThreadPool()</code>(необмежений пул потоків, з автоматичним відновленням потоку), <code class=" language-none">Executors.newFixedThreadPool(int)</code>(пул потоків фіксованого розміру) та <code class=" language-none">Executors.newSingleThreadExecutor()</code>(єдиний фоновий потік), які попередньо конфігурують налаштування для найпоширеніших сценаріїв використання.</p></li>
 <li>
  <p><strong>Скільки способів створити нитку ви знаєте?</strong></p>
  <p>На рівні мови є два способи створення нитки. Об'єкт класу <code class=" language-none">java.lang.Thread</code>є ниткою, але їй потрібне завдання для виконання, яка є об'єктом, що реалізує інтерфейс <code class=" language-none">java.lang.Runnable</code>. Так як клас <code class=" language-none">Thread</code>реалізує інтерфейс <code class=" language-none">Runnable</code>, ви можете перевизначити метод <code class=" language-none">run()</code>успадкувавши ваш клас від <code class=" language-none">Thread</code>або реалізувавши в ньому інтерфейс <code class=" language-none">Runnable</code>.</p></li>
 <li>
  <p><strong>Для чого використовується клас <code class=" language-none">Future</code>?</strong></p>
  <p><code class=" language-none">Future</code>зберігає результат асинхронного обчислення. Ви можете запустити обчислення, надавши кому-небудь об'єкт <code class=" language-none">Future</code>і забути про нього. Власник об'єкта <code class=" language-none">Future</code>може отримати результат, коли він буде готовим.</p></li>
 <li>
  <p><strong>У чому переваги <code class=" language-none">Callable</code>над <code class=" language-none">Runnable</code>?</strong></p>
  <p>Посилання: <a href="https://www.ibm.com/developerworks/ru/library/l-java_universe_multithreading_tasks/index.html" rel="nofollow" target="_blank">Частина 2. Виконання завдань у багатопотоковому режимі</a></p>
  <p>Інтерфейс <code class=" language-none">Callable</code>набагато більше підходить для створення завдань, призначених для паралельного виконання, ніж інтерфейс <code class=" language-none">Runnable</code>або тим більше клас <code class=" language-none">Thread</code>. При цьому варто відзначити, що можливість додати подібний інтерфейс з'явилася лише з версії Java 5, оскільки ключова особливість інтерфейсу <code class=" language-none">Callable</code>– це використання параметризованих типів (generics), як показано у лістингу.</p>
  <pre class="  language-java" tabindex="0"><code class="  language-java">Листинг створення задачи с помощью интерфейса <span class="token class-name"><span class="token class-name">Callable</span></span>
<span class="token number"><span class="token number">10</span></span>	<span class="token number"><span class="token number">1</span></span> <span class="token keyword"><span class="token keyword">import</span></span> <span class="token namespace"><span class="token namespace">java<span class="token punctuation"><span class="token punctuation">.</span></span>util<span class="token punctuation"><span class="token punctuation">.</span></span>concurrent<span class="token punctuation"><span class="token punctuation">.</span></span></span><span class="token punctuation"></span></span><span class="token class-name"><span class="token class-name">Callable</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token number"><span class="token number">11</span></span>	<span class="token number"><span class="token number">2</span></span> <span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">class</span></span> <span class="token class-name"><span class="token class-name">CallableSample</span></span> <span class="token keyword"><span class="token keyword">implements</span></span> <span class="token class-name"><span class="token class-name">Callable</span></span><span class="token punctuation"><span class="token punctuation"></span></span><string><span class="token punctuation"><span class="token punctuation">{</span></span>
<span class="token number"><span class="token number">12</span></span>	<span class="token number"><span class="token number">3</span></span>     <span class="token keyword"><span class="token keyword">public</span></span> <span class="token class-name"><span class="token class-name">String</span></span> <span class="token function"><span class="token function">call</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token keyword"><span class="token keyword">throws</span></span> <span class="token class-name"><span class="token class-name">Exception</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
<span class="token number"><span class="token number">13</span></span>	<span class="token number"><span class="token number">4</span></span>         <span class="token keyword"><span class="token keyword">if</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>якое<span class="token operator"><span class="token operator">-</span></span>то умова<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
<span class="token number"><span class="token number">14</span></span>	<span class="token number"><span class="token number">5</span></span>             <span class="token keyword"><span class="token keyword">throw</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">IOException</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">"error during task processing"</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token number"><span class="token number">15</span></span>	<span class="token number"><span class="token number">6</span></span>         <span class="token punctuation"><span class="token punctuation">}</span></span>
<span class="token number"><span class="token number">16</span></span>	<span class="token number"><span class="token number">7</span></span>         <span class="token class-name"><span class="token class-name">System</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">"task is processing"</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token number"><span class="token number">17</span></span>	<span class="token number"><span class="token number">8</span></span>         <span class="token keyword"><span class="token keyword">return</span></span> <span class="token string"><span class="token string">"result "</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token number"><span class="token number">18</span></span>	<span class="token number"><span class="token number">9</span></span>     <span class="token punctuation"><span class="token punctuation">}</span></span>
<span class="token number"><span class="token number">19</span></span>	<span class="token number"><span class="token number">10</span></span> <span class="token punctuation"><span class="token punctuation">}</span></span>
</string></code></pre>
  <p>Відразу необхідно звернути увагу на рядок 2, де зазначено, що інтерфейс <code class=" language-none">Callable</code>є параметризованим, і його конкретна реалізація – клас <code class=" language-none">CallableSample</code>залежить від типу <code class=" language-none">String</code>. На рядку 3 наведена сигнатура основного методу <code class=" language-none">call</code>вже параметризованому варіанті, так як в якості типу значення, що повертається також зазначений тип <code class=" language-none">String</code>. Фактично це означає, що було створено завдання, результатом виконання якого буде об'єкт типу <code class=" language-none">String</code>(див. рядок 8). Точно також можна створити завдання, в результаті роботи якого в методі <code class=" language-none">call</code>створюватиметься і повертатиметься об'єкт будь-якого необхідного типу. Таке рішення значно зручніше порівняно з методом run в інтерфейсі <code class=" language-none">Runnable</code>, який не повертає нічого (його тип, що повертається –<code class=" language-none">void</code>) і тому доводиться винаходити обхідні шляхи, щоб отримати результат роботи завдання.</p>
  <p>Ще одна перевага інтерфейсу <code class=" language-none">Callable</code>– це можливість «викидати» виняткові ситуації, не впливаючи на інші завдання, що виконуються. На рядку 3 зазначено, що з методу може бути викинута виняткова ситуація типу <code class=" language-none">Exception</code>, що фактично означає будь-яку виняткову ситуацію, так як всі винятки є нащадками <code class=" language-none">java.lang.Exception</code>. На рядку 5 ця можливість використовується створення контрольованої (checked) виняткової ситуації типу <code class=" language-none">IOException</code>. Метод <code class=" language-none">run</code>інтерфейсу <code class=" language-none">Runnable</code>взагалі не допускав викидання контрольованих виняткових ситуацій, а викид неконтрольованої (runtime) виняткової ситуації призводив до зупинки потоку та всього додатка.</p></li>
 <li>
  <p><strong>Чи можна скасувати виконання завдання, якщо використати клас <code class=" language-none">Future</code>?</strong></p>
  <p>Виходячи з <a href="https://habr.com/post/133413/" rel="nofollow" target="_blank">цієї дискусії</a> , піднятої на хабрі, виходить, що не можна.</p>
  <p>Є <code class=" language-none">Future</code>метод <code class=" language-none">Future.cancel(boolean)</code>, який має скасувати виконання завдання. Але якщо завдання вже почало виконуватися, виклик <code class=" language-none">Future.cancel(true)</code>насправді не зупинить його. У надрах реалізації <code class=" language-none">FutureTask</code>виконується код:</p>
  <pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">if</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span>mayInterruptIfRunning<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
<span class="token class-name"><span class="token class-name">Thread</span></span> r <span class="token operator"><span class="token operator">=</span></span> runner<span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token keyword"><span class="token keyword">if</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span>r <span class="token operator"><span class="token operator">!=</span></span> <span class="token keyword"><span class="token keyword">null</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
r<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">interrupt</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span> <span class="token punctuation"><span class="token punctuation">}</span></span></code></pre>
  <p>Тобто. знову потоку, у якому виконується завдання, лише рекомендується припинити виконання. До того ж, ми не маємо навіть можливості дізнатися, чи виконується завдання в даний момент, чи ні. Є метод <code class=" language-none">Future.isDone()</code>, але знову мимо, він повертає <em>true</em> не тільки коли завдання завершило виконання, а відразу після виклику <code class=" language-none">Future.cancel()</code>, навіть якщо завдання все ще виконується (адже <code class=" language-none">Future.cancel(true)</code>не зупиняє завдання, яке вже почало виконуватися).</p>
  <p>Добре, якщо ми пишемо весь код, тоді можна в потрібних місцях акуратно обробляти <code class=" language-none">Thread.isInterrupted()</code>і все буде ОК. Але якщо ми запускаємо код? Якщо у нас є сервер, що розширюється за допомогою плагінів? Який-небудь криво написаний плагін може запитто призвести до непрацездатного стану весь сервер адже ми не можемо коректно перервати виконання плагіна, що завис.</p></li>
</ol>