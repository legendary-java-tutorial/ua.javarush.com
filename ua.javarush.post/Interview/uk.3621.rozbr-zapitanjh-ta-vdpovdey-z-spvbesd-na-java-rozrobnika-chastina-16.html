Розбір запитань та відповідей із співбесід на Java-розробника. Частина 16
<p>----------------------------------------</p>
Hello, friend! Як багато часу потрібно витратити, щоб стати розробником? Я питав багато різних людей і чув багато різних відповідей. Для чогось і когось може вистачити і місяці, а комусь і року буде мало. Але я знаю точно, що становлення Ja
<p>----------------------------------------</p>
Hello, friend! Як багато часу потрібно витратити, щоб стати розробником? Я питав багато різних людей і чув багато різних відповідей. Для чогось і когось може вистачити і місяці, а комусь і року буде мало. Але я знаю точно, що становлення Java-розробником це тернистий і довгий шлях, незалежно від твоїх початкових здібностей. Адже важливі не так здібності, як упертість і працьовитість. <img data-max-width="800" data-id="c649e687-1bf9-4f72-bc02-cfc85860abc0" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 16 - 1" src="https://cdn.javarush.com/images/article/c649e687-1bf9-4f72-bc02-cfc85860abc0/800.jpeg" style="width: 800px;">Тому сьогодні ми так само цілеспрямовано продовжуємо розбирати найпопулярніші питання зі співбесід на Java-розробника. Їхнє вивчення поступово наблизить тебе до заповітної мети. Почнемо! 
<h4>17. Наведіть приклади вдалого та невдалого використання Optional</h4>Припустимо, у нас є певний ряд значень, за яким ми проходимося стримом, і в результаті отримуємо деякий <span class="code">Optional</span> як результат: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class=" language-java"><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> stringOptional <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"ab"</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"abcd"</span><span class="token punctuation">)</span>
   <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>str <span class="token operator">-&gt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">3</span><span class="token punctuation">)</span>
   <span class="token punctuation">.</span><span class="token function">findAny</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Нам, як належить, треба дістати із цього <span class="code">Optional</span> значення. Просто використовувати <span class="code">get()</span> - поганий спосіб: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">String</span> result <span class="token operator">=</span> stringOptional<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Але цей метод повинен дістати значення з <span class="code">Optional</span> і повернути нам? Це, звичайно, так, але якщо у ньому є значення. Ну а якщо значення у стримі були інші, і в результаті ми отримали порожній <span class="code">Optional</span> , при спробі взяти значення з нього за допомогою методу <span class="code">get()</span> буде викинуто: <img data-max-width="512" data-id="289868d5-2b14-4def-918b-5613746168ce" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 16 - 2" src="https://cdn.javarush.com/images/article/289868d5-2b14-4def-918b-5613746168ce/512.jpeg" style="width: 512px;">Що не є добре. У такому разі краще використовувати конструкції:
<ol>
 <li>
  <p></p>
  <pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token class-name">String</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>stringOptional<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 stringOptional<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
  <p></p>
  <p>В даному випадку ми перевіряємо, чи є елемент у <span class="code">Optional</span> . Якщо ні — результуючий рядок має старе значення.</p></li>
 <li>
  <p></p>
  <pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">String</span> result <span class="token operator">=</span> stringOptional<span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">"default value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
  <p></p>
  <p>У даному випадку ми вказуємо деяке значення за замовчуванням, яке буде задане результуючий рядок у разі порожнього <span class="code">Optional</span> .</p></li>
 <li>
  <p></p>
  <pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">String</span> result <span class="token operator">=</span> stringOptional<span class="token punctuation">.</span><span class="token function">orElseThrow</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">CustomException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
  <p></p>
  <p>В даному випадку ми самі викидаємо виняток при порожньому <span class="code">Optional</span> .</p></li>
</ol>Це буває зручно в додатку, коли, наприклад, використовується метод Spring JPA <span class="code">findById()</span> , який повертає <span class="code">Optional</span> значення. У такому разі даним методом ми намагаємося взяти значення, і якщо його немає - кидаємо деякий <span class="text-bold">Runtime</span> виняток, який обробляється на рівні контролерів за допомогою <a href="https://habr.com/ru/post/528116/" rel="nofollow" target="_blank">ExceptionHandler</a> і конвертується в <span class="text-bold">HTTP</span> відповідь зі статусом <span class="text-bold">404 - NOT FOUND</span> . <img data-max-width="512" data-id="d6714011-9b27-4e97-9e94-eff2a55c4a06" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 16 – 3" src="https://cdn.javarush.com/images/article/d6714011-9b27-4e97-9e94-eff2a55c4a06/512.jpeg" style="width: 512px;">
<h4>18. Чи можна оголошувати main method як final?</h4>Так, безперечно, ніщо не заважає нам оголосити метод <span class="code">main()</span> як <span class="code">final</span> . Компілятор не випустить помилок. Але варто пам'ятати, що будь-який метод після оголошення його як <span class="code">final</span> стане <span class="text-bold">останнім методом</span> – не перевизначуваним. Хоча, хто перевизначатиме <span class="code">main</span> ??? <img data-max-width="512" data-id="ff198b61-2eba-4f5a-a409-c99128221515" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 16 – 4" src="https://cdn.javarush.com/images/article/ff198b61-2eba-4f5a-a409-c99128221515/512.jpeg" style="width: 512px;">
<h4>19. Чи можна імпортувати ті самі package/class двічі? Які можуть бути наслідки?</h4>Так можна. Наслідки? Ми матимемо пару непотрібних імпортів, які Intelijj IDEA буде відображати як сірі, тобто. не використовуються. <img data-max-width="256" data-id="9b9e1a16-4611-4c1c-be46-d988987bf56b" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 16 – 5" src="https://cdn.javarush.com/images/article/9b9e1a16-4611-4c1c-be46-d988987bf56b/256.jpeg" style="width: 256px;"><img data-max-width="512" data-id="b007c152-3fd5-4d3c-aac5-d5aad2cb50df" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 16 – 6" src="https://cdn.javarush.com/images/article/b007c152-3fd5-4d3c-aac5-d5aad2cb50df/512.jpeg" style="width: 512px;">
<h4>20. Що таке Casting? Коли ми можемо отримати виняток ClassCastException?</h4>Casting, або <span class="text-bold">приведення типів</span> - це процес перетворення одного типу даних на інший тип даних: вручну (неявне приведення) або автоматично (явне приведення типів). <img data-max-width="512" data-id="ed686a9c-07e1-459b-aecc-2106c8356b75" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 16 – 7" src="https://cdn.javarush.com/images/article/ed686a9c-07e1-459b-aecc-2106c8356b75/512.jpeg" style="width: 512px;">Автоматичне перетворення виконує компілятор, а ручне розробник. Приведення типів для примітивів та класів дещо відрізняється, тому й розглянемо їх окремо. <span class="text-bold"><em>Примітивні типи</em></span> Приклад <span class="text-bold">автоматичного приведення</span> примітивних типів: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class=" language-java"><span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">17</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> convertedValue <span class="token operator">=</span> value<span class="token punctuation">;</span></code></pre> Як бачите, ніяких додаткових маніпуляцій крім знака <span class="code">тут</span> не потрібно. Приклад <span class="text-bold">ручного приведення</span> примітивних типів: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class=" language-java"><span class="token keyword">double</span> value <span class="token operator">=</span> <span class="token number">17.89</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> convertedValue <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>value<span class="token punctuation">;</span></code></pre> У цьому випадку ми можемо спостерігати ручне приведення, яке реалізується за допомогою <span class="code">(int)</span> , при цьому частина за комою буде відкинута, і <span class="code">convertedValue</span> матиме значення - 17. Докладніше про приведення примітивних типів читайте в <a href="https://codegym.cc/groups/posts/1945-rasshirenie-i-suzhenie-primitivnihkh-tipov" target="_blank">цій статті</a> . Ну, а тепер давайте перейдемо до об'єктів. <span class="text-bold"><em>Посилальні типи</em></span> Для типів посилань <span class="text-bold">автоматичне приведення</span> можливе для класів спадкоємців до класів батьків. Це також називається <span class="text-bold">поліморфізмом</span> . Припустимо, у нас є клас <span class="code">Lion</span> , який успадковується від класу <span class="code">Cat</span> . У цьому випадку автоматичне перетворення виглядатиме так: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">Cat</span> cat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Lion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> А ось з <span class="text-bold">явним приведенням</span> дещо складніше, адже немає функціоналу обрізання зайвого, як у примітивів. І зробивши просто явно перетворення виду: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">Lion</span> lion<span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Lion</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Ви і отримаєте помилку: <img data-max-width="1080" data-id="1b2073c5-6f87-4878-9744-cd45de165099" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 16 – 8" src="https://cdn.javarush.com/images/article/1b2073c5-6f87-4878-9744-cd45de165099/1080.jpeg" style="width: 1080px;">Насправді, ви можете класу спадкоємцю <span class="code">Lion</span> додати методи, яких не було спочатку в класі <span class="code">Cat</span> , і потім намагатися викликати їх, адже типу об'єкта у вас стане <span class="code">Lion</span> . Ну, а в цьому логіки ніякої немає. Тому, звуження типу можливе лише коли початковий об'єкт типу <span class="code">Lion</span> , але пізніше приведений до класу батька: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class=" language-java"><span class="token class-name">Lion</span> lion <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Lion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Cat</span> cat <span class="token operator">=</span> lion<span class="token punctuation">;</span>
<span class="token class-name">Lion</span> newLion <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Lion</span><span class="token punctuation">)</span>cat<span class="token punctuation">;</span></code></pre> Також, для більшої надійності, звуження приведення для об'єктів рекомендується з використанням конструкції <span class="code">instanceOf</span> : 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>cat <span class="token keyword">instanceof</span> <span class="token class-name">Lion</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 newLion <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Lion</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre> Докладніше про приведення посилальних типів - <a href="https://codegym.cc/groups/posts/2019-rasshirenie-i-suzhenie-ssihlochnihkh-tipov" target="_blank">у цій статті</a> . 
<h4>21. Чому сучасні фреймворки використовують переважно лише unchecked exceptions?</h4>Думаю, це все тому, що обробка <span class="text-bold">checked</span> винятків – це ще той спагетті код, який повсюдно повторюється, при цьому не завжди дійсно потрібен. <img data-max-width="512" data-id="b529af8e-4b36-4bc8-b381-2177a0b09b17" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 16 – 9" src="https://cdn.javarush.com/images/article/b529af8e-4b36-4bc8-b381-2177a0b09b17/512.jpeg" style="width: 512px;">У таких випадках легше зробити обробку всередині фреймворку, щоб зайвий раз не перекладати це на плечі розробників. Так, безперечно, аварійна ситуація може виникнути, але ці самі <span class="text-bold">uncheked</span> винятки можна обробляти більш зручним способом, не морочачи над обробкою в <span class="code">try-catch</span> і не прокидаючи далі за методами. Достатньо лише в <a href="https://habr.com/ru/post/528116/" rel="nofollow" target="_blank">винятку Handler</a> -е конвертувати виняток у деяку HTTP-відповідь. 
<h4>22. Що таке static import?</h4>При використанні статичних даних (методів, змінних) можна створювати сам об'єкт, а робити це на ім'я класу, а й у разі нам необхідне посилання клас. З нею все просто: вона додається за допомогою звичайного імпорту. Але якщо ми заходимо використовувати статичний метод без написання імені класу, ніби це статичний метод поточного класу? Це можливо за допомогою статичного імпорту! У такому разі ми повинні прописувати <span class="code">static import</span> та посилання на той метод. Як ось, наприклад, статичний метод класу <span class="code">Math</span> для обчислення значення косинуса: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">Math</span><span class="token punctuation">.</span>cos<span class="token punctuation">;</span></code></pre> У результаті ми можемо використовувати метод без вказівки імені класу: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token keyword">double</span> result <span class="token operator">=</span> <span class="token function">cos</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Також елементарно ми можемо підвантажити відразу всі статичні методи класу за допомогою статичного імпорту: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">Math</span><span class="token punctuation">.</span>*<span class="token punctuation">;</span></code></pre><img data-max-width="512" data-id="ab9099ee-2740-4bc5-adec-7722297e317a" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 16 – 10" src="https://cdn.javarush.com/images/article/ab9099ee-2740-4bc5-adec-7722297e317a/512.jpeg" style="width: 512px;">
<h4>23. Який зв'язок між методами hashCode() та equals()?</h4>Відповідно до <a href="https://www.oracle.com/index.html" rel="nofollow" target="_blank">Oracle</a> існує таке правило: <em>Якщо два об'єкти рівні (тобто метод <span class="code">equals()</span> повертає <span class="text-bold">true</span> ), у них повинен бути однаковий хеш-код. </em> При цьому не варто забувати, що однаковий хеш-код може бути у двох різних об'єктів. Щоб розібратися, чому ж <span class="code">equals()</span> і <span class="code">hashCode()</span> перевизначають завжди в парі, розглянемо наступні випадки:
<ol>
 <li>
  <p>Обидва методи перевизначені.</p>
  <p>У такому разі два різних об'єкти з однаковими внутрішніми станами повертатимуть при <span class="code">equals()</span> — <span class="text-bold">true</span> , тоді як і <span class="code">hashCode()</span> буде в обох повертати те саме число.</p>
  <p>Виходить все окей, бо правило виконується.</p></li>
 <li>
  <p>Обидва методи не перевизначені.</p>
  <p>У такому разі два різні об'єкти з однаковими внутрішніми станами при <span class="code">equals()</span> повертатимуть <span class="code">false</span> , оскільки порівняння йде за посиланням через оператор <span class="code">==</span> .</p>
  <p>Метод <span class="code">hashCode()</span> також поверне різні значення (швидше за все), оскільки він видає перетворене значення адресаи осередку пам'яті. Але в одного і того ж об'єкта це значення буде однаковим, як і <span class="code">equals()</span> в даному випадку поверне <span class="text-bold">true</span> тільки коли посилання вказують на той самий об'єкт.</p>
  <p>Виходить, і в цьому випадку все окей і правило виконується.</p></li>
 <li>
  <p>Перевизначено <span class="code">equals()</span> , не перевизначено <span class="code">hashCode()</span> .</p>
  <p>У такому разі для двох різних об'єктів з однаковими внутрішніми станами <span class="code">equals()</span> повертатиме <span class="text-bold">true</span> , а <span class="code">hashCode()</span> повертатиме (швидше за все) різні значення.</p>
  <p>Відбувається порушення правила, тому робити так не рекомендується.</p></li>
 <li>
  <p>Чи не перевизначений <span class="code">equals()</span> , перевизначений <span class="code">hashCode()</span> .</p>
  <p>У такому разі для двох різних об'єктів з однаковими внутрішніми станами <span class="code">equals()</span> повертатиме <span class="text-bold">false</span> , а <span class="code">hashCode()</span> повертатиме однакові значення.</p>
  <p>Відбувається порушення правила, тож підхід неправильний.</p></li>
</ol>Як ви бачите, виконання правила можливе лише коли <span class="code">equals()</span> і <span class="code">hashCode()</span> перевизначаються обидва або обидва не перевизначаються зовсім. <img data-max-width="512" data-id="bdd47f83-90c5-4779-8c6e-d6896142d5ca" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 16 - 11" src="https://cdn.javarush.com/images/article/bdd47f83-90c5-4779-8c6e-d6896142d5ca/512.jpeg" style="width: 512px;">Докладніше про <span class="code">equals()</span> і <span class="code">hashCode()</span> читайте <a href="https://codegym.cc/groups/posts/1989-kontraktih-equals-i-hashcode-ili-kak-ono-vsje-tam" target="_blank">у цій статті</a> . 
<h4>24. Коли використовують класи BufferedInputStream і BufferedOutputStream?</h4><span class="code">InputStream</span> використовується для побайтового читання даних із деякого ресурсу, а <span class="code">OutputStream</span> — для побайтового запису. Але побайтові операції можуть бути незручними і вимагають додаткової обробки (щоб нормально зчитувати/записувати тексти). Власне, для спрощення таких байтових записів ввели <span class="code">BufferedOutputStream</span> , а для читання <span class="code">BufferedInputStream</span> . Ці класи є чим іншим як буферами, що накопичують дані, що дозволяють працювати з даними не побайтово, а цілими пакетами даних (масивами). При створенні <span class="code">BufferedInputStream</span> приймає до конструктора екземпляр типу <span class="code">InputStream</span> , з якого йде рахунок даних: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class=" language-java"><span class="token class-name">BufferedInputStream</span> bufferedInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
bufferedInputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><span class="code">System.in</span> – це об'єкт типу <span class="code">InputStream</span> , який зчитує дані з консолі. Тобто за допомогою цього об'єкта <span class="code">BufferedInputStream</span> ми можемо читати дані з <span class="code">InputStream</span> , записуючи їх у переданий масив. Виходить свого роду обгортка класу <span class="code">InputStream</span> . Масив <span class="code">arr</span> з цього прикладу - масив якому дістаються дані з <span class="code">BufferedInputStream</span> . Той, у свою чергу, читає дані з <span class="code">InputStream</span> іншим масивом, який за замовчуванням має розмір 2048 байт. Аналогічно і для <span class="code">BufferedOutputStream</span> : в конструктор необхідно передати екземпляр типу <span class="code">OutputStream</span>, в який ми будемо писати дані цілими масивами: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token string">"Hello world!!!"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">BufferedOutputStream</span> bufferedInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedOutputStream</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>
bufferedInputStream<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
bufferedInputStream<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><span class="code">System.out</span> – це об'єкт типу <span class="code">OutputStream</span> , який записує дані у консолі. Метод <span class="code">flush()</span> відправляє дані з <span class="code">BufferedOutputStream</span> в <span class="code">OutputStream</span> , очищуючи при цьому <span class="code">BufferedOutputStream</span> . Без цього нічого записуватися і нічого очікувати. І аналогічно попередньому прикладу: <span class="code">arr</span> - це масив, з якого записуються дані в <span class="code">Buffered OutputStream</span> . З нього вони пишуться в <span class="code">OutputStream</span> вже іншим масивом, який за замовчуванням має розмір 512 байт. Докладніше про ці два класи — <a href="https://betacode.net/13359/java-bufferedoutputstream" rel="nofollow" target="_blank">у статті</a> . 
<h4>25. Яка різниця між класами java.util.Collection та java.util.Collections?</h4><span class="code">Collection</span> – інтерфейс, який є головою у ієрархії колекцій. Він представляє класи, що дозволяють створювати, утримувати та змінювати цілі групи об'єктів. Для цього надається безліч методів, наприклад <span class="code">add()</span> , <span class="code">remove()</span> , <span class="code">contains()</span> та інших. Основні інтерфейси класу <span class="code">Collection</span> :
<ul>
 <li>
  <p><span class="code">Set</span> - інтерфейс, що описує безліч, що містить невпорядковані унікальні (неповторні) елементи.</p></li>
 <li>
  <p><span class="code">List</span> - інтерфейс, що описує структуру даних, яка зберігає впорядковану послідовність об'єктів. Ці об'єкти одержують свій індекс (номер), використовуючи який можна взаємодіяти з ними: брати, видаляти, змінювати, перезаписувати.</p></li>
 <li>
  <p><span class="code">Queue</span> - інтерфейс, що описує структуру даних із зберіганням елементів у вигляді черги, яка дотримується правила - <span class="text-bold">FIFO - First In First Out</span> .</p></li>
</ul><img data-max-width="800" data-id="917ed1a0-ced4-46ba-bc19-fc54eaa087c9" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 16 - 12" src="https://cdn.javarush.com/images/article/917ed1a0-ced4-46ba-bc19-fc54eaa087c9/800.jpeg" style="width: 800px;">Докладніше про <a href="https://codegym.cc/groups/posts/2308-korotko-o-glavnom---java-collections-framework" target="_blank">Collection</a> . <span class="code">Collections</span> - утилітний клас, що надає безліч усіляких службових методів. Наприклад:
<ul>
 <li>
  <p><span class="code">addAll (Collection &lt;? super T&gt; collection, T ... element)</span> - додає в <span class="code">collection</span> передані елементи типу <span class="code">Т</span> .</p></li>
 <li>
  <p><span class="code">сopy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)</span> — копіює всі елементи зі списку <span class="code">src</span> до списку <span class="code">dest</span> .</p></li>
 <li>
  <p><span class="code">emptyList()</span> – повертає порожній список.</p></li>
 <li>
  <p><span class="code">max(Collection&lt;? extends T&gt; collection, Comparator&lt;? super T&gt; comp)</span> — повертає максимальний елемент цієї колекції відповідно до порядку, встановленого вказаним компаратором.</p></li>
 <li>
  <p><span class="code">unmodifiableList(List&lt;? extends T&gt; list)</span> — повертає незмінне уявлення переданого списку.</p></li>
</ul>І таких різноманітних зручних методів у <span class="code">Collections</span> – безліч. <img data-max-width="512" data-id="3e47a31f-cf9e-4c43-9a64-b0f431c87eeb" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 16 - 13" src="https://cdn.javarush.com/images/article/3e47a31f-cf9e-4c43-9a64-b0f431c87eeb/512.jpeg" style="width: 512px;">З повним списком даних методів можна ознайомитись <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collections.html" rel="nofollow" target="_blank">на сайті Oracle</a> . Я не дарма сказав, що вони зручні. Адже вони статичні. Тобто, вам не потрібно щоразу створювати об'єкт цього класу, щоб викликати в нього необхідний метод. Достатньо лише прописати назву класу, викликати в нього потрібний метод і передати всі необхідні аргументи. Підводячи межу, <span class="code">Collection</span> - кореневий інтерфейс структури колекцій. <span class="code">Collections</span> – допоміжний клас для зручнішої обробки об'єктів, що належать типу структури колекцій. Ну, а на сьогодні все. Всім добра!<img data-max-width="512" data-id="7ce5b551-f7fc-40f6-a5ea-5a92553e5be6" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 16 - 14" src="https://cdn.javarush.com/images/article/7ce5b551-f7fc-40f6-a5ea-5a92553e5be6/512.jpeg" style="width: 512px;">
<div class="table-container">
 <table>
  <tbody>
   <tr>
    <th>Інші матеріали серії:</th>
   </tr>
   <tr>
    <td>
     <ul>
      <li><a href="https://codegym.cc/groups/posts/3243-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-1" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 1</a></li>
      <li><a href="https://codegym.cc/groups/posts/3252-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-2" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 2</a></li>
      <li><a href="https://codegym.cc/groups/posts/3273-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-3" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 3</a></li>
      <li><a href="https://codegym.cc/groups/posts/3284-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-4" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 4</a></li>
      <li><a href="https://codegym.cc/groups/posts/3296-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-5" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 5</a></li>
      <li><a href="https://codegym.cc/groups/posts/3341-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-6" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 6</a></li>
      <li><a href="https://codegym.cc/groups/posts/3386-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-7" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 7</a></li>
      <li><a href="https://codegym.cc/groups/posts/3415-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-8" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 8</a></li>
      <li><a href="https://codegym.cc/groups/posts/3434-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-9" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 9</a></li>
      <li><a href="https://codegym.cc/groups/posts/3452-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-10" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 10</a></li>
      <li><a href="https://codegym.cc/groups/posts/3464-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-11" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 11</a></li>
      <li><a href="https://codegym.cc/groups/posts/3475-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-12" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 12</a></li>
      <li><a href="https://codegym.cc/groups/posts/3507-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-13" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 13</a></li>
      <li><a href="https://codegym.cc/groups/posts/3558-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-14" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 14</a></li>
      <li><a href="https://codegym.cc/groups/posts/3592-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-15" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 15</a></li>
     </ul></td>
   </tr>
  </tbody>
 </table>
</div><a href="https://codegym.cc/login/signup" target="_blank"><img data-max-width="1080" id="click_banner5_articles" data-id="45b146ac-f14c-450e-990e-a2b24253c9e6" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 16 – 15" src="https://cdn.javarush.com/images/article/45b146ac-f14c-450e-990e-a2b24253c9e6/1080.jpeg" style="width: 1080px;"></a>