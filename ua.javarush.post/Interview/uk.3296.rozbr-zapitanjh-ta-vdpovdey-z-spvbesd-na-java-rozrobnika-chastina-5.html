Розбір запитань та відповідей із співбесід на Java-розробника. Частина 5
<p>----------------------------------------</p>
Hello, Hello! Сьогодні Java-розробники дуже потрібні. Забезпечити вакансією я вас, звичайно, не можу, але трохи допомогти в тому, щоб ви набули нових знань і закрили деякі прогалини, спробую. Тож продовжуємо розбір із співбесід на Java-розр
<p>----------------------------------------</p>
Hello, Hello! Сьогодні Java-розробники дуже потрібні. Забезпечити вакансією я вас, звичайно, не можу, але трохи допомогти в тому, щоб ви набули нових знань і закрабо деякі прогалини, спробую. Тож продовжуємо розбір <a href="https://dou.ua/lenta/articles/interview-questions-java-developer/" rel="nofollow" target="_blank">250+ питань</a> із співбесід на Java-розробника. Посилання на попередні частини розбору – наприкінці статті.<img data-max-width="800" data-id="7b40e358-1302-418c-ad84-36034057f486" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 5 - 1" src="https://cdn.javarush.com/images/article/7b40e358-1302-418c-ad84-36034057f486/800.jpeg" style="width: 800px;">
<h4>39. Що таке модифікатори доступу Java? Назвіть їх. Навіщо вони використовуються?</h4>Раніше я вже описував модифікатори доступу в питанні про елементи Java, які відповідають за інкапсуляцію. Але все ж таки нагадаю. Модифікатори доступу Java — це ключові слова, які описують рівень доступу, що надається, до певного компонента Java. Модифікатори доступу можуть бути:
<ul>
 <li><span class="code">public</span> — елемент із цим модифікатором буде загальнодоступним. Тобто. поля та методи, класи, оголошені з модифікатором public, видно іншим класам як з поточного пакета, так і зовнішніх пакетів;</li>
 <li><span class="code">protected</span> — елемент з даним модифікатором буде доступний з будь-якого місця в поточному класі поточного пакета або класах спадкоємців, навіть якщо вони знаходяться в інших пакетах;</li>
 <li><span class="code">default</span> , або відсутній модифікатор - цей модифікатор використовується неявно, коли модифікатор доступу зовсім не вказується. Він схожий на попередній, крім допустимості видимості у класах-спадкоємцях, які знаходяться в інших пакетах;</li>
 <li><span class="code">private</span> — найзакритіший із усіх модифікаторів, який допускає доступ до елемента лише в межах поточного класу.</li>
</ul><img data-max-width="512" data-id="29e0c7a1-ea94-4400-989d-a628537afd5d" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 5 - 2" src="https://cdn.javarush.com/images/article/29e0c7a1-ea94-4400-989d-a628537afd5d/512.jpeg" style="width: 512px;">
<h4>40. Назвіть основну особливість статичних та змінних методів</h4>Дуже дивне формулювання - "змінні методи". Напевно, тут маються на увазі звичайні, нестатичні методи. Так от, основна різниця в тому, що статичні методи належать класу і, власне, для них не потрібно створювати екземпляр цього класу: його можна викликати лише використовуючи тип класу. Наприклад, у нас є статичний метод, щоб погладити кота: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CatService</span> <span class="token punctuation">{</span>
   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">petTheCat</span><span class="token punctuation">(</span><span class="token class-name">Cat</span> cat<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Погладить кота - "</span> <span class="token operator">+</span> cat<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span></code></pre> Для його виклику нам не потрібен екземпляр класу <span class="code">CatService</span> : 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class=" language-java"><span class="token class-name">Cat</span> cat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">"Bobi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">CatService</span><span class="token punctuation">.</span><span class="token function">petTheCat</span><span class="token punctuation">(</span>cat<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> У той час, як звичайні методи прив'язані (належать) об'єкту, і щоб їх викликати, необхідно мати екземпляр (об'єкт), у якого і буде викликаний метод. Наприклад, у кота є нестатичний метод — м'яукати: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token punctuation">{</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">mew</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Meow! Meow! Meow!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span></code></pre> Для виклику цього методу нам знадобиться конкретний екземпляр кота: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class=" language-java"><span class="token class-name">Cat</span> cat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">"Bobi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cat<span class="token punctuation">.</span><span class="token function">mew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h4>41. Які основні обмеження діють на статичні та “змінні” методи?</h4>Як я і сказав раніше, основне обмеження звичайного методу в тому, що завжди має бути деякий екземпляр, у якого цей метод буде викликаний. А ось статичний метод цього не вимагає, але він і не може посилатися на посилання <span class="code">this</span> - на елементи поточного об'єкта - оскільки поточного об'єкта для нього не існує.
<h4>42. Що означає ключове слово static? Чи може статичне метод бути перевизначений чи перевантажений?</h4>Елемент, позначений ключовим словом <span class="code">static</span> , належить не об'єкту класу, саме класу, і він завантажується при завантаженні самого класу. Статичні елементи єдині на всю програму, а звичайні єдині на конкретний об'єкт. Статичними можуть бути:
<ul>
 <li>поля класу;</li>
 <li>блок ініціалізації класу;</li>
 <li>метод класу;</li>
 <li>внутрішні класи класу (проте, та ще тавтологія).</li>
</ul>Статичний метод не можна перевизначити: він належить класу і успадковується, але водночас його можна перевантажити.
<h4>43. Чи може бути статичним і абстрактним одночасно?</h4>У попередній статті я вже згадував: метод не може бути абстрактним і статичним одночасно. Абстрактність методу має на увазі, що він має бути перевизначений у спадкоємці. У той же час статичний метод належить класу, і його не можна перевизначити: це викликає протиріччя, яке побачить компілятор і почне лаятись. Якщо у вас виникла така ситуація, варто всерйоз задуматися про правильність побудови архітектури вашої програми (адже з нею щось не так).<img data-max-width="512" data-id="a52bee87-4d5c-495a-b054-3ab83c453d72" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 5 - 3" src="https://cdn.javarush.com/images/article/a52bee87-4d5c-495a-b054-3ab83c453d72/512.jpeg" style="width: 512px;">
<h4>44. Чи можна використовувати статичні методи у середині звичайних? Навпаки? Чому?</h4>Статичні методи можна використовувати у звичайних, тому що цьому нічого не перешкоджає. У той самий час зворотна ситуація неможлива: статичний метод неспроможна використовувати звичайний метод, які мають посилання конкретний екземпляр даного класу. А як ми пам'ятаємо, для статичних членів класу посилання <span class="code">this</span> недоступне: конкретних об'єктів класу може бути скільки завгодно, і у кожного з них буде посилання на самого себе — <span class="code">this</span> . І як тоді зрозуміти, яке саме посилання <span class="code">це</span> потрібно взяти? А ніяк. Тому й статичні елементи що неспроможні посилатися на нестатичні, без посилання конкретний об'єкт. Власне, статичний метод може використовувати не статичний тільки якщо має посилання на конкретний об'єкт. Наприклад ту, яка прийшла як аргумент: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">petTheCat</span><span class="token punctuation">(</span><span class="token class-name">Cat</span> cat<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Погладить кота - "</span> <span class="token operator">+</span> cat<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre> Тут бачимо, що у статичному методі <span class="code">petTheCat</span> викликається звичайний, нестатичний метод об'єкта <span class="code">Cat</span> - <span class="code">getName</span> .
<h4>45. Що таке interface? Чи може бути final interface?</h4>Як ми пам'ятаємо, Java не має множинного успадкування. Інтерфейси — це щось подібне до його альтернативи. Інтерфейс нагадує дуже урізаний клас. Вони визначають функціонал без конкретної реалізації, який реалізують класи, що імплементують ці інтерфейси. Приклад інтерфейсу: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">voice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre> Приклад реалізації інтерфейсу класом: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">implements</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>

   <span class="token annotation punctuation">@Override</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">voice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Meow! Meow! Meow!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre> Головне, що потрібно знати про використання інтерфейсів:
<ol>
 <li>Методи інтерфейсу мають лише заголовок, без конкретного тіла методу, тобто. мають бути абстрактними (але без застосування ключового слова <span class="code">abstract</span> ). Виняток із цього — статичні та дефолтні методи, для яких необхідно мати тіло методу.</li>
 <li>Клас може реалізовувати безліч інтерфейсів (як і говорив, це альтернатива множинному успадкування), які прописуються через кому: <span class="code">class Lion implements Animal, Wild</span> .</li>
 <li>Інтерфейси створюються за допомогою ключового слова - <span class="code">interface</span> .</li>
 <li>При реалізації інтерфейсу класом використовується ключове слово - <span class="code">implements</span> .</li>
 <li>Клас, який реалізує певний інтерфейс, повинен реалізувати всі його абстрактні методи, або повинен оголосити себе абстрактним.</li>
 <li>Основна мета використання інтерфейсів - реалізація поліморфізму (здатність об'єктів набувати безліч форм).</li>
 <li>В інтерфейсі, як правило, не пишуть модифікатори доступу для методів: вони за замовчуванням <span class="code">public</span> , інші модифікатори, відмінні від <span class="code">public</span> , задавати не можна. Починаючи з Java 9, можна використовувати <span class="code">private</span> модифікатори для методів.</li>
 <li>Змінні інтерфейси за промовчанням <span class="code">static final</span> , інакше кажучи - константи: їх завжди потрібно проініціалізувати безпосередньо в інтерфейсі.</li>
 <li>Неможливо створити об'єкт інтерфейсу.</li>
</ol>Відповідь на запитання, чи можуть бути інтерфейси фінальними, звичайно ж, ні. Адже сама сутність інтерфейсів у тому, щоб їх реалізовували. А як ми всі чудово пам'ятаємо, <span class="code">final</span> на рівні класу робить його не успадкованим, і у випадку з інтерфейсом не реалізовується. А навіщо нам інтерфейс, який не можна реалізувати та використати? Правильно — нема чого! І компілятор так вважає)) <img data-max-width="512" data-id="a58b0173-64ea-4538-bdc5-c32f2c25cf24" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 5 - 4" src="https://cdn.javarush.com/images/article/a58b0173-64ea-4538-bdc5-c32f2c25cf24/512.jpeg" style="width: 512px;">Сенс хіба що з'явився із введенням статичних методів в інтерфейси з Java 8, але це не змінило того факту, що інтерфейс не може бути фінальним. Про інтерфейси я розповів дуже поверхово, т.к. це велика тема. Докладніше про це — у статтях про <a href="https://codegym.cc/groups/posts/1981-dlja-chego-v-java-nuzhnih-interfeysih" target="_blank">інтерфейси в Java</a> та <a href="https://codegym.cc/groups/posts/1985-raznica-mezhdu-abstraktnihmi-klassami-i-interfeysami" target="_blank">різниці між абстрактними класами та інтерфейсами</a> .
<h4>46. ​​Де можна ініціалізувати статичні поля?</h4>Статичні поля можна ініціалізувати:
<ul>
 <li>безпосередньо при оголошенні через знак рівності <span class="code">=</span> ;</li>
 <li>у статичному блоці ініціалізації;</li>
 <li>у нестатичному блоці ініціалізації, але при цьому ви повинні розуміти, що при кожному створенні об'єкта це поле буде перезаписуватись цим блоком ініціалізації;</li>
 <li>у конструкторі класу. При кожному виклик даного конструктора (тобто при створенні об'єкта через цей конструктор) це поле буде перезаписуватися;</li>
 <li>у статичних методах;</li>
 <li>у нестатичних методах;</li>
 <li>у внутрішніх статичних та нестатичних, локальних та анонімних класах.</li>
</ul>
<h4>47. Що таке анонімні класи?</h4>Анонімні класи — це класи, які не мають власного типу. Про що я? Коли ми говорабо про інтерфейси, я згадав, що не можна створити об'єкт інтерфейсу: можна створити об'єкт класу, який реалізує інтерфейс. А якщо ви не хочете реалізовувати інтерфейс в якомусь класі, але при цьому вам потрібен об'єкт типу інтерфейсу? І найімовірніше, це буде одиничний випадок використання даного об'єкта. І у вас немає потреби створювати повноцінний клас реалізацію. Як ви це зробите? Правильно! Через анонімний клас! <img data-max-width="512" data-id="0ee0881d-5805-4d8b-bcec-1fe686ff85b0" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 5 - 5" src="https://cdn.javarush.com/images/article/0ee0881d-5805-4d8b-bcec-1fe686ff85b0/512.jpeg" style="width: 512px;">Припустимо, у нас є деякий інтерфейс <span class="code">Animal</span> : 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">interface</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">voice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre> Якщо ми хочемо створити екземпляр цього інтерфейсу через анонімний клас: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token class-name">Animal</span> cat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token annotation punctuation">@Override</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">voice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Meow! Meow! Meow!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> І далі ви можете спокійно використовувати даний об'єкт та його реалізований метод — <span class="code">voice</span>. Тобто анонімний клас реалізує цей інтерфейс і всі його абстрактні методи прямо тут і зараз. Інакше нам не створити об'єкт інтерфейсу/абстрактного класу, оскільки є не реалізовані/абстрактні методи. Як я згадав, анонімні класи використовуються як для реалізації абстрактних методів інтерфейсу, а й реалізації абстрактних методів абстрактного класу. Даний підхід хороший для ситуацій, коли об'єкт використовується разово або дана реалізація методів потрібна лише один раз, і немає потреби створювати окремий клас, який реалізовуватиме необхідний абстрактний клас/інтерфейс. Але також зазначу, що використання анонімних класів - рідкісне явище в роботі: як правило перевага все ж таки віддається звичайним класам. Детальніше про анонімні класи можна почитати <a href="https://codegym.cc/groups/posts/2193-anonimnihe-klassih" target="_blank">ось у цій статті</a>.
<h4>48. Що таке примітивні класи?</h4>Як на мене, це дуже дивне питання і, можливо, це таке питання-пастка, адже Java не має такого поняття як примітивні класи: хіба що є поняття примітивні типи, яке ми вже розглядали раніше. Як ми пам'ятаємо, в Java є 8 примітивних типів - <span class="code">byte</span> , <span class="code">short</span> , <span class="code">int</span> , <span class="code">long</span> , <span class="code">float</span> , <span class="code">double</span> , <span class="code">char</span> , <span class="code">boolean</span> .<img data-max-width="512" data-id="6353785e-032a-40c8-ab27-5628b2718b74" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 5 - 6" src="https://cdn.javarush.com/images/article/6353785e-032a-40c8-ab27-5628b2718b74/512.jpeg" style="width: 512px;">
<h4>49. Що таке клас «обгортка» (wrapper)?</h4>Головна проблема використання примітивних типів в Java - це те, що вони все ж таки не класи, а Java - все ж таки ООП мову. Тобто програми, написані цією мовою, зводяться до взаємодії між об'єктами. Ну, а примітиви — це не об'єкти. Вони не мають методів, навіть стандартних від класу <span class="code">Object</span> . Ну а якщо нам знадобилося використовувати примітив як ключ у <span class="code">Map</span> ? Тоді потрібно викликати метод <span class="code">hashCode</span> . Також там можна викликати метод <span class="code">equals</span>. Що тоді? Моментів, де має бути саме клас, а не примітив, може бути дуже і дуже багато, що робить примітиви невикористовуваними та небажаними елементами у програмі, адже це руйнує саму ідею ОВП. Але не так погано, як здається. Адже Java має поняття обгортки примітивів. Кожен примітивний тип має клас-аналог:
<ul>
 <li><span class="code">byte</span> -&gt; <span class="code">Byte.class</span></li>
 <li><span class="code">short</span> -&gt; <span class="code">Short.class</span></li>
 <li><span class="code">int</span> -&gt; <span class="code">Integer.class</span></li>
 <li><span class="code">long</span> -&gt; <span class="code">Long.class</span></li>
 <li><span class="code">float</span> -&gt; <span class="code">Float.class</span></li>
 <li><span class="code">double</span> -&gt; <span class="code">Double.class</span></li>
 <li><span class="code">char</span> -&gt; <span class="code">Character.class</span></li>
 <li><span class="code">boolean</span> -&gt; <span class="code">Boolean.class</span></li>
</ul>Це уявлення простих типів, але як повноцінних класів з купою різноманітних і функціональних методів. Для зручного використання цих класів ввели поняття autoboxing та unboxing. <span class="text-bold">Autoboxing</span> — автоматичне перетворення примітивного типу на клас-аналог за потреби (наприклад, <span class="code">int</span> в <span class="code">Integer</span> ). <span class="text-bold">Unboxing</span> - процес, зворотний попередньому: автоматичне перетворення класу-обгортки примітиву до примітивного типу (наприклад, <span class="code">Integer</span> до <span class="code">int</span> ). Завдяки введенню класів-обгорток примітивів та процесів <span class="text-bold">autoboxing</span> -а та <span class="text-bold">unboxing</span> -а, примітивні типи змогли стати повноцінними членами ООП мови – Java.<img data-max-width="512" data-id="26effbd3-eb9c-4b45-b8f5-3a67203c1a4f" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 5 - 7" src="https://cdn.javarush.com/images/article/26effbd3-eb9c-4b45-b8f5-3a67203c1a4f/512.jpeg" style="width: 512px;">Щоб ознайомитися з цією темою докладніше, наполегливо рекомендую почитати <a href="https://codegym.cc/groups/posts/1948-objertki-raspakovka-i-zapakovka" target="_blank">цю статтю</a> .
<h4>50. Що таке Nested class? Коли він використається?</h4>Nested class – внутрішній клас, який є членом іншого класу. У Java існує 4 види таких внутрішніх класів: <span class="text-bold">1. Внутрішній клас</span> Цей вид класів оголошується у тілі іншого класу. Вкладений внутрішній клас може отримати доступ до будь-якого приватного поля або методу екземпляра зовнішнього класу. Як приклад, створимо зоопарк, у якому ми матимемо тварину — зебра: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Zoo</span> <span class="token punctuation">{</span>
   <span class="token keyword">class</span> <span class="token class-name">Zebra</span> <span class="token punctuation">{</span>
       <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">toFeed</span><span class="token punctuation">(</span><span class="token class-name">String</span> food<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Дать зебре - "</span> <span class="token operator">+</span> food<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre> Нічого складного, чи не так? Погляньмо на приклад створення об'єкта внутрішнього класу: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class=" language-java"><span class="token class-name">Zoo<span class="token punctuation">.</span>Zebra</span> zebra <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Zoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Zebra</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
zebra<span class="token punctuation">.</span><span class="token function">toFeed</span><span class="token punctuation">(</span><span class="token string">"яблоко"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Як ви вже побачабо, обов'язково потрібно створювати об'єкт класу, що обрамляє, на основі посилання якого можна створити об'єкт внутрішнього класу. Також хотілося б відзначити, що вкладений внутрішній клас <span class="text-bold">неспроможна мати у собі статичних методів</span> чи статичних полів. Саме тому, що внутрішній клас неявно пов'язаний з об'єктом свого зовнішнього класу, і він не може оголошувати жодних статичних методів у собі. <span class="text-bold">2. Статичні вкладені класи</span> Цей клас схожий на попередній, тільки у нього модифікатор доступу <span class="code">static</span>біля оголошення класу. Так як у цього виду класів немає доступу до нестатичних полів зовнішнього класу, він більше нагадує статичну частину зовнішнього класу, ніж на внутрішній клас. При цьому дані класу мають доступ до всіх статичних членів зовнішнього класу, навіть до приватних. Приклад статичного вкладеного класу: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Zoo</span> <span class="token punctuation">{</span>
   <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Zebra</span> <span class="token punctuation">{</span>
       <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">toFeed</span><span class="token punctuation">(</span><span class="token class-name">String</span> food<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Дать зебре - "</span> <span class="token operator">+</span> food<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre> Спосіб створення трохи відрізняється від попереднього: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class=" language-java"><span class="token class-name">Zoo<span class="token punctuation">.</span>Zebra</span> zebra <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Zoo<span class="token punctuation">.</span>Zebra</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
zebra<span class="token punctuation">.</span><span class="token function">toFeed</span><span class="token punctuation">(</span><span class="token string">"яблоко"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Тут не потрібен об'єкт зовнішнього класу до створення об'єкта вкладеного статичного класу. Від зовнішнього класу нам потрібен лише його тип, щоб можна було знайти розташування вкладеного класу. <span class="text-bold">3. Локальні класи</span> Локальні класи — це класи, оголошені всередині тіла методу, у своїй створення та використання об'єкта локального класу можливе виключно межах цього методу. Приклад: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Zoo</span> <span class="token punctuation">{</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">toFeed</span><span class="token punctuation">(</span><span class="token class-name">String</span> animal<span class="token punctuation">,</span> <span class="token class-name">String</span> food<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">switch</span><span class="token punctuation">(</span>animal<span class="token punctuation">)</span><span class="token punctuation">{</span>
           <span class="token keyword">case</span> <span class="token string">"зебра"</span><span class="token operator">:</span>
               <span class="token keyword">class</span> <span class="token class-name">Zebra</span> <span class="token punctuation">{</span>
                   <span class="token keyword">void</span> <span class="token function">toFeedZebra</span><span class="token punctuation">(</span><span class="token class-name">String</span> food<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Дать зебре - "</span> <span class="token operator">+</span> food<span class="token punctuation">)</span><span class="token punctuation">;</span>
                   <span class="token punctuation">}</span>
               <span class="token punctuation">}</span>
               <span class="token class-name">Zebra</span> zebra <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Zebra</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
               zebra<span class="token punctuation">.</span><span class="token function">toFeedZebra</span><span class="token punctuation">(</span>food<span class="token punctuation">)</span><span class="token punctuation">;</span>
               <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre> Приклад використання: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class=" language-java"><span class="token class-name">Zoo</span> zoo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Zoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
zoo<span class="token punctuation">.</span><span class="token function">toFeed</span><span class="token punctuation">(</span><span class="token string">"зебра"</span><span class="token punctuation">,</span> <span class="token string">"яблоко"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Не бачачи код методу <span class="code">toFeed</span> , ви б і не запідозрабо про існування локального класу, чи не так? Локальний клас може бути <span class="code">static</span> чи <span class="code">transient</span> , але його можна помітити як <span class="code">abstract</span> чи <span class="code">final</span> (тільки АБО, оскільки використання цих двох модифікаторів призведе до конфлікту). <span class="text-bold">4. Анонімні класи</span> Про анонімні класи ми вже говорабо вище, і як ви пам'ятаєте, їх можна створити із двох джерел – інтерфейси та класи. <span class="text-bold">Причини використання</span> Внутрішні статичні та не статичні класи використовують тому, що іноді краще вбудувати невеликі класи у загальніші і зберігати їх разом: так у них буде більш висока пов'язаність та загальна мета. Власне використання вкладених класів збільшує інкапсуляцію коду. Причиною вибору локальних класів може бути те, що цей клас використовується виключно в межах одного методу. Чи потрібно в такому разі розмазувати код за програмою? Ні. Але при цьому додам, що у своїй практиці жодного разу не бачив використання локальних класів, т.к. потреба у них дуже спірна. Ну а причиною використання анонімних класів може бути те, що конкретна реалізація інтерфейсу або абстрактного класу буде необхідна лише один раз, тому немає потреби створювати під це окремий, повноцінний клас із реалізацією.<img data-max-width="512" data-id="dff3ed7a-a39f-4cfe-8c5a-94e41fb0ce36" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 5 - 8" src="https://cdn.javarush.com/images/article/dff3ed7a-a39f-4cfe-8c5a-94e41fb0ce36/512.jpeg" style="width: 512px;">Вивчити внутрішні класи докладніше вам допоможуть <a href="https://codegym.cc/groups/posts/2181-vlozhennihe-vnutrennie-klassih" target="_blank">ця</a> та <a href="https://codegym.cc/quests/lectures/questmultithreading.level03.lecture03" target="_blank">ця</a> статті.
<h4>51. Які модифікатори доступу можуть мати клас?</h4>Як ми пам'ятаємо, існують різні види класів і для них застосовні різні модифікатори доступу:
<ul>
 <li><span class="text-bold">зовнішній клас</span> може мати модифікатор доступу <span class="code">public</span> або без модифікатора (модифікатор за замовчуванням);</li>
 <li><span class="text-bold">внутрішній клас</span> підтримує всі 4 модифікатори доступу;</li>
 <li><span class="text-bold">вкладений статичний клас</span> підтримує всі модифікатори доступу, крім <span class="code">protected</span> , т.к. даний модифікатор має на увазі успадкування, що суперечить статичному члену класу (статичні елементи не успадковуються);</li>
 <li><span class="text-bold">локальний клас</span> може бути лише з модифікатором за умовчанням (тобто без модифікатора зовсім);</li>
 <li><span class="text-bold">анонімний клас</span> : немає оголошення типу класу, то й модифікатори доступу відсутні зовсім.</li>
</ul>На цьому ми сьогодні й зробимо зупинку. <span class="text-bold">See you soon!</span><img data-max-width="512" data-id="54b4e25c-cc75-4fb7-8cdf-c42a19787cba" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 5 - 9" src="https://cdn.javarush.com/images/article/54b4e25c-cc75-4fb7-8cdf-c42a19787cba/512.jpeg" style="width: 512px;"><a href="https://codegym.cc/login/signup" target="_blank"><img id="click_banner1_articles" data-max-width="1080" data-id="5736eb4b-2b1c-4ab6-b4cc-b9e2d1cef628" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 5 - 10" src="https://cdn.javarush.com/images/article/5736eb4b-2b1c-4ab6-b4cc-b9e2d1cef628/1080.jpeg" style="width: 1080px;"></a>
<div class="table-container">
 <table>
  <tbody>
   <tr>
    <th>Інші матеріали серії:</th>
   </tr>
   <tr>
    <td>
     <ul>
      <li><a href="https://codegym.cc/groups/posts/3243-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-1" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 1</a></li>
      <li><a href="https://codegym.cc/groups/posts/3252-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-2" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 2</a></li>
      <li><a href="https://codegym.cc/groups/posts/3273-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-3" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 3</a></li>
      <li><a href="https://codegym.cc/groups/posts/3284-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-4" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 4</a></li>
      <li><a href="https://codegym.cc/groups/posts/3341-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-6" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 6</a></li>
      <li><a href="https://codegym.cc/groups/posts/3386-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-7" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 7</a></li>
      <li><a href="https://codegym.cc/groups/posts/3415-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-8" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 8</a></li>
      <li><a href="https://codegym.cc/groups/posts/3434-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-9" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 9</a></li>
      <li><a href="https://codegym.cc/groups/posts/3452-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-10" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 10</a></li>
      <li><a href="https://codegym.cc/groups/posts/3464-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-11" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 11</a></li>
      <li><a href="https://codegym.cc/groups/posts/3475-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-12" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 12</a></li>
      <li><a href="https://codegym.cc/groups/posts/3507-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-13" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 13</a></li>
      <li><a href="https://codegym.cc/groups/posts/3558-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-14" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 14</a></li>
      <li><a href="https://codegym.cc/groups/posts/3592-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-15" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 15</a></li>
      <li><a href="https://codegym.cc/groups/posts/3621-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-16" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 16</a></li>
     </ul></td>
   </tr>
  </tbody>
 </table>
</div>