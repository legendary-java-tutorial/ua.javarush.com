Часті запитання щодо класів колекцій в Java (Частина 1)
<p>----------------------------------------</p>
Без сумніву, колекції в Java - це вкрай важлива область, і питання щодо колекцій будуть задавати на співбесідах як новачкам, так і досвідченим програмістам. Тема настільки велика, що практично неможливо покрити її цілком. І все ж, ґрунтуючи
<p>----------------------------------------</p>
Без сумніву, колекції в Java - це вкрай важлива область, і питання щодо колекцій будуть задавати на співбесідах як новачкам, так і досвідченим програмістам. Тема настільки велика, що практично неможливо покрити її цілком. І все ж, ґрунтуючись на моїх попередніх співбесідах, я спробую перерахувати якнайбільше Гарних питань, до яких ви повинні бути готові. <img data-id="55b28d57-6208-48f7-98b0-901123de48d0" data-max-width="850" alt="Часті питання на класах колекцій в Java (Частина 1) - 1" src="https://cdn.javarush.com/images/article/55b28d57-6208-48f7-98b0-901123de48d0/800.jpeg" style="width: 850px;">Питання будуть як складні так і прості, так що якщо питання здається вам занадто примітивним - не забувайте, що він відмінно підійде менш досвідченому програмісту. 
<h2>Запитання у цій статті:</h2><strong>Загальні питання</strong>
<ol>
 <li>Що таке колекції Java? Перерахуйте їх переваги</li>
 <li>Розкажіть про ієрархію колекцій</li>
 <li>Чому колекції не успадковують інтерфейси <code class=" language-none">Cloneable</code>та <code class=" language-none">Serializable</code>?</li>
 <li>Чому інтерфейс <code class=" language-none">Map</code>не успадковує інтерфейс <code class=" language-none">Collection</code>?</li>
</ol><strong>Запитання про списки</strong>
<ol>
 <li value="5">Чому ми використовуємо списки? Які основні класи реалізують інтерфейс <code class=" language-none">List</code>?</li>
 <li>Як перетворити масив рядків на <code class=" language-none">ArrayList</code>?</li>
 <li>Як відсортувати список у зворотному порядку?</li>
</ol><strong>Питання про безліч</strong>
<ol>
 <li value="8">Чому ми використовуємо безліч? Які основні класи реалізують інтерфейс <code class=" language-none">Set</code>?</li>
 <li>Як зберігаються елементи в <code class=" language-none">HashSet</code>?</li>
 <li>Чи може бути елемент <code class=" language-none">null</code>доданий в <code class=" language-none">TreeSet</code>або <code class=" language-none">HashSet</code>?</li>
</ol><strong>Запитання про словники</strong>
<ol>
 <li value="11">Чому ми використовуємо словники? Які основні класи реалізують інтерфейс <code class=" language-none">Map</code>?</li>
 <li>Що таке <code class=" language-none">IdentityHashMap</code>і <code class=" language-none">WeakHashMap</code>?</li>
 <li>Поясніть що таке <code class=" language-none">ConcurrentHashMap</code>? Як воно працює?</li>
 <li>Як працюють словники?</li>
 <li>Як створити добрий ключ для словника?</li>
 <li>Які уявлення вмісту надає інтерфейс <code class=" language-none">Map</code>?</li>
 <li>Коли потрібно використовувати <code class=" language-none">HashMap</code>, а коли <code class=" language-none">TreeMap</code>?</li>
</ol><strong><a href="https://codegym.cc/groups/posts/716-chasto-zadavaemihe-na-sobesedovanijakh-voprosih-po-klassam-kollekcijam-v-java-chastjh-2" target="_blank">Питання про відмінності різних колекцій</a></strong>
<ol>
 <li value="18">Назвіть різницю між <code class=" language-none">Set</code>і <code class=" language-none">List</code>?</li>
 <li>Назвіть різницю між <code class=" language-none">List</code>і <code class=" language-none">Map</code>?</li>
 <li>Назвіть різницю між <code class=" language-none">HashMap</code>і<code class=" language-none">HashTable?</code></li>
 <li>Назвіть різницю між <code class=" language-none">Vector</code>і <code class=" language-none">ArrayList</code>?</li>
 <li>Назвіть різницю між <code class=" language-none">Iterator</code>і <code class=" language-none">Enumeration</code>?</li>
 <li>Назвіть різницю між <code class=" language-none">HashMap</code>і <code class=" language-none">HashSet</code>?</li>
 <li>Назвіть різницю між <code class=" language-none">Iterator</code>і <code class=" language-none">ListIterator</code>?</li>
 <li>Назвіть різницю між <code class=" language-none">TreeSet</code>і <code class=" language-none">SortedSet</code>?</li>
 <li>Назвіть різницю між <code class=" language-none">ArrayList</code>і <code class=" language-none">LinkedList</code>?</li>
</ol><strong><a href="https://codegym.cc/groups/posts/716-chasto-zadavaemihe-na-sobesedovanijakh-voprosih-po-klassam-kollekcijam-v-java-chastjh-2" target="_blank">І ще питання</a></strong>
<ol>
 <li value="27">Як зробити колекцію лише для читання?</li>
 <li>Як зробити потокобезпечну колекцію?</li>
 <li>Чому не існує методу <code class=" language-none">Iterator.add()</code>додавання елементів до колекції?</li>
 <li>Які є способи перебирати елементи списку?</li>
 <li>Як ви розумієте роботу якості ітератора <code class=" language-none">fail-fast</code>?</li>
 <li>Яка різниця між <code class=" language-none">fail-fast</code>і <code class=" language-none">fail-safe</code>?</li>
 <li>Як уникнути <code class=" language-none">ConcurrentModificationException</code>під час перебору колекції?</li>
 <li>Що таке <code class=" language-none">UnsupportedOperationException</code>?</li>
 <li>Які класи колекцій дають доступ до будь-якого елемента?</li>
 <li>Що таке <code class=" language-none">BlockingQueue</code>?</li>
 <li>Що таке черга та стек, перерахуйте різницю між ними?</li>
 <li>Що таке інтерфейси <code class=" language-none">Comparable</code>та <code class=" language-none">Comparator</code>?</li>
 <li>Що таке класи <code class=" language-none">Collections</code>та <code class=" language-none">Arrays</code>?</li>
 <li>Список використаної літератури</li>
</ol>Не марнуючи час, приступимо до пояснень
<h2>Загальні питання</h2>
<ol>
 <li>
  <p><strong>Що таке колекції Java? Перерахуйте їхні переваги?</strong></p>
  <p>За визначенням — колекція це об'єкт, що є групою об'єктів. Як у теорії множин - безліч це група об'єктів. Просто, чи не так? До виходу JDK 1.2, існували такі класи як <code class=" language-none">Vector</code>і <code class=" language-none">HashTable</code>, але не було фреймворку <code class=" language-none">Collection</code>. Потім було вирішено додати підтримку структур даних, що багаторазово використовуються. Цей фреймворк був розроблений переважно Джошуа Блохом, і вперше з'явився у JDK 1.2.</p>
  <p>Як головні переваги ми можемо перерахувати:</p>
  <ul>
   <li>Зменшуються витрати часу на написання коду</li>
   <li>Покращується продуктивність завдяки використанню високоефективних алгоритмів і структур даних</li>
   <li>Колекції є універсальним способом зберігання та передачі даних, що спрощує взаємодію різних частин коду.</li>
   <li>Простота у вивченні, тому що необхідно вивчити тільки найвищі інтерфейси та підтримувані операції</li>
  </ul></li>
 <li>
  <p><strong>Розкажіть про ієрархію колекцій?</strong></p><img data-id="b266e805-26b9-4e74-9808-66fce11e7a7d" data-max-width="650" alt="Часті питання на класах колекцій в Java (Частина 1) - 2" src="https://cdn.javarush.com/images/article/b266e805-26b9-4e74-9808-66fce11e7a7d/512.jpeg" style="width: 650px;">
  <p>Як показано на зображенні, фреймворк колекцій містить один інтерфейс верхнього рівня - <code class=" language-none">Collection</code>, від якого успадковуються <code class=" language-none">Set</code>, <code class=" language-none">List</code>і <code class=" language-none">Queue</code>. Нижче ми розглянемо ще безліч класів, які у цих трьох гілках. Запам'ятайте заголовок інтерфейсу <code class=" language-none">Collection</code>, це допоможе вам з багатьма питаннями.</p>
  <pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">interface</span></span> <span class="token class-name"><span class="token class-name">Collection</span></span> <span class="token keyword"><span class="token keyword">extends</span></span> <span class="token class-name"><span class="token class-name">Iterable</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
<span class="token comment"><span class="token comment">//описание методов</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre>
  <p>Також фреймворк містить <a href="https://codegym.cc/groups/posts/763-9-glavnihkh-voprosov-o-map-v-java" target="_blank">інтерфейс Map</a> , який є спадкоємцем інтерфейсу <code class=" language-none">Collection</code>. Причину чому він не успадковує <code class=" language-none">Collection</code>, ми розберемо у четвертому питанні.</p></li>
 <li>
  <p><strong>Чому колекції не успадковують інтерфейси <code class=" language-none">Cloneable</code>та <code class=" language-none">Serializable</code>?</strong></p>
  <p>Ну, найпростіша відповідь - "бо не треба". Функціонал, що надається інтерфейсами <code class=" language-none">Cloneable</code>і <code class=" language-none">Serializable</code>просто не потрібен для колекцій.</p>
  <p>Ще одна причина — далеко не завжди потрібний підклас, <code class=" language-none">Cloneable</code>тому що кожна операція клонування споживає дуже багато пам'яті, і недосвідчені програмісти можуть витрачати її самі, не розуміючи наслідків.</p>
  <p>І остання причина — клонування та серіалізація є дуже вузькоспецифічними операціями, і реалізовувати їх потрібно лише коли це необхідно. Багато класів колекції реалізують дані інтерфейси, але зовсім не потрібно закладати їх для всіх колекцій взагалі. Якщо вам потрібне клонування та серіалізація - просто скористайтеся тими класами, де вона є, якщо ні - іншими класами.</p></li>
 <li>
  <p><strong>Чому інтерфейс <code class=" language-none">Map</code>не успадковує інтерфейс <code class=" language-none">Collection</code>?</strong></p>
  <p>Хороша відповідь на це питання - "бо вони несумісні". В інтерфейсі <code class=" language-none">Collection</code>описаний метод <code class=" language-none">add(Object o)</code>.</p>
  <p>Словники не можуть містити цей метод, тому що працюють з парами ключ/значення. Також, словники мають уявлення <code class=" language-none">keySet</code>, <code class=" language-none">valueSet,</code>яких немає в колекціях.</p>
  <p>У зв'язку з цими відмінностями, інтерфейс <code class=" language-none">Map</code>не може успадковувати інтерфейс <code class=" language-none">Collection</code>, і є окремою гілкою ієрархії.</p></li>
</ol>
<h2>Запитання про списки</h2>
<ol>
 <li value="5">
  <p><strong>Чому ми використовуємо списки? Які основні класи реалізують інтерфейс <code class=" language-none">List</code>?</strong></p>
  <p>Списки в Java - це впорядкована колекція елементів. Кожен елемент має індекс, що починається з нуля. Усі індекси унікальні. Крім методів описаних в інтерфейсі <code class=" language-none">Collection</code>, списки мають власні методи, в основному для роботи з елементами колекціями за їх індексом. Можна розділити ці методи на 3 групи - пошук елемента, отримання конкретного елемента, вибір колекції і вибірка підгрупи. Всі ці операції можуть проводитись за індексом елемента.</p>
  <p>Основні класи, що реалізують інтерфейс <code class=" language-none">List</code>це <code class=" language-none">Stack</code>, <code class=" language-none">Vector</code>, <code class=" language-none">ArrayList</code>і <code class=" language-none">LinkedList</code>. За більш детальною інформацією щодо них, зверніться до документації.</p></li>
 <li>
  <p><strong>Як перетворити масив рядків на <code class=" language-none">ArrayList</code>?</strong></p>
  <p>Питання це трохи глибше ніж просто з програмування, як це бачиться новачкам. Мета його – перевірити знання кандидатом службових класів фреймворку <code class=" language-none">Collection</code>. Розглянемо два таких класи, які найбільш затребувані на співбесідах — <code class=" language-none">Collections</code>і <code class=" language-none">Arrays</code>.</p>
  <p>Клас <code class=" language-none">Collections</code>надає статичні методи операцій над колекціями. Відповідно <code class=" language-none">Arrays</code>надає статичні методи операцій над масивами.</p>
  <pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">String</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> words <span class="token operator"><span class="token operator">=</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span><span class="token string"><span class="token string">"аз"</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token string"><span class="token string">"буки"</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token string"><span class="token string">"веди"</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token string"><span class="token string">"глагол"</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token string"><span class="token string">"добро"</span></span><span class="token punctuation"><span class="token punctuation">}</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token comment"><span class="token comment">//Как вы можете обратить внимание, у нас есть массив строк String[] words.</span></span>
<span class="token comment"><span class="token comment">//В котором у нас лежат 5 строк.</span></span>
<span class="token class-name"><span class="token class-name">List</span></span> wordList <span class="token operator"><span class="token operator">=</span></span> <span class="token class-name"><span class="token class-name">Arrays</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">asList</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>words<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token comment"><span class="token comment">//легким движением руки, а точнее вызовом Arrays.asList() мы превратабо наш</span></span>
<span class="token comment"><span class="token comment">//массив строк в список List wordList.</span></span></code></pre>
  <p>Також хотілося б відзначити, що цей метод здатний обробляти не лише рядки, він створить список елементів будь-якого типу, якого був масив.</p>
  <pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">Integer</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> nums <span class="token operator"><span class="token operator">=</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span><span class="token number"><span class="token number">1</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token number"><span class="token number">2</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token number"><span class="token number">3</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token number"><span class="token number">4</span></span><span class="token punctuation"><span class="token punctuation">}</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token class-name"><span class="token class-name">List</span></span> numList <span class="token operator"><span class="token operator">=</span></span> <span class="token class-name"><span class="token class-name">Arrays</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">asList</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>nums<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre></li>
 <li>
  <p><strong>Як відсортувати список у зворотному порядку?</strong></p>
  <p>Як і попереднє, це питання перевіряє ваше знання службових класів<code class=" language-none">Collection</code></p>
  <pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">List</span></span> reversedList <span class="token operator"><span class="token operator">=</span></span> <span class="token class-name"><span class="token class-name">Collections</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">reverse</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>list<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre></li>
</ol>
<h2>Питання про безліч</h2>
<ol>
 <li value="8">
  <p>Чому ми використовуємо безліч? Які основні класи реалізують інтерфейс <code class=" language-none">Set</code>?</p>
  <p>Він моделює математичну множину, з теорії множин. Інтерфейс <code class=" language-none">Set</code>схожий на <code class=" language-none">List</code>, але має деякі відмінності. Перше – це не впорядкована колекція. Отже, додавання/видалення елементів не потребує їх сортування. Головна особливість множин - унікальність елементів, тобто один і той самий елемент не може утримуватися в множині двічі.</p>
  <p></p>
  <p>Дуже важливими для функціонування множин є методи <code class=" language-none">equals()</code>і <code class=" language-none">hashCode()</code>вони дозволяють порівнювати безлічі різних класів. Дві множини є ідентичними тільки якщо вони містять одні й ті самі елементи.</p>
  <p>Як випливає з вищевикладеного, множини не підтримують операцій заснованих на індексі елемента, як списки. Багато мають тільки ті методи, які описані в інтерфейсі.<code class=" language-none">Collection</code></p>
  <p>Основними класами, що реалізують інтерфейс <code class=" language-none">Set</code>, є <code class=" language-none">EnumSet</code>, <code class=" language-none">HashSet</code>, <code class=" language-none">LinkedHashSet</code>і <code class=" language-none">TreeSet</code>. Якщо хочете дізнатися більше, почитайте відповідні розділи документації Java.</p></li>
 <li>
  <p><strong>Як зберігаються елементи в <code class=" language-none">HashSet</code>?</strong></p>
  <p>Як ви вже в курсі, <code class=" language-none">HashMap</code>зберігає пари ключ/значення, і ключі мають бути унікальними. <code class=" language-none">HashSet</code>використовує цю особливість <code class=" language-none">HashMap</code>задля забезпечення унікальності своїх елементів. У класі <code class=" language-none">HashSet</code>словник описаний наступним чином:</p>
  <pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">private</span></span> <span class="token keyword"><span class="token keyword">transient</span></span> <span class="token class-name"><span class="token class-name">HashMap</span></span><span class="token generics"><span class="token punctuation"></span><span class="token generics"><span class="token punctuation"><span class="token punctuation">&lt;</span></span><span class="token class-name"><span class="token class-name">E</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token class-name"><span class="token class-name">Object</span></span><span class="token punctuation"><span class="token punctuation">&gt;</span></span></span><span class="token punctuation"></span></span> map<span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token keyword"><span class="token keyword">private</span></span> <span class="token keyword"><span class="token keyword">static</span></span> <span class="token keyword"><span class="token keyword">final</span></span> <span class="token class-name"><span class="token class-name">Object</span></span> PRESENT <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">Object</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre>
  <p>Отже, коли ви зберігаєте елемент у множині, воно кладе даний елемент як ключ у словник, а значенням йде об'єкт PRESENT, як описано нижче:</p>
  <pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">boolean</span></span> <span class="token function"><span class="token function">add</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">E</span></span> e<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
  <span class="token keyword"><span class="token keyword">return</span></span> map<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">put</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>e<span class="token punctuation"><span class="token punctuation">,</span></span> PRESENT<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token operator"><span class="token operator">==</span></span> <span class="token keyword"><span class="token keyword">null</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre>
  <p>Я настійно рекомендую вам прочитати <a href="https://howtodoinjava.com/java/collections/hashmap/how-hashmap-works-in-java/" rel="nofollow" target="_blank">цю статтю</a> , це допоможе вам з легкістю відповісти на всі <code class=" language-none">HashMap</code>питання.</p></li>
 <li>
  <p><strong>Чи може бути елемент <code class=" language-none">null</code>доданий в <code class=" language-none">TreeSet</code>або <code class=" language-none">HashSet</code>?</strong></p>
  <p>Як очевидно з попередньої відповіді, методі <code class=" language-none">add()</code>немає перевірки на <code class=" language-none">null</code>. Також <code class=" language-none">HashMap</code>дозволяє один ключ <code class=" language-none">null</code>, отже, один елемент <code class=" language-none">null</code>може бути доданий в <code class=" language-none">HashSet</code>.</p>
  <p><code class=" language-none">TreeSet</code>працює за тим же принципом, що і <code class=" language-none">HashSet</code>, але використовує <code class=" language-none">NavigableMap</code>для зберігання елементів</p>
  <pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">private</span></span> <span class="token keyword"><span class="token keyword">transient</span></span> <span class="token class-name"><span class="token class-name">NavigableMap</span></span><span class="token generics"><span class="token punctuation"></span><span class="token generics"><span class="token punctuation"><span class="token punctuation">&lt;</span></span><span class="token class-name"><span class="token class-name">E</span></span><span class="token punctuation"><span class="token punctuation">,</span></span><span class="token class-name"><span class="token class-name">Object</span></span><span class="token punctuation"><span class="token punctuation">&gt;</span></span></span><span class="token punctuation"></span></span> m<span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token keyword"><span class="token keyword">private</span></span> <span class="token keyword"><span class="token keyword">static</span></span> <span class="token keyword"><span class="token keyword">final</span></span> <span class="token class-name"><span class="token class-name">Object</span></span> PRESENT <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">Object</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre>
  <p><code class=" language-none">NavigableMap</code>це клас-спадкоємець <code class=" language-none">SortedMap</code>, а <code class=" language-none">SortedMap</code>не дозволяє використання ключів <code class=" language-none">null</code>. Отже, <code class=" language-none">TreeMap</code>не підтримує зберігання елементів типу <code class=" language-none">null</code>. Якщо ви спробуєте додати <code class=" language-none">null в TreeSet</code>, отримайте виняток <code class=" language-none">NullPointerException</code>.</p></li>
</ol>
<h2>Запитання про словники</h2>
<ol>
 <li value="11">
  <p><strong>Чому ми використовуємо словники ( <code class=" language-none">Map</code>)? Які основні класи реалізують інтерфейс <code class=" language-none">Map</code>?</strong></p>
  <p>Словники – спеціальний тип колекції, яка використовується для зберігання пар ключ/значення. З цієї причини він не є спадкоємцем інтерфейсу <code class=" language-none">Collection</code>. Словник надає методи для додавання пар ключ/значення, видалення, пошуку та перебору за уявленням даних, що надаються словником.</p>
  <p>Основні класи реалізують інтерфейс <code class=" language-none">Map</code>: <code class=" language-none">HashMap</code>, <code class=" language-none">Hashtable</code>, <code class=" language-none">EnumMap</code>, <code class=" language-none">IdentityHashMap</code>, <code class=" language-none">LinkedHashMap</code>і <code class=" language-none">Properties</code>.</p></li>
 <li>
  <p><strong>Що таке <code class=" language-none">IdentityHashMap</code>і <code class=" language-none">WeakHashMap</code>?</strong></p>
  <p><code class=" language-none">IdentityHashMap</code>схожий за <code class=" language-none">HashMap</code>одним винятком — для порівняння об'єктів використовується порівняння покажчиків на об'єкти, якщо покажчики не рівні (вказують на об'єкти, що лежать за різними адресаами), отже, об'єкти вважаються різними.</p>
  <p><code class=" language-none">IdentityHashMap</code>є досить рідко використовується. Хоча він реалізує інтерфейс <code class=" language-none">Map</code>, він порушує один з основних принципів пристрою <code class=" language-none">Map</code>, який вимагає використання методу <code class=" language-none">equals()</code>для порівняння об'єктів.</p>
  <p><code class=" language-none">IdentityHashMap</code>використовується тільки в тих випадках, коли потрібно порівняти об'єкти за їх адресаами.</p>
  <p><code class=" language-none">WeakHashMap</code>це реалізація інтерфейсу <code class=" language-none">Map</code>, що містить слабкі посилання елементи. Тобто, якщо за межами <code class=" language-none">WeakHashMap</code>не залишилося жодного посилання на його елемент, цей елемент видаляється збирачем сміття. Клас призначений для використання з об'єктами, у яких метод <code class=" language-none">equals()</code>перевіряє ідентичність об'єктів за допомогою оператора <code class=" language-none">==</code>. Після того як елемент буде видалений збирачем сміття, він вже не може бути відновлений, і на превеликий подив програміста знайти його у словнику більше не вийде.</p></li>
 <li>
  <p><strong>Поясніть що таке <code class=" language-none">ConcurrentHashMap</code>? Як воно працює?</strong></p>
  <p><em>Взято з офіційної документації:</em><br>
    Реалізація словника повністю підтримує багатопотокове додавання/видалення/пошук елементів. Цей клас слід тим самим специфікаціям як і <code class=" language-none">Hashtable</code>, і містить методи відповідні методам <code class=" language-none">Hashtable</code>. Однак, хоча всі операції є потокобезпечними, операція з вибірки елементів не блокує таблицю, і взагалі немає можливості заборонити доступ до таблиці. Цей клас сумісний з <code class=" language-none">Hashtable</code>усім крім питань багатопоточної синхронізації.</p></li>
 <li>
  <p><strong>Як працює <code class=" language-none">hashmap</code>?</strong></p>
  <p>Найважливіше питання, яке швидше за все буде поставлене на співбесіді програмісту будь-якого рівня. Ви повинні добре розбиратися в цій темі, і не тільки тому що це питання, що найбільше задається, але і тому що розуміння пристрою <code class=" language-none">hashmap</code>дозволяє вам легше розібратися в інших особливостях роботи колекцій.</p>
  <p>Відповідь на це питання дуже велика, і повністю її можна прочитати в цій статті - <a href="http://howtodoinjava.com/2012/10/09/how-hashmap-works-in-java/" rel="nofollow">як працює hashmap</a> . А зараз просто запам'ятайте що <code class=" language-none">HashMap</code>працює на основі хешування. Словник, за визначенням, це об'єкт, який пов'язує ключі та значення. Для зберігання таких структур він використовує внутрішній клас <code class=" language-none">Entry</code>.</p>
  <pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">static</span></span> <span class="token keyword"><span class="token keyword">class</span></span> <span class="token class-name"><span class="token class-name">Entry</span></span> <span class="token keyword"><span class="token keyword">implements</span></span> <span class="token class-name"><span class="token class-name">Map<span class="token punctuation"><span class="token punctuation">.</span></span>Entry</span></span>
<span class="token punctuation"><span class="token punctuation">{</span></span>
<span class="token keyword"><span class="token keyword">final</span></span> <span class="token class-name"><span class="token class-name">K</span></span> key<span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token class-name"><span class="token class-name">V</span></span> value<span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token class-name"><span class="token class-name">Entry</span></span> next<span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token keyword"><span class="token keyword">final</span></span> <span class="token keyword"><span class="token keyword">int</span></span> hash<span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token comment"><span class="token comment">//Еще много кода тут</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre>
  <p>Змінні <code class=" language-none">key</code>та <code class=" language-none">value</code>служать для зберігання ключа та значення. А самі об'єкти <code class=" language-none">Entry</code>лежать у масиві.</p>
  <pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token comment"><span class="token comment">/**
* Размер таблицы меняется по необходимости,
* и обязательно должен быть дорівнює степени двойки
*/</span></span>
<span class="token keyword"><span class="token keyword">transient</span></span> <span class="token class-name"><span class="token class-name">Entry</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> table<span class="token punctuation"><span class="token punctuation">;</span></span></code></pre>
  <p>Індекс потрібного елемента в масиві обчислюється за хеш-кодом ключа. Більше інформації можна отримати за посиланням на початку відповіді.</p></li>
 <li>
  <p><strong>Як створити добрий ключ для словника?</strong></p>
  <p>Наступне гарне питання, яке зазвичай ставлять слідом за питанням про функціонування <code class=" language-none">HashMap</code>. Отже, головне обмеження — ключ має бути таким, щоб потім ним можна було отримати зі словника значення. Інакше у його використанні просто немає сенсу. Якщо ви розумієте як функціонує <code class=" language-none">hashmap</code>, ви знаєте, що його робота сильно залежить від методів <code class=" language-none">hashCode()</code>і <code class=" language-none">equals()</code>об'єктів-ключів.</p>
  <p>Як випливає з вищевикладеного, хороший ключ повинен давати той самий <code class=" language-none">hashCode</code>знову і знову, незалежно від того скільки разів він запитується. Також, однакові ключі, при виклику методу <code class=" language-none">equals()</code>повинні повертати true, а різні — false.</p>
  <p>З чого випливає, що найкращими кандидатами на роль ключа є незмінні класи.</p>
  <p>Можете почитати ще за <a href="http://howtodoinjava.com/2013/05/02/how-to-design-a-good-key-for-hashmap/" rel="nofollow">адресаою</a> .</p></li>
 <li>
  <p><strong>Які уявлення вмісту надає інтерфейс <code class=" language-none">Map</code>?</strong></p>
  <p>Інтерфейс <code class=" language-none">Map</code>надає три уявлення збережених даних:</p>
  <ul>
   <li>безліч усіх ключів</li>
   <li>безліч усіх значень</li>
   <li>безліч об'єктів <code class=" language-none">Entry</code>, що містять у собі і ключ і значення</li>
  </ul>
  <p>Переміщатися ними можна за допомогою ітераторів.</p></li>
 <li>
  <p><strong>Коли потрібно використовувати <code class=" language-none">HashMap</code>, а коли <code class=" language-none">TreeMap</code>?</strong></p>
  <p><code class=" language-none">HashMap</code>це дуже широко використовуваний клас, і ви знаєте. Отже, я обмежуся тим, що скажу, що в ньому зберігаються пари ключ/значення і він дозволяє проводити над ними багато операцій.</p>
  <p><code class=" language-none">TreeMap</code>це особливий різновид <code class=" language-none">HashMap</code>. Різниця в тому, що ключі зберігаються <code class=" language-none">TreeMap</code>впорядковано. За умовчанням застосовується "природне сортування". Перевизначити сортування можна надавши екземпляр класу <code class=" language-none">Comparator</code>, метод <code class=" language-none">compare</code>якого буде використаний для сортування ключів.</p>
  <p>Зверніть увагу, що всі ключі, додані до словника, повинні реалізовувати інтерфейс <code class=" language-none">Comparable</code>(це необхідно для сортування). Більше того, всі ключі повинні бути взаємно сумісними: <code class=" language-none"> k1.compareTo(k2)</code>не повинен викликати <code class=" language-none">ClassCastException</code>для тих, <code class=" language-none">k1</code>хто <code class=" language-none">k2</code>зберігається у словнику. Якщо користувач спробує покласти в словник ключ, який порушує цю умову (наприклад, рядковий ключ у словник, де всі ключі типу <code class=" language-none">Integer</code>), метод <code class=" language-none">put(Object key, Object value)</code>повинен викликати <code class=" language-none">ClassCastException</code>.</p></li>
</ol><a href="https://howtodoinjava.com/interview-questions/useful-java-collection-interview-questions/#difference_set_and_list" rel="nofollow" target="_blank">Оригінал статті</a>