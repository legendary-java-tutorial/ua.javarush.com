Продовження аналізу тестового завдання
<p>----------------------------------------</p>
Протягом топіка про публікую аналіз таких питань як прикручування БД до проекту Spring Boot, з'єднання БД до контролера, виведення даних з бд в браузер у форматі JSON.
<p>----------------------------------------</p>
Протягом топіка про <a href="http://info.codegym.cc/timurnav/2015/09/02/%D0%A2%D0%B5%D1%81%D1%82%D0%BE%D0%B2%D0%BE%D0%B5-%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BD%D0%B0-%D1%82%D1%80%D1%83%D0%B4%D0%BE%D1%83%D1%81%D1%82%D1%80%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%BE-%D0%B4%D0%B0%D0%B2%D0%B0%D0%B9%D1%82%D0%B5-%D1%80%D0%B0%D0%B7%D0%B1%D0%B5%D1%80%D0%B5%D0%BC%D1%81%D1%8F-.html">отримане мною завдання</a> публікую аналіз таких питань як прикручування БД до проекту Spring Boot, з'єднання БД до контролера, виведення даних з бд в браузер у форматі JSON. <cut>
 <strong>Прикрутимо базу даних</strong> Почну як зазвичай з лірики. 
 <a href="https://codegym.cc/groups/posts/520-vashe-pervoe-prilozhenie-na-hibernate" target="_blank">Hibernate</a>, навіть якщо і використовували проект Spring Data... Spring Boot наділяє вас унікальним препаратом, що позбавляє геморою всього за одне застосування! Що вже тут казати, давайте за справу! Згідно з офіційною документацією, для того щоб додати в проект базу даних (embeded databases - google it!), нам необхідно тільки додати до пам'ятника проекту залежність драйвера відповідної бази даних і технології (у нас data jpa), написати клас-сутність, написати один інтерфейс без реалізації і написати скрипт заповнення бази даних, все інше зробить за нас великий і могутній Spring Boot, у нас буде не вбудована база даних, тому дій буде трохи більше. А тепер за конкретними діями: Створюємо клас сутність, за завданням потрібно працювати з Користувачами, так і створимо - клас User. Відразу зробимо його персистентним - додамо потрібні інструкції. Створюємо директорію domain у тій же папці, де лежить головний клас. Повинно вийти так: 
 <code class=" language-none">└── src └── main └── java └── demo(тут ваше название) └── controller - о нем речь в конце └── domain └── repository - о нем речь дальше └── User - новый класс └── DemoApplication - главный класс └── DemoController - контроллер созданный нами ранее </code> а ось і сам клас 
 <code class=" language-none">package demo.domain; import org.hibernate.validator.constraints.Email; import org.hibernate.validator.constraints.Length; import java.sql.Timestamp; @Entity @Table(name = "users") public class User { @Id @GeneratedValue private long id; @Column(name = "avatar") private String url; @Length(min = 2) private String name; @Column(unique = true) @Email private String email; public long getId() { return id; } public User setId(long id) { this.id = id; return this; } public String getUrl() { return url; } public User setUrl(String url) { this.url = url; return this; } public String getName() { return name; } public User setName(String name) { this.name = name; return this; } } </code> Якщо ви не виявляли самостійність, то більшість анотацій не підвантажаться, для їх використання нам потрібно підтягнути бібліотечки буту, які надаються, ініціалізатором при створенні проекту якщо поставити галочку на JPA, але їх можна додати і руками, на працездатність не вплине. Відкриваємо pom.xml, знаходимо тег 
 <em>&lt;dependencies&gt;...&lt;/dependencies&gt;</em> і вставляємо в нього ще одну залежність 
 <code class=" language-none"> <dependency>
   <groupid>
    org.springframework.boot
   </groupid>
   <artifactid>
    spring-boot-starter-data-jpa
   </artifactid>
  </dependency></code> вставивши ці рядки, оновлюємо залежності або включаємо автоконфігурацію залежностей мавена, після чого можна перейти назад у клас з Користувачем і імпортувати інструкції з javax.persistence. * Отже що ж ми тут навернули?! @Entity - означає що об'єкт цього може бути збережений у базі даних, а сам клас є схемою таблиці, тобто. відповідає структурі таблиці: поля класу – стовпці таблиці. @Table - говорить про те, який саме таблиці у базі даних відповідає цей клас. У нашому випадку назва таблиці не повірите! "users" @Id - це індентифікатор поля, @GeneratedValue - і їжу зрозуміло, що генерується значення, у нашому випадку мається на увазі автоінкремент, але нам не потрібно про це турбуватися і скоро ми дізнаємося чому! @Column - застосовується якщо потрібно додати властивостей стовпцю або якщо ім'я поля класу не відповідає імені стовпця таблиці (наприклад id відповідає, там і ми і не застосовуємо), але можна і застосовувати, за це не налаштовують. @Length і @Email - це анотація валідації, клікніть по них з натиснутим ctrl - провальтеся в сорси, якщо вони не завантажені - скачайте, почитайте, що там написано. Взагалі, вводьте собі за правило постійно лізти у вихідники та читати коментарі авторів коду, дивитися їх код, це вкрай корисно. Спочатку може бути незрозуміло зовсім, але згодом розумітимете все більше, потім взагалі перестанете читати таку лабуду як зараз читаєте - тільки вихідники тільки хардкор! У тестовому проекті потрібно використовувати MySQL, якщо вона у вас не встановлена ​​- як її ставити та основи синтаксису мови MySQL гуглиться без проблем. Взагалі за це не лають. @Length і @Email - це анотація валідації, клікніть по них з натиснутим ctrl - провальтеся в сорси, якщо вони не завантажені - скачайте, почитайте, що там написано. Взагалі, вводьте собі за правило постійно лізти у вихідники та читати коментарі авторів коду, дивитися їх код, це вкрай корисно. Спочатку може бути незрозуміло зовсім, але згодом розумітимете все більше, потім взагалі перестанете читати таку лабуду як зараз читаєте - тільки вихідники тільки хардкор! У тестовому проекті потрібно використовувати MySQL, якщо вона у вас не встановлена ​​- як її ставити та основи синтаксису мови MySQL гуглиться без проблем. Взагалі за це не лають. @Length і @Email - це анотація валідації, клікніть по них з натиснутим ctrl - провальтеся в сорси, якщо вони не завантажені - скачайте, почитайте, що там написано. Взагалі, вводьте собі за правило постійно лізти у вихідники та читати коментарі авторів коду, дивитися їх код, це вкрай корисно. Спочатку може бути незрозуміло зовсім, але згодом розумітимете все більше, потім взагалі перестанете читати таку лабуду як зараз читаєте - тільки вихідники тільки хардкор! У тестовому проекті потрібно використовувати MySQL, якщо вона у вас не встановлена ​​- як її ставити та основи синтаксису мови MySQL гуглиться без проблем. Взагалі вводьте собі за правило постійно лізти у вихідники та читати коментарі авторів коду, дивитися їх код, це вкрай корисно. Спочатку може бути незрозуміло зовсім, але згодом розумітимете все більше, потім взагалі перестанете читати таку лабуду як зараз читаєте - тільки вихідники тільки хардкор! У тестовому проекті потрібно використовувати MySQL, якщо вона у вас не встановлена ​​- як її ставити та основи синтаксису мови MySQL гуглиться без проблем. Взагалі вводьте собі за правило постійно лізти у вихідники та читати коментарі авторів коду, дивитися їх код, це вкрай корисно. Спочатку може бути незрозуміло зовсім, але згодом розумітимете все більше, потім взагалі перестанете читати таку лабуду як зараз читаєте - тільки вихідники тільки хардкор! У тестовому проекті потрібно використовувати MySQL, якщо вона у вас не встановлена ​​- як її ставити та основи синтаксису мови MySQL гуглиться без проблем. Взагалі якщо вона у вас не встановлена ​​- як її ставити та основи синтаксису мови MySQL гуглиться без проблем. Взагалі якщо вона у вас не встановлена ​​- як її ставити та основи синтаксису мови MySQL гуглиться без проблем. Взагалі
 <a href="https://codegym.cc/groups/posts/476-spring-dlja-lenivihkh-osnovih-bazovihe-koncepcii-i-primerih-s-kodom-chastjh-1" target="_blank">Spring</a> працює з PostgreSQL, MySQL, Apache Derbi, H2 або HSQLDB (це на момент написання статті, найшвидше їх буде більше) Включаємо чергову залежність до пам'ятника. Тепер настала черга уроку чарівництва і чарівництва. Створюємо новий паккадж реpository на тому ж рівні, що і domain. У ньому створюємо один єдиний інтерфейс назвемо його DemoRepository ось весь його код тепер створимо скрипт заповнення таблички, він обов'язково повинен називатися data.sql, кладемо його в папку src/mail/resources ну і останній штрих - те, що не потрібно робити, якщо використовуєш вбудовану основу. у файл application.properties вставляємо наступні рядки 
 <code class=" language-none"> <dependency>
   <groupid>
    mysql
   </groupid>
   <artifactid>
    mysql-connector-java
   </artifactid>
  </dependency></code>
 <code class=" language-none">package demo.repository; import demo.domain.User; import org.springframework.data.jpa.repository.JpaRepository; interface DemoRepository extends JpaRepository<user, long="">
   { }
  </user,></code>
 <code class=" language-none">INSERT INTO users (avatar, name, email) VALUES ('/pic/ava1', 'Kris', 'kroskross@gmail.com'), ('/pic/ava2', 'Josh', 'joshlong@gmail.com');</code>
 <code class=" language-none">spring.data.jpa.repositories.enabled=true spring.jpa.generate-ddl=true spring.jpa.hibernate.ddl-auto=create spring.datasource.url=jdbc:mysql://localhost:3306/test spring.datasource.username=root spring.datasource.password=root spring.jpa.show-sql=true </code> і знову маленький нюанс, потрібно, щоб у вас була створена база в MySQL, яка називається test, або вставте в datasource.url назву іншої своєї створеної бази. Отже резюме: щоб прикрутити базу потрібно: 1. мати створену базу (ніяких табличок руками створювати не потрібно!, тільки базу) 2. створити клас-сутність, екземпляри якої зберігатимуться у базу. 3. вставити 2 залежності в пам'ятник 4. створити інтерфейс репозиторію та успадкуватися від одного із стандартних репозиторіїв Spring Data Jpa. 5. Створити скрипт заповнює базу. 6. внести налаштування бази даних в application.properties Складається враження, що виконано просто величезний обсяг роботи, виділабо б ви скільки потрібно писати коду, щоб підключитися через хібернейт! не кажучи вже про jdbc разом із створенням бази даних через консоль mysql 
 <strong>таким чином перевіряємо.</strong> Перезапустивши додаток ми побачимо набагато більше логів ніж до використання баз даних, але головне повинні з'явитися такі рядки: 
 <code class=" language-none">Hibernate: drop table if exists users Hibernate: create table users (id bigint not null auto_increment, email varchar(255), name varchar(255), avatar varchar(255), primary key (id)) Hibernate: alter table users add constraint UK_6dotkott2kjsp8vw4d0m25fb7 unique (email) </code> Так, це спринг Бут створює за нас наші таблиці. Коли я вперше це побачив, я злегка здивувався :) Тепер якщо у вас змінюється доменна модель на етапі проектування - вирішабо ви Користувачеві додати прізвище або підлогу або додати булеан козел він або не козел - потрібно просто додати поле в клас-@Entity і при перезапуску Спринг бут створить вам таблицю з потрібним стовпцем, залишається лише додати відповідне поле в скрипт data.sql 
 <strong>тепер давайте виведемо нарешті в браузер наших користувачів! </strong> створюємо паккадж controller, в ньому клас UserController, а в ньому, як ми вже знаємо, створюємо метод з мапінгом запиту, який буде повертати нам список наших Користувачів. 
 <code class=" language-none">package demo.controller; import demo.domain.User; import demo.repository.DemoRepository; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController; import java.util.List; @RestController @RequestMapping(value = "/users") public class UserController { @Autowired DemoRepository demoRepository; @RequestMapping(method = RequestMethod.GET) public List<user>
   getAll() { return demoRepository.findAll(); } }
  </user></code> Тут нічого нового крім @Autowired, це прив'язка створеного бина репозиторію (якщо не чули про таких, почитайте що таке java beans, потім почитайте як вони використовуються в Spring) до посилання, що використовується в цьому класі. перезапускаємо програму, пробуємо в браузері адресау 
 <blockquote>
  http://localhost:8080/users
 </blockquote> відповідь має бути такою 
 <blockquote>
  [{"id":1,"url":"/pic/ava1","name":"Kris","email":"kroskross@gmail.com"},{"id":2,"url" :"/pic/ava2","name":"Josh","email":"joshlong@gmail.com"}]
 </blockquote> це наші Користувачі у форматі JSON на сьогодні все. Дякую всім п.с. у наступному пості займемося основним функціоналом сервера за завданням
</cut>