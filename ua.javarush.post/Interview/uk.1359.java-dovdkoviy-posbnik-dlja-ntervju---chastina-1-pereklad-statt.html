Java. Довідковий посібник для інтерв'ю - Частина 1. (Переклад статті)
<p>----------------------------------------</p>
Вихідна стаття знаходиться за адресою: Опублікував: Nitin Kumar, в Core Java, 3 лютого 2014 р Java ґрунтується на об'єктно-орієнтованій концепції, яка дає вищий рівень абстракції для вирішення будь-якої проблеми реальним способом. Об'єктно-
<p>----------------------------------------</p>
Вихідна стаття знаходиться за адресаою: <a href="http://www.javacodegeeks.com/2014/02/java-interview-reference-guide-part-1.html" rel="nofollow">http://www.javacodegeeks.com/2014/02/java-interview-reference-guide-part-1.html</a> Опублікував: Nitin Kumar, в Core Java, 3 лютого 2014 р 
<h4>Java. Об'єктно-орієнтована концепція.</h4> Java ґрунтується на об'єктно-орієнтованій концепції, яка дає вищий рівень абстракції для вирішення будь-якої проблеми реальним способом. Об'єктно-орієнтований підхід концептуалізує вирішення проблеми в об'єктах реального світу, які простіше повторно використовувати у додатках. Наприклад: стілець, вентилятор, собака, комп'ютер тощо. У Java клас - це документація, шаблон або прототип, який визначає загальну поведінку об'єктів того ж виду. Примірник є реалізацією певного класу і всі екземпляри класу мають аналогічні властивості, як представлено в описі класу. Наприклад, можна визначити клас, який називається Будинок, з числом кімнат, як атрибутом, і створити об'єкти: будинок з 2 кімнатами, будинок з 3 кімнатами і т.д. 
<h6>Переваги:</h6> Нижче наведено кілька переваг розробки об'єктно-орієнтованого програмного забезпечення: 
<ul>
 <li>Найменше витрат на обслуговування, головним чином завдяки модульності.</li>
 <li>Код легше повторно використовувати за рахунок таких функцій, як успадкування, що прискорює розробку.</li>
 <li>Підвищується надійність та гнучкість коду.</li>
 <li>Код легше зрозуміти, це зумовлено моделюванням реального світу.</li>
 <li>Найкраща абстракція на об'єктному рівні.</li>
 <li>Зменшення складності переходу від однієї стадії розробки до іншої.</li>
</ul>
<h5>Існують чотири основні поняття ОВП:</h5>
<ul>
 <li>Інкапсуляція</li>
 <li>успадкування</li>
 <li>Поліморфізм</li>
 <li>Абстракція</li>
</ul>
<h5>Інкапсуляція:</h5> Інкапсуляція є правилами для інших об'єктів, які вказують, які елементи приховані, а які відкриті для доступу іншим об'єктам. У Java ми використовуємо модифікатор private доступу для того, щоб приховати метод і обмежити доступ до змінної із зовнішнього середовища. Java також передбачає різні модифікатори доступу, такі як public, який встановлюється за замовчуванням, protected і private, які використовуються для обмеження видимості на різних рівнях, але кінцева мета інкапсуляції - приховати ті елементи, які не повинні змінюватися. Насправді найкраще, коли клас має лише одну причину зміни, і інкапсуляція реалізує принципи проектування цієї <strong>" однієї причини "</strong>. На практиці в Інкапсуляції передбачається приховування методів, щоб уникнути порушення роботи інших класів. 
<h6>Переваги:</h6><cut>
 Нижче наведено кілька переваг інкапсуляції: 
 <ul>
  <li>Ви можете захистити внутрішній стан об'єкта, приховуючи його атрибут.</li>
  <li>Це підвищує модульність коду, запобігаючи взаємодії між об'єктами несподіваним чином.</li>
  <li>Збільшується зручність використання.</li>
  <li>Підтримуються умови об'єкта.</li>
  <li>Інкапсуляція полегшує підтримку ПЗ</li>
  <li>Зміни коду можуть бути незалежними</li>
 </ul>
 <h5>Поліморфізм:</h5> Поліморфізм - це здатність (у програмуванні) уявити той самий інтерфейс для різних форм (типів даних), які у основі. Це означає, що класи мають різну функціональність, незважаючи на те, що використовують спільний інтерфейс і можуть бути динамічно викликані через спеціальне посилання класу. Класичним прикладом є клас Shape (фігура) і всі класи, які можуть успадковуватися від нього (квадрат, коло, додекаедр, неправильний багатокутник, знак і т.д.). У цьому прикладі кожен клас буде мати свою власну функцію Draw() і клієнтський код може виконувати наступні дії: 
 <code class=" language-none">Shape shape = new Square(); Shape.area() чтобы получить корректное поведение для любой формы. </code> Принадність поліморфізму в тому, що код працює з різними класами і немає необхідності знати який клас його використовує, т.к. всі вони працюють за одним принципом. Процес, використовуваний Об'єктно-орієнтованими мовами програмування, що реалізує динамічний поліморфізм, називається динамічним зв'язуванням. 
 <strong>Примітка:</strong> Поліморфізм - це можливість вибору спеціалізованих методів залежно від виконання викликаного об'єкта. Поліморфізм також може використовуватися без участі будь-яких абстрактних класів. 
 <h6>Переваги:</h6>
 <ul>
  <li>Створюється код, що використовується повторно: це означає, що якщо одного разу створені класи, реалізовані та протестовані, то вони можуть бути легко використані, не переймаючись тим, що написано в класі.</li>
  <li>Це забезпечує більш загальний та слабопов'язаний код.</li>
  <li>Час компіляції значно зменшується, а технологія стає швидше.</li>
  <li>Динамічний зв'язок: Один і той же інтерфейс може бути використаний для створення методів з різними реалізаціями.</li>
  <li>Повна реалізація може бути замінена за допомогою методу сигнатури.</li>
 </ul>
 <strong>Перевизначення методу для досягнення Поліморфізму:</strong> Перевизначення інтерфейсів із двома методами: Один у батьківському класі, а інший у дочірньому класі з такими ж іменами та сигнатурами. Перевизначення дозволяє визначити ту саму операцію по-різному для різних типів даних Наприклад: 
 <code class=" language-none">while(it.hasNext()) { Shape s = (Shape) it.next(); totalArea += s.area(dim); //полиморфический вызов метода. Будет вызван правильный об'єкт. } </code>
 <img data-max-width="162" alt="Java.  Довідковий посібник для інтерв'ю - Частина 1. (Переклад статті) - 1" src="https://cdn.javarush.com/images/article/a9c4239a-ed0d-4dd0-935b-be8f731aac56/original.jpeg">
 <h5>Перевантаження методу або спеціальний поліморфізм або статичний поліморфізм:</h5> Перевантаження інтерфейсів з кількома методами в тому ж класі з тим самим ім'ям, але з іншим тілом методу. Перевантаження методу дозволяє визначити ту саму операцію по-різному різних даних. Якийсь час вона називалася статичним поліморфізмом, але насправді це поліморфізм. Перевантаження методів не більше ніж двома методами, з однаковими іменами, але різними списками аргументів. Вона не має нічого спільного з успадкуванням та поліморфізмом. Перевантажений метод, це те саме, як і перевизначений метод. [Глава перша Java] 
 <h5>Параметричний поліморфізм з використанням дженериків у Java:</h5> При оголошенні класу, ім'я поля можна пов'язати з різними типами і ім'я методу так само можна асоціювати з різними параметрами та типами, що повертаються. Java підтримує параметричний поліморфізм із використанням дженериків. Прикладом є список, який може приймати тип даних, що містять дженеріки. 
 <code class=" language-none">List<string>
   list = new ArrayList
   <string>
    ();
   </string>
  </string></code>
 <h5>Чому ми не можемо перевизначити статичний метод Java?</h5> Перевизначення залежить від наявності екземпляра класу. Сенс поліморфізму полягає в тому, що ви можете створити підклас класу і об'єкт реалізує цей підклас, буде різна поведінка тих самих методів, визначених у суперкласі (або перевизначених у підкласі). Статичний метод не пов'язані з будь-яким екземпляром класу, отже це поняття щодо нього не застосовується. Раніше висувалися дві основні ідеї, просування розробки Java, які вплинули на неї. Одна з них - це ставлення до продуктивності: було багато критики з боку Smalltalk про те, що JVM працювала надто повільно (через збирання сміття та поліморфних викликів, які були частиною цієї причини) та розробники Java були змушені виправити це. Інша полягала в тому, що цільова аудиторія для Java – це були розробники C++. Виклик статичних методів влаштований знайомим для програмістів C++ чином і працює так само швидко, тому що немає шляху вгору по ієрархії класів, і щоб з'ясувати, який метод потрібно викликати, ти вирушаєш прямо в клас і викликаєш вказаний метод. [Stack overflow] 
 <h5>Спадкування:</h5> Воно включає поведінки (тобто методи) та стану (тобто змінні) базового класу в похідний клас, таким чином, щоб вони були доступні в цьому похідному класі. Ключова перевага успадкування полягає в тому, що воно забезпечує формальний механізм повторного використання коду та дозволяє уникнути дублювання. Успадкований клас розширює функціональність програми, повторно використовуючи батьківську поведінку та додаючи нову функціональність. Це зробить проектування щільно пов'язаним, тому що якщо ви хочете змінити суперклас, ви повинні знати всі деталі підкласів, щоб уникнути поломки програми. Це форма повторного використання, коли новий клас (підклас) створюється з вже існуючого класу (суперкласу) і розширює свою функціональність, при цьому використовуючи деякі властивості суперкласу. Отже, 
 <h6>Переваги:</h6>
 <ul>
  <li>Легше повторно використовувати код</li>
  <li>Встановлюється логічне відношення "Є кимось", наприклад: Собака є твариною.</li>
  <li>Код стає модульним</li>
  <li>Дозволяє уникати дублювання</li>
 </ul>
 <h6>Недоліки:</h6>
 <ul>
  <li><strong>Тісний зв'язок:</strong> підклас залежить від батьківського класу, що робить код тісно пов'язаним.</li>
 </ul>
 <h5>Абстракція:</h5> Абстракція є розробкою класу з умов інтерфейсів та їх функціональності, не враховуючи деталі їх реалізації. Анотація клас включає інтерфейси без фактичної реалізації. Він відокремлює реалізацію об'єкта від поведінки чи реалізації. Абстракція полегшує розробку, приховуючи несуттєві деталі. 
 <h6>Переваги:</h6>
 <ul>
  <li>При використанні абстракції ми можемо виділити об'єкти, які можуть бути згруповані в інший тип.</li>
  <li>Часто зміни властивостей чи методів можуть бути згруповані окремий тип, причому головний тип залишиться без змін. Це посилює принцип Об'єктно-орієнтованого аналізу та дизайну - "Код повинен бути відкритий для розширення, але закритий для модифікації".</li>
  <li>Спрощує представлення моделей предметної галузі.</li>
 </ul>
 <h5>Відмінності між абстракцією та інкапсуляцією</h5> Інкапсуляція – це стратегія, яка використовується в рамках абстракції. Інкапсуляція відноситься до стану об'єктів - об'єкти інкапсулюють свій стан та приховують його від доступу ззовні; Зовні користувачі класу можуть взаємодіяти з його методами, але не можуть отримати доступ до складових класу безпосередньо. Таким чином, клас абстрагує деталі реалізації, що відносяться до його стану. Абстракція – це загальніший термін; її так само можна досягти шляхом використання підкласів (серед інших). Наприклад, список класів у стандартній бібліотеці - це абстракція для послідовності елементів, проіндексованих за їхньою позицією, конкретними прикладами List'а будуть ArrayList або LinkedList. Код, який взаємодіє зі списком абстракцій більш детальний, ніж вид списку. [Stack overflow] Абстракція часто неможлива, 
 <h5>Що таке абстрактний клас та абстрактний метод?</h5> У проектуванні ви хочете, щоб базовий клас представляв лише інтерфейс для своїх похідних класів. Це означає, що ви не хочете, щоб хтось створював екземпляр об'єкта цього класу. Ви тільки хочете, щоб було приведення до типу (неявне приведення до базового типу, що дає вам поліморфну ​​поведінку), тому цей інтерфейс може бути використаний. Це досягається шляхом вказівки класу абстрактним, у своїй використовується ключове слово abstract. Існують деякі обмеження: не можна створити екземпляр абстрактного класу, слід використовувати лише клас, який реалізує абстрактні методи. І забезпечує поліморфізм. Абстрактний клас може містити як абстрактні методи, і конкретні методи. У класі, якщо один метод оголошений абстрактним, клас має бути оголошено абстрактним. Однак, зворотне не завжди вірне. Якщо клас оголошений як абстрактний, він може мати абстрактних методів у ньому. Якщо метод не забезпечує фактичної реалізації, але забезпечує сигнатуру методу, він називається абстрактним методом. Фактична реалізація доручається підкласи, які розширюють абстрактний клас. Абстрактний метод може бути реалізований; тільки інший клас може успадковуватись від нього. 
 <h5>Коли використається абстрактний клас?</h5> Абстрактні класи допомагають визначити деякі типи поведінки за умовчанням та забезпечити підкласам якусь конкретну поведінку. Наприклад: List - це інтерфейс, у той час як AbstractList реалізує поведінку за умовчанням List'а, який може бути використаний як є або може бути реалізований у підкласі, наприклад ArrayList. 
 <h5>Що таке інтерфейс?</h5> Ключове слово interface переймає концепцію абстрактного класу далі, перешкоджаючи реалізації будь-якого методу чи функції всім. Ви можете лише оголосити метод чи функцію, але не забезпечити реалізацію. Клас, який реалізує інтерфейс, має забезпечувати фактичну реалізацію. Інтерфейс є вкрай ефективним і широко використовується аспектом в Об'єктно-орієнтованому проектуванні, так як він забезпечує 
 <strong>поділ інтерфейсу та реалізації, і дозволяє:</strong>
 <h6>Переваги інтерфейсів:</h6>
 <ul>
  <li>Множинне успадкування</li>
  <li>Вільні парно-визначені абстракції операцій, як окремий тип реалізації, можуть бути будь-чим: JDBC, JPA, JTA, і т.д.</li>
  <li>Інтерфейс програми не реалізується.</li>
  <li>Поліморфізм з динамічним зв'язуванням виявляє об'єкт програмного інтерфейсу, не розкриваючи його фактичної реалізації.</li>
  <li>Абстрактний рівень: Проблеми поділу</li>
 </ul>
 <h6>Різниця між інтерфейсом та абстрактним класом:</h6>
 <ul>
  <li>Інтерфейс є угоду, яким опитуються класи, реалізують інтерфейс, як вони визначають цей интерфейс. Це порожня оболонка із оголошенням методу.</li>
  <li>Абстрактний клас визначає деяке загальне поведінка і задає підкласу властивість визначити рідкісне чи специфічне поведінка цього класу.</li>
  <li>Методи та члени абстрактного класу можуть бути визначені з будь-яким типом видимості, у той час як усі методи інтерфейсів мають бути визначені як public.</li>
  <li>При успадкування від абстрактного класу, дочірній клас повинен визначити абстрактні методи, в той час як інтерфейс може розширювати інший інтерфейс і методи не повинні бути визначені.</li>
  <li>Дочірній клас може успадковуватись тільки від одного абстрактного (або будь-якого іншого) класу, у той час як інтерфейс або клас може успадковуватися від кількох інших інтерфейсів.</li>
  <li>Дочірній клас може реалізувати абстрактні методи з тим самим менш обмеженим рівнем видимості, в той час як клас, що реалізує інтерфейс повинен визначити методи з тим же рівнем видимості.</li>
  <li>Інтерфейс неспроможна містити конструктори, на відміну Абстрактного класу.</li>
  <li>Змінні, оголошені в інтерфейсі Java за промовчанням, мають модифікатор доступу final. Анотація клас може містити змінні не тільки з модифікатором final.</li>
  <li>Методи інтерфейсу Java мають модифікатор доступу public за замовчуванням. Абстрактний клас Java може мати звичайні модифікатори доступу, такі як private, protected і т.д.</li>
 </ul>
 <h5>Композиція:</h5> Можливість багаторазового використання коду може бути досягнута завдяки реалізації успадкування або композиції, але композиційний підхід до повторного використання коду забезпечує більш сильну інкапсуляцію, ніж успадкування, тому що зміна класу back-end не повинна зруйнувати код, який покладається тільки на front-end клас. Композиція - це методика проектування реалізації існуючих зв'язків у класах. Ми можемо використовувати успадкування Java або композицію для повторного використання коду. Композиція висловлює зв'язок між об'єктами. Наприклад, уявіть стілець. Стілець має сидіння. Стілець має спинку. І має набір ніжок. Фраза "має" має на увазі відносини, де стілець володіє чимось, або як мінімум, він використовує інший предмет. Саме такі відносини виду "Має" 
 <h6>Переваги:</h6>
 <div class="table-container">
  <table>
   <tbody>
    <tr>
     <th>№</th>
     <th>Композиція (мати)</th>
     <th>Спадкування (є)</th>
    </tr>
    <tr>
     <td>1</td>
     <td>Підтримує поліморфізм та повторне використання коду</td>
     <td>Підтримує поліморфізм та повторне використання коду</td>
    </tr>
    <tr>
     <td>2</td>
     <td>Об'єкт створюється під час роботи</td>
     <td>Об'єкт створюється динамічно під час компіляції</td>
    </tr>
    <tr>
     <td>3</td>
     <td>Реалізація може бути змінена під час виконання</td>
     <td>Реалізація може бути змінена під час виконання</td>
    </tr>
    <tr>
     <td>4</td>
     <td>Підклас залежить від батьківського класу, що сприяє ослабленню зв'язків (зокрема, в інтерфейсі управління)</td>
     <td>Підклас залежить від реалізації батьківського класу, тому вони тісно пов'язані</td>
    </tr>
    <tr>
     <td>5</td>
     <td>Використовується, наприклад, коли у Будинку є Ванна. Некоректно говорити, що Будинок – це Ванна.</td>
     <td>Спадкування є односпрямованим. Наприклад: Будинок це Будівля. Але Будівля не обов'язково є Будинком.</td>
    </tr>
   </tbody>
  </table>
 </div>
 <strong>Примітка:</strong> Не використовуйте успадкування лише для того, щоб отримати можливість повторно використовувати код. Якщо немає відношення типу "з'являтися" між класами, потрібно використовувати композиція для повторного використання коду. 
 <h5>Відмінності між Композицією та Агрегацією у відносинах об'єктів</h5>
 <strong>Агрегація:</strong> Агрегація є об'єднанням, в якому один клас належить колекції. Він є частиною цілого у відносинах, де частина може існувати без цілого. Це слабкі стосунки. Немає циклічної залежності. Наприклад: замовлення та продукт. 
 <strong>Композиція:</strong> Композиція є об'єднанням, у якому один клас належить колекції. Він є частиною цілого, де частина може існувати без цілого. Якщо в ціле видаляється, то всі частини будуть так само видалені. Ці відносини сильніші. Прикладом можуть бути: Полігон і точки, замовлення та порядок замовлення. 
 <h6>Посилання:</h6>
 <ul>
  <li><a href="http://stackoverflow.com/" rel="nofollow">http://stackoverflow.com/</a></li>
  <li><a href="http://en.wikipedia.org/" rel="nofollow">http://en.wikipedia.org/</a></li>
  <li>Effective Java™</li>
 </ul>
</cut>