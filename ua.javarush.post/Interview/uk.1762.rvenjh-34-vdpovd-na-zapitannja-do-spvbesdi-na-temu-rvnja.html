Рівень 34. Відповіді на запитання до співбесіди на тему рівня
<p>----------------------------------------</p>
Пошукав на сайті рідним пошуком і за допомогою гугла все облазив - немає відповідей на запитання з цього левела. Може я щось пропустив, і вони таки десь є тут на сайті!? Про всяк випадок прикладаю відповіді, які я написав для себе:
<p>----------------------------------------</p>
Пошукав на сайті рідним пошуком і за допомогою гугла все облазив - немає відповідей на запитання з цього левела. Може я щось пропустив, і вони таки десь є тут на сайті!? <img data-id="af3ca0ba-0322-4440-ae01-2fb9c31740d0" data-max-width="850" alt="Рівень 34. Відповіді на запитання до співбесіди на тему рівня - 1" src="https://cdn.javarush.com/images/article/af3ca0ba-0322-4440-ae01-2fb9c31740d0/800.jpeg" style="width: 850px;">Про всяк випадок прикладаю відповіді, які я написав для себе: <strong>Запитання до співбесіди:</strong>
<ol>
 <li>Що таке збирання сміття?</li>
 <li>Коли викликається метод <code class=" language-none">finalize</code>?</li>
 <li>Що станеться, якщо у методі <code class=" language-none">finalize</code>виникне виняток?</li>
 <li>Що таке <code class=" language-none">SoftReference</code>?</li>
 <li>Що таке <code class=" language-none">WeakReference</code>?</li>
 <li>Що таке <code class=" language-none">PhantomReference</code>?</li>
 <li>Як працює <code class=" language-none">WeakHashMap</code>? Де використовується?</li>
 <li>Навіщо треба передавати чергу до конструктора <code class=" language-none">PhantomReference</code>?</li>
 <li>Навіщо потрібний логер?</li>
 <li>Які налаштування логера ви знаєте?</li>
</ol><strong>Мої відповіді:</strong>
<ol>
 <li>
  <p>Це механізм винищення непотрібних об'єктів. Непотрібні об'єкти — це об'єкти, які не використовуються. Існує два способи пошуку таких об'єктів: підрахунок посилань та трасування. У першому випадку з кожним об'єктом пов'язується деяка змінна, яка зберігає кількість посилань на цей об'єкт. Якщо кількість опускається до нуля, то об'єкт вважається мертвим. У другому випадку збирач сміття йде за посиланнями об'єктів з кореневих точок до кінця (до значення нул), обминаючи все це дерево. Об'єкти, яких він не може дістатися з кореневих точок, вважаюся мертвими. Кореневими точками вважаються всі активні нитки, метод main, аргументи методу <code class=" language-none">main()</code>, а також усі статичні змінні класу, в якій знаходиться метод <code class=" language-none">main()</code>.</p>
  <p>Визначення об'єктів, придатних до знищення – це перша частина роботи збирача сміття. Друга частина - це власне їхнє видалення та робота з пам'яттю. Тут використовується гібридний підхід. Вся доступна для об'єктів пам'ять поділяється на три області: область молодих об'єктів, область старих об'єктів і область перманентних об'єктів (це класи, метадані, рядки інтерновані і т.д.). Перша область розділяється ще на три підобласті: на Eden та suvivor space 1 і 2. У Eden зберігаються всі створені об'єкти. В решті двох зон зберігаються об'єкти, що вижабо після останнього складання сміття. Складальник сміття працює з усією цією областю (областю молодих об'єктів) в такий спосіб. Під час чергового складання сміття він знаходить живі об'єкти в області Eden і копіює їх у другу область тих, хто вижив. Після цього він у першій області також шукає живі об'єкти і копіює їх або в другу область тих, хто вижив, або якщо вони вже досить "старі" - область старого покоління. Після цього він очищає область Eden і першу область тих, хто вижив. Далі він вважає другу область тих, що вижабо першою. І все, на це складання сміття закінчується для цієї галузі.</p>
  <p>Для другої області складання сміття йде дещо по-іншому. Там є одна велика область, вона ні на що не ділиться, але збирач сміття усі живі об'єкти в ній під час своєї роботи переміщує на початок області. Відповідно, друга частина області складатиметься лише з порожнього простору та мертвих об'єктів. Після цього збирач сміття завершує свою роботу.</p></li>
 <li>
  <p>Перед знищенням об'єкта збирачем сміття. Також можна вручну запустити дзвінки цього методу у всіх недосяжних об'єктів, для цього потрібно викликати метод <code class=" language-none">System.runFinalization()</code>або <code class=" language-none">Runtime.getRuntime().runFinalization()</code>.</p></li>
 <li>
  <p>Цей виняток буде проігноровано, і відбудеться вихід із методу.</p></li>
 <li>
  <p><code class=" language-none">SoftReference</code>перекладається як "м'яке посилання". Це посилання на об'єкт, але слабкіше, ніж звичайне посилання (StrongReference). Об'єкти, на які існують тільки м'які посилання, називаються м'якодосяжними. Такі об'єкти не знищуються у звичному випадку. Але якщо у JVM закочувалася пам'ять, то збирач сміття видаляє всі такі об'єкти.</p></li>
 <li>
  <p><code class=" language-none">WeakReference</code>- Це так зване слабке посилання на об'єкт. Вона ще слабша за Soft-посилання. Усі об'єкти, на які існують лише слабкі посилання, будуть видалені під час найближчого складання сміття.</p></li>
 <li>
  <p><code class=" language-none">PhantomReference</code>- Це найслабше посилання. Механізм роботи з такими посиланням запускається тільки якщо на об'єкт немає більше жодних інших посилань. Примарні посилання використовують для складної процедури видалення об'єкта. Це може бути необхідно, якщо об'єкт робить що за межі Java-машини, наприклад, викликає низькорівневі функції ОС або пише свій стан у файл, або робить ще щось важливе і складне.</p>
  <p>Механізм роботи з такими посиланнями є наступним. Якщо на об'єкт не залишилося більше жодних інших посилань, і у нього перевизначено методу <code class=" language-none">finalize()</code>, то цей метод буде викликаний під час найближчого складання сміття. Якщо цей метод не перевизначено, цей об'єкт пропускає поточну збірку сміття, і потрапляє лише у наступну. Під час цього (наступного) складання сміття даний об'єкт поміщається в чергу примарних об'єктів, з якої буде видалено, коли його примарне посилання викличе метод <code class=" language-none">clear()</code>. Також варто зазначити, що метод <code class=" language-none">get()</code>у примарної посилання завжди повертає null (на відміну від двох інших несильних посилань, у яких він повертає <code class=" language-none">null</code>, тільки якщо об'єкт вже знищений).</p></li>
 <li>
  <p><code class=" language-none">WeakHashMap</code>- Це <code class=" language-none">HashMap</code>, у якого ключами є слабкі посилання. Тому, якщо під час найближчого складання сміття буде виявлено, що на об'єкт існує тільки посилання в <code class=" language-none">WeakHashMap</code>, то <code class=" language-none">WeakHashMap</code>буде видалена вся пара "ключ-значення", пов'язана з цим об'єктом.</p>
  <p>У зв'язку з цим колекція може бути використана для зберігання якоїсь додаткової, не дуже важливої ​​інформації про об'єкт. Також її зручно використовуватиметься для зберігання якоїсь тимчасової інформації (яка потрібна лише рамках цієї операції).</p></li>
 <li>
  <p>Ця черга використовується для відстеження того, що об'єкт більше не потрібний. Може бути використане для закриття ресурсів, відкритих даним об'єктом (наприклад, видалення створених файлів).</p></li>
 <li>
  <p>Логгер необхідний збереження інформації про поведінку програми, і навіть її станах. Може бути використаний для налагодження та виявлення помилок у роботі програми та збоїв. Також логгер дозволяє розробнику отримувати зворотний зв'язок від своєї програми під час її роботи. Крім того, при критичних збоях логер може оперативно сповіщати потрібних людей (наприклад, розробників, клієнтів, менеджерів проектів, службу техпідтримки тощо) про ці збої.</p></li>
 <li>
  <p>При налаштуванні логгрування можна вказати такі речі:</p>
  <ul style="list-style-type:lower-alpha">
   <li>місце, куди писатиметься інформація (файл, консоль, база даних, мережа тощо)</li>
   <li>повідомлення якого рівня записуватимуться</li>
   <li>вид записів у лозі</li>
   <li>для файлів можна вказати: шлях до файлу та каталогу, розмір файлів, кількість файлів</li>
   <li>вказати для кожного окремого пакета свій рівень повідомлень, які будуть писатись у лог</li>
  </ul></li>
</ol>