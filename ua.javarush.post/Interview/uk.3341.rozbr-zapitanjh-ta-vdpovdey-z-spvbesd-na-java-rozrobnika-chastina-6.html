Розбір запитань та відповідей із співбесід на Java-розробника. Частина 6
<p>----------------------------------------</p>
Hello, World! Не переставати розвиватись дуже важливо для будь-якого розробника. Адже якщо зупинитися, є ризик стати незатребуваним і зовсім вилетіти з ринку: IT світ постійно розвивається та рухається вперед, і треба рухатися разом із ним.
<p>----------------------------------------</p>
Hello, World! Не переставати розвиватись дуже важливо для будь-якого розробника. Адже якщо зупинитися, є ризик стати незатребуваним і зовсім вилетіти з ринку: IT світ постійно розвивається та рухається вперед, і треба рухатися разом із ним. Але і при цьому не можна тільки зациклюватися тільки на нових і свіжих технологіях, щоб не забувати, так би мовити, про класику (класичні теми). Сьогодні я хочу продовжити свій розбір питань по “класичним” темам для Java-розробника. <img data-max-width="800" data-id="587d4a1b-d8c9-4d26-b6a3-4ef3f0399f3a" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 6 - 1" src="https://cdn.javarush.com/images/article/587d4a1b-d8c9-4d26-b6a3-4ef3f0399f3a/800.jpeg" style="width: 800px;">Зазначу, що мої відповіді не є останньою інстанцією — це лише те, як я бачу правильні відповіді на ці запитання, і з чимось ви можете бути не згодні. Це буде цілком нормально, тому не соромтеся ділитися своєю думкою в коментарях. Посилання на частини розбору – наприкінці статті.<img data-max-width="512" data-id="cab15092-c31a-490f-99de-f79b11fef12b" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 6 - 2" src="https://cdn.javarush.com/images/article/cab15092-c31a-490f-99de-f79b11fef12b/512.jpeg" style="width: 512px;">
<h3>Бібліотеки та стандарти</h3>
<h4>52. Що таке Hibernate? У чому різниця між JPA та Hibernate?</h4>Я думаю, щоб відповісти на це питання, нам спочатку потрібно зрозуміти, що таке <a href="https://codegym.cc/groups/posts/2259-jpa--znakomstvo-s-tekhnologiey" target="_blank">JPA</a> . <span class="text-bold">JPA</span> - це специфікація, що описує об'єктно-реляційне відображення простих Java об'єктів і надає API для збереження, отримання та керування такими об'єктами. Тобто, як ми пам'ятаємо, реляційні <a href="https://codegym.cc/groups/posts/2946-java-proekt-ot-a-do-ja-razbiraem-bazih-dannihkh-i-jazihk-sql" target="_blank">бази даних</a> (БД) представлені як безліч пов'язаних між собою таблиць. І <span class="text-bold">JPA</span> є загальноприйнятим стандартом, який описує, як об'єкти можуть взаємодіяти з реляційними базами даних. Як бачите, <span class="text-bold">JPA</span> - це щось абстрактне і невловиме. Це як би сама ідея, підхід. <img data-max-width="512" data-id="117c78f8-e2bf-4226-8f34-6c2d62a6ac89" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 6 - 3" src="https://cdn.javarush.com/images/article/117c78f8-e2bf-4226-8f34-6c2d62a6ac89/512.jpeg" style="width: 512px;">У той же час, <span class="text-bold"><a href="https://codegym.cc/groups/posts/hibernate-java" target="_blank">Hibernate</a></span> — це конкретна бібліотека, що реалізує парадигми <span class="text-bold">JPA.</span>. Тобто за допомогою цієї бібліотеки ви можете працювати з реляційною базою даних через об'єкти, які представляють дані з БД (Entity). Як кажуть, ця бібліотека дуже близька до ідеалів <span class="text-bold">JPA</span> і можливо, тому вона стала популярною. А як ви розумієте, популярність використання — добрий аргумент для подальшої розробки та покращень. До того ж, за частим використанням стоїть величезне ком'юніті, яке розібрало вже всі можливі та неможливі питання, пов'язані з цим інструментом. Ось <a href="https://codegym.cc/groups/posts/498-hibernate-dlja-chaynikov-obzor-knigi-java-persistence-api-i-hibernate" target="_blank">приклад книги</a> , яка докладно розбирає всі темні закутки цієї технології. Тобто Hibernate максимально вивчений і, виходить, надійний. Власне, не дарма навіть ідеальна реалізація JPA з боку Spring-а під капотом зазвичай використовує Hibernate.
<h4>53. Що таке каскадність? Як вона використовується у Hibernate?</h4>Як я і сказав раніше, Hibernate взаємодія ведеться через об'єкти даних, звані <span class="text-bold">entity</span> . Ці entity представляють якісь конкретні таблиці в базі даних, і як ви пам'ятаєте, Java класи можуть містити посилання на інші класи. Ці відносини відбиваються і базі даних. У БД, як правило, це зовнішні ключі (для OneToOne, OneToMany, ManyToOne), або проміжні таблиці (для ManyToMany) Детальніше про взаємозв'язок між сутностями можна почитати в цій <a href="https://codegym.cc/groups/posts/1982-jpa-entities--db-relationships" target="_blank">статті</a> . Коли у вашому entity є посилання інші зв'язані сутності, над цими посиланнями ставляться інструкції для вказівки типу зв'язку: @OneToOne, @OneToMany, @ManyToOne, @ManyToMane, у параметрах ви можете вказати значення властивості — cascade — тип каскаданості для цієї <span class="text-bold">связи</span> . У<span class="text-bold">JPA</span> є специфічні методи взаємодії з сутностями (persist, save, merge…). Каскадні типи використовуються для того, щоб показати, як повинні поводитися пов'язані дані при використанні цих методів на цільову сутність. Отже, які ж є стратегії каскаскадності (типи каскадності)? Стандарт JPA передбачає використання шести видів каскадності:
<ul>
 <li>
  <p><span class="text-bold">PERSIST</span> — операції збереження відбуватимуться каскадно (для методів <span class="code">save()</span> та <span class="code">persist()</span> ). Тобто якщо ми зберігаємо сутність, пов'язану з іншими сутностями, вони також зберігаються в БД (якщо їх ще там немає)</p>
  <p></p></li>
 <li>
  <p><span class="text-bold">MERGE</span> — операції оновлення відбуватимуться каскадно (для методу <span class="code">merge()</span> )</p></li>
 <li>
  <p><span class="text-bold">REMOVE</span> - операції видалення відбуваються каскадно (метод <span class="code">remove()</span> )</p></li>
 <li>
  <p><span class="text-bold">ALL</span> - містить відразу три каскадні операції - <span class="text-bold">PERSIST</span> - <span class="text-bold">MERGE</span> - <span class="text-bold">REMOVE</span></p></li>
</ul>У <span class="text-bold">JPA</span> є поняття персистентна ( <em>persistence</em> ) сутність - сутність, пов'язана з її даними в БД, яка керується поточною сесією (сполукою). Якщо її змінити, але при цьому не зберегти зміни до БД, все одно її дані у БД будуть змінені.
<ul>
 <li>
  <p><span class="text-bold">DETACH</span> - пов'язані сутності не керуватимуться сесією (метод <span class="code">detach()</span> ). Тобто, при їх зміні не буде автоматичної зміни їх даних у БД - вони переводяться зі стану persistence в detached (сутність, не керована JPA)</p></li>
 <li>
  <p><span class="text-bold">REFRESH</span> - при кожному оновленні сутності даними з БД ( <span class="code">refresh()</span> - оновлює detached об'єкти) пов'язані сутності оновлюються так само. Наприклад, ви змінабо дані, взяті з БД, і хочете повернути їх початкові значення. У такому разі вам і знадобиться ця операція.</p></li>
</ul><img data-max-width="512" data-id="f9f3623d-4c86-4cbd-a22d-44cd1d5e2c9e" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 6 - 4" src="https://cdn.javarush.com/images/article/f9f3623d-4c86-4cbd-a22d-44cd1d5e2c9e/512.jpeg" style="width: 512px;">Hibernate підтримує всі ці стандартні каскадні операції, але також привносить три свої:
<ul>
 <li>
  <p><span class="text-bold">REPLICATE</span> — використовується, коли ми маємо більше одного джерела даних і ми хочемо, щоб дані синхронізувалися (метод Hibernate — replicate). У всіх сутностей повинні бути ідентифікатори (id), щоб не було проблем з їх генерацією (щоб для різних БД одна й та сама сутність не мала різних id)</p></li>
 <li>
  <p><span class="text-bold">SAVE_UPDATE</span> — каскадне збереження/видалення (для Hibernate — <span class="text-bold">saveOrUpdate</span> )</p></li>
 <li>
  <p><span class="text-bold">LOCK</span> - операція, зворотна до <span class="text-bold">DETACHED</span> : переводить <span class="text-bold">detached</span> сутність назад у стан <span class="text-bold">persistence</span> , тобто. entity стане знову відстежуваною поточною сесією</p></li>
</ul>Якщо не вибрано тип каскадування, жодна операція з сутністю не матиме ефекту для пов'язаних з нею інших entity.
<h4>54. Чи може Entity клас бути абстрактним?</h4>У <a href="https://download.oracle.com/otn-pub/jcp/persistence-2_1-fr-eval-spec/JavaPersistence.pdf?AuthParam=1619340265_e6d5555a1d0e8eee38710c27caed21c0" rel="nofollow" target="_blank">специфікації JPA</a> у пункті <span class="text-bold">2.1 The Entity Class</span> є рядок: " <em>І абстрактні, і конкретні класи можуть бути сутностями</em> ". Тобто відповідь — так, абстрактний клас може бути сутністю і може бути анотований за допомогою @Entity.
<h4>55. Що таке entity manager? За що він відповідає?</h4>В першу чергу хотілося б відзначити, що <span class="text-bold">EntityManager</span> - один із ключових компонентів <span class="text-bold">JPA</span> , який використовується для взаємодії сутностей із базою даних. Загалом методи взаємодії сутності з БД у нього і викликаються (persist, merge, remove, detach) ... Але також зазначу, що даний компонент як правило не є одним на все додаток: найчастіше він легковажний, часто видаляється і створюється новий за допомогою <span class="text-bold">EntityManagerFactory</span> . Якщо проводити паралель з <span class="text-bold">JDBC</span> , де <span class="text-bold">EntityManagerFactory</span> буде аналогом <span class="text-bold">DataSource</span> , то <span class="text-bold">EntityManager</span> у свою чергу буде аналогом <span class="text-bold">Connection</span>. Раніше я згадував про персистентну ( <em>persistence</em> ) сутність, як сутність, яка керується поточною сполукою. Так ось: ця сутність управляється саме <span class="text-bold">EntityManager</span> -ом, який тісно пов'язаний з поточним з'єднанням та <span class="text-bold">TransactionManager</span> -ом, який відповідає за відкриття/закриття транзакцій. Далі на малюнку нижче ви можете бачити життєвий цикл сутності:<img data-max-width="800" data-id="fe81f8a3-ff85-4b22-986e-1ca664052373" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 6 - 5" src="https://cdn.javarush.com/images/article/fe81f8a3-ff85-4b22-986e-1ca664052373/800.jpeg" style="width: 800px;">EntityManager управляє сутністю, коли вона на етапі Managed (у цей час вона персистентна, тому що має зв'язок з EntityManager-ом). Тобто вона вже не new і ще не removed. Можна сміливо сказати, що коли сутність new чи removed, вона також і detached, т.к. вона не управляється EntityManager-ом. Існують різні стратегії для EntityManager-а. Тобто, може бути один синглтоновий EntityManager на всю програму, а може створюватися щоразу новий, під кожне з'єднання. Якщо ж ви використовуєте Spring, то управління створенням/видаленням EntityManager-а відбувається автоматично під капотом (але це не означає, що не можна налаштувати це під себе). Варто зазначити, що один або кілька членівадміністраторів і утворюють і <em>послідовність контексту</em> . <span class="text-bold">Persistence context</span>— це середовище, в якому екземпляри сутностей синхронізуються з аналогічними сутностями в базі даних (як я й казав, це працює тільки для персистентних сутностей). Якщо ви заглибитеся у вивчення <span class="text-bold">JPA</span> (що я дуже вам рекомендую), то з цим поняттям ви стикатиметеся дуже і дуже часто.
<h4>56. Що таке клас Assert? Для чого його використовувати?</h4>У <span class="text-bold">JPA</span> я про такий клас не чув, тому припускаю, що тут мається на увазі клас <span class="text-bold"><a href="https://codegym.cc/groups/posts/605-junit" target="_blank">JUnit</a></span> бібліотеки, яка використовується для модульного тестування коду. Клас цієї бібліотеки, <span class="code">Assert</span> , використовується для перевірки результатів виконання коду ( <span class="text-bold">assert</span> — твердження, що в певному місці у вас певний стан/дані). Наприклад, ви тестуєте метод, який має створювати кота. Ви запускаєте метод та отримуєте деякий результат: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">Cat</span> resultOfTest <span class="token operator">=</span> <span class="token function">createCat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Але вам потрібно переконатися, що він був правильно створений, чи не так? Тому ви до цього створабо деякого кота — <span class="code">expectedCat</span> — вручну з такими параметрами, які ви очікуєте від кота, отриманого з методу <span class="code">createCat()</span> . Далі ви використовуєте клас <span class="code">Assert</span> для звірки отриманих результатів: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span>resultOfTest<span class="token punctuation">,</span> expectedCat<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Якщо коти будуть відрізнятися, буде викинуто виняток <span class="text-bold">AssertionError</span> , яке говорить нам про те, що очікувані результати не сходяться. У класу <span class="code">Assert</span> є безліч різних методів, які покривають безліч завдань із перевірки очікуваних результатів. Ось деякі з них:
<ul>
 <li>
  <p><span class="code">assertTrue(&lt;boolean&gt;)</span> — очікуване значення, отримане як аргумент, має бути <span class="text-bold">true</span></p>
  <p></p></li>
 <li>
  <p><span class="code">assertFalse(&lt;boolean&gt;)</span> — очікуване значення, отримане як аргумент, має бути <span class="text-bold">false</span></p></li>
 <li>
  <p><span class="code">assertNotEquals(&lt;object1&gt;, &lt;object2&gt;)</span> — об'єкти, отримані як аргументи, при порівнянні за допомогою equals повинні бути різними ( <span class="text-bold">false</span> )</p></li>
 <li>
  <p><span class="code">assertThrows(&lt;ClassNameOfException&gt;.class, &lt;exceptionObject&gt;)</span> — очікується, що другим аргументом буде виняток класу, прописаного першим аргументом (тобто, як правило, на місці другого аргументу викликається метод, який повинен кидати виняток потрібного типу)</p></li>
</ul>
<h3>String</h3>
<h4>57. Дайте характеристику String у Java</h4><span class="code">String</span> - стандартний клас Java, що відповідає за зберігання і маніпуляції з рядковими значеннями (послідовності символів), є <span class="text-bold">immutable</span> класом (про <span class="text-bold">immutable</span> я писав <a href="https://codegym.cc/groups/posts/3252-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-2" target="_blank">раніше</a> ), тобто. дані об'єктів цього класу неможливо змінити після створення. Хотілося б відразу відзначити, що класи <span class="code">StringBuilder</span> і <span class="code">StringBuffer</span> - це два фактично однакових класи з тією різницею, що один з них призначений для використання в багатопотоковому середовищі (StringBuffer). Ці класи є аналогами <span class="code">String</span> , але на відміну від нього вони <span class="text-bold">змінюються</span>. Тобто об'єкти після створення допускають модифікацію рядка, який репрезентують, без створення нового об'єкта. Власне, методи відрізняються від стандартних методів <span class="code">String</span> і спрямовані на задоволення потреб щодо зміни рядка (не дарма ж builder-ом назвали). Докладніше про <span class="code">String</span> , <span class="code">StringBuffer</span> та <span class="code">StringBuilder</span> читайте ось <a href="https://codegym.cc/groups/posts/2351-znakomstvo-so-string-stringbuffer-i-stringbuilder-v-java" target="_blank">у цій статті</a> .
<h4>58. Які є способи створення об'єкта String? Де воно створюється?</h4>Найзвичніший спосіб створення рядка – просте завдання потрібного нам значення у подвійних дужках: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"Hello World!"</span><span class="token punctuation">;</span></code></pre> Також можна зробити це безпосередньо через <span class="code">new</span> : 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Можна створити рядок та відштовхуючись від масиву символів: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class=" language-java"><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> charArr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'H'</span><span class="token punctuation">,</span><span class="token string">'e'</span><span class="token punctuation">,</span><span class="token string">'l'</span><span class="token punctuation">,</span><span class="token string">'l'</span><span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">,</span><span class="token string">' '</span><span class="token punctuation">,</span> <span class="token string">'W'</span><span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">,</span><span class="token string">'l'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">,</span><span class="token string">'!'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>charArr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Як результат роботи методу <span class="code">toString</span> на деякому об'єкті: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">String</span> str <span class="token operator">=</span> someObject<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Як результат роботи будь-якого іншого методу повертає рядкову виставу. Наприклад: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class=" language-java"><span class="token class-name">BufferedReader</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> str <span class="token operator">=</span>  reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Як ви зрозуміли, способів створення рядка може бути дуже багато. При створенні об'єкта <span class="code">String</span> він зберігається в <span class="text-bold">рядковому пулі</span> , про який докладніше ми поговоримо в одному з питань.
<h4>59. Як порівняти два рядки Java і як їх відсортувати?</h4>Для порівняння значень Java використовується знак подвійного дорівнює <span class="code">==</span> . Якби нам потрібно було порівнювати деякі прості значення на зразок <span class="code">int</span> , ми б скористалися ним. Але для порівняння повноцінних об'єктів цей спосіб не застосовується. У такому разі це буде лише порівняння посилань — чи вказують вони на той самий об'єкт чи ні. Тобто при порівнянні двох об'єктів з абсолютно однаковими значеннями внутрішніх полів порівняння через <span class="code">==</span> дасть результат <span class="text-bold">false</span> : незважаючи на однаковість полів об'єктів, об'єкти займають різні осередки пам'яті. А об'єкти класу <span class="code">String</span> , незважаючи на оманливу простоту, все ж таки є об'єктами. І порівняння через <span class="code">==</span>для них також не застосовується (навіть незважаючи на наявність рядкового пулу). Тут за справу береться стандартний метод класу <span class="code">Object</span> - <span class="code">equals</span> , який необхідно перевизначити в класі для його коректної роботи (інакше за умовчанням він порівнює через <span class="code">==</span> ). У класі <span class="code">String</span> він перевизначений, отже, просто беремо і використовуємо його: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class=" language-java"><span class="token class-name">String</span> firstStr <span class="token operator">=</span> <span class="token string">"Hello World!"</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> secondStr <span class="token operator">=</span> <span class="token string">"Hello World!"</span><span class="token punctuation">;</span>
<span class="token keyword">boolean</span> isEquals <span class="token operator">=</span> firstStr<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>secondStr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><img data-max-width="512" data-id="c4cbf258-2841-4708-843d-e16e59c06bc3" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 6 - 6" src="https://cdn.javarush.com/images/article/c4cbf258-2841-4708-843d-e16e59c06bc3/512.jpeg" style="width: 512px;">Ми говорабо про порівняння на відповідність, тепер розберемо порівняння для сортування. Адже для сортування чогось потрібно знати, за яким принципом сортувати. Для цього можна скористатися стандартним відсортованим безліччю - <span class="code">TreeSet</span> . Докладніше про різні колекції в Java ви можете почитати <a href="https://codegym.cc/groups/posts/2985-chto-mogut-sprositjh-na-sobesedovanii-strukturih-dannihkh-v-java" target="_blank">в цій статті</a> . Даний список працює на основі алгоритму червоно-чорного дерева та сортує безліч відповідно до заданого принципу сортування. Як я й сказав раніше, треба розуміти, як відсортувати об'єкти певного типу. Для встановлення способу порівняння для сортування використовують <a href="https://codegym.cc/groups/posts/2262-comparator-v-java" target="_blank">компаратори</a> . Як правило їх необхідно реалізовувати для класів, які ви хочете сортувати, але у випадку зі <span class="code">String</span>вони вже реалізовані. Тому просто додаємо потрібні нам рядки в <span class="code">TreeSet</span> , а він їх відсортує: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> sortedSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
sortedSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
sortedSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
sortedSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
sortedSet<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Висновок у консолі: 
<div class="terminal">
 A B C
</div>
<h4>60. Наведіть алгоритм переведення рядка до символу. Напишіть відповідний код</h4>Як я й говорив раніше, у об'єктів класу <span class="code">String</span> дуже багато різних корисних методів. Один з таких - <span class="code">toCharArray</span> . Даний метод переводить рядок у масив символів: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class=" language-java"><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"Hello world"</span><span class="token punctuation">;</span>
<span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> charArr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Далі ми маємо масив символів, які можемо викликати за індексом: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token keyword">char</span> firstChar <span class="token operator">=</span> charArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// H</span></code></pre>
<h4>61. Як перевести рядок у масив байтів і назад? Напишіть відповідний код</h4>Аналогічний метод <span class="code">toCharArray</span> , клас <span class="code">String</span> має метод <span class="code">getBytes</span> , який повертає масив байтів рядка: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class=" language-java"><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"Hello world"</span><span class="token punctuation">;</span>
<span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> byteArr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">byte</span> firstChar <span class="token operator">=</span> byteArr<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 119</span></code></pre> Сьогоднішня частина аналізу підійшла до логічного кінця. Дякую за увагу!<img data-max-width="512" data-id="27b2740d-7749-4a0f-bcc4-3ee9cc5b4884" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 6 - 7" src="https://cdn.javarush.com/images/article/27b2740d-7749-4a0f-bcc4-3ee9cc5b4884/512.jpeg" style="width: 512px;"><a href="https://codegym.cc/login/signup" target="_blank"><img id="click_banner1_articles" data-max-width="1080" data-id="5736eb4b-2b1c-4ab6-b4cc-b9e2d1cef628" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 6 - 8" src="https://cdn.javarush.com/images/article/5736eb4b-2b1c-4ab6-b4cc-b9e2d1cef628/1080.jpeg" style="width: 1080px;"></a>
<div class="table-container">
 <table>
  <tbody>
   <tr>
    <th>Інші матеріали серії:</th>
   </tr>
   <tr>
    <td>
     <ul>
      <li><a href="https://codegym.cc/groups/posts/3243-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-1" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 1</a></li>
      <li><a href="https://codegym.cc/groups/posts/3252-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-2" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 2</a></li>
      <li><a href="https://codegym.cc/groups/posts/3273-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-3" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 3</a></li>
      <li><a href="https://codegym.cc/groups/posts/3284-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-4" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 4</a></li>
      <li><a href="https://codegym.cc/groups/posts/3296-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-5" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 5</a></li>
      <li><a href="https://codegym.cc/groups/posts/3386-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-7" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 7</a></li>
      <li><a href="https://codegym.cc/groups/posts/3415-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-8" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 8</a></li>
      <li><a href="https://codegym.cc/groups/posts/3434-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-9" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 9</a></li>
      <li><a href="https://codegym.cc/groups/posts/3452-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-10" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 10</a></li>
      <li><a href="https://codegym.cc/groups/posts/3464-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-11" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 11</a></li>
      <li><a href="https://codegym.cc/groups/posts/3475-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-12" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 12</a></li>
      <li><a href="https://codegym.cc/groups/posts/3507-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-13" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 13</a></li>
      <li><a href="https://codegym.cc/groups/posts/3558-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-14" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 14</a></li>
      <li><a href="https://codegym.cc/groups/posts/3592-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-15" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 15</a></li>
      <li><a href="https://codegym.cc/groups/posts/3621-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-16" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 16</a></li>
     </ul></td>
   </tr>
  </tbody>
 </table>
</div>