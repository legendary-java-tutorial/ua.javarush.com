Розбір запитань та відповідей із співбесід на Java-розробника. Частина 10
<p>----------------------------------------</p>
Вітання! Як багато годин потрібно витратити, щоб стати чимось майстром? Часто чув щось на зразок: “Щоб стати майстром у будь-якій справі, потрібно витратити 10 000 годин”. Жахлива цифра, чи не так? Проте, мені цікаво, а чи це правда? І я по
<p>----------------------------------------</p>
Вітання! Як багато годин потрібно витратити, щоб стати чимось майстром? Часто чув щось на зразок: “Щоб стати майстром у будь-якій справі, потрібно витратити 10 000 годин”. Жахлива цифра, чи не так? <img data-max-width="800" data-id="6e514b6b-2f0a-42fb-b59e-f008956f054c" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 10 - 1" src="https://cdn.javarush.com/images/article/6e514b6b-2f0a-42fb-b59e-f008956f054c/800.jpeg" style="width: 800px;">Проте, мені цікаво, а чи це правда? І я постійно намагаюся прикидати, скільки годин я вже вклав у оволодіння програмістським мистецтвом. І коли я перейду ті заповітні 10000 годин і стану майстром, чи я відчую цю різницю? Чи я їх уже давно переступив, не усвідомивши цього? Так чи інакше, щоб стати програмістом, не потрібно вкладати таку величезну кількість часу. Головне - використовувати його з розумом. Ваша першорядна мета – пройти співбесіду. А на співбесідах новачків насамперед питають теорію, тому ви повинні бути в ній сильні. Власне, при самій підготовці до співбесіди, ваше завдання — виявити всі ваші прогалини в базовій теорії Java-розробника і покрити їх знаннями. І сьогодні я вам допоможу у цій справі, адже я тут, щоб продовжити розбір найпопулярніших питань. Отже, продовжимо! 
<h4>89. Чим відрізняється ArrayList від LinkedList?</h4>Це одне з найпопулярніших питань нарівні з питанням про внутрішній пристрій <span class="code">HashMap</span> . Жодна співбесіда не обходиться без неї, і тому відповідь на неї у вас має “відсякувати від зубів”. Крім очевидної — різної назви, вони відрізняються внутрішнім пристроєм. Раніше ми розбирали внутрішній пристрій і <span class="code">ArrayList</span> -а і <span class="code">LinkedList</span> -а, тому вдаватися в деталі їх реалізації я не буду. Лише нагадаю, що <span class="code">ArrayList</span> реалізований на основі внутрішнього масиву, який за потребою збільшується за формулою: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token operator">&lt;</span>размерТекущегоМассива<span class="token operator">&gt;</span> <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">/</span> <span class="token number">2</span>  <span class="token operator">+</span> <span class="token number">1</span></code></pre> У той же час <span class="code">LinkedList</span> реалізований на основі внутрішнього двозв'язкового списку, тобто кожен елемент має посилання на попередній і наступний, за винятком значень, які є початком/кінцем списку. Це питання люблять ставити у форматі: "Що краще - <span class="code">ArrayList</span> або <span class="code">LinkedList</span> ?", Сподіваючись вас підловити. Адже якщо ви як відповідь вкажете на одну з них, це буде неправильна відповідь. <img data-max-width="512" data-id="d3701523-2a0b-47c0-a1e5-c7bf5e0711e5" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 10 - 2" src="https://cdn.javarush.com/images/article/d3701523-2a0b-47c0-a1e5-c7bf5e0711e5/512.jpeg" style="width: 512px;">Натомість вам варто уточнити, про яку конкретну ситуацію йдеться - доступ за індексом або вставка в середину списку. Залежно від відповіді, ви зможете пояснити свій вибір. Раніше я вже описував, як працює <span class="code">ArrayList</span> та <span class="code">LinkedList</span>у тій чи іншій ситуації. Давайте підсумуємо це, поставивши в один ряд для порівняння: <span class="text-bold">Додавання елемента (add)</span>
<ol>
 <li>
  <p>Додавання нового елемента без вказівки індексу як розташування буде відбуватися автоматично до кінця обох списків. У <span class="code">LinkedList</span> новий елемент стане новим хвостом (відбувається лише перезаписування пари посилань - алгоритмічна складність <span class="text-bold">O(1)</span> ).</p>
  <p>В <span class="code">ArrayList</span> буде додано новий елемент в останню порожню комірку масиву - <span class="text-bold">O(1)</span> .</p></li>
 <li>
  <p>Додавання елемента за індексом зазвичай має на увазі вставку приблизно в середину списку. У <span class="code">LinkedList</span> спершу вестиметься пошук потрібного місця за допомогою перебору елементів з "хвоста" і "голови" - <span class="text-bold">O(n/2)</span> , а потім - вставка значення шляхом перевизначення посилань елементів, між якими вставляється новий - <span class="text-bold">O(1)</span> . Сумарна алгоритмічна складність цієї дії буде <span class="text-bold">O(n/2)</span> .</p><span class="code">ArrayList</span> в даній ситуації за індексом знаходить елемент - <span class="text-bold">O(1)</span> , і всі елементи праворуч (включаючи елемент, який вже зберігається за цим індексом) рухаються на одну одиницю вправо (при цьому можливо знадобиться створення нового списку та копіювання елементів до нього) - <span class="text-bold">O (n/2)</span> . Сумарна складність - <span class="text-bold">O(n/2)</span> .
  <p></p></li>
 <li>
  <p>Додавання елемента на початок списку в <span class="code">LinkedList</span> буде ситуація схожа з додаванням в кінець: новий елемент стане новою "головою" - <span class="text-bold">O (1)</span> , в той же час коли <span class="code">ArrayList</span> -у потрібно буде рухати всі елементи вправо - <span class="text-bold">O (n)</span> .</p></li>
</ol>Підсумок: в <span class="code">LinkedList</span> алгоритмічна складність коливатиметься від <span class="text-bold">O(1)</span> до <span class="text-bold">O(n/2)</span> . Тобто чим ближче вставка до кінця або початку списку, тим швидше. У той же час у <span class="code">ArrayList</span> вона коливається від <span class="text-bold">O(1)</span> до <span class="text-bold">O(n)</span> : чим вставка ближче до кінця списку, тим швидше. <span class="text-bold">Завдання елемента (set)</span> Ця операція записує елемент у вказану позицію у списку, перезаписуючи попередній, якщо він є. У <span class="code">LinkedList</span> ця операція схожа з додаванням, т.к. Найбільша складність тут - пошук елемента. Перезапис елемента проходитиме шляхом перезаписування пари посилань, тому тут також алгоритмічна складність коливатиметься від<span class="text-bold">O(1)</span> до <span class="text-bold">O(n/2)</span> залежно від віддаленості позиції від кінця чи початку списку. У той час в <span class="code">ArrayList</span> для цієї операції за індексом буде знайдено потрібну комірку, а в неї записано новий елемент. Пошук за індексом, як і операція, має алгоритмічну складність <span class="text-bold">O(1)</span> . <span class="text-bold">Взяти елемент за індексом (get)</span> У <span class="code">LinkedList</span> взяття елемента відбуватиметься за тим самим принципом, як і пошук інших операцій — залежно від віддаленості від кінця чи початку, тобто. від <span class="text-bold">O(1)</span> до <span class="text-bold">O(n/2)</span> . В <span class="code">ArrayList</span> , як і раніше, пошук елемента в масиві за індексом має складність <span class="text-bold">O(1)</span> . <span class="text-bold">Видалити елемент за індексом (remove)</span> Для <span class="code">LinkedList</span> тут теж спрацьовує його принцип дії: спочатку знаходиться елемент, а потім відбувається перезаписування посилань - сусіди елемента починають посилатися один на одного, втрачаючи посилання на даний елемент, який згодом буде видалено збирачем сміття. Тобто, алгоритмічна складність така сама — від <span class="text-bold">O(1)</span> до <span class="text-bold">O(n/2)</span> . Для <span class="code">ArrayList</span> ця операція більше схожа на операцію додавання нового елемента (add). Спочатку знаходиться елемент, що шукається — <span class="text-bold">O(1)</span>, потім він видаляється, і всі елементи, які були праворуч від нього переміщаються на одну одиницю вліво, щоб закрити пролом, що утворився. Операція видалення матиме ту ж алгоритмічну складність, що й операція додавання – від <span class="text-bold">O(1)</span> до <span class="text-bold">O(n)</span> . Чим видалення ближче до кінця списку, тим менша алгоритмічна складність. Власне це були всі основні операції. Нагадую: при порівнянні цих двох списків вам потрібно уточнити, про яку конкретну ситуацію йдеться, і тоді вже можна однозначно відповісти на поставлене запитання. 
<h4>90. Чим відрізняється ArrayList від HashSet?</h4>Якщо <span class="code">ArrayList</span> і <span class="code">LinkedList</span> можна було порівняти за операціями - де хто краще - то з <span class="code">ArrayList</span> з <span class="code">HashSet</span> порівняти вже не так просто, адже це різні колекції. Можна порівняти одну солодку страву з іншою, але з м'ясною вже вийде — надто вже вони різні. Тим не менш, я спробую навести їх деякі відмінності:
<ul>
 <li>
  <p><span class="code">ArrayList</span> реалізує інтерфейс <span class="code">List</span> , тоді як <span class="code">HashSet</span> реалізує інтерфейс <span class="code">Set</span> ;</p></li>
 <li>
  <p>У <span class="code">ArrayList</span> можливий доступ за індексом елемента: операція <span class="code">get</span> має алгоритмічну складність <span class="text-bold">O(1)</span> , а <span class="code">HashSet</span> необхідний елемент можна отримати лише шляхом перебору, але це від <span class="text-bold">O(1)</span> до <span class="text-bold">O(n)</span> ;</p></li>
 <li>
  <p><span class="code">ArrayList</span> допускає наявність дублікатів елементів. У <span class="code">HashSet</span> всі елементи унікальні: додати в <span class="code">HashSet</span> елемент, аналог якого вже присутній у колекції, не вийде (перевірка дублікатів ведеться за hashcode, звідси і назва цієї колекції);</p></li>
 <li>
  <p><span class="code">ArrayList</span> реалізований за допомогою внутрішнього масиву, а <span class="code">HashSet</span> реалізований за допомогою внутрішньої <span class="code">HashMap</span> ;</p></li>
 <li>
  <p><span class="code">ArrayList</span> підтримує порядок вставки елементів, у той час як <span class="code">HashSet</span> - це невпорядкована множина і не підтримує порядок елементів;</p></li>
 <li>
  <p><span class="code">ArrayList</span> допускає будь-яку кількість порожніх значень (null), в <span class="code">HashSet</span> можна вставити лише одне значення null (як-не-як, унікальність елементів).</p></li>
</ul>
<h4>91. Навіщо в Java така різноманітність імплементації динамічного масиву?</h4><img data-max-width="512" data-id="84c21648-4cc5-4175-9ea2-f8e4fdbbe329" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 10 – 3" src="https://cdn.javarush.com/images/article/84c21648-4cc5-4175-9ea2-f8e4fdbbe329/512.jpeg" style="width: 512px;">Ну, це скоріше філософське питання. Ну а навіщо вигадують таку кількість нових різноманітних технологій? Для зручності. Власне, так само і з великою кількістю імплементацій динамічного масиву. Жодну з них не можна назвати кращою чи ідеальною. Кожна має перевагу в якійсь конкретній ситуації. І наше завдання — знати їхні відмінності, їх сильні/слабкі сторони: щоб зуміти в потрібній ситуації використовувати найкращу з них. 
<h4>92. Навіщо в Java така різноманітність імплементацій key-value storage?</h4>Тут ситуація така сама, як і з імплементаціями динамічного масиву. Однозначно найкращих немає: у кожної є сильні та слабкі сторони. І ми, звичайно, маємо максимально використовувати сильні сторони. <span class="text-bold">Приклад:</span> у пакеті concurrent, в якому є безліч багатопотокових технологій, є свої <span class="code">Concurrent</span> колекції. У тій же <a href="https://codegym.cc/groups/posts/713-hashmap-i-concurrenthashmap-populjarnihe-voprosih-na-sobesedovanijakh" target="_blank">ConcurrentHashMap</a> є перевага в безпеці багатопоточної роботи з даними в порівнянні зі звичайною <span class="code">HashMap</span> , але не в багатопоточному середовищі вона програє у швидкості роботи. Ну а імплементації, які в жодній із ситуацій не бувають найсильнішими, поступово перестають використовувати. <span class="text-bold">Приклад: </span> <span class="code">Hashtable</span> , яка спочатку замислювалася як потокобезпечна<span class="code">HashMap</span> , але <span class="code">ConcurrentHashMap</span> перевершила її при роботі в багатопотоковому середовищі, і в результаті про <span class="code">Hashtable</span> забули і перестали використовувати. 
<h4>93. Як сортувати колекцію елементів?</h4>Перше, що треба сказати, клас елемента колекції повинен імплементувати інтерфейс <span class="code">Comparable</span> і його метод <span class="code">compareTo</span> . Або потрібен клас, який імплементує <span class="code">Comaprator</span> з його методом <span class="code">comparator</span> . Докладніше про них можна почитати в <a href="https://codegym.cc/groups/posts/1939-comparator-v-java" target="_blank">цьому пості</a> . Обидва способи вказують, як потрібно порівнювати об'єкти даного типу. При сортуванні це є критично важливим, адже потрібно розуміти принцип, за яким елементи можна порівняти. В основному використовується спосіб через імплементацію <span class="code">Comparable</span> , що реалізується безпосередньо в класі, який ви хочете сортувати. У той же час застосування <span class="code">Comparator</span>-а рідше. Скажімо, ви використовуєте клас з якоїсь бібліотеки, яка не має реалізації <span class="code">Comparable</span> , але вам якось потрібно буде його сортувати. Не маючи можливості змінити код цього класу (крім як розширити його), ви можете написати реалізацію <span class="code">Comparator</span> -а, в якому вкажете, за яким принципом потрібно порівнювати об'єкти даного класу. І ще один приклад. Допустимо, вам потрібні різні принципи сортування об'єктів одного і того ж типу, тому ви пишете кілька <span class="code">Comparator</span> -ів, які використовуєте в різних ситуаціях. Як правило, багато класів з коробки вже реалізують інтерфейс <span class="code">Comparable</span> - той же <span class="code">String</span>. Власне, при їх використанні вам не потрібно паритись, як їх порівняти. Ви просто берете та використовуєте їх. <span class="text-bold">Перший</span> і найочевидніший спосіб - використовувати колекцію типу <span class="code">TreeSet</span> або <span class="code">TreeMap</span> , які зберігають елементи в уже відсортованому порядку, згідно з компаратором класу елементів. Не забувайте, що <span class="code">TreeMap</span> сортує ключі, але не значення. Якщо ви використовуєте імплементацію <span class="code">Comparator</span> замість <span class="code">Comparable</span> , вам потрібно буде передати його об'єкт у конструктор колекції під час створення: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">TreeSet</span> treeSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token punctuation">(</span>customComparator<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> А якщо у вас колекція іншого типу? Як її відсортувати? І тут <span class="text-bold">другий</span> спосіб утилітного класу <span class="code">Collections</span> — метод <span class="code">sort()</span> . Він статичний, тому все, що вам потрібно – ім'я класу та метод, до якого передається необхідний список. Наприклад: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>someList<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Якщо ви використовуєте не <span class="code">Comparable</span> , а <span class="code">Comparator</span> , його потрібно передати другим параметром: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>someList<span class="token punctuation">,</span> customComparator<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> У результаті внутрішній порядок елементів переданого списку зміниться: його буде відсортовано відповідно до компаратора елементів. Зазначу, що список елементів має бути мутабельним, тобто. зміненим, інакше метод не спрацює і буде викинуто <span class="code">UnsupportedOperationException</span> . Як <span class="text-bold">третій</span> спосіб можна використовувати <span class="code">Stream</span> операцію <span class="code">sort</span> , яка сортує елементи колекції, якщо використовується імплементація <span class="code">Comparable</span> : 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java">someList <span class="token operator">=</span> someList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> якщо <span class="code">Comparator</span> : 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java">someList <span class="token operator">=</span> someList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span>customComparator<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Докладніше про <span class="code">Stream</span> можна почитати у <a href="https://codegym.cc/groups/posts/2203-stream-api" target="_blank">цій статті</a> . <span class="text-bold">Четвертий</span> спосіб - ручна реалізація сортування, наприклад, <a href="https://codegym.cc/groups/posts/634-realizacija-puzihrjhkovoy-sortirovki-na-java" target="_blank">сортування бульбашкою</a> або <a href="https://codegym.cc/groups/posts/2202-sortirovka-slijaniem-merge-sort" target="_blank">сортування злиттям</a> . 
<h3>Class Object. Equals and HashCode</h3>
<h4>94. Дайте коротку характеристику class object Java</h4>У другій частині розбору ми вже говорабо про методи класу <span class="code">Object</span> , і я нагадаю, що клас <span class="code">Object</span> — прабатько всіх класів Java. Він має 11 методів, які, відповідно, успадковуються всіма класами. <img data-max-width="512" data-id="f67dd5ea-dfce-40d1-94b6-d06bc38ec912" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 10 – 4" src="https://cdn.javarush.com/images/article/f67dd5ea-dfce-40d1-94b6-d06bc38ec912/512.jpeg" style="width: 512px;">Інформацію про всі 11 методів можна знайти <a href="https://codegym.cc/groups/posts/3252-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-2" target="_blank">у другій частині</a> аналізу питань. 
<h4>95. Для чого використовують Equals та HashCode у Java?</h4><span class="code">hashCode()</span> - це метод класу <span class="code">Object</span> , який успадковується всіма класами. Його завдання - генерування деякої кількості, що представляє конкретний об'єкт. Прикладом використання даного методу може бути його застосування в <span class="code">HashMap</span> на об'єкті ключа для подальшого визначення локального хешкода, за яким визначиться комірка внутрішнього масиву (бакета), в якій буде збережено пару. Докладно про роботу <span class="code">HashMap</span> ми говорабо <a href="https://codegym.cc/groups/posts/3434-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-9" target="_blank">в 9 частині розбору</a> , тому особливо зупинятись на цьому не будемо. <img data-max-width="512" data-id="147525b9-ab24-444e-bbfb-65ca5b9db478" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 10 – 5" src="https://cdn.javarush.com/images/article/147525b9-ab24-444e-bbfb-65ca5b9db478/512.jpeg" style="width: 512px;">Також зазвичай цей метод використовується в методі <span class="code">equals()</span> як один з його основних інструментів визначення ідентичності об'єктів. <span class="code">equals()</span> - метод класу<span class="code">Object</span> , завдання якого - порівнювати об'єкти і визначати, рівні вони чи ні. Цей метод використовується повсюдно там, де необхідно порівняти об'єкти, адже звичайне порівняння через <span class="code">==</span> не підходить об'єктів, т.к. порівнює лише посилання ними. 
<h4>96. Розкажіть про контракт між Equals та HashCode у Java?</h4>Перше, що скажу, для коректної роботи методів <span class="code">equals()</span> і <span class="code">hashCode()</span> їх потрібно правильно перевизначити. Після цього вони повинні дотримуватися правил:
<ul>
 <li>однакові об'єкти, для яких порівняння через <span class="text-bold">equals повертає true обов'язково </span><span class="code">мають</span> однакові <em>хеш</em> - коди;<span class="text-bold"></span></li>
 <li>об'єкти з однаковими хеш-кодами <span class="text-bold">не завжди</span> можуть бути рівними.</li>
</ul>На цьому ми зробимо паузу до наступної частини розбору!<img data-max-width="512" data-id="34677cb0-c690-4de0-b0bf-4150c8d0ad8e" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 10 – 6" src="https://cdn.javarush.com/images/article/34677cb0-c690-4de0-b0bf-4150c8d0ad8e/512.jpeg" style="width: 512px;"><a href="https://codegym.cc/login/signup" target="_blank"><img id="click_banner1_articles" data-max-width="1080" data-id="5736eb4b-2b1c-4ab6-b4cc-b9e2d1cef628" alt="Розбір запитань та відповідей із співбесід на Java-розробника.  Частина 10 – 7" src="https://cdn.javarush.com/images/article/5736eb4b-2b1c-4ab6-b4cc-b9e2d1cef628/1080.jpeg" style="width: 1080px;"></a>
<div class="table-container">
 <table>
  <tbody>
   <tr>
    <th>Інші матеріали серії:</th>
   </tr>
   <tr>
    <td>
     <ul>
      <li><a href="https://codegym.cc/groups/posts/3243-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-1" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 1</a></li>
      <li><a href="https://codegym.cc/groups/posts/3252-razbor-voprosov-i-otvetov-na-sobesedovanii-chastjh-2" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 2</a></li>
      <li><a href="https://codegym.cc/groups/posts/3273-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-3" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 3</a></li>
      <li><a href="https://codegym.cc/groups/posts/3284-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-4" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 4</a></li>
      <li><a href="https://codegym.cc/groups/posts/3296-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-5" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 5</a></li>
      <li><a href="https://codegym.cc/groups/posts/3341-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-6" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 6</a></li>
      <li><a href="https://codegym.cc/groups/posts/3386-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-7" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 7</a></li>
      <li><a href="https://codegym.cc/groups/posts/3415-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-8" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 8</a></li>
      <li><a href="https://codegym.cc/groups/posts/3434-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-9" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 9</a></li>
      <li><a href="https://codegym.cc/groups/posts/3464-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-11" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 11</a></li>
      <li><a href="https://codegym.cc/groups/posts/3475-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-12" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 12</a></li>
      <li><a href="https://codegym.cc/groups/posts/3507-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-13" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 13</a></li>
      <li><a href="https://codegym.cc/groups/posts/3558-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-14" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 14</a></li>
      <li><a href="https://codegym.cc/groups/posts/3592-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-15" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 15</a></li>
      <li><a href="https://codegym.cc/groups/posts/3621-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-16" target="_blank">Розбір запитань та відповідей із співбесід на Java-розробника. Частина 16</a></li>
     </ul></td>
   </tr>
  </tbody>
 </table>
</div>