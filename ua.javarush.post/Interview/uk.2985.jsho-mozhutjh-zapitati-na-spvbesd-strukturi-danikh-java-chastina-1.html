Що можуть запитати на співбесіді: структури даних Java. Частина 1
<p>----------------------------------------</p>
Вітання! Як не крути, вам не стати розробником без успішного проходження вхідної технічної співбесіди. Технологій, пов'язаних з Java, дуже багато і вивчити все неможливо. Щось специфічне, як правило, на співбесідах запитують лише в тому вип
<p>----------------------------------------</p>
Вітання! Як не крути, вам не стати розробником без успішного проходження вхідної технічної співбесіди. <img data-max-width="800" data-id="0eecf617-65d6-4cec-a113-eb97bca478e3" alt="Що можуть запитати на співбесіді: структури даних у Java - 1" src="https://cdn.javarush.com/images/article/0eecf617-65d6-4cec-a113-eb97bca478e3/800.jpeg" style="width: 800px;">Технологій, пов'язаних з Java, дуже багато і вивчити все неможливо. Щось специфічне, як правило, на співбесідах запитують лише в тому випадку, якщо шукають розробника з гарним досвідом у якомусь важливому для проекту фреймворку. Якщо це так, вас будуть ганяти цим фреймворком на весь зріст, ви вже не сумнівайтеся. <img data-max-width="512" data-id="362c401b-e9b0-48f9-865f-ed54c64e3092" alt="Що можуть запитати на співбесіді: структури даних у Java - 2" src="https://cdn.javarush.com/images/article/362c401b-e9b0-48f9-865f-ed54c64e3092/512.jpeg" style="width: 512px;">Але ми зараз говоримо про базу, яку має знати кожен Java developer. Про ті класичні знання, з яких все і починається. Сьогодні хотілося б торкнутися однієї з основних тем будь-якої співбесіди — <span class="text-bold">структури даних у Java</span>. Отже, замість ходіння навкруги, ми почнемо. Ловіть список питань, які можуть вам поставити на цю тему на співбесіді.
<h2>1. Розкажіть трохи про структури даних</h2><span class="text-bold">Структура даних</span> — це сховище даних, де лежить інформація, структурована певним чином. Ці структури заточені під ефективне виконання певних операцій. Типовими прикладами структур даних є:
<ul>
 <li>масиви,</li>
 <li>стеки,</li>
 <li>черги,</li>
 <li>пов'язані списки,</li>
 <li>графи,</li>
 <li>дерева,</li>
 <li>префіксні дерева,</li>
 <li>таблиці хеш.</li>
</ul>Докладніше з ними можна ознайомитися <a href="https://codegym.cc/quests/lectures/questharvardcs50.level05.lecture06" target="_blank">тут</a> і <a href="https://codegym.cc/quests/lectures/questharvardcs50.level05.lecture03" target="_blank">тут</a> . Дані є ключовою складовою в програмі, структури дозволяють зберігати ці дані в певному, чітко структурованому вигляді. Чим би не займався ваш додаток, цей аспект завжди буде в ньому присутній: якщо це веб-магазин, то зберігатиметься інформація про товари, якщо соціальна мережа — дані про користувачів і файли, і так далі.
<h2>2. Що ви знаєте про Масиви?</h2>Масив – це контейнер для зберігання однотипних значень, кількість яких було задано заздалегідь. Приклад створення масиву з рядковими значеннями: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strArray <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Java"</span><span class="token punctuation">,</span><span class="token string">"is"</span><span class="token punctuation">,</span><span class="token string">"the"</span><span class="token punctuation">,</span><span class="token string">"best"</span><span class="token punctuation">,</span><span class="token string">"language"</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> Під час створення масиву виділяється пам'ять під його елементи: що більше осередків під елементи задано спочатку, тим більше буде виділено пам'яті. Якщо створюється порожній масив із деякою кількістю осередків, то всім елементам масиву будуть надаватися значення за промовчанням. Наприклад: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre> Так, для масиву з елементами типу <span class="text-bold">boolean</span> початкові ( <span class="text-bold">default</span> ) значення дорівнюють <span class="text-bold"><em>false</em></span> , для масивів з числовими значеннями - 0, з елементами типу <span class="text-bold">char</span> - <span class="code">\u0000</span> . Для масиву типу класу (об'єкти) - <span class="text-bold">null</span> (не порожні рядки - <span class="code">"</span> а саме <span class="text-bold">null"</span> ). Тобто, у прикладі вищі всі значення масиву <span class="code">arr</span>дорівнюють 0 до тих пір, поки вони не будуть безпосередньо задані. На відміну від колекцій масиви не є динамічними. Після оголошення масиву певного розміру, сам розмір не можна змінити. Щоб додати новий елемент до масиву, необхідно створити новий масив більшого розміру та скопіювати в нього всі елементи зі старого (це принцип роботи ArrayList). Є один момент, який не всі знають і на якому вас можуть непогано підловити. У Java є два види змінних - <a href="https://codegym.cc/groups/posts/2630-prostihe-peremennihe-v-java-i-konstantih" target="_blank">прості типи</a> та <a href="https://codegym.cc/groups/posts/2642-ssihlochnihe-tipih-dannihkh-v-java" target="_blank">посилання</a> на повноцінні об'єкти. До якого з них належать масиви? Наприклад, ось: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre> Начебто все просто - це 10 елементів <span class="text-bold">int</span> . Виходить, можна сказати, що це найпростіший тип? Як би не так. <span class="text-bold">У Java масиви є об'єктами, що динамічно створюються і можуть бути призначені змінним типу Object. </span> Усі методи класу Object можна викликати у масиві. Тому ми можемо навіть написати: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class=" language-java"><span class="token class-name">Object</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> При виведенні в консолі можна отримати щось на зразок: 
<div class="terminal">
 [I@4769b07b
</div> Докладніше про особливості масивів Java розповідається в <a href="https://codegym.cc/groups/posts/massivy-java" target="_blank">цій статті o Java Array</a> . Щоб закріпити знання, можна вирішити кілька завдань із <a href="https://codegym.cc/groups/posts/2669-reshaem-zadachi-na-odnomernihe-i-dvumernihe-massivih" target="_blank">цієї добірки</a> .
<h2>3. Розкажіть про ієрархію колекцій</h2>Колекції застосовують у ситуаціях, коли потрібна гнучкість під час роботи з даними. Колекції можуть додавати елемент, видаляти елемент та виконувати безліч інших операцій. У Java є безліч різних реалізацій, а нам потрібно лише вибрати правильну колекцію для поточної ситуації. Як правило, коли ви згадуєте інтерфейс <span class="text-bold">Collection</span> , вас просять перерахувати деякі його реалізації та відношення з <span class="text-bold">Map</span> . Що ж, розбираймося. Отже, <span class="text-bold">Collection</span> та <span class="text-bold">Map</span> – це дві різні ієрархії для структур даних. Як виглядає ієрархія <span class="text-bold">Collection</span> : <img data-max-width="800" data-id="eae23ccc-7029-44ad-8b2b-3ae9ac2c39e6" alt="Що можуть запитати на співбесіді: структури даних у Java - 3" src="https://cdn.javarush.com/images/article/eae23ccc-7029-44ad-8b2b-3ae9ac2c39e6/800.jpeg" style="width: 800px;">Інтерфейс <span class="text-bold">Collection</span>є ключовою верховною ланкою з переліком базових методів, від якого беруть початок три базові види структур даних - <span class="text-bold">Set</span> , <span class="text-bold">List</span> , <span class="text-bold">Queue</span> . <span class="text-bold">Set&lt;T&gt;</span> - інтерфейс, що є сукупністю об'єктів, в якій кожен об'єкт є унікальним. <span class="text-bold">List&lt;T&gt;</span> - інтерфейс, що представляє впорядковану послідовність об'єктів, яка називається списком. <span class="text-bold">Queue&lt;T&gt;</span> - інтерфейс, що відповідає за структури, які організовані у вигляді черги (послідовне зберігання елементів). Як говорилося раніше, <span class="text-bold">Map</span> є окремою ієрархією: <img data-max-width="800" data-id="bba4b588-f78a-4b8b-9a84-e0a3d5d4bb86" alt="Що можуть запитати на співбесіді: структури даних у Java - 4" src="https://cdn.javarush.com/images/article/bba4b588-f78a-4b8b-9a84-e0a3d5d4bb86/800.jpeg" style="width: 800px;"><span class="text-bold">Map&lt;K, V&gt;</span>- Інтерфейс, що представляє словник, в якому елементи містяться у вигляді пар "ключ-значення". При цьому всі ключі (K) є унікальними в межах об'єкта <span class="text-bold">Map</span> . Цей вид колекції полегшує пошук елемента, якщо нам відомий ключ – унікальний ідентифікатор об'єкта.
<h2>4. Що ви знаєте про Set?</h2>Як говорилося раніше, ця колекція представляє безліч унікальних елементів. Інакше кажучи, той самий об'єкт не може зустрічатися в Java <span class="text-bold">Set</span> більше одного разу. Також хотілося б позначити, що з <span class="text-bold">Set</span> ми не можемо витягнути елемент за номером (індексом) лише перебором. Важливо, що різні реалізації <span class="text-bold">Set</span> мають різний спосіб структуризації даних. Конкретні реалізації ми розглянемо далі. Отже, основні реалізації <span class="text-bold">Set</span> : <span class="text-bold">HashSet</span>— безліч, яка заснована на хеш-таблиці, що допомагає при пошуку. Використовує хеш-функцію, яка покращує продуктивність при пошуку та вставці. Незалежно від кількості елементів, в основному, вставка та пошук (іноді і видалення) виконуються за час, близький до постійного – O(1). Докладніше з хеш-функцією ми ознайомимося трохи пізніше. Також хотілося б відзначити, що <span class="text-bold">HashSet</span> містить у собі <span class="text-bold">HashMap</span> , в якому і відбувається вся магія. Ось <a href="https://codegym.cc/groups/posts/2147-hashset-v-java" target="_blank">докладна стаття про HashSet в Java</a> . <span class="text-bold">LinkedHashSet</span> - цей клас розширює <span class="text-bold">HashSet</span> , при цьому не додаючи жодних нових методів. Як і <span class="text-bold">LinkedList</span>, даний клас підтримує зв'язковий список елементів набору в порядку, в якому вони вставлялися. Це дозволяє організувати необхідний порядок у цій реалізації <span class="text-bold">Set</span> . Клас <span class="text-bold">TreeSet</span> створює безліч, яка для організації структури зберігання елементів ґрунтується на червоно-чорному дереві. Інакше кажучи, у цьому безлічі ми можемо сортувати елементи у порядку. Якщо ми використовуємо деякі стандартні об'єкти з “коробки”, наприклад <span class="text-bold">Integer</span> , то для вибудовування безлічі Integer у зростаючому порядку нам нічого і не потрібно робити: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token class-name">TreeSet</span><integer> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span></integer><span class="token punctuation"></span></code></pre> І в консолі ми отримаємо висновок: 
<div class="terminal">
 [1, 2, 3, 4]
</div> Тобто, у цьому <span class="code">set</span> числа зберігаються у відсортованому вигляді. Якщо ми будемо використовувати елементи <span class="text-bold">String</span> у <span class="code">TreeSet</span> , вони будуть відсортовані, але за абеткою. Ну а що якщо у нас є деякий стандартний (користувацький) клас? Яким чином об'єкти даного класу буде структурувати <span class="text-bold">TreeSet</span> ? Якщо ми спробуємо задати довільний об'єкт у цей <span class="text-bold">Set</span> : 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token class-name">TreeSet</span><cat> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"Мурзик"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"Барсик"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"Гарфилд"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>
</cat></code></pre> Ми отримаємо <span class="code">ClassCastException</span> , оскільки <span class="text-bold">TreeSet</span> не знає, як сортувати об'єкти даного типу. У такому разі потрібно, щоб наш кастомний об'єкт реалізував інтерфейс <span class="text-bold">Comparable</span> , і його метод <span class="code">compareTo</span> : 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><cat> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    <span class="token class-name">String</span> name<span class="token punctuation">;</span>

   <span class="token keyword">public</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
       <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token annotation punctuation">@Override</span>
   <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Cat</span> cat<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">return</span> age <span class="token operator">&gt;</span> cat<span class="token punctuation">.</span>age <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token annotation punctuation">@Override</span>
   <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">return</span> <span class="token string">"Cat{"</span> <span class="token operator">+</span>
               <span class="token string">"age="</span> <span class="token operator">+</span> age <span class="token operator">+</span>
               <span class="token string">", name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>
               <span class="token string">'}'</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</cat></code></pre> Як ви помітабо, метод <span class="code">compareTo</span> повертає <span class="text-bold">int</span> :
<ul>
 <li>1, якщо поточний об'єкт вважається великим;</li>
 <li>-1 якщо поточний об'єкт вважається меншим, ніж той, який прийшов аргументом;</li>
 <li>0, якщо об'єкти рівні (у разі ми це використовуємо).</li>
</ul>У такому випадку наш <span class="text-bold">TreeSet</span> відпрацює коректно та виведе результат: 
<div class="terminal">
 [Cat{age=2, name='Барсик'}, Cat{age=3, name='Гарфілд'}, Cat{age=4, name='Мурзик'}]
</div> Інший спосіб - створення окремого класу, відповідального за сортування, який реалізує інтерфейс <span class="text-bold">comparator</span> та його метод <span class="code">compare</span> : 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CatComparator</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><cat> <span class="token punctuation">{</span>

   <span class="token annotation punctuation">@Override</span>
   <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Cat</span> o1<span class="token punctuation">,</span> <span class="token class-name">Cat</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">return</span> o1<span class="token punctuation">.</span>age <span class="token operator">&gt;</span> o2<span class="token punctuation">.</span>age <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</cat></code></pre> У такому разі для його використання ми повинні задати об'єкт даного класу в конструктор <span class="code">TreeSet</span> : 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">TreeSet</span><cat> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CatComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</cat></code></pre> Після цього всі об'єкти класу <span class="code">Cat</span> , що потрапабо до <span class="code">TreeSet</span> , будуть відсортовані за допомогою класу <span class="code">Cat Comparator</span> . Більше про <span class="text-bold">Comparator</span> і <span class="text-bold">Comparable</span> Java можна дізнатися з <a href="https://codegym.cc/groups/posts/1939-comparator-v-java" target="_blank">цієї статті</a> .
<h2>5. Розкажіть про Queue</h2><span class="text-bold">Queue</span> - інтерфейс, що відповідає за структури, які організовані у вигляді черги - структури даних, що зберігає елементи послідовно. Наприклад, із черги людей першою зайде людина, яка прийшла раніше за інших, останнім — той, хто прийшов пізніше за всіх. Цей спосіб називається - <span class="text-bold">FIFO</span> , тобто <span class="text-bold">First in First Out</span> . Унікальні методи <span class="text-bold">Queue</span> спрямовані на роботу з першим або останнім елементом, наприклад:
<ul>
 <li><span class="text-bold">add</span> і <span class="text-bold">offer</span> - вставляє елемент у кінець черги,</li>
 <li><span class="text-bold">remove</span> — витягує та видаляє заголовок цієї черги,</li>
 <li><span class="text-bold">peek – витягує, але не видаляє заголовок черги.</span></li>
</ul><a href="https://codegym.cc/groups/posts/2988-chto-mogut-sprositjh-na-sobesedovanii-strukturih-dannihkh-v-java-chastjh-2" target="_blank">ЧАСТИНА 2</a><a href="https://codegym.cc/welcome" target="_blank"><img id="click_banner1_articles" data-max-width="1080" data-id="e2f93d4b-45ef-4c5b-827f-50c6f38bcfe8" alt="Що можуть запитати на співбесіді: структури даних Java.  Частина 1 - 5" src="https://cdn.javarush.com/images/article/e2f93d4b-45ef-4c5b-827f-50c6f38bcfe8/1080.jpeg" style="width: 1080px;"></a>