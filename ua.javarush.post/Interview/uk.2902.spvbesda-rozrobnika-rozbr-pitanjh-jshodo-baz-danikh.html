Співбесіда розробника: розбір питань щодо баз даних
<p>----------------------------------------</p>
Всім привіт! Всі ми тут б'ємося над однією метою стати -ами. Мабуть, найважливіший етап на шляху становлення — технічна співбесіда. Як правило, співбесідник проходить по основним темам, ставлячи з кількох питань. У цій статті ми поговоримо 
<p>----------------------------------------</p>
Всім привіт! Всі ми тут б'ємося над однією метою стати <span class="text-bold">Java Developer</span> -ами. Мабуть, найважливіший етап на шляху становлення — технічна співбесіда. Як правило, співбесідник проходить по основним темам, ставлячи з кількох питань. У цій статті ми поговоримо про одну з таких ключових тем - <span class="text-bold">бази даних</span> . Розглянемо найчастіші питання та спробуємо відповісти на них без глибокого занурення у матеріал, адже у такому разі нам і обсягу книги не вистачить! Тож поїхали.<img data-max-width="800" data-id="5dcc2bb3-08f0-447a-a77f-83c55b370b79" alt="Співбесіда розробника: розбір питань щодо баз даних - 1" src="https://cdn.javarush.com/images/article/5dcc2bb3-08f0-447a-a77f-83c55b370b79/800.jpeg" style="width: 800px;">
<h2>1. Що таке бази даних? На які типи вони поділяються?</h2>
<h4>Що мається на увазі під СУБД?</h4><img data-max-width="512" data-id="a52210bf-cabd-4bad-a879-afa5f2777567" alt="Співбесіда розробника: розбір питань щодо баз даних - 2" src="https://cdn.javarush.com/images/article/a52210bf-cabd-4bad-a879-afa5f2777567/512.jpeg" style="width: 512px;"><span class="text-bold">База даних (БД)</span> - це організована структура, призначена для зберігання, зміни та обробки взаємопов'язаної інформації переважно більших обсягів. Іншими словами, БД – це структуроване сховище даних. Наприклад телефонна книга.
<h4>Типи БД</h4>
<ol>
 <li><span class="text-bold">Реляційна база даних</span> - це набір даних із зумовленими зв'язками між ними. Дані зберігаються як набору таблиць, що з стовпців і рядків. У таблицях зберігається інформація про об'єкти, які у базі даних. У кожному стовпчику таблиці зберігається певний тип даних, у кожному осередку — значення атрибута.</li>
 <li><span class="text-bold">Нереляційні системи (NoSQL)</span> - системи, створені для певних моделей даних, що мають гнучкі схеми. Інакше висловлюючись, це БД, які зберігають дані над вигляді табличних схем, рядків і стовпців, а інших форматах.</li>
</ol>Докладніше про нереляційні бази даних можна прочитати в цій статті: <a href="https://codegym.cc/groups/posts/467-rukovodstvo-po-nosql-dlja-razrabotchikov-" target="_blank">Посібник з NoSQL для розробників</a> . <span class="text-bold">Система управління базами даних (СУБД)</span> - це сукупність програмного забезпечення, за допомогою якого користувач може створювати бази даних (БД) і проводити над ними різні операції: доповнювати, оновлювати, видаляти, вибирати і т. д. СУБД гарантує збереження, цілісність безпеку зберігання даних та дозволяє видавати доступ до адміністрування БД. Як приклад можна навести MySql - це СУБД, що надає доступ до реляційної бази даних або MongoDB для нереляційної.
<h2>2. Що таке нормалізація? Нормалізована форма? Скільки форм нормалізації існує? Назвіть перші три.</h2><span class="text-bold">Нормалізація</span> - це процес організації, структуризації даних у базі, який забезпечує велику гнучкість бази даних за рахунок виключення надмірності та неузгодженості залежностей. <span class="text-bold">Нормальна форма</span> - властивість таблиці, що розглядається в контексті нормалізації, що характеризує таблицю з погляду простоти та правильності побудови структури. Нормальна форма окреслюється сукупність вимог, яким має задовольняти таблиця. Усього існує шість нормальних форм, але на практиці застосовуються не більше перших трьох:
<ol>
 <li>Перша нормальна форма: 
  <ul>
   <li>Усі атрибути прості (тобто атомарні та неподільні);</li>
   <li>Усі дані скалярні (тобто позитивні);</li>
   <li>Немає рядків, що повторюються (для цього для кожного рядка створюється первинний ключ).</li>
  </ul></li>
 <li>Друга нормальна форма: 
  <ul>
   <li>Дотримано умов першої нормальної форми;</li>
   <li>Кожен неключовий атрибут посилається на первинний ключ.</li>
  </ul></li>
 <li>Третя нормальна форма: 
  <ul>
   <li>Дотримано умов другої нормальної групи;</li>
   <li>Неключові поля не залежать від інших полів: вони можуть бути пов'язані лише з первинним ключем.</li>
  </ul></li>
</ol>
<h2>3. Денормалізація</h2><span class="text-bold">Денормалізація</span>— навмисне зниження чи порушення форм нормалізації бази даних, зазвичай — щоб прискорити читання з бази з допомогою додавання надлишкових даних. Загалом це процес, зворотний до нормалізації. Так відбувається тому, що теорія нормальних форм не завжди застосовується на практиці. Наприклад, не атомарні значення не завжди «зло»: іноді навіть навпаки. У деяких випадках необхідне додаткове об'єднання під час виконання запитів, особливо під час обробки великого масиву інформації. У результаті це може покращити продуктивність. Для баз даних, призначених для аналітики, часто виконують денормалізацію, щоб прискорити виконання запитів. Наприклад, у вас часто буде проводитись вибірка деяких даних для звітів, де неключові колонки будуть пов'язані між собою.
<h2>4. Індекси</h2><span class="text-bold">Індекс</span> - відсортований набір значень, пов'язаних з таблицею або поданням з конкретною колонкою, що прискорює отримання даних. Тобто це такий собі покажчик: як алфавіт у телефонній книзі, який допомагає нам при пошуку на прізвище. Якщо використовувати цю можливість правильно, можна підвищити продуктивність під час роботи з великими базами даних. А можна і сильно знизити. Щоб прискорити пошук, ці ключі зберігаються у вигляді структури збалансованого дерева, за яким виконується пошук. Як правило індекси потрібно вводити на поля, якими найчастіше ведеться пошук. Замислюватися про створення індексу потрібно не раніше, ніж у вас з'явиться хоча б 10 тисяч записів. В іншому випадку ви не побачите помітного результату, бо передчасна оптимізація — <span class="text-bold">ЗЛО</span>. І як індекс може вдарити по продуктивності системи, запитаєте ви? При вставці нових даних або видаленні старих структура збалансованого дерева буде знову перераховуватися. Власне, що більше даних та індексів, то більше дерев потрібно перерахувати. Уявіть ситуацію: у вас є близько 20 000 записів та 7 індексів на цю таблицю. Тобто при вставці даних потрібно заново перерахувати 7 дерев, у кожному з яких по 20 000 записів. Строго кажучи, використовувати індекси для таблиць, в які часто додаватимуться/видалятимуться дані, і зовсім не рекомендується. Насамкінець зазначу те, що індекси для стовпців, в яких часто зустрічається значення <code class=" language-none">null</code>, будуть не такі ефективні, тому не варто їх додавати на такі колонки.
<h2>У чому різниця між кластеризованим та некластеризованим індексами в SQL?</h2>
<h4>Кластеризований:</h4>
<ul>
 <li>Забезпечує фізичний порядок обраним полем;</li>
 <li>Якщо таблиця має кластеризований індекс, вона називається кластеризованою;</li>
 <li>Потрібно трохи більше одного індексу на таблицю;</li>
 <li>MySQL кластеризований індекс не задається явно користувачем, так як якщо ви не визначаєте PRIMARY KEY для своєї таблиці, MySQL знаходить перший індекс <code class=" language-none">UNIQUE</code>, де всі ключові стовпці - <code class=" language-none">NOT NULL</code>, і InnoDB використовує його як кластеризований індекс.</li>
</ul>
<h4>Некластеризований:</h4>
<ul>
 <li>В одній таблиці можливе до 999 некластеризованих індексів;</li>
 <li>Містить покажчик на рядки з реальними даними у таблиці;</li>
 <li>Чи не забезпечує фізичний порядок;</li>
 <li>Для некластеризованих індексів присутні окремі таблиці з відсортованими даними, а саме одна таблиця для одного стовпця, на якому індекс, тому при запиті даних, що не входять до складу даного поля, спочатку виконуватиметься запит до поля в даній таблиці, а тільки потім додатковий запит до рядка у початковій таблиці.</li>
</ul>Створення некластеризованого індексу: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class="  language-java">CREATE INDEX index_name <span class="token class-name"><span class="token class-name">ON</span></span> <span class="token function"><span class="token function">table_name</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>column_name<span class="token punctuation"><span class="token punctuation">)</span></span></code></pre>
<h2>6. Що таке складовий індекс?</h2><span class="text-bold">Складовий індекс</span> - побудований з посиланням на кілька колонок одночасно. Інакше висловлюючись, це комплексний індекс, що з кількох колонок. Такі індекси використовують, коли в одному запиті фігурує більше однієї колонки. Створення складового індексу: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class="  language-java">CREATE INDEX index_name <span class="token class-name"><span class="token class-name">ON</span></span> <span class="token function"><span class="token function">table_name</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>first_column_name<span class="token punctuation"><span class="token punctuation">,</span></span> second_column_name<span class="token punctuation"><span class="token punctuation">,</span></span> third_column_name<span class="token punctuation"><span class="token punctuation">)</span></span></code></pre> Як правило, ці індекси використовуються, коли дані в декількох стовпцях логічно взаємопов'язані.
<h2>7. Що таке індекс, що покриває? Унікальний індекс?</h2><span class="text-bold">Покриваючий індекс</span> - це індекс, якого цілком достатньо для відповіді на запит без звернення до таблиці. За цим індексом можна дістати весь рядок даних, але це просто не потрібно. Завдяки тому, що не потрібно ходити безпосередньо у вихідну таблицю, а відповісти можна, використовуючи лише індекс, що покриває індекси трохи швидше у використанні. При цьому не варто забувати, що чим більше колонок, тим громіздкішим і повільнішим стає сам індекс. Тож зловживати цим не варто. Вище ми говорабо про кластеризовані та некластеризовані індекси, які можуть бути <span class="text-bold">унікальними</span>. Це означає, що жодні дві поля не мають значення для ключа індексу. В іншому випадку індекс не буде унікальним, адже кілька рядків можуть містити те саме значення. Приклад створення унікального некластеризованого індексу: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class="  language-java">CREATE UNIQUE INDEX index_name <span class="token class-name"><span class="token class-name">ON</span></span> <span class="token function"><span class="token function">table_name</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>column_name<span class="token punctuation"><span class="token punctuation">)</span></span></code></pre>
<h2>8. Що таке первинний ключ</h2><span class="text-bold">Первинний ключ (Primary key)</span> — поле таблиці для ідентифікації кожного рядка в таблиці бази даних. У таблиці може бути тільки одне таке поле, і всі значення мають бути унікальними. Нічого не нагадало? <img data-max-width="512" data-id="20a8ee18-58e1-4013-ac6e-e8c2698f5e1a" alt="Співбесіда розробника: розбір питань щодо баз даних - 3" src="https://cdn.javarush.com/images/article/20a8ee18-58e1-4013-ac6e-e8c2698f5e1a/512.jpeg" style="width: 512px;">Адже первинний ключ — ніщо інше, як <span class="text-bold">унікальний кластеризований</span> індекс. Як правило, первинні ключі створюються при закладі таблиці: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class="  language-java">CREATE <span class="token class-name"><span class="token class-name">TABLE</span></span> <span class="token function"><span class="token function">table_name</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>
column_name <span class="token keyword"><span class="token keyword">int</span></span> <span class="token class-name"><span class="token class-name">PRIMARY</span></span> KEY<span class="token punctuation"><span class="token punctuation">,</span></span>
…<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token punctuation"><span class="token punctuation">)</span></span></code></pre> До цієї колонки автоматично додасться обмеження - <code class=" language-none">NOT NULL</code>. Також можна встановити ключ і для вже створеної таблиці: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class="  language-java">ALTER TABLE table_name ADD <span class="token class-name"><span class="token class-name">PRIMARY</span></span> KEY <span class="token punctuation"><span class="token punctuation">(</span></span>column_name<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> Якщо первинний ключ додається способом, описаним вище, значення полів, що задаються як первинний ключ ( <code class=" language-none">column_name</code>), перевіряються на відсутність нульових (також буде додано обмеження — <code class=" language-none">NOT NULL</code>).
<h2>Що таке ключ?</h2><span class="text-bold">Зовнішній ключ (Foreign key)</span> — це властивість, створювана у тому, щоб забезпечити зв'язок між таблицями. Як правило, зовнішній ключ встановлюється для стовпців у підпорядкованій таблиці та вказує на один із стовпців із головної таблиці. Може задаватися як при створенні таблиці: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><code class="  language-java">CREATE TABLE table_name<span class="token punctuation"><span class="token punctuation">{</span></span>
column_name <span class="token keyword"><span class="token keyword">int</span></span><span class="token punctuation"><span class="token punctuation">,</span></span>
…<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>
<span class="token class-name"><span class="token class-name">FOREIGN</span></span> <span class="token function"><span class="token function">KEY</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>column_name<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token class-name"><span class="token class-name">REFERENCES</span></span> <span class="token function"><span class="token function">another_table_name</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>another_table_column_name<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> Так і після створення таблиці: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class="  language-java">ALTER TABLE table_name
ADD <span class="token class-name"><span class="token class-name">FOREIGN</span></span> <span class="token function"><span class="token function">KEY</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>column_name<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token class-name"><span class="token class-name">REFERENCES</span></span> <span class="token function"><span class="token function">another_table_name</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>another_table_column_name<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> Можна встановити поведінка зовнішнього ключа при маніпуляціях із полем, яким він посилається. Маніпуляції можуть бути виду <code class=" language-none">ON DELETE</code>та <code class=" language-none">ON UPDATE</code>. Можливі варіанти поведінки:
<ul>
 <li><code class=" language-none">CASCADE</code>— із цією властивістю будуть автоматично видалені або змінені рядки із залежної таблиці при видаленні або зміні зв'язаних рядків у головній таблиці;</li>
 <li><code class=" language-none">SET NULL</code>— при даній властивості, коли відбувається видалення або оновлення рядка з головної таблиці, буде встановлюватися значення <code class=" language-none">NULL</code>для стовпця зовнішнього ключа;</li>
 <li><code class=" language-none">NO ACTION</code>— відхиляє спроби видалити або змінити рядки в головній таблиці, якщо є зв'язані рядки в залежній таблиці;</li>
 <li><code class=" language-none">RESTRICT</code>- Еквівалентно <code class=" language-none">NO ACTION</code>;</li><code class=" language-none">SET DEFAULT</code>— при даній властивості, коли відбувається видалення або оновлення зв'язаного рядка з головної таблиці, буде встановлено значення за замовчуванням (якщо воно є) для стовпчика зовнішнього ключа.
</ul>Приклад використання: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><code class="  language-java">CREATE TABLE table_name<span class="token punctuation"><span class="token punctuation">{</span></span>
column_name <span class="token keyword"><span class="token keyword">int</span></span><span class="token punctuation"><span class="token punctuation">,</span></span>
…<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>
<span class="token class-name"><span class="token class-name">FOREIGN</span></span> <span class="token function"><span class="token function">KEY</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>column_name<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token class-name"><span class="token class-name">REFERENCES</span></span> <span class="token function"><span class="token function">another_table_name</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>another_table_column_name<span class="token punctuation"><span class="token punctuation">)</span></span> ON UPDATE CASCADE ON DELETE CASCADE <span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> Якщо не буде явно задано поведінку для <code class=" language-none">ON DELETE</code>і <code class=" language-none">ON UPDATE</code>, то встановлюватиметься поведінка <code class=" language-none">RESTRICT</code>.
<h2>10. Типи з'єднань між таблицями (Join)</h2>Зв'язок між таблицями забезпечується з урахуванням загальних даних (полів). Це відбувається за допомогою оператора <code class=" language-none">JOIN</code>— операції, яка зіставляє рядки з таблиці з рядками в інший. Зіставлення виконується те щоб стовпці обох таблиць розташовувалися поруч, хоча їх можна з окремих таблиць. І якщо ми маємо спільні поля для трьох таблиць, ми можемо вивести їх дані у вигляді однієї загальної таблиці. Тим не менш, варто враховувати, що чим менше таблиць об'єднується, тим швидше виконуватиметься запит. Отже, види <code class=" language-none">JOIN</code>:
<ul>
 <li><code class=" language-none">INNER JOIN</code>— з'єднання, яке показує лише дані з першої таблиці, яким відповідають деякі дані з другої таблиці. Інші - опускаються.<img data-max-width="512" data-id="925b9b60-f8f3-424f-8414-55db2ae0b857" alt="Співбесіда розробника: розбір питань щодо баз даних - 4" src="https://cdn.javarush.com/images/article/925b9b60-f8f3-424f-8414-55db2ae0b857/512.jpeg" style="width: 512px;"></li>
 <li><code class=" language-none">LEFT JOIN</code>— з'єднання, яке показує всі дані з першої таблиці та відповідні дані з другої, якщо вони є. Якщо відповідних даних немає, поля для даних з другої таблиці будуть порожніми.<img data-max-width="512" data-id="437072f8-77ca-4917-9bce-d93b2a31346c" alt="Співбесіда розробника: розбір питань щодо баз даних - 5" src="https://cdn.javarush.com/images/article/437072f8-77ca-4917-9bce-d93b2a31346c/512.jpeg" style="width: 512px;"></li>
 <li><code class=" language-none">RIGHT JOIN</code>— з'єднання, яке показує всі дані з другої таблиці та відповідні дані з першої, якщо вони є. Якщо відповідних даних немає, поля для даних з першої таблиці будуть порожніми.<img data-max-width="512" data-id="7ac00cb1-70a1-4ec0-bb99-e326e1b9b2f4" alt="Співбесіда розробника: розбір питань щодо баз даних - 6" src="https://cdn.javarush.com/images/article/7ac00cb1-70a1-4ec0-bb99-e326e1b9b2f4/512.jpeg" style="width: 512px;"></li>
 <li><code class=" language-none">FULL JOIN</code>- З'єднання, яке показує всі дані з першої та другої таблиці. Якщо пов'язаних даних в іншій таблиці немає, поля цих даних будуть порожніми.<img data-max-width="512" data-id="72c19e8c-0685-4275-bbea-2f8d8f31515c" alt="Співбесіда розробника: розбір питань щодо баз даних - 7" src="https://cdn.javarush.com/images/article/72c19e8c-0685-4275-bbea-2f8d8f31515c/512.jpeg" style="width: 512px;"></li>
 <li><code class=" language-none">CROSS JOIN</code>- перехресне з'єднання, при якому кожен рядок першої таблиці з'єднується з кожним рядком другої таблиці (кожний з кожної). Тобто, якщо у двох таблицях по 3 рядки, після цього з'єднання ми отримаємо результат із 9 рядків.<img data-max-width="512" data-id="6afa166b-058d-4389-ba72-037af308b714" alt="Співбесіда розробника: розбір питань щодо баз даних - 8" src="https://cdn.javarush.com/images/article/6afa166b-058d-4389-ba72-037af308b714/512.jpeg" style="width: 512px;"></li>
</ul>Приклад <code class=" language-none">Join(inner)</code>: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class="  language-java">SELECT <span class="token operator"><span class="token operator">*</span></span>
FROM first_table
INNER JOIN second_table ON first_table<span class="token punctuation"><span class="token punctuation">.</span></span>some_column <span class="token operator"><span class="token operator">=</span></span> second_table<span class="token punctuation"><span class="token punctuation">.</span></span>some_column</code></pre>
<h2>11. Що таке властивість ACID у базі даних?</h2><span class="text-bold">A — Атомарність</span> гарантує, що ніяка транзакція не фіксується в системі частково. Виконуються або її підоперації, або жодної. Наприклад, переказ грошей у банку на інший рахунок — це дві операції:
<ol>
 <li>Переказати гроші на рахунок банку.</li>
 <li>Переказати гроші з рахунку банку на конкретний рахунок.</li>
</ol>Але може всяке трапитися. Наприклад, надійдуть до банку, а далі випаде якась помилка, і друга операція не виконається. Або навпаки: виконається лише друга операція. Тому ці дії здійснюються в рамках однієї транзакції, і в результаті все або нічого. <span class="text-bold">С — Узгодженість</span> : кожна успішна транзакція завжди фіксує лише результати, що дозволяються. Це гарантує, що всі обмеження будуть дотримані (наприклад, <code class=" language-none">NOT NULL</code>), інакше транзакція відкотиться. <span class="text-bold">І - ізольованість</span>: під час виконання транзакції паралельні транзакції не повинні впливати на результат. Це дає можливість приховувати від усіх не кінцеві стану даних. Власне тому неуспішні транзакції не можуть нічого зламати. Трохи нижче ми ознайомимося із рівнями ізольованості транзакцій. <span class="text-bold">Д - довговічність</span> : якщо транзакція виконана, то можна бути впевненим, що внесені нею зміни не скасовуються через будь-який збій.
<h2>12. Рівні ізольованості транзакцій</h2>Кожен рівень ізольованості дозволяє/забороняє певні дії (можливості):
<ul>
 <li><span class="text-bold">фантомне читання</span> — у межах однієї транзакції той самий запит даних дає різні результати, що відбувається через додавання даних іншою (паралельною) транзакцією.</li>
 <li><span class="text-bold">неповторне читання</span> — в рамках однієї транзакції той самий запит даних дає різні результати, що відбувається через зміну або видалення даних іншою (паралельною) транзакцією.</li>
 <li><span class="text-bold">"брудне" читання</span> - читання даних, доданих або змінених транзакцією, яка згодом не відкотиться;</li>
 <li><span class="text-bold">втрачене оновлення</span> - при одночасному зміні одного блоку даних різними транзакціями втрачаються всі зміни, крім останнього (схоже на стан гонки в багатопоточності).</li>
</ul>Для зручності розглянемо рівні ізоляцій та їх можливості в таблиці:
<div class="table-container">
 <table>
  <tbody>
   <tr align="center">
    <td>Рівні ізоляцій</td>
    <td>Фантомне читання</td>
    <td>Неповторне читання</td>
    <td>"брудне" читання</td>
    <td>втрачене оновлення</td>
   </tr>
   <tr align="center">
    <td>SERIALIZABLE</td>
    <td>+</td>
    <td>+</td>
    <td>+</td>
    <td>+</td>
   </tr>
   <tr align="center">
    <td>REPEATABLE_READ</td>
    <td>-</td>
    <td>+</td>
    <td>+</td>
    <td>+</td>
   </tr>
   <tr align="center">
    <td>READ_COMMITTED</td>
    <td>-</td>
    <td>-</td>
    <td>+</td>
    <td>+</td>
   </tr>
   <tr align="center">
    <td>READ_UNCOMMITTED</td>
    <td>-</td>
    <td>-</td>
    <td>-</td>
    <td>+</td>
   </tr>
  </tbody>
 </table>
</div>
<h2>13. Що таке SQL-ін'єкція?</h2><span class="text-bold">SQL-ін'єкція</span> - один із способів злому сайту, суть якого - впровадження в дані через <code class=" language-none">GET</code>, <code class=" language-none">POST</code>запити або Cookie деякого SQL коду. Якщо веб-сайт виконує такі ін'єкції, можна отримати доступ до БД та зламати програму. Наприклад, ми знаємо ім'я деякої змінної. Допустимо, <code class=" language-none">column_name</code>з типом <code class=" language-none">boolean</code>. Якщо система сприйнятлива ін'єкцій, можна додати <code class=" language-none">OR column_name=true</code>і після цього писати все, що нам потрібно від БД. <code class=" language-none">OR</code>створить умову АБО, і наш вираз після нього буде завжди <code class=" language-none">true</code>, що і пропустить нас далі. Атака на сайт на зразок ін'єкції SQL можлива через неправильну обробку вхідних даних, що використовуються в SQL-запитах. При з'єднанні з базою даних за допомогою <a href="https://codegym.cc/groups/posts/2172-jdbc-ili-s-chego-vsje-nachinaetsja" target="_blank">JDBC</a> ви використовуєте різні<code class=" language-none">Statements</code>. Для підвищення безпеки необхідно використовувати <code class=" language-none">PreparedStatement</code>замість звичайного <code class=" language-none">Statement</code>, оскільки при використанні <code class=" language-none">Statement</code>рядка запиту та значень просто складаються, уможливлюючи ін'єкції. У свою чергу, <code class=" language-none">PreparedStatement</code>є конкретний шаблон запиту, і дані в нього вставляються з відображенням лапок. У результаті SQL-ін'єкції сприйматимуться лише як рядкове уявлення якогось поля. Для захисту від SQL-ін'єкцій можна використовувати перевірку на основі регулярних виразів (докладніше про регулярні вирази можна почитати <a href="https://codegym.cc/groups/posts/regulyarnye-vyrazheniya-v-java" target="_blank">у цій статті</a> ). <img data-max-width="1024" data-id="355cb1cd-e787-4995-8d5f-008f4800fffe" alt="Співбесіда розробника: розбір питань щодо баз даних - 9" src="https://cdn.javarush.com/images/article/355cb1cd-e787-4995-8d5f-008f4800fffe/1024.jpeg" style="width: 1024px;">Ще варіант — встановити обмеження на кількість символів вхідних параметрів: наприклад, якщо вам має приходити число не більше 9999, підійде обмеження чотирьох вхідних символів. Воно зменшить ризик злому за допомогою SQL-ін'єкцій.<a href="https://codegym.cc/welcome" target="_blank"><img id="click_banner3_1_articles" data-max-width="1080" data-id="b9898661-622a-4fc6-a614-96edeb9ee766" alt="Співбесіда розробника: розбір питань щодо баз даних - 10" src="https://cdn.javarush.com/images/article/b9898661-622a-4fc6-a614-96edeb9ee766/1080.jpeg" style="width: 1080px;"></a>Докладніше про безпеку Java можна дізнатися зі статті <a href="https://codegym.cc/groups/posts/2713-bezopasnostjh-v-java-best-practices" target="_blank">“Безпека Java: best practices”</a> .
<h2>14. Що таке процедури, що зберігаються? Зберігаються функції? Тригер?</h2><span class="text-bold">Збережені процедури в SQL</span> - сутність у БД, що є набором SQL-інструкцій, який компілюється один раз і зберігається на сервері. Словом, це аналог методів Java. Процедури, що зберігаються, можуть виконувати дії над даними як звичайні запити, так і деякі дії, недоступні для звичайних запитів. Процедура є суть SQL, яку створюють один раз, а потім викликають, передаючи аргументи. Плюс цього підходу полягає в тому, що ці інструкції можна перевикористовувати не раз. Збережені процедури збільшують продуктивність, розширюють можливості програмування та підтримують функції безпеки даних. Розглянемо створення процедури: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><code class="  language-java">CREATE <span class="token class-name"><span class="token class-name">PROCEDURE</span></span> procedure_name <span class="token punctuation"><span class="token punctuation">(</span></span>first_param some_type<span class="token punctuation"><span class="token punctuation">,</span></span> second_param some_type<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
 begin
……<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>
 end</code></pre> Виклик процедури: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">CALL</span></span> procedure_name <span class="token punctuation"><span class="token punctuation">(</span></span>first_param<span class="token punctuation"><span class="token punctuation">,</span></span> second_param…<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre><span class="text-bold">Зберігається функція</span> - це різновид процедури, що зберігається. Відмінність функції у тому, що вона завжди повертає лише одиничне значення, а процедура — набір значень. Збережені процедури не можна змішувати зі звичайним SQL, тоді як із збереженою функцією це можна — і це її перевага. З іншого боку, у функцій, що зберігаються, набагато більше обмежень, ніж у процедур. Створення функції, що зберігається: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java">CREATE <span class="token class-name"><span class="token class-name">FUNCTION</span></span> function_name <span class="token punctuation"><span class="token punctuation">(</span></span>first_param<span class="token punctuation"><span class="token punctuation">,</span></span> second_param…<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
RETURNS some_type
 begin
……<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>
<span class="token class-name"><span class="token class-name">RETURN</span></span> some_value<span class="token punctuation"><span class="token punctuation">;</span></span>
end</code></pre> Виклик функції, що зберігається: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">SELECT</span></span> <span class="token function"><span class="token function">function_name</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>first_param<span class="token punctuation"><span class="token punctuation">,</span></span> second_param…<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre><span class="text-bold">Тригер</span> — ще один різновид процедури, що зберігається, яка викликається не безпосередньо користувачем, а її активація відбувається при модифікації даних. Тобто ця процедура активується при виконанні деяких умов, як, наприклад, <code class=" language-none">INSERT</code>, <code class=" language-none">DELETE</code>або <code class=" language-none">UPDATE</code>даних у певному стовпці даної таблиці. Момент запуску тригера визначається за допомогою ключових слів <code class=" language-none">BEFORE</code>(тригер запускається до пов'язаної події) або <code class=" language-none">AFTER</code>(після події). 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java">CREATE TRIGGER trigger_name
ON table_name
AFTER INSERT
 begin
……<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>
 end</code></pre>
<h2>15. Практика</h2>Як би там не було, найчастішим SQL-питанням на співбесіді буде практика вирішення завдань. Намагатися вгадати, які саме вам трапляться завдання, безглуздо, адже все залежить від витонченості фантазії людини навпроти. Тому єдиним робочим варіантом буде набивання руки на SQL-запитах різної складності. Як ресурс для практики на різних завданнях може послужити <a href="https://www.sql-ex.ru/">sql-ex.ru</a> . Вже після перших двадцяти виконаних тяган вашому співрозмовнику буде досить складно налякати вас яким-небудь SQL-завданням. <img data-max-width="1024" data-id="df78001b-c3b9-4efb-93e3-3c2797c37a9f" alt="Співбесіда розробника: розбір питань щодо баз даних - 11" src="https://cdn.javarush.com/images/article/df78001b-c3b9-4efb-93e3-3c2797c37a9f/1024.jpeg" style="width: 1024px;">На цьому сьогодні все: сподіваюся, після прочитання цієї статті питання щодо баз даних не викличуть жодних складнощів та проблем. Дякуємо за увагу і до нових зустрічей!