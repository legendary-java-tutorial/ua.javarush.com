Запитання на співбесіду Hibernate
<p>----------------------------------------</p>
Ця стаття є перекладом та покращенням зарубіжних статей (список ресурсів перерахований наприкінці статті). Відповіді деякі питання розширено, представлені посилання сторонні ресурси які містять відповіді які можуть виникнути у процесі читан
<p>----------------------------------------</p>
Ця стаття є перекладом та покращенням зарубіжних статей (список ресурсів перерахований наприкінці статті). Відповіді деякі питання розширено, представлені посилання сторонні ресурси які містять відповіді які можуть виникнути у процесі читання. 1) Що таке Hibernate? Це фреймворк для об'єктно-реляційного відображення сутностей у традиційній реляційній базі даних. Основні можливості фреймворку: 1) Автоматична генерація та оновлення таблиць у базах даних; 2) Оскільки основні запити до бази даних (збереження, оновлення, видалення та пошук) представлені як методи фрейморка, то значно скорочується код, який пишеться розробником; 3) Забезпечує використання SQL подібної мови (HQL - hibernate query language). Запити HQL може бути записані поруч об'єктами даних (POJO класи підготовлені до роботи з базою даних). 2) Як<a href="https://codegym.cc/groups/posts/520-vashe-pervoe-prilozhenie-na-hibernate" target="_blank">Hibernate</a>допомагає у програмуванні? Hibernate реалізує ряд фіч, які значно спрощують роботу розробника. — Однією з таких фіч є те, що hibernate дозволяє розробнику уникнути написання більшості SQL запитів (вони вже реалізовані, вам треба просто використовувати методи, які надає фреймворк). — Під бортом у Hibernate є купа корисних інструментів, які значно прискорюють роботу програми, найпримітнішими з них є дворівневе кешування та тонкі налаштування lazy та fetch вилучення. — Сам генерує таблиці до бази даних. 3) Методи зміни роботи з Hibernate. Існує чотири способи конфігурації роботи з Hibernate: - Використовуючи інструкції; - hibernate.cfg.xml; - hibernate.properties; - Persistence.xml. Найчастіший спосіб конфігурації: через анотації та файл persistence.xml, Що стосується файлів hibernate.properties і hibernate.cfg.xml, то hibernate.cfg.xml головніше (якщо додаток є обидва файли, то приймаються налаштування з файлу hibernate.cfg.xml). Конфігурація анотаціями, хоч і зручна, але не завжди можлива, наприклад, якщо для різних баз даних або для різних ситуацій ви хочете мати різні конфігурацію сутностей, слід використовувати xml файли конфігурацій. 4) Які ключові інтерфейси використовує Hibernate? Існує п'ять ключових інтерфейсів, які використовуються в кожному додатку пов'язаному з Hibernate: — Session interface; - SessionFactory interface; - Configuration interface; - Transaction interface; - Query and Criteria interfaces. 5) Яка роль інтерфейсу Session у Hibernate? Session – це основний інтерфейс, який відповідає за зв'язок із базою даних. Так само, він допомагає створювати об'єкти запитів отримання персистентних об'єктів. (персистентний об'єкт — об'єкт, який вже знаходиться в базі даних; об'єкт запиту — об'єкт, який виходить, коли ми отримуємо результат запиту до бази даних, саме з ним працює додаток). Об'єкт Session можна отримати з SessionFactory: Session session = sessionFactory.openSession(); Роль інтерфейсу Session: є обгорткою для jdbc підключення до бази даних; (https://ua.wikipedia.org/wiki/Java_Database_Connectiv..) - є фабрикою для транзакцій (відповідно до офіційної документації transaction - аllows the application to define units of work, що, по суті, означає що транзакція визначає межі операцій пов'язаних з базою даних). - є зберігачем обов'язкового кешу першого рівня. 6) Яка роль інтерфейсу SessionFactory у Hibernate? Саме із об'єкта SessionFactory ми отримуємо об'єкти типу Session. На всю програму існує тільки одна SessionFactory і вона ініціалізується разом зі стартом програми. SessionFactory кешує мета-дату та SQL запити, які часто використовуються додатком під час роботи. Так само воно кешує інформацію, яка була отримана в одній з транзакцій і може бути використана і в інших транзакціях. Об'єкт SessionFactory можна отримати таким зверненням: SessionFactory sessionFactory = configuration.buildSessionFactory(); 7) Які типи колекцій представлені у Hibernate? Bag, Set, List, Map, Array. 8) Що являє собою колекція типу Bag і навіщо вона використовується? Своєї реалізації тип колекції Bag дуже нагадує Set, різниця полягає в тому, що Bag може зберігати значення, що повторюються. Bag зберігає непроіндексований список елементів. Більшість таблиць у базі даних мають індекси, що відображають положення елемента даних один щодо іншого, дані індекси мають подання в таблиці у вигляді окремої колонки. При об'єктно-реляційному мапінгу, значення колонки індексів мапиться на індекс в Array, на індекс у List або на key в Map. Якщо вам потрібно отримати колекцію об'єктів, що не містять дані індекси, то ви можете скористатися колекціями типу Bag або Set (колекції містять дані в невідсортованому вигляді, але можуть бути відсортовані згідно з запитом). 9) Яка різниця у роботі методів load(); та get();? Метод load(); зазвичай використовується коли не впевнений що запитуваний об'єкт вже знаходиться в базі даних. Якщо об'єкт не знайдено, то метод кидає виняток Якщо об'єкт знайдено — метод повертає проксі об'єкт, який є посиланням на об'єкт, що знаходиться в базі даних (запит у базу даних ще не був здійснений, свого роду lazy вилучення), безпосередній запит до бази даних, коли ми безпосередньо звертаємось до необхідного об'єкта через проксі об'єкт. Метод get(); використовується тоді, ви на 100 відсотків не впевнені, чи є запитуваний об'єкт у базі даних. У разі звернення до неіснуючого об'єкта метод get(); поверне null. У разі знаходження об'єкта, метод get(); поверне сам об'єкт і запит до бази даних буде зроблено негайно. 10) Що таке Lazy fetching (вилучення) у Hibernate? Тип вилучення Lazy, в Hibernate, пов'язаний з листовими (дочірніми) сутностями і визначають політику спільного вилучення, якщо йде запит на вилучення сутності батька. Простий приклад: Є суть Будинок. Він зберігає інформацію про свій номер, вулицю, кількість квартир та інформацію про сім'ї, які живуть у квартирах, ці сім'ї формують дочірню сутність щодо сутності Будинок. Коли ми запитуємо інформацію про Будинок, нам може бути зовсім непотрібним знати інформацію сім'ях, які в ньому проживають, тут нам на допомогу приходить lazy (ледаче) вилучення (fetching), яка дозволяє конфігурувати сутність Будинку, щоб інформацію про сім'ї подавалася тільки на запит, це значно одягає запит і прискорює роботу програми. ©dev-bay нам може бути зовсім непотрібним знати інформацію сім'ях, які в ньому проживають, тут нам на допомогу приходить lazy (ледаче) вилучення (fetching), яка дозволяє сконфігурувати сутність Будинок, щоб інформацію про сім'ї подавалася тільки на запит, це значно вкриває запит і прискорює роботу програми. ©dev-bay нам може бути зовсім непотрібним знати інформацію сім'ях, які в ньому проживають, тут нам на допомогу приходить lazy (ледаче) вилучення (fetching), яка дозволяє сконфігурувати сутність Будинок, щоб інформацію про сім'ї подавалася тільки на запит, це значно вкриває запит і прискорює роботу програми. ©dev-bay