Рівень 32. Відповіді на запитання до співбесіди на тему рівня
<p>----------------------------------------</p>
Навіщо потрібен RandomAccessFile? RandomAccessFile- клас пакету Java IO API, він дозволяє переміщатися файлом, читати з нього або писати в нього, як вам буде завгодно. Ви також зможете замінити існуючі частини файлу, йдеться про оновлення в
<p>----------------------------------------</p>
<img data-id="631dc277-e224-4765-a807-e68aa22362ea" data-max-width="850" alt="Рівень 32. Відповіді на запитання до співбесіди на тему рівня - 1" src="https://cdn.javarush.com/images/article/631dc277-e224-4765-a807-e68aa22362ea/800.jpeg" style="width: 850px;">
<ol>
 <li>
  <p><strong>Навіщо потрібен <code class=" language-none">RandomAccessFile</code>?</strong></p>
  <p><code class=" language-none">RandomAccessFile</code>- клас пакету Java IO API, він дозволяє переміщатися файлом, читати з нього або писати в нього, як вам буде завгодно. Ви також зможете замінити існуючі частини файлу, йдеться про оновлення вмісту файлу, а точніше про оновлення фрагмента файлу. Це неможливо зробити за допомогою <code class=" language-none">FileInputStream</code>або <code class=" language-none">FileOutputStream</code>, але <code class=" language-none">RandomAccessFile</code>дасть вам цю можливість.</p>
  <p>Посилання: <a href="https://devcolibri.com/%D1%83%D1%80%D0%BE%D0%BA-4-randomaccessfile-%D0%B8-%D0%B5%D0%B3%D0%BE-%D0%B2%D0%BE%D0%B7%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8/" rel="nofollow" target="_blank">RandomAccessFile та його можливості</a></p></li>
 <li>
  <p><strong>Що буде, якщо файл, звідки читає <code class=" language-none">RandomAccessFile</code>, не існує?</strong></p>
  <p>Буде<code class=" language-none">FileNotFoundException</code></p></li>
 <li>
  <p><strong>Що буде, якщо файл, куди пише <code class=" language-none">RandomAccessFile</code>, не існує?</strong></p>
  <p>Створить новий і запише до нього.</p></li>
 <li>
  <p><strong>Навіщо потрібен клас <code class=" language-none">StringReader</code>?</strong></p>
  <p>The Java.io.StringReader class is a character stream whose source is a string.</p>
  <p>Являє собою потік символів, чиє джерело називається рядком</p></li>
 <li>
  <p><strong>Навіщо потрібен клас <code class=" language-none">StringWriter</code>?</strong></p>
  <p><code class=" language-none">public class StringWriter</code><br><code class=" language-none">extends Writer</code></p>
  <p>Character stream, що з'єднує його відправлення в string buffer, який може бути використаний до структури string.</p>
  <p>Подивіться на StringWriter не має ефекту. Методи в цій категорії можуть бути названі після stream, які були заблоковані без generating IOException.</p>
  <p>Потік символів, що збирає свій потік у буфер рядків, які потім можуть бути використані для створення рядка.</p></li>
 <li>
  <p><strong>Навіщо потрібен клас <code class=" language-none">ByteArrayStream</code>?</strong></p>
  <p>Отже, <code class=" language-none">ByteArrayInputStream</code>і <code class=" language-none">ByteArrayOutputStream</code>.</p>
  <p>Ці класи по суті чимось схожі на <code class=" language-none">StringReader</code>і<code.stringwriter>
    &lt; code=""&gt;. Тільки 
    <code class=" language-none">StringReader</code>читав символи (char) із рядка (String), а 
    <code class=" language-none">ByteArrayInputStream</code>читає байти із масиву байт (ByteArray).
   </code.stringwriter>&lt;&gt;</p>
  <p><code class=" language-none">StringWriter</code>писав символи (char) у рядок, а <code class=" language-none">ByteArrayOutputStream</code>пише байти в масив байт у нього всередині. При записі в <code class=" language-none">StringWriter</code>рядок усередині нього подовжувалась, а при записі в <code class=" language-none">ByteArrayOutputStream</code>його внутрішній масив байт теж динамічно розширюється.</p></li>
 <li>
  <p><strong>Навіщо потрібен клас <code class=" language-none">PrintStream</code>? Назвіть місця, де використовується?</strong></p>
  <p>Клас <code class=" language-none">PrintStream</code>був придуманий для читального висновку інформації. Він практично весь складається з методів <code class=" language-none">print</code>та <code class=" language-none">println</code>.</p></li>
 <li>
  <p><strong>Навіщо потрібен <code class=" language-none">DynamicProxy</code>?</strong></p>
  <p>У Java є спеціальний клас (java.lang.reflect.Proxy), за допомогою якого фактично можна сконструювати об'єкт під час виконання програми (динамічно), не створюючи для нього окремого класу.</p></li>
 <li>
  <p><strong>Як працює RMI?</strong></p>
  <p>RMI розшифровується Remote Method Invokation – віддалений виклик методів. Або іншими словами RMI - це механізм, який дозволяє об'єкту в одній Java-машині викликати методи об'єкта в іншій Java-машині, навіть якщо вони знаходяться на різних комп'ютерах, у різних країнах, на різних сторонах земної кулі.</p>
  <p>Традиційний підхід до виконання коду на інших машинах, рознесених по мережі, може збентежити через свою нудну і схильну до помилок реалізації. Найкращий спосіб розглянути цю проблему полягає в припущенні, що деякі об'єкти розміщуються на іншій машині, і що ви можете надсилати повідомлення цим віддаленим об'єктам і отримувати результат, начебто вони розміщуються на вашій локальній машині. Це спрощення в точності є тим, що дозволяє робити віддалений виклик методів (RMI) в Java.</p>
  <p>Ось стаття зі створення власної реалізації RMI: <a href="http://javatutor.net/books/tiej/rmi" rel="nofollow" target="_blank">Віддалений виклик методів (RMI)</a></p></li>
 <li>
  <p><strong>Об'єкти яких типів можна передавати RMI?</strong></p>
  <p>Об'єкти мають імплементувати інтерфейс<code class=" language-none">Serializable</code></p>
  <p>Remote method Invocation – механізм, який дозволяє викликати метод віддаленого об'єкта. Згідно з ним, всі операції з підготовки і передачі даних інкапсулюються в методі клієнтського об'єкта-заглушки (stub), що викликається. Сам виклик методу нічим не відрізняється від виклику методу звичайного локального об'єкта, за невеликим винятком:</p>
  <ul>
   <li>локальні об'єкти передаються за значенням (копії);</li>
   <li>при передачі віддаленого ( <code class=" language-none">Remote</code>) об'єкта, якщо він експортований, передається stub цього об'єкта;</li>
   <li>передані об'єкти повинні бути <code class=" language-none">Serializable</code>;</li>
   <li>окрім інших виняткових ситуацій, при виклику віддаленого методу може збуджуватися виняток <code class=" language-none">RemoteException</code>(помилки маршалізації/демаршалізації, передачі даних та інші можливі помилки протоколу);</li>
  </ul>
  <p>Також слід зазначити, що з виклику методу ми працюємо з віддаленим інтерфейсом, а чи не з віддаленим класом.</p></li>
</ol>