Хитрі питання щодо Java, які часто ставлять на співбесідах
<p>----------------------------------------</p>
Якщо ви хоч раз готувалися до співбесіди на посаду або складали будь-який іспит (не обов'язково з програмування) для отримання сертифікату, то, швидше за все, вже встигли помітити, що питання, які там ставлять, дуже специфічні. Багато хто з
<p>----------------------------------------</p>
Якщо ви хоч раз готувалися до співбесіди на посаду <span class="text-bold">Java-програміста</span> або складали будь-який іспит (не обов'язково з програмування) для отримання сертифікату, то, швидше за все, вже встигли помітити, що питання, які там ставлять, дуже специфічні. Багато хто з них змушує подумати над архітектурою мови, деякі розраховані на глибокі знання. Є й ті, що більше схожі на головоломки чи стосуються нюансів, які відчути без практики дуже важко. У цій статті розробник <span class="text-bold">Саранс Сінг</span> (Saraans Singh) наводить кілька таких питань щодо Java. З відповідями, зрозуміло. <img data-max-width="850" alt="Хитрі питання з Java, які часто ставлять на співбесідах - 1" src="https://cdn.javarush.com/images/article/801ca927-4a0d-474f-a9d9-72c4243440e4/original.jpeg"><span class="text-bold">1. Що станеться, якщо помістити оператор return або System.exit() у блок try/catch?</span> Це дуже популярне питання "на засипку" з Java. Хитрість його в тому, що багато програмістів вважають, що блок <code class=" language-none">finally</code>виконається у будь-якому випадку. Дане питання ставить цю концепцію під сумнів шляхом розміщення оператора <code class=" language-none">return</code>в блок <code class=" language-none">try/catch</code>або виклику з блоку <code class=" language-none">try/catch</code>оператора <code class=" language-none">System.exit ()</code>. <span class="text-bold">Відповідь на це каверзне питання:</span> блок <code class=" language-none">finally</code>буде виконуватися при поміщенні оператора <code class=" language-none">return</code>в блок <code class=" language-none">try/catch</code>і не буде виконуватися при виклику з блоку <code class=" language-none">try/catch</code>оператора <code class=" language-none">System.exit ()</code>. <span class="text-bold">2. Чи підтримує мова Java множинне спадкування? </span> Це дуже хитре питання. Інтерв'юери часто говорять: якщо мова C++ може підтримувати безпосереднє успадкування, то чому Java не може? <span class="text-bold">Відповідь</span>дещо складніший, ніж може здатися, оскільки Java підтримує множинне успадкування типів, адже інтерфейс у ньому може розширювати інші інтерфейси. Але множинне спадкування реалізацій мова Java не підтримує. <span class="text-bold">3. У разі, коли метод генерує виняток </span><span class="text-bold"><code class=" language-none">NullPointerException</code>у батьківському класі, чи можна його перевизначити методом, що генерує <code class=" language-none">RuntimeException</code>? </span> Ще одне каверзне питання, пов'язане з концепціями навантаження та перевизначення. <span class="text-bold">Відповідь:</span> у перевизначеному методі можна спокійно генерувати батьківський клас виключення <code class=" language-none">NullPointerException – RuntimeException</code>, але не можна зробити те саме з виключенням типу, що перевіряється <code class=" language-none">Exception</code>. <span class="text-bold">4. Як гарантувати можливість звернення <code class=" language-none">N</code>ниток до <code class=" language-none">N</code>ресурсів без взаємного блокування?</span> Якщо ви не надто добре знаєтеся на написанні багатопоточного коду, це питання буде для вас по-справжньому каверзним. Він може виявитися непростим навіть для досвідченого програміста, який не мав справи із взаємними блокуваннями та станами гонки. Весь трюк тут упорядкований: запобігти взаємному блокуванню можна завдяки звільненню ресурсів у порядку, зворотному порядку їх отримання. <span class="text-bold">5. У чому різниця між класами <code class=" language-none">StringBuffer</code>та <code class=" language-none">StringBuilder</code>в мові Java? </span> Класичне питання мови Java, яку деякі розробники вважають хитрим, а інші – дуже простим. Клас <code class=" language-none">StringBuilder</code>з'явився в JDK 1.5 і єдина відмінність між ними полягає в тому, що методи класу <code class=" language-none">StringBuffer</code>, наприклад, <code class=" language-none">length()</code>або <code class=" language-none">capacity()</code>синхронізовані <code class=" language-none">append()</code>, в той час як відповідні методи класу<code class=" language-none">StringBuilder</code>- Ні. З огляду на цю фундаментальну відмінність, конкатенація рядків за допомогою <code class=" language-none">StringBuilder</code>виконується швидше, ніж за допомогою <code class=" language-none">StringBuffer</code>. Насправді, використовувати <code class=" language-none">StringBuffer</code>не рекомендується, оскільки в 99% сценаріїв використання конкатенація рядків проводиться в тій же нитці. <span class="text-bold">6. Що поверне вираз 1.0/0.0? Чи призведе воно до генерації виключення чи помилки під час компіляції? </span> Ще одне каверзне питання щодо класу <code class=" language-none">Double</code>. Хоча розробники Java знають про існування простого типу даних double і класу <code class=" language-none">Double</code>, при виконанні операцій з плаваючою точкою вони не приділяють достатньої уваги <code class=" language-none">Double.INFINITY</code>, <code class=" language-none">NaN</code>і <code class=" language-none">-0.0</code>правилам, яким підпорядковуються пов'язані з ними арифметичні обчислення. <span class="text-bold">Відповідь на це питання проста:</span> генерації винятку<code class=" language-none">ArithmeticException</code>не станеться, буде повернено значення <code class=" language-none">Double.INFINITY</code>. <span class="text-bold">7. Що буде, якщо спробувати вставити в </span><span class="text-bold">ключовий об'єкт, що вже є в ній? </span> Це каверзне питання – частина іншого питання, що часто ставиться: як працюють у мові Java? – популярна тема для заплутаних та каверзних питань з мови Java. <span class="text-bold">Відповідь така:</span> якщо спробувати повторно вставити ключ у , він замінить старий, оскільки клас не допускає ключів, що дублюються. А той самий ключ означає такий самий хеш-код, тому він потрапить у те саме місце в хеш-сегменті. За матеріалами <a href="https://www.quora.com/What-are-the-trickiest-Java-questions" target="_blank">Quora</a><a href="https://codegym.cc/welcome" target="_blank"><img id="click_banner1_articles" data-max-width="1024" data-id="3a9d5391-1665-40cc-967f-81d6b0d8ffb6" class="img-fluid" alt="Хитрі питання з Java, які часто ставлять на співбесідах - 2" src="https://cdn.javarush.com/images/article/3a9d5391-1665-40cc-967f-81d6b0d8ffb6/1024.jpeg" style="width: 1024px;"></a><span class="text-bold"><code class=" language-none">HashMap</code></span><code class=" language-none">HashMap</code><code class=" language-none">HashMap</code><span class="text-bold"></span><code class=" language-none">HashMap</code><code class=" language-none">HashMap</code><a href="https://www.quora.com/What-are-the-trickiest-Java-questions" target="_blank"></a>
<div class="table-container">
 <table>
  <tbody>
   <tr>
    <th>
     <p>Що ще почитати:</p></th>
   </tr>
   <tr>
    <td><a href="https://codegym.cc/groups/posts/292-kljevihe-optimizacii-sql-ne-zavisjajshie-ot-stoimostnoy-modeli" target="_blank">Кльові оптимізації SQL, що не залежать від вартісної моделі. Частина 1 </a><br><a href="https://codegym.cc/groups/posts/382-kak-statjh-magom-v-intellij-idea-smotrite-besplatnihy-kurs-khaynca-kabuca-" target="_blank">Як стати магом у IntelliJ IDEA? Дивіться безкоштовний курс Хайнца Кабуца</a></td>
   </tr>
  </tbody>
 </table>
</div>