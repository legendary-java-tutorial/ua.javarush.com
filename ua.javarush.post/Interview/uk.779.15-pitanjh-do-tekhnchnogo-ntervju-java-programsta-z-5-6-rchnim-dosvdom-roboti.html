15 питань до технічного інтерв'ю Java програміста з 5-6 річним досвідом роботи
<p>----------------------------------------</p>
Зі зростанням досвіду програміста від рівня розробника-початківця (від 2 до 4 років досвіду роботи) до рівня старшого розробника (від 5 до 7 років) змінюються і питання на інтерв'ю по Core Java. Звичайно такі основи як залишаються, але пита
<p>----------------------------------------</p>
Зі зростанням досвіду програміста від рівня розробника-початківця (від 2 до 4 років досвіду роботи) до рівня старшого розробника (від 5 до 7 років) змінюються і питання на інтерв'ю по Core Java. <img data-id="421a8c52-4766-4f9e-a25f-7b6f22f17685" data-max-width="850" alt="15 питань до технічного інтерв'ю Java програміста з 5-6-річним досвідом роботи - 1" src="https://cdn.javarush.com/images/article/421a8c52-4766-4f9e-a25f-7b6f22f17685/800.jpeg" style="width: 850px;">Звичайно такі основи як <strong>структури даних, алгоритми та об'єктно-орієнтоване програмування</strong>залишаються, але питання та відповіді стають більш докладними. Я часто отримую питання про те, які питання щодо Core Java ставлять старшим розробникам, або яких питань варто очікувати на співбесіді на позицію старшого розробника Java. Це мене на деякий час спантеличує, адже як тільки ви станете старшими розробниками, ви автоматично почнете брати участь у співбесідах і вам треба мати уявлення про те, чого очікувати від співбесіди, але в той же час, я розумію, що знаючи питання співбесіди, вам буде легше підготуватися до нього. Звичайно, ви не отримаєте питань, які ставлять програмістам з 2-3 роками досвіду роботи з Java, хоча на початку співбесіди це не виключено. Я не бачу відмінностей між телефонними інтерв'ю і співбесідами віч-на-віч. Якісь питання залишаються тими ж, якісь питання вимагають більш докладних відповідей. У цій статті я поділюся<strong>15 технічними питаннями з Core Java</strong> , які задавалися під час співбесід старших розробників під час телефонного інтерв'ю. Я не публікую всі відповіді, але ви можете знайти їх у поточному блозі або блозі <a href="https://javarevisited.blogspot.com/#axzz5d3NuS3Zo" rel="nofollow" target="_blank">Javarevisited</a> . 
<h2>15 питань щодо Core Java для програмістів з 5-6 досвідом розробки</h2>Всі питання були отримані від працюючих старших розробників, які мають більш ніж 5-річний досвід роботи. Розробники зустрічалися з цими питаннями на різних етапах працевлаштування, включаючи телефонні інтерв'ю та співбесіди віч-на-віч. 
<ol>
 <li>
  <p><strong>Як працює метод <code class=" language-none">get</code>класу <code class=" language-none">HashMap</code>Java?</strong></p>
  <p>Так, це, як і раніше, одне з найпопулярніших питань для старшого розробника, ви повинні чекати його на телефонному інтерв'ю, після нього можливо буде багато суміжних питань, подивіться відповіді на них <a href="http://www.java67.com/2013/06/how-get-method-of-hashmap-or-hashtable-works-internally.html" rel="nofollow" target="_blank">тут</a> .</p></li>
 <li>
  <p><strong>Які 2 методи має реалізувати об'єкт ключа <code class=" language-none">HashMap</code>?</strong></p>
  <p><code class=" language-none">equals</code>і<code class=" language-none">hashcode</code></p></li>
 <li>
  <p><strong>Чому об'єкти, що використовуються як ключ, повинні бути іммутабельними (незмінними)?</strong></p>
  <p>Щоб хеш-код завжди повертав одне й те саме значення.</p></li>
 <li>
  <p><strong>Завдяки чому <code class=" language-none">ConcurrentHashMap</code>досягається масштабованість?</strong></p>
  <p>Іноді це питання звучить на інтерв'ю як: різниця між <code class=" language-none">ConcurrentHashMap</code>і <code class=" language-none">Hashtable</code>Java, пошукайте відповіді <a href="http://www.java67.com/2012/08/difference-between-hashmap-and-concurrentHashMap-java-collection.html" rel="nofollow" target="_blank">тут</a> .</p></li>
 <li>
  <p><strong>Як зробити об'єкт спільним для різних потоків? Або як передати об'єкт від одного потоку до іншого?</strong></p>
  <p>Є багато шляхів реалізації цього, такі як черги, обмінники, але блоковані черги з шаблоном проектування <a href="http://www.java67.com/2012/12/producer-consumer-problem-with-wait-and-notify-example.html" rel="nofollow" target="_blank">Producer/Consumer</a> це найпростіший спосіб передати об'єкт з одного потоку в інший.</p></li>
 <li>
  <p><strong>Як дізнатися, що у вашій програмі є взаємне блокування?</strong></p>
  <p>(Отримавши дамп потоку, використовуючи kill -3, застосовуючи JConsole чи VisualVM). Я пропоную підготуватися до цього питання на інтерв'ю дуже ретельно, оскільки інтерв'юери люблять деталі, вони запитують, чи були у вашому проекті подібні проблеми і як вам вдалося їх вирішити.</p></li>
 <li>
  <p><strong>Як уникнути взаємних блокувань під час кодування?</strong></p>
  <p>Щоб розібратися з блокуваннями і отримати повну інформацію про тему, прочитайте <a href="https://javarevisited.blogspot.com/2018/08/how-to-avoid-deadlock-in-java-threads.html" rel="nofollow" target="_blank">це</a> .</p></li>
 <li>
  <p><strong>Що таке очікування зайнятості ("Busy spinning")? Чому ви маєте використовувати його?</strong></p>
  <p>Одне з найцікавіших питань багатопоточності для старшого розробника Java, Busy spinning – це стратегія очікування, коли потік виконує очікування в циклі, при цьому не використовуючи ресурси процесора і як би <a href="http://www.java67.com/2012/08/what-are-difference-between-wait-and.html" rel="nofollow" target="_blank">засинаючи</a> . Цю стратегію використовують, коли час очікування дуже мало, при цьому не навантажується процесор і не зупиняється потік, зберігаються всі дані, які можуть бути втрачені при запуску потоку на іншому ядрі процесора. Це питання популярне у програмістів, які створюють високо навантажені проекти, де програмісти домагаються надзвичайно низьких затримок у роботі, в діапазоні мікро- і мілі-секунд.</p></li>
 <li>
  <p><strong>Що таке блокування Читання та Записи ( <code class=" language-none">ReadWriteLock</code>)? Чи використовує <code class=" language-none">ConcurrentHashMap ReadWrite</code>блокування?</strong></p>
  <p>Блокування Читання та Записи це така реалізація блокування, коли кілька різних потоків намагаються зробити операцію читання та запису з одним об'єктом. сама собою операція читання не змінює об'єкт, що допускає багатопотокові операції читання без блокувань. Java надає реалізацію <code class=" language-none">ReadWriteLock</code>з якою варто ознайомитись. Наприклад , <code class=" language-none">ConcurrentHashMap</code>не застосовує <code class=" language-none">ReadWriteLock</code>, замість цього він ділить <code class=" language-none">Hash</code>на окремі частини і блокує їх окремо, таким чином у будь-який момент часу заблокована тільки частина хеша, а не він весь. Це питання популярне у досвідчених розробників, які зазвичай просять відповісти докладніше, запитують різні реалізації ReadWriteLock для різних випадків.</p></li>
 <li>
  <p><strong>Як зробити об'єкт іммутабельним (не змінним) Java? Навіщо робити об'єкт іммутабельним?</strong></p>
  <p>Імутабельність передбачає кілька переваг, включаючи потокобезпеку, можливість кешування, а так само робить багатопоточний код більш читаним.</p>
  <p>Подивіться <a href="https://javarevisited.blogspot.com/2013/03/how-to-create-immutable-class-object-java-example-tutorial.html" rel="nofollow" target="_blank">це</a> та навчитеся робити об'єкти іммутабельними. На співбесіді з цього питання можливі додаткові уточнення залежно від повноти вашої відповіді. Наприклад коли ви кажете, що Spring іммутабельний, будьте готові відповісти чому рядки так само іммутабельні Java.</p></li>
 <li>
  <p><strong>Які шаблони проектування використовуєте?</strong></p>
  <p>Завжди чекайте на питання про шаблони проектування на співбесіді до вакансії старшого розробника. Краще відзначити будь-який GOF шаблон, а не Singleton або MVC, який використовує кожен другий Java програміст. Найкращою відповіддю може бути шаблон <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BA%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F" rel="nofollow" target="_blank">Декоратор</a> або шаблон <a href="https://ru.wikipedia.org/wiki/%D0%92%D0%BD%D0%B5%D0%B4%D1%80%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8" rel="nofollow" target="_blank">Впровадження залежності</a> , які досить популярні в Spring Framework. Так само добре, якщо звані вами шаблони проектування ви дійсно використовували і знаєте, до якого компромісу веде їх застосування. Як тільки ви скажете назву шаблону проектування, наприклад: "Фабрика", інтерв'юер відразу запитає: "Ви використовували це у своїх проектах?" Тому будьте готові навести приклади та розповісти чому ви вибрали у своєму проекті саме цей шаблон.</p></li>
 <li>
  <p><strong>Чи знаєте ви про принцип <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%BE%D1%82%D0%BA%D1%80%D1%8B%D1%82%D0%BE%D1%81%D1%82%D0%B8/%D0%B7%D0%B0%D0%BA%D1%80%D1%8B%D1%82%D0%BE%D1%81%D1%82%D0%B8" rel="nofollow" target="_blank">Відкритості/Закритості</a> чи <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%BF%D0%BE%D0%B4%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B8_%D0%91%D0%B0%D1%80%D0%B1%D0%B0%D1%80%D1%8B_%D0%9B%D0%B8%D1%81%D0%BA%D0%BE%D0%B2" rel="nofollow" target="_blank">Принцип підстановки Барбари Лисків</a> ?</strong></p>
  <p>Шаблони проектування ґрунтуються на принципах об'єктно-орієнтованого проектування.</p>
  <p>Настійно рекомендую подивитися мою статтю <a href="https://javarevisited.blogspot.com/2018/07/10-object-oriented-design-principles.html" rel="nofollow" target="_blank">10 принципів об'єктно орієнтованого дизайну</a> , які повинен знати програміст Java, принаймні мати уявлення про те, як ці принципи допоможуть вам писати об'єктно орієнтований код. Якщо у вас немає відповіді на це питання, ви можете ввічливо відповісти "ні", ніхто не очікує від вас знання відповіді на всі запитання. Однак, знаючи відповідь на питання, яке викликає труднощі у більшості розробників, ви робите свою кандидатуру на співбесіді дуже сильною.</p></li>
 <li><strong>Який шаблон проектування використовуватимете, щоб захистити ваш код від сторонньої бібліотеки, яка буде замінена через кілька років?</strong>
  <p></p>
  <p>Це лише один з можливих варіацій питання про шаблони проектування, які можуть бути задані вам залежно від того, про що ви говорите зараз на співбесіді. Один із способів як захистити свій код від сторонньої бібліотеки, це залежність від інтерфейсу, а не від реалізації та використання залежностей, щоб забезпечити конкретну реалізацію. Подібні питання часто ставлять старшим розробникам із 5-7 роками досвіду роботи.</p></li>
 <li>
  <p><strong>Як запобігти SQL ін'єкції в коді Java?</strong></p>
  <p>Це питання частіше ставлять Java EE розробникам, ніж звичайним Java програмістам, проте це чудова нагода дізнатися про PreparedStatement. PreparedStatement - це об'єкт, який представляє попередньо скомпільований SQL-оператор. Підпорядкованедержавність не тільки забезпечує більш високу продуктивність, але й захищає від SQL ін'єкцій. Якщо ви працюєте здебільшого з Java EE або J2EE, ви повинні бути знайомі з деякими питаннями безпеки, у тому числі "атака Фіксації Сесії" або "міжсайтовий скриптинг", так само вам потрібно вміти уникати цих атак.</p></li>
 <li>
  <p><strong>Розкажіть про відмінності типів посилань у Java, таких як WeakReference, SoftReference та PhantomReference? І чому ви маєте їх використовувати?</strong></p>
  <p>По суті, різницю між усіма типами посилань лише одне — поведінка Java Garbage Collector з об'єктами, куди вони посилаються. У Java об'єкти, створювані через оператор new створюються за сильним посиланням. Складальник сміття (garbage collector) знищує такі об'єкти тільки тоді, коли на них більше не залишається сильних посилань. У пакеті java.lang.ref є 3 класи, які описують 3 типи посилань, відповідно SoftReference, WeakReference, PhantomReference. Об'єкти, створені через SoftReference, будуть зібрані, якщо JVM вимагає пам'ять. Тобто є гарантія, що всі SoftReference об'єкти будуть зібрані, перш ніж JVM викине виняток OutOfMemoryError. SoftReference часто використовується для кешів, які споживають велику кількість пам'яті. WeakReference не рятує об'єкт від фіналізації, навіть якщо є достатньо вільної пам'яті. Як тільки на об'єкт не залишиться strong та soft посилань, він може бути фіналізований. Використовується для кешів і створення ланцюгів пов'язаних між собою об'єктів. Об'єкти, створені через PhantomReference, знищуються тоді, коли GC визначають, що об'єкти, що посилаються, можуть бути звільнені. Цей тип посилань використовується як альтернатива фіналізації (для більш гнучкого звільнення ресурсів).</p>
  <p>Це весь перелік питань для інтерв'ю старшого Java розробника. Я не включив у нього багато важливих питань щодо обробки винятків, збирача сміття, налаштування JVM, які дуже популярні у старших розробників, можливо я включу їх у наступній частині. Але якщо ви не знаходите відповіді на якесь питання, дайте мені знати і я оновлю цей пост для моїх постійних читачів.</p></li>
</ol>Оригінальна стаття:<a href="http://www.java67.com/2013/07/15-advanced-core-java-interview-questions-answers-senior-experienced-5-6-years-programmers-developers.html" rel="nofollow" target="_blank"> 15 Technical Core Java Interview Questions Answers for Experienced Developers</a>