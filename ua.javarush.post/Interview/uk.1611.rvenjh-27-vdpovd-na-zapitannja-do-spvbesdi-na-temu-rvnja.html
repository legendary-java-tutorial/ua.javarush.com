Рівень 27. Відповіді на запитання до співбесіди на тему рівня
<p>----------------------------------------</p>
Що таке дідлок? Дідлок – це ситуація, коли два і більше ниток заблоковані, які чекають один на одного. Дідлоком також називається взаємне блокування. Взаємне блокування - це ситуація в якій, два або більше процесу займаючи деякі ресурси, на
<p>----------------------------------------</p>
<img data-id="ce961db6-56c1-4a07-a341-c85c821b873c" data-max-width="850" alt="Рівень 27. Відповіді на запитання до співбесіди на тему рівня - 1" src="https://cdn.javarush.com/images/article/ce961db6-56c1-4a07-a341-c85c821b873c/800.jpeg" style="width: 850px;">
<ol>
 <li>
  <p><strong>Що таке дідлок?</strong></p>
  <p><strong>Дідлок</strong> – це ситуація, коли два і більше ниток заблоковані, які чекають один на одного. Дідлоком також називається взаємне блокування.</p>
  <p><strong>Взаємне блокування</strong> - це ситуація в якій, два або більше процесу займаючи деякі ресурси, намагаються отримати деякі інші ресурси, зайняті іншими процесами і жоден з процесів не може зайняти необхідний їм ресурс, і відповідно звільнити займаний.</p>
  <p>Бувають взаємні блокування системи синхронізації (вирішуються призначенням системи);</p>
  <p>Взаємне блокування між об'єктами (різні об'єкти намагаються отримати доступ до тих самих синхронізованих блоків);</p>
  <p>Ресурсне взаємоблокування (при спробі отримати доступ до деяких ресурсів, які можуть використовувати одночасно лише один потік).</p></li>
 <li>
  <p><strong>Які ви знаєте стратегії, що запобігають появі дідлок?</strong></p>
  <p>Безперечно, якщо код написаний без будь-яких помилок, то взаємних блокувань у ньому не буде. Але хто може доручитись, що його код написаний без помилок? Безумовно, тестування допомагає виявити значну частину помилок, але, як ми вже бачабо раніше, помилки в багатопотоковому коді нелегко діагностувати і навіть після тестування не можна бути впевненим у відсутності ситуацій взаємних блокувань. Чи можемо ми перестрахуватися від блокувань? Відповідь – так. Подібні техніки використовуються в двигунах баз даних, яким часто потрібно відновлюватися після взаємних блокувань (пов'язаних з механізмом транзакцій в БД). Інтерфейс <code class=" language-none">Lock</code>та його реалізації доступні у пакеті <code class=" language-none">java.util.concurrent.locks</code>дозволяють спробувати зайняти монітор, пов'язаний з екземпляром даного класу методом <code class=" language-none">tryLock</code>(повертає true, якщо вдалося зайняти монітор).</p>
  <p>Також є стратегія застосування відкритих викликів, тобто викликати методи інших об'єктів поза синхронізованим блоком.</p>
  <p>Посилання на статтю: <a href="http://www.developersonthe.net/ru/posts/post_id/34-Vzaimnaja-blokirovkadeadlock-v-Java-i-metody-borby-s-nej/" rel="nofollow" target="_blank">Взаємне блокування в Java і методи боротьби з нею</a></p></li>
 <li>
  <p><strong>Чи можуть виникнути дідлок при використанні методів <code class=" language-none">wait-notify</code>?</strong></p>
  <p>Відповісти на це питання важко мені, але прочитавши в інтернеті різні дискусії на цю тему, можна сказати наступне:</p>
  <p>Дедлоков можна уникнути з допомогою розумного використання <code class=" language-none">synchronized</code>, <code class=" language-none">volatile</code>, монітора ( <code class=" language-none">wait()</code>, <code class=" language-none">notify()</code>, <code class=" language-none">notifyAll()</code>), і якщо копати глибше, використовуючи класи <code class=" language-none">java.utils.concurrent</code>: замість звичайних колекцій - многопоточные варіанти ( <code class=" language-none">ConcurrentHashMap</code>, наприклад); якщо необхідний складніший спосіб синхронізації потоків — різні <code class=" language-none">CyclicBarrier</code>, <code class=" language-none">CountDownLatch</code>.</p>
  <p>Якщо грамотно використовувати <code class=" language-none">wait</code>– <code class=" language-none">notify</code>то дідлоки виникнути не повинні.)))</p>
  <p>Ось посилання: <a href="http://www.quizful.net/interview/java/Deadlock" rel="nofollow" target="_blank">Взаємне блокування або Deadlock.</a></p></li>
 <li>
  <p><strong>Що найчастіше використовується: <code class=" language-none">notify</code>або <code class=" language-none">notifyAll</code>?</strong></p>
  <p>java.lang.Object.notify() wakes up a single thread that is waiting on this object's monitor. Якщо кожний threads waiting on this object, один з них є chosen to be awakened. choice є arbitrary and occurs at discretion of the implementation. Під час подачі на object 's monitor за допомогою одного з побіжних методів.</p>
  <p>Цей метод повинен тільки бути названий під час того, що це власник цього об'єкта monitor. Під час переміщення власника object's monitor в одному з трьох способів:</p>
  <ul>
   <li>Використовуючи synchronized instance метод того, що об'єкт.</li>
   <li>Використовуючи body of synchronized statement that synchronizes on the object.</li>
   <li>Для об'єктів типу класу виконується synchronized static method that class.</li>
  </ul>
  <p>Тільки один день в часі може бути власним об'єктом monitor.</p>
  <p>The java.lang.Object.notifyAll() переміщаються всі threads, що є waiting on this object's monitor. Під час подачі на object 's monitor за допомогою одного з побіжних методів.</p>
  <p>Нахилені threads не можуть бути виконані until the current thread relinquishes the lock on this object. Звільнені літери будуть складені в будь-якому manner with any other threads that might be actively competing to synchronize on this object; для прикладу, звільнені ходи приємно не надійні привілеї або розрив в тому, що next thread to lock this object.</p>
  <p>Цей метод повинен тільки бути названий під час того, що це власник цього об'єкта monitor.</p>
  <p>Це уривки із документації. Питання – то здебільшого риторичне, дивлячись якесь додаток, залежно від ситуації))) Я навіть не знаю, як би я відповів. Якщо у когось є якісь здогадки, то прошу в коментарях залишити, дуже радий почитати.</p></li>
 <li>
  <p><strong>Метод <code class=" language-none">wait</code>рекомендується використовувати з конструкціями <code class=" language-none">if</code>чи <code class=" language-none">while</code>?</strong></p>
  <p>Тут відповім просто цитатою із сайту: <a href="http://www.skipy.ru/technics/synchronization.html" rel="nofollow" target="_blank">Синхронізація потоків</a></p>
  <p>З приводу виклику методу <code class=" language-none">wait</code>. Це вже із розряду чистої техніки. Рекомендується викликати <code class=" language-none">wait</code>зсередини циклу <code class=" language-none">while</code>. Тобто, писати не</p>
  <pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">if</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span>some condition<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">{</span></span>
    obj<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">wait</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre>
  <p>..., а</p>
  <pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">while</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span>some condition<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">{</span></span>
    obj<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">wait</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre>
  <p>Для чого це треба. Справа в тому, що <code class=" language-none">notify</code>може викликати будь-хто. Просто помилково, від якої ніхто не застрахований. У тому випадку з досвіду, про який я розповідав вище, ми взялися за переробку саме для того, щоб уникнути такої можливості. Просто сховали об'єкт, на якому відбувається синхронізація. І доступ до нього мав лише наш код. Це хороша практика, але не завжди можливо, на жаль. Так от, якщо потік чекає на виконання деякої умови – варіант з <code class=" language-none">while</code>надійнішим. Якщо потік пустабо помилково – він знову перевірить умову і, якщо треба, чекатиме далі.</p>
  <p>Крім того, не виключена можливість простого виходу з очікування без виклику <code class=" language-none">notify</code>. Я чесно зізнаюся, що не бачив цього у специфікації віртуальної машини, хоч спеціально шукав. Але деякі гуру стверджують, що VM може вийти зі стану очікування мимоволі. Більше того, періодично це спостерігається. Якщо хтось дасть посилання на відповідну специфікацію – буду вдячний!</p></li>
 <li>
  <p><strong>Що відбувається після виклику методу <code class=" language-none">notifyAll</code>?</strong></p>
  <p>The java.lang.Object.notifyAll() переміщаються всі threads, що є waiting on this object's monitor. Під час подачі на object 's monitor за допомогою одного з побіжних методів.</p>
  <p>Пробуджує всі нитки, які чекали на цьому моніторі.</p></li>
 <li>
  <p><strong>Які вигоди отримує об'єкт, якщо він <code class=" language-none">immutable</code>?</strong></p>
  <p>Знайшов коментар на: <a href="http://ru.stackoverflow.com/questions/432545/" rel="nofollow" target="_blank">immutable-об'єкти та багатопоточність</a></p>
  <p><code class=" language-none">Immutable</code>об'єкт — це об'єкт, стан якого після створення неможливо змінити. У випадку Java це означає, що всі поля екземпляра у клас відзначені як <code class=" language-none">final</code>і є примітивами або теж <code class=" language-none">immutable</code>типами.</p>
  <p>Приклад:</p>
  <pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">class</span></span> <span class="token class-name"><span class="token class-name">ImmutablePoint</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
    <span class="token keyword"><span class="token keyword">private</span></span> <span class="token keyword"><span class="token keyword">final</span></span> <span class="token keyword"><span class="token keyword">int</span></span> x<span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token keyword"><span class="token keyword">private</span></span> <span class="token keyword"><span class="token keyword">final</span></span> <span class="token keyword"><span class="token keyword">int</span></span> y<span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token keyword"><span class="token keyword">private</span></span> <span class="token keyword"><span class="token keyword">final</span></span> <span class="token class-name"><span class="token class-name">String</span></span> description<span class="token punctuation"><span class="token punctuation">;</span></span>

    <span class="token keyword"><span class="token keyword">public</span></span> <span class="token class-name"><span class="token class-name">ImmutablePoint</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">int</span></span> x<span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token keyword"><span class="token keyword">int</span></span> y<span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token class-name"><span class="token class-name">String</span></span> description<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
        <span class="token keyword"><span class="token keyword">this</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>x <span class="token operator"><span class="token operator">=</span></span> x<span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token keyword"><span class="token keyword">this</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>y <span class="token operator"><span class="token operator">=</span></span> y<span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token keyword"><span class="token keyword">this</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>description <span class="token operator"><span class="token operator">=</span></span> description<span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token punctuation"><span class="token punctuation">}</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre>
  <p>Після створення екземпляра <code class=" language-none">ImmutablePoint</code>його модифікація неможлива.</p>
  <p>Найпростіший приклад <code class=" language-none">immutable</code>класу з JDK це <code class=" language-none">String</code>. Будь-які методи, які ви викликаєте на рядку (наприклад <code class=" language-none">description.toLowerCase()</code>), повернуть новий рядок, а не модифікують вихідний.</p>
  <p>Приклад <code class=" language-none">mutable</code>класу з JDK - <code class=" language-none">Date</code>. Наприклад <code class=" language-none">myDate.setHours(x)</code>модифікує сам екземпляр <code class=" language-none">myDate</code>!</p>
  <p>Є різниця між <code class=" language-none">immutable</code>-об'єктом (тобто незмінним), і <code class=" language-none">final</code>-посиланням.</p>
  <p>Ключове слово <code class=" language-none">final</code>для об'єктних типів гарантує незмінність лише посилання, але з самого об'єкта. Наприклад, якщо у вас є <code class=" language-none">final</code>посилання на <code class=" language-none">ArrayList&lt;T&gt;</code>, ви можете додавати до нього нові елементи або змінювати існуючі.</p>
  <p>У разі <code class=" language-none">immutable</code>об'єкта об'єкт після закінчення конструктора не змінюється взагалі. Лише модифікатора <code class=" language-none">final</code>для цього недостатньо, необхідно, щоб усі подоб'єкти були теж незмінними. Ви в принципі можете тримати всередині посилання на об'єкт, що змінюється, але звертатися з ним так, щоб він не змінювався.</p>
  <p>Використання незмінних об'єктів дає багато вигод. Наприклад, про такий об'єкт набагато легше судити в ситуації, коли в багатьох частинах програми є посилання на нього (для об'єкта, що змінюється, будь-яка частина програми може викликати мутуючу функцію в практично будь-який момент часу і з будь-якого потоку).</p>
  <p>Але те, що для нас є важливим у контексті питання — незмінні об'єкти не вимагають синхронізації при багатопоточному доступі. Ось, власне, і вся рекомендація: використовуйте незмінні об'єкти, і вам не доведеться думати про те, що потрібно, а що не потрібно синхронізувати. Єдина можлива проблема — якщо ви всередині конструктора, що ще не відпрацював, публікуєте посилання на об'єкт, через яке до нього може отримати доступ хтось ще, і побачити об'єкт у стані, що змінюється! (Це буває не так і рідко. Наприклад, іноді програміст хоче додати об'єкт у конструкторі в колекцію всіх об'єктів даного типу.)</p>
  <hr>
  <p>Слід розрізняти дійсно незмінні об'єкти і об'єкти, що мають лише інтерфейс «тільки для читання». При читанні об'єкт може змінювати свою внутрішню структуру (наприклад, кешувати найсвіжіший запит даних). Такі об'єкти не є в строгому сенсі незмінними, і не можуть бути використані з різних потоків без обережності. (Тому, якщо ваш об'єкт включає інші об'єкти, переконайтеся, що документація гарантує їх незмінність!)</p>
  <hr>
  <p>Зверніть увагу, що для полів постійного об'єкта ви фактично повинні використовувати <code class=" language-none">final</code>! Справа в так званій безпечній публікації. Дивіться. Інструкції в Java-програмі може бути переставлені як оптимізатором, і процесором (у Java досить слабка модель пам'яті). Тому, якщо не робити спеціальних дій, закінчення роботи конструктора та присвоєння значень полям може бути переставлено (але невидимо у рамках поточного потоку)! Використання <code class=" language-none">final</code>гарантує, що такого не станеться.</p>
  <p>У разі багатопотокового програмування переваги <code class=" language-none">immutable</code>класів очевидні: після створення об'єкти можна передавати іншим потокам і вони завжди будуть у актуальному стані. Тобто. вам не треба перевіряти чи не застарів стан вашого екземпляра і чи не модифікував його інший потік поки ви з ним працюєте. Наприклад, у вас є метод <code class=" language-none">bill(Date endDate)</code>, у ньому ви наївно перевіряєте відповідність <code class=" language-none">endDate</code>якимось попереднім умовам і починаєте з нею працювати. У цей момент інший потік може змінити <code class=" language-none">endDate</code>, наприклад, встановить її глибоко в минуле. Наслідки можуть бути найдивовижнішими.</p></li>
 <li>
  <p><strong>Що таке "thread-safe"?</strong></p>
  <p>Знову ж таки: <a href="http://stackoverflow.com/questions/6324085/" rel="nofollow" target="_blank">What is thread Safe in java? [duplicate]</a></p>
  <p>Thread safe means те, що метод або class instance може бути використана з multiple threads at the same time without any problems occuring.</p>
  <p>Стан потоко-безпеки передбачає, що метод чи клас може бути використаний безліччю ниток без проблем зіткнення, тобто дідлок.</p>
  <p>Consider the following method:</p>
  <pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">private</span></span> <span class="token keyword"><span class="token keyword">int</span></span> myInt <span class="token operator"><span class="token operator">=</span></span> <span class="token number"><span class="token number">0</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">int</span></span> <span class="token class-name"><span class="token class-name">AddOne</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
<span class="token punctuation"><span class="token punctuation">{</span></span>
    <span class="token keyword"><span class="token keyword">int</span></span> tmp <span class="token operator"><span class="token operator">=</span></span> myInt<span class="token punctuation"><span class="token punctuation">;</span></span>
    tmp <span class="token operator"><span class="token operator">=</span></span> tmp <span class="token operator"><span class="token operator">+</span></span> <span class="token number"><span class="token number">1</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
    myInt <span class="token operator"><span class="token operator">=</span></span> tmp<span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token keyword"><span class="token keyword">return</span></span> tmp<span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre>
  <p>Now thread A and thread B both would like to execute AddOne(). but A starts first and reads the value of myInt (0) в tmp. Для того, щоб зазначити, що освітянин вирішить, щоб статевий кінець A і запобігти виконанню до дії B. Третій B зараз також витрачає ціну myInt (завжди 0) в її власну варіаційну tmp. Підпис B вказує на введення методу, так в кінці myInt = 1. І 1 є відновленим. Now it's Thread A's turn again. Thread A continues. And adds 1 to tmp (tmp був 0 for thread A). And then saves this value in myInt. myInt is again 1.</p>
  <p>Тут і нитку А і нитку B хочуть виконати <code class=" language-none">AddOne ()</code>. але А починається першою і зчитує значення myInt(0) у TMP. Тепер з деяких причин планувальник вирішує зупинити потік А та відкласти виконання нитки B. Потік В даний час також зчитує значення myInt (0) у його власній змінній TMP. Нитка B завершує весь метод так, що, зрештою, myInt = 1. І 1 повертається. Потік А продовжується. І додає 1 TMP (TMP 0 для нитки A). А потім зберігає це значення в myInt. myInt знову 1.</p>
  <p>Якщо в цьому випадку метод AddOne була названа в два рази, але тому, що метод не був впроваджений в третій надійний спосіб значення миттєво не є 2, as expected, але 1 згодом згодом read read the variable myInt befor updating it.</p>
  <p>Так що в цьому випадку метод <code class=" language-none">AddOne</code>був викликаний двічі, але так як цей метод не був реалізований у потоці безпечним способом величина myInt не 2, як очікувалося, а 1, тому що другий потік читання змінної закінчився <code class=" language-none">myInt</code>перед першою ниткою до його оновлення.</p>
  <p>Creating thread safe methods is very hard in no trivial cases. І вони існують кілька технологій. У Java ви можете оцінити метод, як synchronized, це рішення, що тільки один кінець може виконувати те, що метод при виконанні часу. Інші threads wait in line. Це робить метод методу захисту, але якщо є багато праць для того, щоб зробити в спосіб, то це було багато часу. Ще одна технологія є 'марком тільки малої частини методу synchronized', створюючи lock або semaphore, і locking ця маленька частина (зазвичай називається critical section). Там є деякі методи, які є здійснені як lockless thread safe, які рішення, що вони будуть побудовані в такій мірі, що низка подій може йти через те, що в той же час без будь-яких проблем, які можуть бути atomic call.</p>
  <p>Створення потоково-безпечних методів дуже важко. У Java можна позначити метод як синхронізований, це означатиме, що тільки один потік може виконати цей метод в даний момент часу. Інші нитки чекатимуть у черзі. Це робить метод потоково-безпечним, але якщо багато роботи доведеться зробити в методі, то на це буде витрачати багато часу. Інший метод полягає в розмітці лише малої частини методу, як синхронізованого шляхом створення локів (locks) або семафорів, і замикання цієї невеликої частини (звичайно званий критичний розділ (critical section)). Є навіть деякі методи, які реалізуються як беззамкові потокобезпечні (lockless thread safe), це означає, що вони побудовані таким чином, що кілька потоків можуть проходити через них в один час і ніколи не викликають проблем, це може бути у випадку, коли метод виконує лише один атомарний виклик. Атомарні виклики – це виклики, які не можуть бути перервані, і може бути реалізовані лише одним потоком.</p></li>
 <li>
  <p><strong>Що таке happens-before?</strong></p>
  <p>Є стаття на вікіпедії, вона не конкретно про "happens-before", але все-таки.</p>
  <p>А так: <br>
    «Виконується раніше» (англ. happens before) — відношення суворого часткового порядку (арефлексивне, антисиметричне, транзитивне), введене між атомарними командами ( <code class=" language-none">++</code>і <code class=" language-none">--</code>не атомарними!), придумане Леслі Лемпортом і не означає «фізично раніше». Воно означає, що друга команда буде "в курсі" змін, проведених першою.</p>
  <p><a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8_Java" rel="nofollow" target="_blank">Модель пам'яті Java</a></p>
  <p>Зокрема, одне виконується насамперед для таких операцій (список не вичерпний):</p>
  <ul>
   <li>Синхронізація та монітори:</li>
   <li>Захоплення монітора (початок <code class=" language-none">synchronized</code>, метод <code class=" language-none">lock</code>) і все, що після нього в тому ж потоці.</li>
   <li>Повернення монітора (кінець <code class=" language-none">synchronized</code>, метод <code class=" language-none">unlock</code>) і все, що перед ним у тому ж потоці.</li>
   <li>Таким чином, оптимізатор може заносити рядки до синхроблок, але не назовні.</li>
   <li>Повернення монітора та подальше захоплення іншим потоком.</li>
   <li>Запис та читання:</li>
   <li>Будь-які залежності за даними (тобто запис у будь-яку змінну і подальше читання її) в одному потоці.</li>
   <li>Все, що в тому ж потоці перед записом в <code class=" language-none">volatile</code>змінну, і сам запис.</li>
   <li><code class=" language-none">volatile</code>-Читання і все, що після нього в тому ж потоці.</li>
   <li>Запис в <code class=" language-none">volatile</code>-змінну і наступне зчитування її.[4][2] Отже, <code class=" language-none">volatile</code>-запис робить із пам'яттю те саме, що повернення монітора, а читання — те саме, що захоплення.[5] А значить: якщо один потік записав у <code class=" language-none">volatile</code>змінну, а другий виявив це, все, що передує запису, виконується насамперед, що йде після читання; див. ілюстрацію.</li>
   <li>Для об'єктних змінних (наприклад, <code class=" language-none">volatile List x;</code>) такі сильні гарантії виконуються для посилання на об'єкт, але не для його вмісту.</li>
   <li>Обслуговування об'єкту:</li>
   <li>Статична ініціалізація та будь-які дії з будь-якими екземплярами об'єктів.</li>
   <li>Запис <code class=" language-none">final</code>-поля в конструкторе[6] і що після конструктора. Як виняток із загальної транзитивності, це співвідношення happens-before не з'єднується транзитивно коїться з іншими правилами і тому може викликати межпоточную гонку.[7]</li>
   <li>Будь-яка робота з об'єктом та <code class=" language-none">finalize()</code>.</li>
   <li>Обслуговування потоку:</li>
   <li>Запуск потоку та будь-який код у потоці.</li>
   <li>Занулення змінних, що відносяться до потоку, та будь-який код у потоці.</li>
   <li>Код у потоці та <code class=" language-none">join();</code>код у потоці та <code class=" language-none">isAlive() == false</code>.</li>
   <li><code class=" language-none">interrupt()</code>потоку та виявлення факту зупинки.</li>
  </ul></li>
 <li>
  <p><strong>Що таке JMM?</strong></p>
  <p>Java Memory Model</p>
  <p>Ось посилання: <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html" rel="nofollow" target="_blank">Chapter 17. Threads and Locks</a></p>
  <p>І ось витяг з неї:</p>
  <p>На пам'ятній моделі описано, ведеться програма і execution trace of that program, за допомогою якого execution trace є legal execution of program. Java програмування англійською мовою моделлю робіт вивчають їх read in execution trace a checking that the write observed by read is valid according to certain rules.</p>
  <p>Я зрозумів на своєму рівні, що це набір правил:</p>
  <p>Правило № 1: однопотокові програми виконуються псевдопослідовно. Це означає: насправді процесор може виконувати кілька операцій за такт, заодно змінивши їхній порядок, проте всі залежності за даними залишаються, так що поведінка не відрізняється від послідовної. Правило № 2: немає значень, що казна-звідки взялися. Читання будь-якої змінної (крім не-volatile long і double, для яких це правило може не виконуватися) видасть або значення за умовчанням (нуль), або щось, записане туди іншою командою. І правило № 3: інші події виконуються по порядку, якщо пов'язані ставленням суворого часткового порядку «виконується насамперед» (англ. happens before).</p></li>
 <li>
  <p><strong>Який виняток вилетить, якщо викликати <code class=" language-none">wait</code>не в блоці <code class=" language-none">synchronized</code>?</strong></p>
  <p>Ось посилання: <a href="https://jsehelper.blogspot.ru/2016/01/multithreading-2.html" rel="nofollow" target="_blank">Відповіді на запитання на співбесіду Multithreading (частина 2)</a></p>
  <p>Основна причина виклику <code class=" language-none">wait</code>і <code class=" language-none">notify</code>зі статичного блоку чи методу у тому, що Java API обов'язково вимагає цього. Якщо ви викличете їх не з синхронізованого блоку, код викине <code class=" language-none">IllegalMonitorStateException</code>. Більш хитра причина в тому, щоб уникнути стану гонки між викликами <code class=" language-none">wait</code>та <code class=" language-none">notify</code>.</p></li>
</ol>