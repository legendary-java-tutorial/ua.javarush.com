36 рівень. Відповіді на запитання до співбесіди на тему рівня
<p>----------------------------------------</p>
Знову все перервав, відповідей не знайшов. Що ж. Викладу свої, хоча я писав їх чисто для себе, і по можливості коротко. Але все краще ніж нічого. Отже, були такі питання: А тепер мої відповіді:
<p>----------------------------------------</p>
Знову все перервав, відповідей не знайшов. Що ж. Викладу свої, хоча я писав їх чисто для себе, і по можливості коротко. Але все краще ніж нічого. Отже, були такі питання: <img data-id="48ab19be-883b-44ff-8073-e5021bbc4776" data-max-width="850" alt="36 рівень.  Відповіді на запитання до співбесіди на тему рівня - 1" src="https://cdn.javarush.com/images/article/48ab19be-883b-44ff-8073-e5021bbc4776/800.jpeg" style="width: 850px;"><strong>Запитання до співбесіди:</strong>
<ol>
 <li>Що таке <strong>MVC</strong> ?</li>
 <li>Що таке <strong>DAO</strong> та <strong>DTO</strong> ?</li>
 <li>Що таке <strong>POJO</strong> ?</li>
 <li>Що таке <strong>Entity</strong> ?</li>
 <li>Які <strong>колекції-списки</strong> ви знаєте?</li>
 <li>Які <strong>колекції-множини</strong> ви знаєте?</li>
 <li>Що таке <strong>map</strong> , чим він відрізняється від « <strong>словника</strong> »?</li>
 <li>Що таке <strong>Queue</strong> та <strong>Dequeue</strong> ?</li>
 <li>Які класи, які реалізують <strong>інтерфейс Queeue,</strong> ви знаєте?</li>
 <li>Що таке <strong>дерево</strong> ?</li>
</ol> А тепер мої відповіді: 
<ol>
 <li>
  <p><strong>MVC</strong> - це такий патерн проектування додаток, при якому програма поділяється на три окремі частини: модель (model), представлення (view) та контролер (controller). Модель надає дані та реагує на команди контролера, змінюючи свій стан. Подання відповідає за відображення даних моделі користувача, реагуючи на зміни моделі. А контролер інтерпретує дії користувача, сповіщаючи модель необхідність змін. Таким чином, кожен з компонентів цієї схеми слабо пов'язаний з іншими компонентами, за рахунок чого досягається гнучкість програми. Найчастіше вся бізнес-логіка розміщується в моделі, хоча іноді вона міститься і в контролері. У першому випадку модель називають тонкою, в останньому товстою.</p></li>
 <li>
  <p><strong>DAO</strong> (Data Access Object) - це об'єкт, основне завдання якого зберігати дані в базу даних, а також витягувати їх з неї. DTO (Data Transfer Object) – це об'єкт, призначений для транспортування даних. Тому його основне завдання – зберігати ці дані. Жодної логіки він не міститься. Крім того, він повинен бути серіалізується, так як транспортування об'єктів зазвичай відбувається за допомогою серіалізації-десеріалізації.</p></li>
 <li>
  <p><strong>POJO</strong> перекладається як "об'єкт Java у старому стилі". Їх протиставляють EJB-об'єктами. Останні слідують спеціальної конвенції і зазвичай жорстко прив'язані до якогось конкретного enterprise-фреймворку (наприклад, у них має бути публічний конструктор без параметрів, повинен бути гетери та сеттери для полів, вони мають бути серіалізованими тощо). POJO - це, відповідно, звичайний клас, який не успадковує ні від яких спеціальних класів і не реалізує жодних спеціальних бібліотек. Зазвичай POJO нічого особливого не робить і містить лише стан.</p></li>
 <li>
  <p><strong>Entity Bean</strong> – це бін, мета якого зберігати деякі дані. У логіку такого біна вбудований механізм збереження себе та своїх полів у базу даних. Такий об'єкт може бути знищений, а потім відтворений із бази заново. Але, крім зберігання даних, у нього немає жодної логіки. А бін у свою чергу - це особливий клас, який повинен виконувати такі правила:</p>
  <ul style="list-style-type:lower-alpha">
   <li>Клас повинен мати конструктор без параметрів з модифікатором доступу public. Такий конструктор дозволяє інструментам створити об'єкт без додаткових складнощів із параметрами.</li>
   <li>Властивості класу мають бути доступні через get, set та інші методи (так звані методи доступу), які повинні підкорятися стандартній угоді про імена. Це легко дозволяє інструментам автоматично визначати та оновлювати зміст bean'ів. Багато інструментів навіть мають спеціалізовані редактори для різних типів властивостей.</li>
   <li>Клас повинен бути серіалізованим. Це дає можливість надійно зберігати, зберігати та відновлювати стан bean незалежним від платформи та віртуальної машини способом.</li>
   <li>Клас повинен мати перевизначені методи equals(), hashCode() та toString().</li>
  </ul></li>
 <li>
  <p>Усі <strong>колекції-списки</strong> реалізують інтерфейс List&lt;E&gt; та успадковуються від абстрактного класу AbstractList&lt;E&gt;. Серед них можна виділити ArrayList&lt;E&gt; і LinkedList&lt;E7gt;. ArrayList7lt;E&gt; - це список, заснований на масиві, а LinkedList&lt;E&gt; - це класичний двозв'язний список.</p></li>
 <li>
  <p><strong>Колекції-множини</strong> Java реалізують інтерфейс Set&lt;E&gt; і успадковуються від AbstractSet&lt;E&gt;. Безліч – це такі набори даних, у яких всі елементи є унікальними. Серед них у Java є HashSet, LinkedHashSet та TreeSet. Перша колекція зберігає свої об'єкти на основі хеш-кодів. Друга - це модифікована перша, в ній елементи ще до того ж розташовуються у зв'язковому списку, тому всі вони розташовані в порядку додавання. Третя колекція забезпечує сортування своїх елементів.</p></li>
 <li>
  <p><strong>Map</strong> - це вид колекцій, що зберігають свої елементи у вигляді пар "ключ-значення". Причому всі ключі мають бути унікальними. Серед реалізацій є HashMap та TreeMap. Перша реалізація зберігає елементи з використанням хеш-кодів. Друга - зберігає елементи у відсортованому за ключом порядку.</p></li>
 <li>
  <p><strong>Черга (Queue)</strong> - це структура даних, що працює за принципом "Перший увійшов - перший вийшов". Тобто елементи до чергу додаються з одного кінця, а витягуються — з іншого. <strong>Deque</strong>- Це двостороння черга. У цій черзі елементи можна додавати як на початок, так і в кінець, а також брати елементи також можна і з початку, і з кінця черги. Відповідно є методи, які дозволяю покласти елемент (це методи add(e) та offer(e)), і є методи, що дозволяють вилучити елемент із черги (це такі методи, як remove() та poll()). Крім того, є методи, які дозволяють просто отримати елемент із черги без його видалення звідти (це методи element() та peek()). В інтерфейсі Deque додатково є методи для додавання елементів до початку і кінця черги, вилучення елементів з початку або кінця, а також отримання елементів з початку або кінця черги (без їх видалення з черги).</p></li>
 <li>
  <p>Серед простих реалізацій можна відзначити <strong>ArrayDeque</strong> , <strong>LinkedList</strong> та <strong>PriorityQueue</strong> . Також існують багато класів у Concurrent Collections, які реалізують ці два інтерфейси (обидва відразу чи тільки один з них).</p></li>
 <li>
  <p><strong>Дерево</strong> – це зв'язковий граф без петель та кратних ребер. Зазвичай, якщо в дереві N вершин, то кількість ребер як мінімум N-1. Також одну вершину в дереві вибирають як корінь. Інші вершини оголошують гілками. Гілки, які не мають своїх гілок, називаються листям дерева. <br>
    У програмуванні дерева використовуються досить широко, і придумано багато видів цього дерева. Одне з найбільш широко застосовуваних дерев - це бінарне дерево. У цьому дереві кожен елемент має не більше двох нащадків (тобто може бути від 0 до 2). Одним із різновидів двійкового дерева є BST — бінарне дерево пошуку. У цьому дереві на елементи накладається правило: лівий нащадок елемента повинні бути за значенням меншим за нього, а правий — за значенням більшим за нього або дорівнює йому.<br>
    Також ще є червоно-чорні дерева. Це різновид двійкових дерев пошуку. У червоно-чорних деревах вводиться ще одна властивість елемента – колір. Колір може бути чорний чи червоний. Також кожне червоно-чорне дерево повинне задовольняти такі вимоги:</p>
  <ol>
   <li>корінь дерева – чорний;</li>
   <li>вузол або червоний, або чорний;</li>
   <li>все листя дерева - чорні;</li>
   <li>обидва нащадки червоно вузла – чорні;</li>
   <li>всякий шлях від цього вузла до будь-якого листового вузла, що є його нащадка, містить однакову кількість чорних вузлів.</li>
  </ol></li>
</ol>Ці правила дозволяють досягти збалансованості дерева. Дерево збалансоване, коли довжина шляху від кореня до будь-якого листового вузла відрізняється не більше, ніж на 1. (Тобто по-простому, у дереві немає перекосів та довгих гілок).