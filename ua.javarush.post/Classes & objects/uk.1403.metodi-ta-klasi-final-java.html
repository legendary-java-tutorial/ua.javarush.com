Методи та класи final Java
<p>----------------------------------------</p>
Позначаючи метод класу модифікатором , ми маємо на увазі, що жоден похідний клас неспроможна перевизначити цей метод, змінивши його внутрішню реалізацію. Іншими словами, йдеться про фінальну версію методу. Клас загалом також може бути позна
<p>----------------------------------------</p>
Позначаючи метод класу модифікатором <code class=" language-none"><strong>final</strong></code>, ми маємо на увазі, що жоден похідний клас неспроможна перевизначити цей метод, змінивши його внутрішню реалізацію. Іншими словами, йдеться про фінальну версію методу. Клас загалом також може бути позначений як <code class=" language-none"><strong>final</strong></code>. <img data-id="ba738c64-b6ac-48c5-80b9-33190a1e90e7" data-max-width="850" alt="Методи та класи final Java - 1" src="https://cdn.javarush.com/images/article/ba738c64-b6ac-48c5-80b9-33190a1e90e7/800.jpeg" style="width: 850px;">
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">final</span></span> <span class="token keyword"><span class="token keyword">class</span></span> <span class="token class-name"><span class="token class-name">NoExtending</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
<span class="token comment"><span class="token comment">// …</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> Клас, позначений як <code class=" language-none"><strong>final</strong></code>, не піддається успадкування і всі його методи опосередковано набувають властивість <code class=" language-none"><strong>final</strong></code>. Застосування ознака <code class=" language-none"><strong>final</strong></code>в оголошеннях класів і методів здатне підвищити рівень безпеки коду. Якщо клас має модифікатор <code class=" language-none"><strong>final</strong></code>, ніхто не в стані розширити клас і, ймовірно, порушити при цьому його контракт. Якщо ознакою <code class=" language-none"><strong>final</strong></code>позначено метод, ви можете повністю довіряти його внутрішній реалізації у всіх ситуаціях, не побоюючись "підробки". Доречно застосувати<code class=" language-none"><strong>final</strong></code>наприклад, в оголошенні методу, що передбачає перевірку пароля, що вводиться користувачем, щоб гарантувати точне виконання того, що методом передбачено спочатку. Можливому зловмиснику не вдасться змінити вихідну реалізацію такого методу, "підсунувши" програмі його перевизначену версію, яка, скажімо, завжди повертає значення true, що свідчить про успішну реєстрацію користувача, незалежно від того, який пароль він запровадив насправді. Ви маєте право, якщо дозволяє конкретна ситуація, піти далі і оголосити як <code class=" language-none"><strong>final</strong></code>клас цілком; метод <code class=" language-none"><strong>ValidatePassword</strong></code>набуде те саме властивість непрямим шляхом. Вживання модифікатора <code class=" language-none"><strong>final</strong></code>в оголошенні методу чи класу накладає серйозні обмеження можливість подальшого використання та розвитку коду. Застосування<code class=" language-none"><strong>final</strong></code>в оголошенні методу - це правильний показник того, що реалізація методу самодостатня та повністю завершена. Інші програмісти, які захочуть користуватися вашим класом, розширивши його функції для своїх потреб, будуть обмежені у виборі засобів досягнення мети або повністю позбавлені таких. Помітивши ознакою <code class=" language-none"><strong>final</strong></code>клас загалом, ви забороните можливість його успадкування і, мабуть, суттєво знизите його практичну цінність іншим. Зібравшись застосувати модифікатор <code class=" language-none"><strong>final</strong></code>, переконайтеся, чи готові ВИ до подібних жертв і чи варто їх принести. У багатьох випадках для досягнення достатнього рівня безпеки коду немає необхідності позначати весь клас як <code class=" language-none"><strong>final</strong></code>– цілком можливо зберегти здатність класу до розширення, помітивши модифікатором<code class=" language-none"><strong>final</strong></code>лише його "критичні" структурні елементи. У цьому випадку ви залишите в недоторканності основні функції класу і одночасно дозволите його успадкування з додаванням нових членів, але без перевизначення "старих". Вочевидь, поля, яких звертається код методів <code class=" language-none"><strong>final</strong></code>, повинні бути у свою чергу позначені як <code class=" language-none"><strong>final</strong></code>або <code class=" language-none"><strong>private</strong></code>, оскільки у іншому разі будь-який похідний клас отримає можливість змінювати їх вміст, впливаючи на поведінка відповідних методів. Ще один ефект застосування модифікатора <code class=" language-none"><strong>final</strong></code>пов'язаний зі спрощенням задачі оптимізації коду, що вирішується компілятором. Ось що відбувається, коли викликається метод, не помічений як<code class=" language-none"><strong>final</strong></code>, виконуюча система визначає фактичний клас об'єкта, пов'язує виклик з найбільш відповідним кодом групи перевантажених методів і передає управління цьому коду. Але якби, наприклад, метод <code class=" language-none"><strong>getName</strong></code>у прикладі класу <code class=" language-none"><strong>Attr</strong></code>, розглянутому раніше, був позначений як <code class=" language-none"><strong>final</strong></code>операція звернення до нього, можливо, була б помітно спрощена. У самому тривіальному випадку, подібному до того, що стосується <code class=" language-none"><strong>getName</strong></code>, компілятор може просто замінити виклик методу кодом його тіла. Такий механізм зветься вбудовування коду (inlining). При використанні inline-версії методу <code class=" language-none"><strong>getName</strong></code>два наступні вирази виконуються абсолютно однаково: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class="  language-java">system<span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">"id = "</span></span> <span class="token operator"><span class="token operator">+</span></span> rose<span class="token punctuation"><span class="token punctuation">.</span></span>name<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
system<span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">"id = "</span></span> <span class="token operator"><span class="token operator">+</span></span> rose<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">getName</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> Хоча наведені висловлювання рівнозначні, друге все-таки має перевагу, оскільки метод <code class=" language-none"><strong>getName</strong></code>дозволяє надати полю name властивість "тільки для читання", а коду класу - певний ступінь абстракції, який забезпечує можливість більш вільної зміни реалізації класу. Та ж схема оптимізації може бути застосована компілятором і по відношенню до методів <code class=" language-none"><strong>private</strong></code>і <code class=" language-none"><strong>statiс</strong></code>, так як вони не допускають перевизначення. Використання модифікатора <code class=" language-none">final</code>в оголошеннях класів сприяє підвищенню ефективності деяких операцій перевірки типів. У цьому випадку багато таких операцій можуть бути виконані вже на стадії компіляції і тому потенційні помилки виявляються набагато раніше. Якщо компілятор зустрічає у вихідному тексті посилання на клас<code class=" language-none"><strong>final</strong></code>, може бути " впевнений " , що відповідний об'єкт належить саме до типу, який зазначений. Компілятор може відразу визначити місце, займане класом у спільній ієрархії класів, і перевірити, вірно той використовується чи ні. Якщо модифікатор <code class=" language-none"><strong>final</strong></code>не застосовується, відповідні перевірки здійснюються лише на стадії виконання програми. <em>Вправа</em> 3.4. Чи доцільно включити в оголошення методів (і якщо так, та яких саме) класів <strong>vehicle</strong> і passengervehicle модифікатор <strong>final</strong> ? Посилання на першоджерело: <a href="http://src-code.net/metody-i-klassy-final-java/" rel="nofollow" target="_blank">http://src-code.net/metody-i-klassy-final-java</a>