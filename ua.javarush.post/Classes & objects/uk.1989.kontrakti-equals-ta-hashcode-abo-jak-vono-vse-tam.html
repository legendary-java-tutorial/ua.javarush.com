Контракти equals та hashCode або як воно все там
<p>----------------------------------------</p>
Переважна більшість програмуючих на Java звичайно ж знають, що методи і тісно пов'язані один з одним, і що обидва ці методи бажано перевизначати у своїх класах узгоджено. Трохи менше знають, чому це так і які сумні наслідки можуть бути, якщ
<p>----------------------------------------</p>
Переважна більшість програмуючих на Java звичайно ж знають, що методи <code class=" language-none">equals</code>і <code class=" language-none">hashCode</code>тісно пов'язані один з одним, і що обидва ці методи бажано перевизначати у своїх класах узгоджено. Трохи менше знають, чому це так і які сумні наслідки можуть бути, якщо порушити це правило. Пропоную розглянути концепцію цих методів, повторити їх призначення та розібратися, чому вони так пов'язані. Цю статтю, як і попередню завантаження класів, я писав для себе, щоб остаточно розкрити всі деталі питання і більше не повертатися до сторонніх джерел. Тому буду радий конструктивній критиці, оскільки якщо десь є прогалини, їх слід усунути. Стаття, на жаль, вийшла досить великою. 
<h2>Правила перевизначення equals</h2>Метод <code class=" language-none">equals()</code>необхідний Java для підтвердження або заперечення того факту, що два об'єкти одного походження є <em>логічно рівними</em> . Тобто, порівнюючи два об'єкти, програмісту необхідно зрозуміти, чи еквівалентні їх <em>значущі поля</em> . Не обов'язково всі поля мають бути ідентичними, оскільки метод <code class=" language-none">equals()</code>має на увазі саме <em>логічну рівність</em> . Але іноді немає особливої ​​потреби у використанні цього методу. Як кажуть, найлегший шлях уникнути проблем, використовуючи той чи інший механізм не використовувати його. Також слід зауважити, що одного разу порушивши контракт<code class=" language-none">equals</code>ви втрачаєте контроль над розумінням того, як інші об'єкти та структури взаємодіятимуть з вашим об'єктом. І згодом знайти причину помилки буде дуже важко. 
<h3>Коли не варто перевизначати цей метод</h3>
<ul>
 <li><strong>Коли кожен екземпляр класу є унікальним.</strong></li> Більшою мірою це стосується тих класів, які надають певну поведінку, ніж призначені для роботи з даними. Таких, наприклад, як клас <code class=" language-none">Thread</code>. Їх реалізації методу <code class=" language-none">equals</code>, наданого класом <code class=" language-none">Object</code>, більш ніж достатньо. Інший приклад - класи перерахувань ( <code class=" language-none">Enum</code>). 
 <li><strong>Коли насправді від класу не потрібно визначати еквівалентність його екземплярів.</strong></li> Наприклад, для класу <code class=" language-none">java.util.Random</code>взагалі немає необхідності порівнювати між собою екземпляри класу, визначаючи, чи можуть вони повернути однакову послідовність випадкових чисел. Просто тому, що природа цього класу навіть не має на увазі таку поведінку. 
 <li><strong>Коли клас, який ви розширюєте, вже має власну реалізацію способу <code class=" language-none">equals</code>і поведінка цієї реалізації вас влаштовує.</strong></li> Наприклад, для класів <code class=" language-none">Set</code>, <code class=" language-none">List</code>, <code class=" language-none">Map</code>реалізація <code class=" language-none">equals</code>знаходиться у <code class=" language-none">AbstractSet</code>, <code class=" language-none">AbstractList</code>і <code class=" language-none">AbstractMap</code>відповідно. 
 <li><strong>І, нарешті, немає необхідності перекривати <code class=" language-none">equals</code>, коли область видимості вашого класу є <code class=" language-none">private</code>або <code class=" language-none">package-private</code>ви впевнені, що цей метод ніколи не буде викликаний.</strong></li>
</ul>
<h3>Контракт equals</h3>При перевизначенні методу <code class=" language-none">equals</code>розробник повинен дотримуватися основних правил, визначених специфікації мови Java. 
<ul>
 <li><strong>Рефлексивність</strong></li> для будь-якого заданого значення <code class=" language-none">x</code>, вираз <code class=" language-none">x.equals(x)</code>має повертати <code class=" language-none">true</code>. 
 <br><em>Заданого</em> - мається на увазі такого, що<code class=" language-none">x != null</code>
 <li><strong>Симетричність</strong></li> для будь-яких заданих значень <code class=" language-none">x</code>і <code class=" language-none">y</code>, <code class=" language-none">x.equals(y)</code>має повертати <code class=" language-none">true</code>тільки в тому випадку, <code class=" language-none">y.equals(x)</code>коли <code class=" language-none">true</code>. 
 <li><strong>Транзитивність</strong></li> для будь-яких заданих значень <code class=" language-none">x</code>, <code class=" language-none">y</code>і <code class=" language-none">z</code>, якщо <code class=" language-none">x.equals(y)</code>повертає <code class=" language-none">true</code>та <code class=" language-none">y.equals(z)</code>повертає <code class=" language-none">true</code>, <code class=" language-none">x.equals(z)</code>має повернути значення <code class=" language-none">true</code>. 
 <li><strong>Узгодженість</strong></li> для будь-яких заданих значень <code class=" language-none">x</code>та <code class=" language-none">y</code>повторний виклик <code class=" language-none">x.equals(y)</code>повертатиме значення попереднього виклику цього методу за умови, що поля, які використовуються для порівняння цих двох об'єктів, не змінювалися між викликами. 
 <li><strong>Порівняння null</strong></li> для будь-якого заданого значення <code class=" language-none">x</code>виклик <code class=" language-none">x.equals(null)</code>повинен повертати <code class=" language-none">false</code>.
</ul>
<h3>Порушення контракту equals</h3>Багато класи, наприклад класи з Java Collections Framework, залежить від реалізації методу <code class=" language-none">equals()</code>, тому варто їм нехтувати, т.к. Порушення договору цього може призвести до нераціональної роботі програми й у разі знайти причину буде досить складно. Відповідно до принципу <u><strong>рефлексивності</strong></u> , кожен об'єкт має бути еквівалентним самому собі. Якщо цей принцип буде порушено, при додаванні об'єкта в колекцію та при подальшому пошуку його за допомогою методу <code class=" language-none">contains()</code>ми не зможемо знайти той об'єкт, який щойно поклали до колекції. Умова <u><strong>симетричності</strong></u>свідчить, що два будь-яких об'єкти повинні бути рівними незалежно від того, в якому порядку вони будуть порівнюватися. Наприклад, маючи клас, що містить одне поле рядкового типу, буде неправильно порівнювати в методі <code class=" language-none">equals</code>дане поле з рядком. Т.к. у разі зворотного порівняння метод завжди поверне значення <code class=" language-none">false</code>. 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token comment"><span class="token comment">// Нарушение симметричности</span></span>
<span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">class</span></span> <span class="token class-name"><span class="token class-name">SomeStringify</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
    <span class="token keyword"><span class="token keyword">private</span></span> <span class="token class-name"><span class="token class-name">String</span></span> s<span class="token punctuation"><span class="token punctuation">;</span></span>

    <span class="token annotation punctuation"><span class="token annotation punctuation">@Override</span></span>
    <span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">boolean</span></span> <span class="token function"><span class="token function">equals</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">Object</span></span> o<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
        <span class="token keyword"><span class="token keyword">if</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">this</span></span> <span class="token operator"><span class="token operator">==</span></span> o<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token keyword"><span class="token keyword">return</span></span> <span class="token boolean"><span class="token boolean">true</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token keyword"><span class="token keyword">if</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span>o <span class="token keyword"><span class="token keyword">instanceof</span></span> <span class="token class-name"><span class="token class-name">SomeStringify</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
            <span class="token keyword"><span class="token keyword">return</span></span> s<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">equals</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">SomeStringify</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> o<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>s<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token punctuation"><span class="token punctuation">}</span></span>
        <span class="token comment"><span class="token comment">// нарушение симметричности, классы разного происхождения</span></span>
        <span class="token keyword"><span class="token keyword">if</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span>o <span class="token keyword"><span class="token keyword">instanceof</span></span> <span class="token class-name"><span class="token class-name">String</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
            <span class="token keyword"><span class="token keyword">return</span></span> s<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">equals</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>o<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token punctuation"><span class="token punctuation">}</span></span>
        <span class="token keyword"><span class="token keyword">return</span></span> <span class="token boolean"><span class="token boolean">false</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token punctuation"><span class="token punctuation">}</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre>
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token comment"><span class="token comment">//Правильное определение метода equals</span></span>
<span class="token annotation punctuation"><span class="token annotation punctuation">@Override</span></span>
<span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">boolean</span></span> <span class="token function"><span class="token function">equals</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">Object</span></span> o<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
    <span class="token keyword"><span class="token keyword">if</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">this</span></span> <span class="token operator"><span class="token operator">==</span></span> o<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token keyword"><span class="token keyword">return</span></span> <span class="token boolean"><span class="token boolean">true</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token keyword"><span class="token keyword">return</span></span> o <span class="token keyword"><span class="token keyword">instanceof</span></span> <span class="token class-name"><span class="token class-name">SomeStringify</span></span> <span class="token operator"><span class="token operator">&amp;&amp;</span></span>
            <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">SomeStringify</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> o<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>s<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">equals</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>s<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> З умови <u><strong>транзитивності</strong></u> випливає, що якщо будь-які два з трьох об'єктів рівні, то в такому разі мають бути рівні три. Цей принцип легко порушити у разі, коли потрібно розширити якийсь базовий клас, додавши щодо нього <em>значний компонент</em> . Наприклад, до класу <code class=" language-none">Point</code>з координатами <code class=" language-none">x</code>необхідно <code class=" language-none">y</code>додати колір точки, розширивши його. Для цього потрібно оголосити клас <code class=" language-none">ColorPoint</code>із відповідним полем <code class=" language-none">color</code>. Таким чином, якщо в розширеному класі викликати метод <code class=" language-none">equals</code>батька, а в батьківському вважатимемо, що порівнюються лише координати <code class=" language-none">x</code>та<code class=" language-none">y</code>тоді дві точки різного кольору, але з однаковими координатами будуть вважатися рівними, що неправильно. У такому разі необхідно навчити похідний клас розрізняти кольори. Для цього можна скористатися двома способами. Але один порушуватиме правило <em>симетричності</em> , а другий — <em>транзитивності</em> . 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token comment"><span class="token comment">// Первый способ, нарушая симметричность</span></span>
<span class="token comment"><span class="token comment">// Метод переопределен в классе ColorPoint</span></span>
<span class="token annotation punctuation"><span class="token annotation punctuation">@Override</span></span>
<span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">boolean</span></span> <span class="token function"><span class="token function">equals</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">Object</span></span> o<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
    <span class="token keyword"><span class="token keyword">if</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token operator"><span class="token operator">!</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>o <span class="token keyword"><span class="token keyword">instanceof</span></span> <span class="token class-name"><span class="token class-name">ColorPoint</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token keyword"><span class="token keyword">return</span></span> <span class="token boolean"><span class="token boolean">false</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token keyword"><span class="token keyword">return</span></span> <span class="token keyword"><span class="token keyword">super</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">equals</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>o<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token operator"><span class="token operator">&amp;&amp;</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">ColorPoint</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> o<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>color <span class="token operator"><span class="token operator">==</span></span> color<span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> І тут виклик <code class=" language-none">point.equals(colorPoint)</code>поверне значення <code class=" language-none">true</code>, а порівняння <code class=" language-none">colorPoint.equals(point)</code>— <code class=" language-none">false</code>, т.к. очікує об'єкт "свого" класу. У такий спосіб і порушується правило симетричності. Другий спосіб має на увазі робити "сліпу" перевірку, у разі, коли немає даних про колір точки, тобто маємо клас <code class=" language-none">Point</code>. Або перевіряти колір, якщо інформація про нього доступна, тобто порівнювати об'єкт класу <code class=" language-none">ColorPoint</code>. 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token comment"><span class="token comment">// Метод переопределен в классе ColorPoint</span></span>
<span class="token annotation punctuation"><span class="token annotation punctuation">@Override</span></span>
<span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">boolean</span></span> <span class="token function"><span class="token function">equals</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">Object</span></span> o<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
    <span class="token keyword"><span class="token keyword">if</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token operator"><span class="token operator">!</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>o <span class="token keyword"><span class="token keyword">instanceof</span></span> <span class="token class-name"><span class="token class-name">Point</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token keyword"><span class="token keyword">return</span></span> <span class="token boolean"><span class="token boolean">false</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>

    <span class="token comment"><span class="token comment">// Слепая проверка</span></span>
    <span class="token keyword"><span class="token keyword">if</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token operator"><span class="token operator">!</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>o <span class="token keyword"><span class="token keyword">instanceof</span></span> <span class="token class-name"><span class="token class-name">ColorPoint</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
        <span class="token keyword"><span class="token keyword">return</span></span> <span class="token keyword"><span class="token keyword">super</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">equals</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>o<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>

    <span class="token comment"><span class="token comment">// Полная проверка, включая цвет точки</span></span>
    <span class="token keyword"><span class="token keyword">return</span></span> <span class="token keyword"><span class="token keyword">super</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">equals</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>o<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token operator"><span class="token operator">&amp;&amp;</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">ColorPoint</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> o<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>color <span class="token operator"><span class="token operator">==</span></span> color<span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> Принцип <em>транзитивності</em> тут порушується так. Допустимо, є визначення наступних об'єктів: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">ColorPoint</span></span> p1 <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">ColorPoint</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token number"><span class="token number">1</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token number"><span class="token number">2</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token class-name"><span class="token class-name">Color</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>RED<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token class-name"><span class="token class-name">Point</span></span> p2 <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">Point</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token number"><span class="token number">1</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token number"><span class="token number">2</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token class-name"><span class="token class-name">ColorPoint</span></span> p3 <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">ColorPoint</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token number"><span class="token number">1</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token number"><span class="token number">2</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token class-name"><span class="token class-name">Color</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>BLUE<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> Таким чином хоч і виконується рівність і <code class=" language-none">p1.equals(p2)</code>поверне значення . У цьому другий спосіб, мій погляд, виглядає менш привабливим, т.к. в деяких випадках алгоритм може засліпнути і не виконати порівняння повною мірою, а ви про це можете і не дізнатися. <em>Трохи лірики</em> Загалом конкретного вирішення цієї проблеми, як я зрозумів, немає. Існує думка одного авторитетного автора на ім'я Кей Хорстманн, що можна замінити використання оператора на виклик методу , який повертає клас об'єкта і, перш ніж почати порівнювати самі об'єкти, переконатися, що вони одного типу, а на факт їхнього загального походження не звертати уваги. Таким чином, правила <em>симетричності</em> та <em>транзитивності</em><code class=" language-none">p2.equals(p3)</code><code class=" language-none">p1.equals(p3)</code><code class=" language-none">false</code><em></em><code class=" language-none">instanceof</code><code class=" language-none">getClass()</code><em></em><em></em>будуть виконані. Але при цьому з іншого боку барикади стоїть ще один не менш шанований у широких колах автор Джошуа Блох, який вважає, що такий підхід порушує принцип підстановки Барбари Лисков. Цей принцип говорить, що <em>“викликаючий код повинен працювати з базовим класом так само, як і з його підкласами, не знаючи про це”</em> . І у рішенні, запропонованому Хорстманном, цей принцип явно порушується, тому що залежить від реалізації. Коротше справа ясна, що справа темна. Слід також зазначити, що Хорстманн уточнює правило застосування свого підходу і англійською по білому пише, що потрібно визначитися зі стратегією при проектуванні класів, і якщо перевірка на рівність проводитиметься лише силами суперкласу, можна це робити, виконуючи операцію<code class=" language-none">instanceof</code>. Інакше, коли семантика перевірки змінюється залежно від похідного класу і методу потрібно спустити вниз по ієрархії, необхідно використовувати метод <code class=" language-none">getClass()</code>. Джошуа Блох, у свою чергу, пропонує відмовитися від успадкування і скористатися композицією об'єктів, включивши до складу класу клас <code class=" language-none">ColorPoint</code>і <code class=" language-none">Point</code>надавши метод доступу <code class=" language-none">asPoint()</code>для отримання інформації конкретно про точку. Це дозволить уникнути порушення всіх правил, але, як на мене, ускладнить розуміння коду. Третій варіант – скористатися автоматичною генерацією методу equals за допомогою IDE. Idea, до речі, відтворює генерацію за Хорстманном, причому дозволяючи вибрати стратегію реалізації методу у суперкласі чи його спадкоємцях. І, нарешті, таке правило <u><strong>узгодженості</strong></u>говорить, що й об'єкти <code class=" language-none">x</code>і <code class=" language-none">y</code>змінюються, повторний виклик <code class=" language-none">x.equals(y)</code>повинен відновити те саме значення, як і раніше. Останнє правило полягає в тому, що жоден об'єкт не повинен дорівнювати <code class=" language-none">null</code>. Тут усе зрозуміло <code class=" language-none">null</code>— це невизначеність, чи об'єкт невизначеності дорівнює? Незрозуміло, тобто <code class=" language-none">false</code>. 
<h3>Загальний алгоритм визначення equals</h3>
<ol>
 <li>Перевірити рівність посилання об'єктів <code class=" language-none">this</code>і параметра методу <code class=" language-none">o</code>.<br><code class=" language-none">if (this == o) return true;</code></li>
 <li>Перевірити, чи визначено посилання <code class=" language-none">o</code>, тобто є вона <code class=" language-none">null</code>. <br>
   Якщо в подальшому при порівнянні типів об'єктів використовуватиметься оператор <code class=" language-none">instanceof</code>, цей пункт можна пропустити, тому що цей параметр повертає <code class=" language-none">false</code>в даному випадку <code class=" language-none">null instanceof Object</code>.</li>
 <li>Порівняти типи об'єктів <code class=" language-none">this</code>і <code class=" language-none">o</code>за допомогою оператора <code class=" language-none">instanceof</code>або методу <code class=" language-none">getClass()</code>, керуючись описом вище та власним чуттям.</li>
 <li>Якщо метод <code class=" language-none">equals</code>перевизначається у підкласі, не забудьте зробити виклик<code class=" language-none">super.equals(o)</code></li>
 <li>Перетворення типу параметра <code class=" language-none">o</code>до потрібного класу.</li>
 <li>Здійснити порівняння всіх значних полів об'єктів: 
  <ul>
   <li>для примітивних типів (крім <code class=" language-none">float</code>і <code class=" language-none">double</code>), використовуючи оператор<code class=" language-none">==</code></li>
   <li>для посилальних полів необхідно викликати їх метод<code class=" language-none">equals</code></li>
   <li>для масивів можна користуватися перебором по циклу, або шляхом<code class=" language-none">Arrays.equals()</code></li>
   <li>для типів <code class=" language-none">float</code>і <code class=" language-none">double</code>необхідно використовувати методи порівняння відповідних обгорткових класів <code class=" language-none">Float.compare()</code>та<code class=" language-none">Double.compare()</code></li>
  </ul></li>
 <li>І, нарешті, відповісти на три питання: чи є реалізований метод <u>симетричним</u> ? <u>Транзитивним</u> ? <u>Узгодженим</u> ? Два інших принципи ( <u>рефлексивність</u> та <u>визначеність</u> ), як правило, виконуються автоматично.</li>
</ol>
<h3>Правила перевизначення hashCode</h3>Хеш - це деяке число, що генерується на основі об'єкта і описує його стан в якийсь момент часу. Це число використовується Java переважно в хеш-таблицях, таких як <code class=" language-none">HashMap</code>. При цьому хеш-функція отримання числа на основі об'єкта повинна бути реалізована таким чином, щоб забезпечити рівномірний розподіл елементів по хеш-таблиці. А також мінімізувати можливість появи колізій, коли за різними ключами функція поверне однакове значення. 
<h3>Контракт hashCode</h3>Для реалізації хеш-функції у специфікації мови визначено такі правила: 
<ul>
 <li>виклик методу <code class=" language-none">hashCode</code>один і більше разів над тим самим об'єктом повинен повертати те саме хеш-значення, за умови що поля об'єкта, що беруть участь у обчисленні значення, не змінювалися.</li>
 <li>виклик методу <code class=" language-none">hashCode</code>над двома об'єктами повинен завжди повертати те саме число, якщо ці об'єкти рівні (виклик методу <code class=" language-none">equals</code>цих об'єктів повертає <code class=" language-none">true</code>).</li>
 <li>виклик методу <code class=" language-none">hashCode</code>над двома нерівними між собою об'єктами має повертати різні хеш-значення. Хоча ця вимога не є обов'язковою, слід враховувати, що її виконання позитивно вплине на продуктивність роботи хеш-таблиць.</li>
</ul>
<h3>Методи equals та hashCode необхідно перевизначати разом</h3>Виходячи з описаних вище контрактів слід, що перевизначаючи у своєму коді метод <code class=" language-none">equals</code>, необхідно завжди перевизначати і метод <code class=" language-none">hashCode</code>. Так як фактично два екземпляри класу відрізняються, тому що знаходяться в різних сферах пам'яті, порівнювати їх доводиться за деякими логічними ознаками. Відповідно, два логічно еквівалентні об'єкти повинні повертати однакове значення хеш-функції. <u><strong>Що станеться, якщо буде перевизначено лише один із цих методів?</strong></u>
<ol>
 <li>
  <p><code class=" language-none">equals</code>є, <code class=" language-none">hashCode</code>ні</p>
  <p>Допустимо ми правильно визначабо метод <code class=" language-none">equals</code>у нашому класі, а метод <code class=" language-none">hashCode</code>вирішабо залишити як він є у класі <code class=" language-none">Object</code>. Тоді з погляду методу <code class=" language-none">equals</code>два об'єкти будуть логічно рівні, тоді як із погляду методу <code class=" language-none">hashCode</code>вони нічого очікувати мати нічого спільного. І, таким чином, поміщаючи якийсь об'єкт у хеш-таблицю, ми ризикуємо не отримати його за ключом. <br>
    Наприклад, так:</p>
  <pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">Map</span></span><span class="token generics"><span class="token punctuation"></span><span class="token generics"><span class="token punctuation"><span class="token punctuation">&lt;</span></span><span class="token class-name"><span class="token class-name">Point</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token class-name"><span class="token class-name">String</span></span><span class="token punctuation"><span class="token punctuation">&gt;</span></span></span><span class="token punctuation"></span></span> m <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">HashMap</span></span><span class="token generics"><span class="token punctuation"></span><span class="token generics"><span class="token punctuation"><span class="token punctuation">&lt;</span></span><span class="token punctuation"><span class="token punctuation">&gt;</span></span></span><span class="token punctuation"></span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
m<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">put</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">Point</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token number"><span class="token number">1</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token number"><span class="token number">1</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> “<span class="token class-name"><span class="token class-name">Point</span></span> <span class="token class-name"><span class="token class-name">A</span></span>”<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token comment"><span class="token comment">// pointName == null</span></span>
<span class="token class-name"><span class="token class-name">String</span></span> pointName <span class="token operator"><span class="token operator">=</span></span> m<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">get</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">Point</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token number"><span class="token number">1</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token number"><span class="token number">1</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre>
  <p>Очевидно, що об'єкт, що міститься і шукається, — це два різні об'єкти, хоча вони і є логічно рівними. Проте, т.к. вони мають різне хеш-значення, тому що ми порушабо контракт, можна сказати, що ми втратабо свій об'єкт десь у надрах хеш-таблиці.</p>
  <p></p></li>
 <li>
  <p><code class=" language-none">hashCode</code>є, <code class=" language-none">equals</code>ні.</p>
  <p>Що буде, якщо ми перевизначимо метод <code class=" language-none">hashCode</code>, а реалізацію методу <code class=" language-none">equals</code>успадкуємо з класу <code class=" language-none">Object</code>. Як відомо, метод <code class=" language-none">equals</code>за замовчуванням просто порівнює покажчики на об'єкти, визначаючи, чи посилаються вони на той самий об'єкт. Припустимо, що метод <code class=" language-none">hashCode</code>ми написали за всіма канонами, а саме згенерували засобами IDE, і він повертатиме однакові хеш-значення для логічно однакових об'єктів. Очевидно, що цим ми вже визначабо деякий механізм порівняння двох об'єктів.<br></p>
  <p>Отже, приклад із попереднього пункту за ідеєю має виконуватися. Але ми, як і раніше, не зможемо знайти наш об'єкт у хеш-таблиці. Хоча будемо вже близькі до цього, бо щонайменше знайдемо кошик хеш-таблиці, в якому об'єкт лежатиме.<br></p>
  <p>Для успішного пошуку об'єкта в хеш-таблиці крім порівняння хеш-значень ключа використовується також визначення логічної рівності ключа з об'єктом, що шукається. Т. е. без перевизначення методу <code class=" language-none">equals</code>ніяк не вийде обійтися.</p></li>
</ol>
<h2>Загальний алгоритм визначення hashCode</h2>Тут, мені здається, взагалі не варто сильно переживати та виконати генерацію методу у своїй улюбленій IDE. Тому що всі ці усунення бітів праворуч, ліворуч у пошуку золотого перерізу, тобто нормального розподілу — це для зовсім затятих чуваків. Особисто я сумніваюся, що зможу зробити краще та швидше, ніж та сама Idea. 
<h2>Замість ув'язнення</h2>Таким чином, ми бачимо, що методи <code class=" language-none">equals</code>і <code class=" language-none">hashCode</code>відіграють чітко певну роль у мові Java і призначені для одержання характеристики логічної рівності двох об'єктів. У випадку з методом <code class=" language-none">equals</code>це має пряме відношення до порівняння об'єктів, у разі <code class=" language-none">hashCode</code>непряме, коли необхідно, скажімо так, визначити зразкове розташування об'єкта в хеш-таблицях або подібних структурах даних з метою збільшення швидкості пошуку об'єкта. Крім контрактів <code class=" language-none">equals</code>є <code class=" language-none">hashCode</code>ще одна вимога, що відноситься до порівняння об'єктів. Це узгодженість методу <code class=" language-none">compareTo</code>інтерфейсу <code class=" language-none">Comparable</code>з методом <code class=" language-none">equals</code>. Ця вимога зобов'язує розробника завжди повертати <code class=" language-none">x.equals(y) == true</code>, коли<code class=" language-none">x.compareTo(y) == 0</code>. Т. е. ми бачимо, що логічне порівняння двох об'єктів не повинно суперечити ніде в додатку і завжди бути узгодженим. 
<h2>Джерела</h2><a href="https://www.amazon.com/Effective-Java-2nd-Joshua-Bloch/dp/0321356683" target="_blank" rel="nofollow">Effective Java, Second Edition. Joshua Bloch. </a> Вільний переклад дуже непоганої книги. <a href="https://www.ozon.ru/context/detail/id/137377512/" target="_blank" rel="nofollow">Java, бібліотека професіонала. Том 1. Основи. Кей Хорстманн. </a> Трохи менше теорії та більше практики. Але не так детально розібрано все, як у Блоха. Хоча є свій погляд на той же equals(). <a href="https://habr.com/post/128017" target="_blank" rel="nofollow">Структури даних у картинках. HashMap</a> Вкрай корисна стаття з пристрою HashMap у Java. Замість того, щоб вихідники дивитися.