Гарвард CS50: завдання другого тижня (лекції 5 та 6)
<p>----------------------------------------</p>
Лекції CS50 лежать тут: . У цьому матеріалі - 3 завдання, теоретичні відомості до них та керівництво до дії. • Поглибитись у функції та бібліотеки • Познайомитись з криптографією, реалізувати пару простих шифрів https://reference.cs50.net/ 
<p>----------------------------------------</p>
<img data-id="d22c4e71-1f11-428b-af81-2d5d2265bb96" data-max-width="740" alt="cs50 завдання до лекцій 5 та 6" src="https://cdn.javarush.com/images/article/d22c4e71-1f11-428b-af81-2d5d2265bb96/512.jpeg" style="width: 740px;"> Лекції CS50 лежать тут: <a href="https://cdn.javarush.com/images/article/155cea79-acfd-4968-9361-ad585e939b82/original.pngcs50.html">https://cdn.javarush.com/images/article/155cea79-acfd-4968-9361-ad585e939b82/original.pngcs50.html</a> . У цьому матеріалі - 3 завдання, теоретичні відомості до них та керівництво до дії. 
<h4>Цілі</h4> • Поглибитись у функції та бібліотеки • Познайомитись з криптографією, реалізувати пару простих шифрів 
<h4>Додаткові матеріали</h4> https://reference.cs50.net/ — роз'яснення функцій бібліотек під час навчання. Англійською. <a href="http://computer.howstuffworks.com/c.htm" rel="nofollow">http://computer.howstuffworks.com/c.htm</a> стор 11 – 14 та 39 
<h4>Підготовка</h4> Залогіньтесь на cs50.io, <code class=" language-none">update50</code> щоб переконатися в актуальності версії вашого робочого простору. Якщо ви випадково закрабо термінальне вікно, зайдіть у меню View і переконайтеся, що навпроти пункту Console стоїть галочка (поставте її, якщо це не так). <img data-id="4df836f2-afce-416d-a7a7-a4c133745ef9" data-max-width="422" alt="Гарвард CS50: завдання другого тижня (лекції 5 та 6) - 1" src="https://cdn.javarush.com/images/article/4df836f2-afce-416d-a7a7-a4c133745ef9/256.jpeg" style="width: 422px;"> Клацніть на(+), всередині зеленого кола на рамці термінального вікна, виберіть <strong>New Terminal</strong> . <img data-id="04a36441-3e0c-4ede-9494-eda108a39693" data-max-width="740" alt="Гарвард CS50: завдання другого тижня (лекції 5 та 6) - 2" src="https://cdn.javarush.com/images/article/04a36441-3e0c-4ede-9494-eda108a39693/512.jpeg" style="width: 740px;"> Створіть робочу директорію: <code class=" language-none">mkdir ~/workspace/pset2</code> Зверніть увагу: між <strong>mkdir</strong> та <strong>~/workspace/pset2</strong> є пробіл. Нагадаємо, <strong>~</strong> означає кореневий каталог, <strong>~/workspace</strong> - папка, звана робочим простором, знаходиться всередині кореневого каталогу, <strong>~/workspace/pset2</strong> - директорія на ім'я<strong>pset2</strong> всередині <strong>~/workspace</strong> . Тепер виконайте: <code class=" language-none">cd ~/workspace/pset2</code> щоб перейти до нової директорії. Командний рядок виглядає приблизно так: <code class=" language-none">username:~/workspace/pset2 $</code> Якщо щось не так, повторіть кроки. Також можете викликати команду <code class=" language-none">history</code> , щоб переглянути останні кілька команд у хронологічному порядку. Також ви можете, встановивши курсор на командний рядок і натискаючи стрілку вгору на клавіатурі, переглядати всі команди в порядку від останньої, введеної до першої. За допомогою кнопки вниз ви можете йти назад. До речі, замість того, щоб щоразу набирати ті самі команди, ви можете прокручувати вже набрані команди і виконувати їх знову, натискаючи на Enter. Ви могли помітити, що Девід робить саме так. Завдання другого тижня потрібно зберігати в <strong>pset2</strong> . 
<h4>Завдання 0. Ініціалізація</h4> Ознайомимось із рядками ближче. У файлі <strong>initials.c</strong> напишіть програму, яка запитує ім'я користувача (за допомогою функції GetString отримуємо ім'я у вигляді рядка) і потім виводить перші літери імені (або імен) та прізвища у верхньому регістрі без пробілів, точок та інших знаків тільки з перекладом рядка ( <strong>\n</strong> ). Припускаємо, що користувачі вводять виключно літери (у нижньому або верхньому регістрі, або обох відразу) плюс по одному пропуску між словами. Вважайте, що хлопці з іменами Joseph Gordon-Levitt, Conan O'Brien або David J. Malan не користуватимуться програмою. Для перевірки коректності роботи програми викликайте check50 Хочете погратися з реалізацією програми, підготовленої співробітниками CS50? Набирайте рядок: <code class=" language-none">username:~/workspace/pset2 $ ./initials <u>Zamyla Chan</u> ZC username:~/workspace/pset2 $ ./initials robert thomas bowden RTB</code><code class=" language-none">check50 2015.fall.pset2.initials initials.c</code><code class=" language-none">~cs50/pset2/initials</code>
<h5>Криптографія</h5> Криптографія, наука про шифрування та дешифрування інформації... Насправді зашифровані послання існують з давніх-давен, і використовувалися арміями для передачі секретних повідомлень. Ну і зараз ваші паролі у Facebook та інших мережах зберігаються у зашифрованому вигляді. 
<h4>Завдання 1. Аве, Цезарю!</h4>
<h5>Теоретичні відомості</h5> Ми вивчимо один із найпростіших шифрів – шифр Цезаря, названий на честь римського імператора. У цьому шифрі кожна літера тексту замінюється іншою, яка знаходиться на фіксоване число букв нижче в алфавіті. Це фіксоване число букв називається <strong>ключем</strong> . Так, ключ 1 переводить букву латиниці C букву D, а Z — по циклу в A. Якщо ключ 3, то буква C перейде F, а Z — C. Приклади: використовуємо шифр Цезаря <strong>з</strong> ключем 5 на слові cat. <code class=" language-none">c -&gt; h a -&gt; f t -&gt; y Caesar (cat, 5) = hfy</code> Ключ = 7, слово = комп'ютер <code class=" language-none">c-&gt;j o-&gt;v m-&gt;t p-&gt;w u-&gt;b t-&gt;a e-&gt;l r-&gt;y Caesar(computer,7) = jvtwbaly</code> <img data-id="1d76c87e-3c60-46ea-88ce-da138bada6b9" data-max-width="740" alt="Гарвард CS50: завдання другого тижня (лекції 5 та 6) - 3" src="https://cdn.javarush.com/images/article/1d76c87e-3c60-46ea-88ce-da138bada6b9/512.jpeg" style="width: 740px;"> Шифр Цезаря простий, але, на жаль, ненадійний (це взаємопов'язані речі!): Для англійського алфавіту - всього 25 варіантів шифрування, перебрати всі варіанти легко навіть без комп'ютера. Тим не менш, шифр Цезаря часто використовують як крок в інших шифрах, таких як шифр Віженера (про нього - в наступному пункті). "Математизуємо" шифр Цезаря. Позначимо незашифрований текст літерою p, pi — літера у тексті p, що знаходиться на позиції з номером i. Назвемо секретний ключ літерою k, з — зашифрований текст, а ci — літера у шифрованому тексті, що знаходиться на позиції i. Тоді обчислити кожну букву шифру можна за такою формулою: <code class=" language-none">ci = (pi + k) % 26</code> Звикайте до такої формалізації, вона дозволяє програмувати алгоритм і висловлює сенс шифру точно та стисло. Якщо ключ k = 13 а початковий текст p - "Be sure to drink your Ovaltine!", Ось який шифр ми отримаємо: Зверніть <code class=" language-none">Or fher gb qevax lbhe Binygvar!</code> увагу, O (перша буква в шифрованому тексті) зміщена на 13 позицій від букви B (перша буква в оригінальному тексті ). Те саме з літерою r (друга літера в шифруванні) зміщена на 13 літер від e (друга літера в оригіналі). Третя літера в шифруванні, f, зміщена на 13 літер від s (третя в оригіналі), тут ходимо по колу від z до a. Шифр Цезаря з ключем 13 має спеціальну назву <a href="https://ru.wikipedia.org/wiki/ROT13" rel="nofollow">ROT13</a> . Він симетричний: застосувавши його двічі, ми повернемось до первісного тексту. Звичайно, є ще й ROT26, цей взагалі супер-сек'юрний, але тільки якщо ви нечітко висловлюєте свої думки. 
<h5>Умова</h5> Написати у файлі <strong>caesar.c</strong> програму, що шифрує текст за допомогою шифру Цезаря. На вхід програми подавайте один аргумент командного рядка: негативне ціле число. Для простоти назвемо його k. Якщо користувач виконує програму без аргументів командного рядка або більше, ніж з одним аргументом, програма повинна обуритися і повернути значення 1 (зазвичай так позначають помилки): <code class=" language-none">return 1;</code> У всіх інших випадках програма запитує користувача, який потрібно зашифрувати, потім виводить на екран текст, зашифрований ключем k (тобто зміщений на k позицій вправо по циклу). Якщо текст містить символи, що виходять за межі англійського алфавіту, їх програма не змінює. Після виведення шифрованого тексту, програма завершує роботу, <strong>main</strong> повертає 0: <code class=" language-none">return 0;</code> Якщо<strong>main</strong>не повертає нуль явно, він повертається автоматично (насправді int - тип, що повертається main, але про це іншим разом). Відповідно до конвенції (правил хорошого тону в програмуванні), якщо ви явно повертаєте 1 щоб вказати на помилку, то потрібно повернути і 0 як вказівник на успішне завершення роботи програми. Хоча в англійському алфавіті тільки 26 літер, k може бути і більше 26. По суті, ключ k = 27 дасть той же результат, що і k = 1, але потрібно дозволити користувачеві вводити будь-яке невід'ємне число, що не перевищує 2^31 – 26 ( воно має поміститися в int). Програма також повинна враховувати, що малі літери шифруються малими, а великі - великими. З чого починаємо? Оскільки програма має прийняти значення k безпосередньо в рядку аргументів, заголовок функції main у нас має такий вигляд: <code class=" language-none">int main(int argc, string argv[])</code> З шостої лекції ви знаєте, що <strong>argv</strong> це масив рядків. Масив можна уявити, як ряд шафок-осередків у спортзалі. У кожному їх приховано деяке значення. У нашому випадку, всередині кожного осередку лежить аргумент типу <code class=" language-none">string</code> Щоб відкрити першу шафку, використовуємо argv [0], другий - argv [1] і так далі. Якщо ми маємо n замків, нам потрібно зупинитися на argv[n - 1], оскільки argv[n] вже немає (чи існує, але належить комусь ще, нам краще його чіпати). Таким чином, ви можете отримати доступ до аргументу k наступним чином: <code class=" language-none">string k = argv[1];</code> Ми вважаємо, що там справді щось є! Нагадаємо, argc - змінна типу int, що дорівнює кількості рядків argv. Значить, краще перевірити значення argc перш, ніж намагатися відкрити комірку, адже може статися, що її немає. В ідеалі argc=2. Чому так? Всередині argv[0] зазвичай міститься ім'я програми. Тобто, argc завжди не менше 1. Але нашій програмі потрібно, щоб користувач надав аргумент командного рядка k, отже, argc = 2. Звичайно, якщо користувач у командному рядку введе більше одного аргументу, argc також підростає і може бути більшим, ніж 2 Якщо користувач вводить ціле число в рядок, це ще не означає, що внесене значення автоматично буде збережено в тип int. Точніше, воно не буде. Воно буде string, навіть якщо виглядає точнісінько, як int! Тому нам потрібно конвертувати string в int самостійно. На щастя, існує функція atoi, створена з цією метою. Її синтаксис: <code class=" language-none">int k = atoi(argv[1]);</code> Зверніть увагу: k має тип int, тому можна з ним провернути арифметичні дії. З цією функцією не потрібно турбуватися, чи введе користувач ціле число, або, скажімо, foo: у такому випадку atoi поверне 0. Функція atoi оголошена в бібліотеці <strong>stdlib.h</strong> , тому не забудьте прописати її директивою #include на початку програми. Код і без цього скомпілюється, оскільки ми вже включабо цю функцію до бібліотеки <strong>cs50.h</strong>. Проте краще довіряти нативним бібліотекам. Отже, ви отримали k збережене як int. Тепер запитаємо на введення тексту. Якщо ви робабо завдання першого тижня, вже знайомі з функцією бібліотеки CS50, яка називається GetString. Вона нам і допоможе. Після того, як ви отримали k і початковий текст, приступимо до шифрування. Нагадаємо, ви можете пройтися по всіх символах рядка і надрукувати їх за допомогою наступного циклу: <code class=" language-none">for (int i = 0, n = strlen(p); i &lt; n; i++) { printf("%c", p[i]); } </code> Іншими словами, так само, як <strong>argv</strong> - масив рядків, <strong>string</strong>є масивом символів. Тому ми можемо використовувати квадратні дужки для доступу до окремих елементів рядка так само, як отримувати окремі рядки в argv. Звичайно, немає нічого криптографічного у друку кожного із символів. Або, технічно, коли k = 0. Але ж ми повинні допомогти Цезарю зашифрувати його текст! Аве, Цезарю! Щоб використати strlen, потрібно підключити ще одну <a href="https://reference.cs50.net/string.h/strlen" rel="nofollow">бібліотеку</a> . Оскільки ми автоматизуємо деякі перевірочні тести, програма повинна поводитися рівно таким чином: <code class=" language-none">username:~/workspace/pset2 $ ./caesar 13 Be sure to drink your Ovaltine! Or fher gb qevax lbhe Binygvar!</code> Крім <strong>atoi</strong> , ви можете знайти інші класні функції в бібліотеках <strong>ctype.h</strong> і <strong>stdlib.h</strong> . Для цього перейдіть за <a href="https://reference.cs50.net/" rel="nofollow">посиланням</a> і поріться там небагато. Наприклад, <strong>isdigit</strong> - явно щось цікаве =). Коли переходите від Z до A (або від z до a), не забувайте про оператора поділу по модулю <strong>%</strong> у мові С. Також вивчіть <a href="http://asciitable.com/" rel="nofollow">таблицю</a> , вона показує символи ASCII як літер. Щоб перевірити правильність роботи програми з <strong>check50</strong> , виконайте наступне: <code class=" language-none">check50 2015.fall.pset2.caesar caesar.c</code> А якщо вам цікаво пограти з кодом, зробленим співробітниками СS50, виконайте команду: <code class=" language-none">~cs50/pset2/caesar</code> До речі, <a href="uggc://jjj.lbhghor.pbz/jngpu?i=bUt5FWLEUN0">uggc://jjj.lbhghor.pbz/jngpu?i=bUt5FWLEUN0</a> . 
<h5>Розбір завдання</h5>
<ol>
 <li>Отримати ключ</li>
 <li>Отримати текст</li>
 <li>Зашифрувати</li>
 <li>Вивести на екран зашифроване повідомлення</li>
</ol> 1. Формуємо функцію main так, щоб користувач вводив ключ у командному рядку та перевіряємо ключ на коректність. <code class=" language-none">int main(int argc, string argv[])</code> argc: • int • кількість аргументів, введених у командний рядок • якщо argc = 2 всі прибл. Якщо ні, виводимо інструкцію та закриваємо програму. • Якщо argc = 2 перевіряємо, чи є ключ цілим • Argv - це масив рядків, список з введеними в нього аргументами Масив - структура даних, що містить різні дані одного типу в різних осередках. <img data-id="51959b19-2030-4dc1-95b3-f5463852bd86" data-max-width="685" alt="Гарвард CS50: завдання другого тижня (лекції 5 та 6) - 4" src="https://cdn.javarush.com/images/article/51959b19-2030-4dc1-95b3-f5463852bd86/512.jpeg" style="width: 685px;"> Наприклад, користувач ввів рядок blastoff Team Rocket, тоді: <img data-id="b05b164f-876a-4791-a95b-95fe442f65f0" data-max-width="587" alt="Гарвард CS50: завдання другого тижня (лекції 5 та 6) - 5" src="https://cdn.javarush.com/images/article/b05b164f-876a-4791-a95b-95fe442f65f0/512.jpeg" style="width: 587px;"> Перекладаємо за допомогою функції atoi() отримане ціле число. Якщо неможливо, функція поверне 0. <img data-id="875e8303-3591-42ba-b225-249cd38760c2" data-max-width="442" alt="Гарвард CS50: завдання другого тижня (лекції 5 та 6) - 6" src="https://cdn.javarush.com/images/article/875e8303-3591-42ba-b225-249cd38760c2/256.jpeg" style="width: 442px;"> 2. Запит у користувача тексту. Це просто: все, що вводить користувач є рядком. 3. Шифрування. Алгоритм простий, але як пояснити комп'ютеру, які букви йдуть одна за одною? Саме час згадати таблицю ASCII! <img data-id="3c2376ca-6e56-4532-a50e-d4f70ab1ec4e" data-max-width="740" alt="Гарвард CS50: завдання другого тижня (лекції 5 та 6) - 7" src="https://cdn.javarush.com/images/article/3c2376ca-6e56-4532-a50e-d4f70ab1ec4e/512.jpeg" style="width: 740px;"> Однак у рядку можуть бути не лише літери… Перш ніж перейти до зміни рядків, уявіть, що потрібно змінити лише один символ. Ми хочемо змінити літери з початкового тексту, а чи не знаки чи цифри. Що ми повинні зробити? Спочатку нам потрібно перевірити, чи є цей символ в алфавіті. Це можна зробити за допомогою функції <strong>isalpha()</strong> . Якщо символ входить до алфавіту, ця функція повертає значення true та false у всіх інших випадках. Ще дві корисні функції - <strong>isupper ()</strong> та <strong>islower ()</strong>повертають true у випадку, якщо літера велика або мала відповідно. Таким чином: <code class=" language-none">Isalpha(‘Z’) -&gt; true Isalpha(‘;’) -&gt; false Isupper(‘Z’) -&gt;true Isupper(‘z’) -&gt; false Islower(‘Z’) -&gt; false Islower(‘z’)-&gt;true</code> Якщо isalpha повертає true, нам потрібно змінити цей символ за допомогою ключа. Розглянемо і розберемо як приклад програму Замілі, помічника CS50. Вас може здивувати, чому 'A' це ціле число, тоді як вона явно є буквою. Виявляється символи та цілі числа – взаємозамінні. Поставивши букву A одиночні лапки можна отримати її ASCII-код в int. Будьте уважні: вам потрібні саме одинарні лапки, без них компілятор шукатиме змінну на ім'я A, а не символ. Потім у рядку <code class=" language-none">/* * asciimath.c * by Zamyla Chan * * Calculates the addition of a char and an integer, * and displays both the resultant character and its * ASCII value. * * Usage: ./asciimath key [char] * */ #include <cs50.h>
  #include 
  <stdio.h>
   #include 
   <stdlib.h>
    int main(int argc, string argv[]) { if (argc != 2) { printf("print the key next time \n"); return 1; } // key is the second command line argument int key = atoi(argv[1]); //преобразование строки в int int letter = 'A'; printf("\nCalculating '%c' + %d...\n", letter, key); int result = (letter + key); printf("The ASCII value of %c is %d.\n\n", result, result); return 0; }
   </stdlib.h>
  </stdio.h>
 </cs50.h></code><code class=" language-none">int result = (letter + key);</code> ми додаємо значення ключа до ASCII-коду літери та зберігаємо їх у змінній цілого типу. Навіть якщо результат має тип int, оператор printf використовує плейсхолдер %с для символів. Таким чином, програма друкує символ, пов'язаний з цілим результатом. У другому випадку ми виводимо на екран число за допомогою плейс-холдера %d. Ви можете ввести цей код у сs50 IDE і грати з ним. Перевіримо роботу asciimath для різних ключів. Візьмемо значення 25, побачимо наступну картинку: <img data-max-width="242" alt="Гарвард CS50: завдання другого тижня (лекції 5 та 6) - 8" src="https://cdn.javarush.com/images/article/a8cbcd04-74f1-4fe6-8ec5-c96c78f05946/original.jpeg"> А тепер нехай ключ буде 26: <img data-max-width="240" alt="Гарвард CS50: завдання другого тижня (лекції 5 та 6) - 9" src="https://cdn.javarush.com/images/article/4cd0fbe0-6881-4f63-9088-ff883fd30298/original.jpeg"> Ми отримали [, а зовсім не букву A. Це просто наступний символ ASCII після Z. Так що простий додаток ключа не працюватиме. Нам потрібно використовувати формулу шифру, щоб повертатися на початок алфавіту як тільки літери закінчаться. Пам'ятайте, ми вже писали вище: <code class=" language-none">ci = (pi + k) % 26</code> Де ci — літера номер i у шифрованому тексті, pi — літера номер i у незашифрованому тексті, k — ключ, а %26 — залишок від поділу на 26 (або поділ за модулем 26). Давайте застосуємо цю формулу для літери Y. Візьмемо k = 2. Порахуємо ('Y' + 2) %26 ASCII-код літери 'Y'= 89. Тоді ('Y' + 2) %26 = (89 + 2)% 26 = 91%26 = 13 Але це зовсім не ASCII-значення потрібної нам літери A, яке дорівнює 65. Тепер давайте надамо кожній літері алфавіту значення від 0 до 25 по порядку. У такому разі Y = 24. (24+2)%26 = 0 Літера А якраз має такий індекс. Таким чином, ця формула відноситься до алфавітного індексу букв, а не їх ASCII значень. Для друку зашифрованого символу вам потрібно буде його значення ASCII. І розберіться з тим, як перемикатися між значенням ASCII і номером в алфавіті. Після того, як ми з'ясували формулу для одного символу, Необхідно застосувати її для кожної літери у рядку, що вводиться з клавіатури. Але лише якщо це букви! І пам'ятайте, для великих і малих літер потрібні різні значення. Тут знадобляться функції isupper і islower. У вас може бути дві формули, одна для великих букв, інша для малих, функції допоможуть вибрати, яку з них застосувати. Як застосувати формулу до кожного окремого символу у рядку? Пам'ятаємо, що рядок це просто масив символів. Визначити кількість ітерацій у циклі допоможе функція Як застосувати формулу до кожного окремого символу у рядку? Пам'ятаємо, що рядок це просто масив символів. Визначити кількість ітерацій у циклі допоможе функція Як застосувати формулу до кожного окремого символу у рядку? Пам'ятаємо, що рядок це просто масив символів. Визначити кількість ітерацій у циклі допоможе функція<strong>strlen</strong> (довжина рядка). <img data-id="97e1a401-4ecf-4653-b087-01ad086cc64f" data-max-width="699" alt="Гарвард CS50: завдання другого тижня (лекції 5 та 6) - 10" src="https://cdn.javarush.com/images/article/97e1a401-4ecf-4653-b087-01ad086cc64f/512.jpeg" style="width: 699px;">
<h4>Завдання 2. Parlez-vous français?</h4>
<h5>Теорія</h5> Шифр Віженера дещо безпечніший за шифр Цезаря: як ключ у ньому використовується слово і його складно зламати вручну за допомогою одного тільки частотного аналізу або перебору. Кожна буква ключа генерує число, і в результаті ми отримуємо кілька ключів для зсуву букв. <strong>Приклад:</strong> <code class=" language-none">p = Meet me in the park at eleven am В качестве ключевого слова возьмем k = bacon Длина повідомлення p = 25 В то время як длина k = 5 Поэтому его нужно повторять 5 раз.</code> <img data-id="81a20544-e365-4918-b32f-c8eb6d94503a" data-max-width="704" alt="Гарвард CS50: завдання другого тижня (лекції 5 та 6) - 11" src="https://cdn.javarush.com/images/article/81a20544-e365-4918-b32f-c8eb6d94503a/512.jpeg" style="width: 704px;"> Якщо число літер у повідомленні не ділиться на ключ націло, ми в останньому застосуванні ключа використовуємо лише його частину: <img data-id="0abc57da-6609-4e37-873a-d14aa73019c9" data-max-width="341" alt="Гарвард CS50: завдання другого тижня (лекції 5 та 6) - 12" src="https://cdn.javarush.com/images/article/0abc57da-6609-4e37-873a-d14aa73019c9/256.jpeg" style="width: 341px;"> Щоб знайти значення для усунення, використовуємо позиції кожної літери нашого ключа bacon в алфавіті (від a до z). Вважаємо з нуля, як справжні програмісти. І кожну букву в оригінальному тексті зміщуємо на задане число, як у шифрі Цезаря, повертаючись за потреби після Z на початок алфавіту. Таким чином, M зміститься на 1, перша e взагалі не зміститься, а друга зміститься на 2 позиції. Нижче ви бачите початкове повідомлення, розписаний ключ та результат його застосування. <img data-id="2c7f7c2d-4b61-4452-a6bf-d64f76b60dc7" data-max-width="731" alt="Гарвард CS50: завдання другого тижня (лекції 5 та 6) - 13" src="https://cdn.javarush.com/images/article/2c7f7c2d-4b61-4452-a6bf-d64f76b60dc7/512.jpeg" style="width: 731px;"> Шифр Віженера, звичайно, надійніший, але якщо ви знаєте довжину ключа, його зламати досить просто. Як її виявити? Якщо оригінальний текст досить довгий, щоб деякі слова зустрічалися в ньому кілька разів, ви побачите деякі повторення: <img data-id="550d86ac-b353-4cb3-9c6b-978272d86bd5" data-max-width="543" alt="Гарвард CS50: завдання другого тижня (лекції 5 та 6) - 14" src="https://cdn.javarush.com/images/article/550d86ac-b353-4cb3-9c6b-978272d86bd5/512.jpeg" style="width: 543px;"> Також можна використовувати повний перебір, але варіантів чимало: 26 n - 1 де n - Довжина невідомого ключа. Але зазвичай це багато. Щоправда, для комп'ютера це проблема. А тепер математика шифру: Нехай р – деякий текст, k – ключове слово, kj – j-я літера ключа, pi – літера під номером i в оригінальному тексті, ci – літера під номером i у шифруванні. Тоді: <code class=" language-none">ci = (pi + kj) % 26</code>
<h5>Завдання</h5><strong>Умова</strong> Написати програму vigenere.c, яка шифрує повідомлення за допомогою шифру Віженера. На вхід програми подаємо один аргумент командного рядка: ключове слово k, що складається з літер англійської абетки. Якщо програма запускається більш ніж з одним аргументом або з аргументом, що не входить до алфавіту, потрібно вивести інформацію про помилку із завершенням програми. Тобто main повертатиме 1 — у такому разі наші автоматичні тести зрозуміють, що тут все добре, і ця умова врахована. Якщо все добре, програма повинна перейти до запиту рядка тексту p, який ми і шифруємо отриманим ключем k, надрукувати результат і завершити виконання програми, повернувши значення 0. <strong>Уточнення</strong> Потрібно зробити так, щоб у ключі k символи A та a позначалися як 0, B та b як 1, ..., Z та z як 25. Програма повинна застосовувати шифр Віженера лише до літер тексту p. Інші символи (цифри, розділові знаки, пробіли) потрібно вивести без змін. Якщо алгоритм має намір застосувати j-й символ <strong>k</strong> до i-го символу <strong>p</strong> , що не входить до алфавіту, застосовуємо цей j-й символ ключа до наступного алфавітного символу в тексті; ви не можете просто залишити його і перейти до іншого символу в k. Нарешті, програма повинна зберегти регістр кожної літери <strong>p</strong> . 
<h5>Не знаєте з чого почати?</h5><img data-id="61e4b6f6-ec30-49e2-a4a4-5d5c48027ca7" data-max-width="740" alt="Гарвард CS50: завдання другого тижня (лекції 5 та 6) - 15" src="https://cdn.javarush.com/images/article/61e4b6f6-ec30-49e2-a4a4-5d5c48027ca7/512.jpeg" style="width: 740px;">
<h6>Ось вам кілька порад від Замілі, помічника курсу CS50</h6> На щастя, програма дуже схожа на шифр Цезаря, тільки як ключ використовується не ціле число, а рядок. Якщо ви успішно реалізували шифр імені римського імператора, він може стати чудовим стартом для реалізації другого завдання. Ви, мабуть, уже зрозуміли, що шифр Віженера з однією літерою як ключ — це той самий шифр Цезаря. В алгоритмі Віженера застосовуються ті самі кроки, що й у «Цезарі»: 
<ol>
 <li>Отримати ключ 
  <ul>
   <li>кодове слово - це другий аргумент командного рядка argv[1]</li>
   <li>повинен входити до алфавіту: функція isalpha</li>
  </ul></li>
 <li>Отримати текст</li>
 <li>Зашифрувати</li>
 <li>Друкувати шифрований текст</li>
</ol> Отже, другий аргумент командного рядка argv[1] перевіримо на приналежність до символів алфавіту. Робимо це за допомогою вже знайомої <strong>isalpha</strong> . Якщо ключ коректний, отримуємо від користувача рядок і починаємо шифрувати. Формула шифру Віженера схожа на формулу шифру Цезаря. Як ви перетворюєте літеру на відповідне усунення шифру? Спробуйте порівняти значення таблиці ASCII. <img data-id="9fd90aea-da77-4990-b55e-a92bfb0eb952" data-max-width="740" alt="Гарвард CS50: завдання другого тижня (лекції 5 та 6) - 16" src="https://cdn.javarush.com/images/article/9fd90aea-da77-4990-b55e-a92bfb0eb952/512.jpeg" style="width: 740px;"> Швидше за все, вам вдасться знайти закономірність між літерами та їх алфавітними індексами використовуючи послідовності в таблиці. Здогадалися, як відібрати одну літеру від іншої, щоб отримати бажаний результат? Зміщення для великих і малих букв однакові, так що вам доведеться визначити дві схожі формули для визначення зсуву для малих і окремо для великих букв. Також не забудьте, що цикл проходу по тексту має ігнорувати символи, що не входять до англійського алфавіту. І не забудьте зберегти регістр літер. Якщо подивитися на формулу шифру: <code class=" language-none">ci = (pi + kj) % 26</code> ви побачите дві індексні змінні, i та j. Одна зберігає позицію у вихідному тексті, інша – у ключі. Якщо ваш текст довший за ключ, індекс по ключу проходить з кінця ключа знову в його початок. Як це зробити? За допомогою операції поділу за модулем! Результат операції - залишок від розподілу двох чисел. Практична користь цієї операції у програмуванні просто величезна! Уявіть, що численну групу людей потрібно поділити на три підгрупи. Один із способів це зробити — попросити їх розрахуватися на перший-другий-третій. <img data-id="7f962f3b-a4eb-4fc4-bc70-8f5e7faa8412" data-max-width="740" alt="Гарвард CS50: завдання другого тижня (лекції 5 та 6) - 17" src="https://cdn.javarush.com/images/article/7f962f3b-a4eb-4fc4-bc70-8f5e7faa8412/512.jpeg" style="width: 740px;"> Тобто перша людина належить до першої групи, друга — до другої, третьої — до третьої, четверта — знову до першої і так далі. Ви можете використовувати поділ по модулю, щоб зробити цю ж операцію. Пронумеруємо ті ж три групи з нуля. Ось як це робиться: <img data-id="cb275c01-ca68-4047-8916-31f47f867f9b" data-max-width="737" alt="Гарвард CS50: завдання другого тижня (лекції 5 та 6) - 18" src="https://cdn.javarush.com/images/article/cb275c01-ca68-4047-8916-31f47f867f9b/512.jpeg" style="width: 737px;"> Якщо ви візьмете індекс і поділіть його за модулем максимального значення, отриманий результат ніколи не буде більшим або дорівнює цьому значенню. Спробуйте застосувати цей принцип для повернення ключового слова на початок! Тільки замість сортування груп вам потрібен індекс ключового слова, щоб ви могли правильну букву для зміщення, не виходячи за довжину ключа. Оскільки ми автоматизуємо деякі тести вашого коду, програма повинна поводитися так, як показано нижче: <code class=" language-none">jharvard@appliance (~/Dropbox/pset2): ./vigenere bacon Meet me at the park at eleven am Negh zf av huf pcfx bt gzrwep oz</code> Як ще можна протестувати програму, крім ручного обчислення зашифрованого тексту? Ми добрі: для цього ми написали програму <strong>devigenere</strong>. Вона приймає один і лише один аргумент командного рядка (ключове слово), а її робота полягає в тому, щоб прийняти зашифрований текст як вхідні дані і повернути звичайний. Запустіть її: <code class=" language-none">~cs50/pset2/devigenere k</code> Де k - ключове слово. Якщо ви хочете перевірити правильність вашої програми за допомогою check50, виконайте: <code class=" language-none">check50 2014.fall.pset2.vigenere vigenere.c</code> А якщо хочете оцінити нашу реалізацію vigenere, наберіть: <code class=" language-none">~cs50/pset2/vigenere</code>
<h4>Як підтвердити правильність коду та отримати оцінки</h4><strong>Увага! </strong>Якщо вам важливо перевірити тільки правильність завдань, то скористайтеся cs50check. Якщо ж ви ходите отримати оцінки на платформі edx, виконайте процедуру, описану нижче. Майте на увазі, ця процедура для перевірки завдань використовує той же cs50check. Різниця лише в тому, що вона запам'ятовує результати та підраховує загальну оцінку. 
<ol>
 <li>Залогіньтесь у <a href="https://id.cs50.net/authorize?state=foo&amp;response_type=code&amp;redirect_uri=https%3A%2F%2Fcs50.io%2Fauth%2Fcs50_callback&amp;scope=openid%20profile%20email&amp;client_id=prod" rel="nofollow">CS50 IDE</a></li>
 <li>Поряд з лівим верхнім кутом <strong>CS50 IDE</strong> там, де розташований її файловий браузер (не в термінальному вікні), клацніть правою клавішею миші по файлу <strong>initials.c</strong> , що знаходиться в директорії <strong>pset2</strong> і натисніть <strong>Download</strong> . Ви повинні побачити, що браузер завантажив <strong>initials.c</strong> .</li>
 <li>Повторіть <strong>caesar.c</strong> .</li>
 <li>Повторіть для <strong>vigenere.c</strong> .</li>
 <li>В окремому вікні або вкладці введіть <a href="http://apps.cs50.edx.org/cs50x/2016/@/portal" rel="nofollow">CS50 Submit</a></li>
 <li>Клацніть по іконці <strong>Submit</strong> у верхньому лівому куті екрана. <img data-id="fd2b9306-dfa4-4c59-ac0e-66e87a613727" data-max-width="740" alt="Гарвард CS50: завдання другого тижня (лекції 5 та 6) - 19" src="https://cdn.javarush.com/images/article/fd2b9306-dfa4-4c59-ac0e-66e87a613727/512.jpeg" style="width: 740px;"></li>
 <li>У списку папок зліва клацніть по директорії <strong>Problem Set 2</strong> , потім натисніть кнопку <strong>Upload New Submission</strong> . Вона знаходиться праворуч. <img data-id="4da35da3-94be-4a93-941f-705d7a174fd6" data-max-width="740" alt="Гарвард CS50: завдання другого тижня (лекції 5 та 6) - 20" src="https://cdn.javarush.com/images/article/4da35da3-94be-4a93-941f-705d7a174fd6/512.jpeg" style="width: 740px;"></li>
 <li>На екрані клікніть по кнопці <strong>Add files</strong> …. Відкриється вікно вибору файлів із комп'ютера. <img data-id="1ab36598-f33e-4f15-9bc3-1d8700d1d530" data-max-width="740" alt="Гарвард CS50: завдання другого тижня (лекції 5 та 6) - 21" src="https://cdn.javarush.com/images/article/1ab36598-f33e-4f15-9bc3-1d8700d1d530/512.jpeg" style="width: 740px;"></li>
 <li>Перейдіть до папки, де ви зберігаєте <strong>initials.c</strong> . Швидше за все, він знаходиться в папці <strong>Downloads</strong> ("Завантаження") або там, куди ваш браузер складає стандартні файли. Коли знайдете <strong>initials.c</strong> , клацніть по ньому один раз, щоб вибрати, потім клацніть Open («Відкрити»).</li>
 <li>Натисніть <strong>Add files</strong> ще раз.</li>
 <li>Знайдіть <strong>caesar.c</strong> і відкрийте його.</li>
 <li>Виконайте те саме для файлу <strong>vigenere.c</strong> .</li>
 <li>Натисніть кнопку Start upload. Ваші файли будуть завантажені на сервери <strong>CS50</strong> .</li>
 <li>На екрані ви повинні побачити вікно <strong>No File Selected</strong> . Якщо ви переведете курсор миші вліво, ви побачите список файлів, що завантажабося. Для підтвердження клацніть по кожному з них. Якщо ви у чомусь не впевнені, ви можете перезавантажити файли, повторивши ті самі кроки. Ви це можете робити скільки завгодно разів до кінця 2016 року.</li>
</ol>