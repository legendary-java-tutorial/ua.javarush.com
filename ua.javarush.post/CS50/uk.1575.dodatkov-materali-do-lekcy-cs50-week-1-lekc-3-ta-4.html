Додаткові матеріали до лекцій CS50: Week 1 (лекції 3 та 4)
<p>----------------------------------------</p>
Для виконання завдань CS50 пропонує IDE (Integrated Development Environment, інтегроване середовище розробки) у «хмарі». Щоб нею скористатися, створіть обліковий запис на платформі edX, і зареєструйтесь на . Після цього: 1. Заходимо на cs50
<p>----------------------------------------</p>
<img data-id="e3237b9e-ac01-4e02-a0b1-0507942d7214" data-max-width="740" alt="cs50 російською додаткові матеріали" src="https://cdn.javarush.com/images/article/e3237b9e-ac01-4e02-a0b1-0507942d7214/512.jpeg" style="width: 740px;"> <a href="http://info.codegym.cc/Masha/2016/07/18/%D0%93%D0%B0%D1%80%D0%B2%D0%B0%D1%80%D0%B4-CS50-%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B9-%D0%BD%D0%B5%D0%B4%D0%B5%D0%BB%D0%B8-%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B8-3-%D0%B8-4-.html">Завдання 1 тижня</a>
<h4 id="#goals">Цілі першого тижня</h4>
<ul>
 <li>Ознайомитись з основними командами Linux</li>
 <li>Вивчити основний синтаксис C та вирішити кілька завдань</li>
 <li>Почати мислити чіткіше =)</li>
</ul>
<h5>IDE CS50</h5> Для виконання завдань CS50 пропонує IDE (Integrated Development Environment, інтегроване середовище розробки) у «хмарі». Щоб нею скористатися, створіть обліковий запис на платформі edX, і зареєструйтесь на <a href="https://courses.edx.org/courses/course-v1:HarvardX+CS50+X/info" rel="nofollow">оригінальний курс</a> . Після цього: 
<br>
 1. Заходимо на cs50.io, зі списку вибираємо edX, вводимо логін і пароль, тиснемо <strong>Submit</strong> 2. Вводимо дані свого edX-акаунта, тиснемо <strong>Return to ID.CS50.NET</strong> . <img data-id="4148a158-fca2-40fb-9a74-c2de63829484" data-max-width="684" alt="cs50.io" src="https://cdn.javarush.com/images/article/4148a158-fca2-40fb-9a74-c2de63829484/512.jpeg" style="width: 684px;"> 3. Чекаємо: створюється ваш віртуальний простір. <img data-id="57edaa77-a943-49d1-94a2-5d2fee357aa1" data-max-width="740" alt="віртуальний простір cs50" src="https://cdn.javarush.com/images/article/57edaa77-a943-49d1-94a2-5d2fee357aa1/512.jpeg" style="width: 740px;"> 4. Готово! <img data-id="6c52dac2-9a3d-4557-9ffa-c33e328220a7" data-max-width="740" alt="cs50 ide" src="https://cdn.javarush.com/images/article/6c52dac2-9a3d-4557-9ffa-c33e328220a7/512.jpeg" style="width: 740px;">
<h5>Командний рядок та запуск CS50 IDE</h5> У нижній частині вікна CS50 IDE у вкладці Terminal є термінальне вікно або панель командного рядка. Сюди можна вводити рядкові команди: ви зможете робити те саме, що і з віконним інтерфейсом, наприклад, запускати програми, видаляти та створювати файли, інсталювати ПЗ. Якщо ви ніколи не працювали з командним рядком, ймовірно, такий спосіб здасться громіздким: потрібно пам'ятати команди, набирати їх текстом замість клацання по іконках і кнопках. Певною мірою так і є, потім віконний інтерфейс і вигадали. Однак командний рядок є у всіх ОС і його обожнюють адміни. А все тому, що інколи без неї ніяк. У вікні IDE у терміналі ви побачите загадковий рядок: <strong>username:~/workspace $</strong> на місці "username" буде автоматично згенероване (на основі ваших реєстраційних даних) ім'я. Клацніть на віконце терміналу, надрукуйте: <code class=" language-none">update50</code> Натисніть Enter. Команда просить систему оновитись. Ви побачите, як у терміналі з'являються рядки, що описують процес встановлення. Не закривайте CS50 IDE доки не побачите <strong>Update complete! </strong>. Після цього знову з'явиться рядок за промовчанням, що з вашим ім'ям. 
<h5>Робота в IDE</h5> Створимо папку, де лежатимуть ваші файли. Клацніть правою кнопкою миші по <strong>~/workspace</strong> (ваш кореневий каталог) у лівому верхньому кутку <strong>CS50 IDE</strong> , виберіть <strong>New Folder</strong> . Перейменуйте папку в <strong>pset1</strong> (якщо ви помаболися в імені, клацніть правою кнопкою по папці і виберіть <strong>Rename</strong> ). <img data-max-width="229" alt="cs50 ide rename folder" src="https://cdn.javarush.com/images/article/8f8f100f-95c5-43ea-a57c-def8fa98fac2/original.jpeg"> Потім клацаємо правою кнопкою по папці <strong>pset1</strong> , вибираємо <strong>New File</strong> . З'являється файл Untilted, перейменуємо його в <strong>hello.txt</strong> . <img data-max-width="229" alt="cs50 ide" src="https://cdn.javarush.com/images/article/d4118710-8cdd-408c-981d-443b8ea23469/original.jpeg"> Двічі клацніть по hello.txt. У CS50 IDE праворуч ви побачите нову вкладку та поле, де можна друкувати. Якщо ви це зробабо, зверніть увагу на символ зірочки (*), що з'явилася перед назвою файлу на вкладці — індикатор того, що до файлу були внесені, але не збережені зміни. <img data-id="a63981ef-95e9-4065-815c-63e1d3f907ec" data-max-width="630" alt="Додаткові матеріали до лекцій CS50: Week 1 (лекції 3 та 4) - 1" src="https://cdn.javarush.com/images/article/a63981ef-95e9-4065-815c-63e1d3f907ec/512.jpeg" style="width: 630px;"> Збережіть файл у меню <strong>*File &gt; Save</strong> або за допомогою клавіш <strong>command + S</strong> (на машинах Apple) або <strong>Ctrl + S</strong> (на ПК). Зірочка має зникнути. Давайте перевіримо, чи лежить файл там, де має. Зробимо це за допомогою командного рядка, настав час до неї звикати:). Як і раніше, активний рядок у терміналі виглядає так: <code class=" language-none">username:~/workspace $</code> Workspace - поточна робоча директорія (та, що відкрита в робочому середовищі). Тільда ​​(~) вказує на кореневу директорію (у ній лежить workspace). Зверніть увагу, що workspace у терміналі — те саме, що й іконка ~/workspace у верхньому лівому куті CS50 IDE. Давайте попрактикуємось. Клацніть у якомусь місці терміналу і наберіть у командному рядку <code class=" language-none">ls</code> і натисніть Enter. Ці дві малі літери - скорочення від "list" ("список") - викличуть список файлів і папок, що знаходяться всередині поточної директорії workspace. Серед іншого ви побачите і створену вами <strong>pset1</strong> ! Тепер відкриємо нашу папку за допомогою команди. Набираємо <code class=" language-none">cd pset1</code> або багатослівніше: <code class=" language-none">cd ~/workspace/pset1</code> Команда cd (change directory) змінює активну директорію, у нашому випадку на <code class=" language-none">~/pset1</code> Активний рядок змінилася на <code class=" language-none">username:~/workspace/pset1 $</code> Це підтверджує, що ви тепер перебуваєте в директорії <code class=" language-none">~/workspace/pset1</code> (рядок розшифровується як «я перебуваю в pset1 всередині папки workspace, яка лежить в кореневій папці, що позначається ~"). Тепер наберіть Ви <code class=" language-none">ls</code> побачите файл <strong>hello.txt</strong> ! нічого не станеться: це текст, і він не видає активного посилання, але підтверджує, що hello.txt знаходиться там, де повинен <code class=" language-none">cd</code> . перейти), вона поверне вас до кореневої директорії за промовчанням.Таким чином, в активному рядку ви побачите наступну картину: <code class=" language-none">username:~ $</code> Щоб повернутися назад до папки pset1, наберіть <code class=" language-none">cd workspace</code> і натисніть Enter. <code class=" language-none">cd pset1</code> та знову Enter. Також ви можете замінити ці дві команди однією, достовірніше: <code class=" language-none">cd workspace/pset1</code>
<h5>Hello, C!</h5> Нарешті ця хвабона настала! Починаємо програмувати. Усередині нашої папки pset1 в IDE створюємо файл під назвою <strong>hello.c</strong> (розширення обов'язково), відкриваємо у новій вкладці (думаємо, ви пам'ятаєте, як це робити з попереднього параграфа). <strong>ВАЖЛИВО! </strong>Літери мають бути малими, Linux чутливий до регістру. Hello.c і hello.c – різні файли. У правій частині вікна CS50 IDE набираємо точнісінько такий текст, як ви бачите нижче. Так, його можна скопіювати, але корисніше набрати. <code class=" language-none">#include <stdio.h>
  int main(void) { printf("hello, world\n"); }
 </stdio.h></code> Літери різного кольору тому, що в CS50 IDE працює підсвічування синтаксису. Вона виділяє кольором блоки тексту для кращого читання. У самому файлі кольори не зберігаються, вони помітні лише в IDE. Якщо вони є, значить, IDE розуміє C, а про те, що це саме C, ви повідомабо розширення файлу (*.c). Якби ви назвали той самий файл hello.txt, текст був би одноколірний. Переконайтеся, що ви надрукували все так, як у прикладі, інакше зловите перший баг=). Знову звертаємо вашу увагу на різницю між малими і великими літерами. Символ \n переводить курсор на наступний рядок, і введений текст не злипнеться з виведеною програмою. Ах так, і про точку з комою (;) не забувайте. Це важливий роздільник операторів програми, без них працювати не захоче. Натисніть <strong>File &gt; Save</strong>(або комбінацію command-або Ctrl-s). Чи помітабо, що зірочка перед назвою файлу зникла? Якщо так, то зміни збереглися. Клацніть у будь-якому місці по термінальному вікні під вашим кодом і переконайтеся, що ви всередині <strong>~/workspace/pset1</strong> (якщо це не так, клацніть cd і натисніть Enter, потім cd workspace/pset1 і знову Enter). Ваш активний рядок має виглядати так: <code class=" language-none">username:~/workspace/pset1 $</code> Переконаємося, що файл <strong>hello.c</strong> знаходиться там, де повинен. Набираємо <code class=" language-none">ls</code> та тиснемо Enter. Ви бачите і hello.c? Якщо ні, поверніться на пару кроків назад і створіть файл ще раз. … Тепер настає урочистий момент: схрещуємо пальці та… друкуємо: <code class=" language-none">make hello</code> і схрещеними ж пальцями тиснемо Enter. Саме hello, не hello.c. Якщо все, що ви після цього дійства перед собою побачабо - другий активний рядок, який виглядає точнісінько, як попередній, значить, все працює! Ваш вихідний код було переведено в машинний або об'єктний код (тобто послідовності 0 і 1). Тепер цей код можна виконати (тобто запустити програму!). Для цього друкуємо: <code class=" language-none">./hello</code> у командному рядку, тиснемо Enter. Якщо ви не змінювали укладений між текстом, нижче ви побачите: <code class=" language-none">hello, world</code> Якщо ви тепер наберете команду <code class=" language-none">ls</code> і натиснете Enter, ви побачите новий файл hello, поряд з hello.c і hello.txt. У першого hello має бути зірочка після імені, яка сигналізує про те, що це виконуваний файл, тобто такий, за допомогою якого ви запускаєте програму. 
<h5>Баги?</h5> Якщо після команди make, ви побачабо помилки, настав час першої налагодження! Написи на кшталт "expected declaration" означають, що ви десь допустабо друкарську помилку. Звірте код з наведеним вище ще раз, тільки будьте дуже уважні до всіх деталей. <strong>Увага! </strong>Описи помилок видаються англійською. Якщо незрозуміло, скористайтеся пошуковою системою, Google Translate або запитайте у коментарі. Як тільки ви виправабо помилки, не забудьте зберегти ваш код за допомогою <strong>File &gt; Save</strong> (або command- або Ctrl-s), знову натисніть на внутрішній частині термінального вікна і наберіть <code class=" language-none">make hello</code> (Тільки попередньо переконайтеся, що ви знаходитесь в директорії ~/workspace/pset1 ). Якщо більше помилок немає, запускайте програму, набираючи команду <code class=" language-none">./hello</code> За ідеєю перед вами має виникнути заповітна фраза, укладена в лапки оператора printf, який командує «надрукуй». Якщо вікно терміналу здається вам занадто маленьким, клацніть по іконці ув'язненого в колі плюса (+), розташованого поряд з hello.c. 
<h5>Перевірка на правильність</h5> У CS50 IDE вбудовано програму check50. Воно працює з командного рядка і перевіряє деякі програми на наявність помилок. Якщо ви ще не там, перейдіть до директорії ~/workspace/pset1, виконавши в терміналі команду: <code class=" language-none">cd ~/workspace/pset1</code> Тепер виконайте <code class=" language-none">ls</code> ви побачите щонайменше файл hello.c. Переконайтеся, що назва файлу виглядає так, а не, скажімо, Hello.c або hello.C. Перейменувати файл можна, виконавши команду <code class=" language-none">mv source destination</code> source – поточне ім'я файлу, destination – нове ім'я файлу. mv (від англ. move) - Утиліта для перейменування. Якщо ви випадково назвали файл Hello.c, наберіть рядок: <code class=" language-none">mv Hello.c hello.c</code> Переконавшись, що файл точно називається hello.c, викличемо перевірочну програму check50. Зверніть увагу, що 2015.fall.pset1.hello - унікальний ідентифікатор для завдання "hello world". check50 2015.fall.pset1.hello hello.c Якщо програма виконана правильно, ви побачите: <img data-id="d40b2da7-25f6-40d7-ab89-c4cbe33ec566" data-max-width="441" alt="Додаткові матеріали до лекцій CS50: Week 1 (лекції 3 та 4) - 2" src="https://cdn.javarush.com/images/article/d40b2da7-25f6-40d7-ab89-c4cbe33ec566/256.jpeg" style="width: 441px;"> Зелені смайлики означають, що тест пройдено. Також можете бачити URL внизу виводу check50, але він потрібен лише співробітникам (втім, якщо цікаво заходьте!). check50 запускає 3 тести: чи існує файл hello.c, чи компілюється hello.c і чи видає додаток рядок, у якому написано текст "hello, world\n". Якщо ви побачите сумні червоні смайли, значить у вас баг. <code class=" language-none">:( hello.c exists \ expected hello.c to exist :| hello.c compiles \ can't check until a frown turns upside down :| prints "hello, world\n" \ can't check until a frown turns upside down </code> Тут check50 не знайшов hello.c, і червоний смайлик сигналізує, що ви помаболися в імені, або завантажабо файл не туди. Жовті "нейтральні" смайли означають, що тести не запустабося. І звідки їм запуститись, якщо програма не знайшла файл, який потрібно перевірити? Ось ще один варіант, який вискочить у тому випадку, якщо ви змінювали текст, який має вивести функція printf(): <code class=" language-none">:) hello.c exists :) hello.c compiles :( prints "hello, world\n" \ expected output, but not "hello, world" </code> check50 повідомляє, що очікувався рядок hello, world\n, але з'явилося щось інше. check50 не рахує бали за проходження курсу, але перевіряє, чи відрізняється результат виконання завдання від очікуваного. І дозволяє вам переконатися в цьому, перш ніж підтвердити правильність завдання всередині курсу (як це зробити, ми розповімо пізніше). 
<h5>Основи С: порівняння зі Scratch</h5>
<h6>Hello world на Scratch та C:</h6><img data-id="b371e02b-93f6-49b3-90d7-fb9dd0267d80" data-max-width="344" alt="Додаткові матеріали до лекцій CS50: Week 1 (лекції 3 та 4) - 3" src="https://cdn.javarush.com/images/article/b371e02b-93f6-49b3-90d7-fb9dd0267d80/256.jpeg" style="width: 344px;"> <code class=" language-none">#include <stdio.h>
  int main(void) { printf("hello, world\n"); }
 </stdio.h></code>
<ul>
 <li><img data-max-width="62" alt="Додаткові матеріали до лекцій CS50: Week 1 (лекції 3 та 4) - 4" src="https://cdn.javarush.com/images/article/576f71b0-6a06-4683-9fe8-47ac5f966893/original.jpeg">представляє функцію, яка друкує «слова» спрайту в хмаринці коміксу в Scratch, в C є функція printf, яка робить те саме, тільки без мультиків.</li>
 <li>main – англійською – «головна». Точка входу до програми. Те саме, що <img data-max-width="127" alt="Додаткові матеріали до лекцій CS50: Week 1 (лекції 3 та 4) - 5" src="https://cdn.javarush.com/images/article/b04077a5-06f0-4210-aeeb-1e87ed5a0171/original.jpeg">.</li>
</ul>
<h6>Безкінечний цикл</h6><img data-id="c8d90434-4347-4614-bfed-ea03be77a42f" data-max-width="271" alt="Додаткові матеріали до лекцій CS50: Week 1 (лекції 3 та 4) - 6" src="https://cdn.javarush.com/images/article/c8d90434-4347-4614-bfed-ea03be77a42f/256.jpeg" style="width: 271px;"> у перекладі на C: <code class=" language-none">while (true) { printf("hello, world\n"); }</code> while (true) робить те саме: цикл продовжує свою роботу поки (while) значення true (булевський вираз «правда» або «одиничка»). Такий цикл виконуватиметься нескінченно. 
<h6>Цикл, що виводить фразу на екран 10 разів</h6><strong>Scratch </strong> <img data-id="0e6e10b4-57c3-48bd-8448-97a76fc4d6e1" data-max-width="281" alt="Додаткові матеріали до лекцій CS50: Week 1 (лекції 3 та 4) - 7" src="https://cdn.javarush.com/images/article/0e6e10b4-57c3-48bd-8448-97a76fc4d6e1/256.jpeg" style="width: 281px;"> <strong>С</strong> <code class=" language-none">for (int i = 0; i &lt; 10; i++) { printf("hello, world!\n"); }</code> i - змінна-лічильник, її значення змінює оператор інкременту i + +, збільшуючи його на 1 при кожному витку циклу. Спочатку i надається значення 0 за допомогою оператора присвоєння =. <strong>Увага! </strong> <em>Як і Java, в C рівність позначається ==, оператор присвоювання =. Тобто, a = 5 означає, що змінної a надали значення 5, а (a = =5) означає булонський вираз (якщо а дорівнює 5, то вираз правдивий, якщо не одно, то хибно). </em> Цикл зупиниться, коли «доросте» до 9. Нескладно порахувати, цикл виконається 10 разів. Таким чином, якщо вам потрібно повторити щось певну кількість разів, у C ви задаєте цикл for (int i = 0; i &lt; 10; i++). <strong>Ще один приклад:</strong> <img data-id="fc692af9-1a60-4504-a4c8-2a8315204aa1" data-max-width="359" alt="Додаткові матеріали до лекцій CS50: Week 1 (лекції 3 та 4) - 8" src="https://cdn.javarush.com/images/article/fc692af9-1a60-4504-a4c8-2a8315204aa1/256.jpeg" style="width: 359px;"> І те саме в перекладі на C: <code class=" language-none">int counter = 0; while (true) { printf("%i\n", counter); counter++; }</code>
<ul>
 <li>counter зберігає значення C і Scratch. У З задаємо int counter = 0 замість <img data-id="b440590e-488b-443a-8121-fdf1cc131678" data-max-width="274" alt="Додаткові матеріали до лекцій CS50: Week 1 (лекції 3 та 4) - 9" src="https://cdn.javarush.com/images/article/b440590e-488b-443a-8121-fdf1cc131678/256.jpeg" style="width: 274px;">.</li>
 <li>Позначаємо тип змінної як int уточнення: i — ціле число (від англ. integer, цілий).</li>
 <li>Значок %i, який ми використовуємо в printf у четвертому рядку — заповнювач, який говорить про те, що ми повинні надрукувати десяткове ціле, так само, ми говоримо printf замінити заповнювач на значення, яке приймає змінна counter.</li>
</ul>
<h6>Булеві вирази</h6><img data-id="021cfb41-3d5f-4d5d-b403-fe6969b38855" data-max-width="412" alt="Додаткові матеріали до лекцій CS50: Week 1 (лекції 3 та 4) - 10" src="https://cdn.javarush.com/images/article/021cfb41-3d5f-4d5d-b403-fe6969b38855/256.jpeg" style="width: 412px;"> Це те саме, що <code class=" language-none">(x &lt; y) ((x &lt; y) &amp;&amp; (y &lt; z))</code>
<h6>Умови</h6><img data-id="8e5a5854-d3c6-40bc-8549-51fb2fa1acda" data-max-width="392" alt="Додаткові матеріали до лекцій CS50: Week 1 (лекції 3 та 4) - 11" src="https://cdn.javarush.com/images/article/8e5a5854-d3c6-40bc-8549-51fb2fa1acda/256.jpeg" style="width: 392px;"> І «сишний» еквівалент: <img data-id="99dc8cfb-bd5d-4c18-8edd-47f5d620f315" data-max-width="491" alt="Додаткові матеріали до лекцій CS50: Week 1 (лекції 3 та 4) - 12" src="https://cdn.javarush.com/images/article/99dc8cfb-bd5d-4c18-8edd-47f5d620f315/256.jpeg" style="width: 491px;"> А що щодо першої незрозумілої фрази? Про це пізніше, у розділі «Бібліотеки» <code class=" language-none">#include </code>
<h6>Умовні оператори</h6> Ці хлопці перевіряють, чи виконується певна умова (логічне вираження, питання, який можна відповісти лише «так» чи «ні»), і якщо це так, то виконують деякі дії, прив'язані до цієї умови. Приклад із життя: якщо пішов дощ (за умови, що пішов дощ) і я на вулиці (я під час дощу на вулиці), я відкриваю парасольку. <code class=" language-none">if (умова) { //исполнить, если значення истинно }</code> Ускладнений варіант: якщо умова виконується, вчинити дію, якщо ні — зробити іншу дію. <code class=" language-none">if (умова) { //выполнить действие } else { //выполнить другое действие, если умова ложно }</code> Зразок: якщо тобі більше 18, схвалити доступ. Якщо менше, не схвалити. <img data-id="71d0fe2c-a39b-49b7-96c9-3209cd5eb32f" data-max-width="378" alt="Додаткові матеріали до лекцій CS50: Week 1 (лекції 3 та 4) - 12" src="https://cdn.javarush.com/images/article/71d0fe2c-a39b-49b7-96c9-3209cd5eb32f/256.jpeg" style="width: 378px;">
<h6>Оператор вибору</h6><code class=" language-none">switch (n) { case const1: // если n дорівнює const1, выполнить break; // умова совершилось — выйти из выбора case const2: // если n дорівнює const2, выполнить break; ... default: // если n не дорівнює ни одной из констант, выполнить break; }</code> Приклад: якщо n = 50, надрукувати "CS50 є Introduction to Computer Science I", якщо n = 51, надрукувати "CS51 є Introduction to Computer Science II", інакше - надрукувати "Sorry, I'm not familiar with that class!" <code class=" language-none">switch (n) { case 50: printf("CS50 is Introduction to Computer Science I\n"); break; case 51: printf("CS51 is Introduction to Computer Science II\n"); break; default: printf("Sorry, I'm not familiar with that class!\n"); break; }</code>
<h6>Цикли</h6> while: перевіряє умову, потім виконує дію, поки умова істинно <code class=" language-none">while (умова) { // выполнять, пока истина }</code> do/while відрізняється тим, що він виконує дію без перевірки умови, та був лише перевіряє його. Якщо умова виконується, він повторює дію, доки умова стане брехнею. <code class=" language-none">do { ) // выполнять, пока истина } while (умова);</code> Цикл for повторює дію задану кількість разів <img data-id="455f6072-2928-4e83-afcf-5c0ed5b74e13" data-max-width="582" alt="Додаткові матеріали до лекцій CS50: Week 1 (лекції 3 та 4) - 13" src="https://cdn.javarush.com/images/article/455f6072-2928-4e83-afcf-5c0ed5b74e13/512.jpeg" style="width: 582px;"> Цикли можна вкладати один в інший. У такому разі на кожному кроці зовнішнього циклу буде повністю виконуватися внутрішній цикл. <img data-id="a6146862-5037-4e12-97b4-7c8f6b3c65e9" data-max-width="526" alt="Додаткові матеріали до лекцій CS50: Week 1 (лекції 3 та 4) - 14" src="https://cdn.javarush.com/images/article/a6146862-5037-4e12-97b4-7c8f6b3c65e9/512.jpeg" style="width: 526px;">
<h5>Основні типи даних у C</h5><img data-id="41b34ecf-b604-48ca-bbb7-854b32ffe270" data-max-width="740" alt="основні типи даних у C" src="https://cdn.javarush.com/images/article/41b34ecf-b604-48ca-bbb7-854b32ffe270/512.jpeg" style="width: 740px;">
<h6>Бібліотеки С</h6> Ви, напевно, вже запитали, що означає перший рядок програми на C: Яка її роль і чи можна обійтися без неї? Рядок #include робить дуже важливу річ: вона підключає бібліотеки вже написаного коду до вашої програми. Ім'я підключеної бібліотеки йде у кутових дужках (&lt;&gt;) і має розширення (.h). Якби не було бібліотек, то будь-яку, найпростішу дію, довелося б щоразу описувати знову і знову. Підключена бібліотека<code class=" language-none">#include </code><stdio.h>
 містить функції введення/виводу. Саме вона дозволяє нам використовувати функцію printf() для виведення на екран. Тобто якби ми не написали рядок #include
 <strong><stdio.h></stdio.h></strong>, але залишабо в тілі програми функцію printf(), при спробі запуску ми отримали помилку! Тому що без цієї бібліотеки компілятор не знає, що таке printf(). Є стандартні бібліотеки, вони складають словниковий запас мови. Функція printf() не вбудована в комп'ютер, але входить до стандартної бібліотеки мови C. Тобто програміст раніше написав її і включив до бібліотеки. Тепер інші можуть нею користуватися, не вигадуючи велосипеда. Щоб компілятор її «зрозумів», підключаємо
 <stdio.h>
  . Є й інші стандартні бібліотеки, які у процесі проходження CS50. Наприклад, бібліотека рядків, де описані операції з рядками (визначення довжини, додавання та інше). У порівнянні з іншими популярними мовами програмування кількість стандартних бібліотек C дуже невелика. Але є самописні, найчастіше більш вузькоспеціалізовані бібліотеки. Так, бібліотека
  <cs50.h>
   було створено спеціально для студентів CS50. 
   <strong>Саме час зробити важливе зауваження:</strong>крім написання програм, вирішення завдань за допомогою власного коду, хороший розробник має ще одну важливу навичку: знання інструментів, вже написаних і вміння використовувати їх (чужі бібліотеки), щоб не витрачати час на винахід «колеса». Так, якщо ви знаходитесь в процесі вирішення нудного або складного завдання, яке при цьому здається досить поширеним, привчайтесь ставити собі питання: «а чи не написав її рішення хтось інший?» Великі шанси, що так і є, і ви можете знайти цю функцію в існуючій бібліотеці. У технічних термінах бібліотека - це двійковий файл, отриманий шляхом об'єднання в колекцію об'єктних файлів, використовуючи компонувальник. Об'єктні файли — це файли з розширенням (*.o), які ви отримуєте під час компіляції програм. 
   <h6>Структура бібліотек C</h6> Коли програміст пише бібліотеку, код розподіляється за двома типами файлів - заголовний файл (header, розширення *. h) та файл реалізації (implementation, розширення *. c). Заголовковий файл містить код, який описує ресурси бібліотеки, які можна використовувати. Тобто описи змінних, функцій, структур, типів та інше. Якщо вам цікаво, що містить та чи інша бібліотека, потрібно заглянути саме в файл заголовка. У терміналі CS50 IDE (та інших середовищах Linux) ви можете викликати програму less для перегляду файлів і відкрити з його допомогою бібліотеку, що вас цікавить: 
   <code class=" language-none">less /usr/include/stdio.h</code> Файл відкриється прямо в терміналі. Щоправда, для новачків він буде дуже важко читаним. 
   <img data-id="1d178892-963f-4ff1-b671-23a10a24bcb9" data-max-width="740" alt="Додаткові матеріали до лекцій CS50: Week 1 (лекції 3 та 4) - 15" src="https://cdn.javarush.com/images/article/1d178892-963f-4ff1-b671-23a10a24bcb9/512.jpeg" style="width: 740px;"> Щоб вийти з less, натисніть q на клавіатурі. Заголовний файл не містить код функцій, що є прикладом дуже важливого поняття - приховування даних або інкапсуляції. Користувачеві системи нема чого знати «начинки» бібліотек, йому достатньо, щоб вона працювала. Якщо ви прошерстіть stdio.h, то не знайдете там реалізації printf(), хоча як її використовувати, ви вже знаєте. Це зроблено для того, щоб захистити дані від втручання, яке часом може погано позначитися на системі. Так, якщо хтось змінить реалізацію функції printf() у бібліотеці, це відіб'ється на всіх програмах, які її використовують. Допитливим буде цікаво, де заховано реалізацію. Відповідно до конвенції (угоди, прийняті у світі програмування) такий код зберігають у файлі з розширенням (*.c). Після компіляції бібліотеки на основі двох файлів з однаковим ім'ям 
   <img data-id="8a831116-28b2-49d8-9f9f-801bada19736" data-max-width="593" alt="Додаткові матеріали до лекцій CS50: Week 1 (лекції 3 та 4) - 16" src="https://cdn.javarush.com/images/article/8a831116-28b2-49d8-9f9f-801bada19736/512.jpeg" style="width: 593px;"> Автор бібліотеки передає програмісту, який хоче її використовувати, два файли - з двійковим кодом, а також заголовний файл. Таким чином, файл із вихідним кодом програмісту не потрібний. Точніше, може бути необхідний, якщо програміст хоче щось змінити у бібліотеці і перекомпілювати її під власні потреби. Щоб скористатися функціями бібліотеки у своїй програмі, потрібно виконати таке: 1. Включити заголовковий файл у програму за допомогою рядка #include У випадку стандартних бібліотек достатньо вказати ім'я бібліотеки в кутових дужках: Якщо бібліотека, яку ви хочете підключити, лежить у тій же папці, 
   <code class=" language-none">#include &lt;ім'я_библиотеки.h&gt;</code> що і ваша програма, підключайте її так: 
   <code class=" language-none">#include “ім'я_библиотеки.h”</code> 2.Приєднати бінарний файл для компіляції. Це дуже важливий крок, оскільки, як ми говорабо вище, файл заголовку не містить реалізації елементів бібліотеки. Щоб це зробити, потрібно викликати компілятор clang з прапором –l і назвою бібліотеки, що йде безпосередньо за ним. Наприклад, компонуємо бібліотеку CS50: 
   <code class=" language-none">clang hello –lcs50</code> Clang - один з компіляторів. Для компіляції можна використовувати вже знайому вам програму make. По суті вона викликає clang з певними аргументами командного рядка. 
   <h5>І знову Hello C: розбір синтаксису найпростіших програм</h5> Директива #include підключає бібліотеку вводу/виводу
   <stdio.h>
    . Програми C складаються з функцій, а ті — з операторів і змінних. Функція - це шматок коду, в якому вже є або подаються якісь дані, а якісь дані отримують у результаті її виконання. Фігурні дужки обмежують тіло функції - опис того, що вона повинна робити. printf() із стандартної бібліотеки stdio виводить будь-який рядок на екран. Рядки полягають у подвійні лапки, а символ "\n" означає переведення курсору на новий рядок. Приклад: функція порахувати квадрат цілого числа. Передаємо функції дані, у разі — число, що треба звести у квадрат. Потім в ній прописується алгоритм множення числа на себе, і результат цього множення вона видає на виході. 
    <code class=" language-none">int sqr(int a) { return a*a; }</code> int sqr(int a) - назва функції. У дужках її аргумент a, це те, що подається на вхід функції. Це як змінна у рівнянні. Тобто, якщо хочемо дізнатися квадрат числа 5, ми викличемо нашу функцію як sqr(5) і отримаємо результат 25. int — тип даних (від англ. integer — цілі числа). Наша функція написана так, що ми не можемо викликати її аргументом a = 5.5. Така спроба видасть помилку, оскільки 5.5 — число дрібне, а наше число має бути цілим. int перед ім'ям функції означає тип, який ця функція повинна повертати. Він обов'язково збігається з типом аргументу. Приклад: функція, яка забирає від цілого числа 0.5: 
    <code class=" language-none">double bit_less(int a) { double b; b = a – 0.5; return b; }</code> int main (void) - назва головної функції. В одній програмі може бути багато функцій, але щоб почати її виконувати, потрібна функція під назвою main. Слово void у дужках означає, що ця функція не має аргументів. 
    <strong>Увага! </strong>main завжди повертає int, але return для неї не є обов'язковим. Приклад функції, що не повертає значення: 
    <code class=" language-none">void sayhello(void) { printf(“hello everyone!\n”); }</code> При виклику функції у головній програмі вона виведе вітання. Давайте напишемо одну програму, де буде кілька функцій. Ті, що ми вже створабо вище. Дві створені нами функції викличемо через головну функцію main(). У C, як і будь-якій мові, є такий елемент, як коментар або примітка в програмному колі, призначене не для комп'ютера, а для розуміння людей. Наприклад, опис, що робить код. Компілятор не бачить коментарів. Коментування програм - дуже важливий момент, оскільки часом розібратися в чужому (і навіть своєму) коді дуже складно. 
    <code class=" language-none">//пример однострочного комментария /** а это – многострочного **/ #include <stdio.h>
      //функция возведения в квадрат числа a int sqr(int a) { return a*a; } //выводит приветствие void test(void) { printf ("hello everyone!\n"); } //главная функция int main(void) { test(); printf("%d\n", sqr(5)); }
     </stdio.h></code> Майже все, що є у цій програмі, ви вже бачабо. Дві функції - зведення в квадрат і вітання та головна функція main, де ми послідовно викликаємо ці дві функції. В результаті виконання програми у нас спочатку виведеться вітання, на наступному рядку – квадрат 5. Зверніть увагу, функція test() викликається з порожніми дужками, тому що її аргументи визначені як void. 
    <h5>Ще трохи про введення/виведення в C</h5> Ви, напевно, вже встигли помітити дивні символи %d та %f у дужках оператора printf. Справа в тому, що функція printf виводить дані у наступному узагальненому вигляді: 
    <code class=" language-none">рrintf ("управляющая строка", аргумент1, аргумент2,...);</code> Керуючий рядок містить компоненти трьох типів: 
    <ul>
     <li>символи, що відображаються на екрані дисплея;</li>
     <li>специфікатори перетворення, що викликають виведення на екран чергового аргументу з наступного списку;</li>
     <li>керуючі символьні константи.</li>
    </ul> Специфікатор перетворення починається зі знака % і закінчується символом, що задає перетворення. Деякі з таких символів: 
    <ul>
     <li>з: значенням аргументу символ;</li>
     <li>d чи i: десяткове ціле число;</li>
     <li>f: десяткове число з плаваючою точкою;</li>
     <li>s: рядок символів.</li>
    </ul> Тобто %d означає, що на екрані з'явиться ціле десяткове, а %f — десяткове з плаваючою комою. Що, якщо нам потрібно, щоб користувач ввів дані з клавіатури? Для цього можна використовувати функцію scanf( ), прототип якої лежить у бібліотеці stdio. Щоб рахувати з екрана речове число, у програмі потрібно написати рядок 
    <code class=" language-none">scanf("%d", &amp;a);</code> Давайте перепишемо нашу програму так, щоб користувач сам вводив число, яке потрібно звести в квадрат. 
    <img data-id="878c3986-677e-48f7-841f-aa210ea856bc" data-max-width="496" alt="Додаткові матеріали до лекцій CS50: Week 1 (лекції 3 та 4) - 17" src="https://cdn.javarush.com/images/article/878c3986-677e-48f7-841f-aa210ea856bc/256.jpeg" style="width: 496px;">
   </stdio.h>
  </cs50.h>
 </stdio.h>
</stdio.h>