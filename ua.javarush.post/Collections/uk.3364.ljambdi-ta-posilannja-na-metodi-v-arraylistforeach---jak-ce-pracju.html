Лямбди та посилання на методи в ArrayList.forEach - як це працює
<p>----------------------------------------</p>
Знайомство з лямбда-виразами у квесті Java Syntax Zero починається з вкрай специфічного прикладу: Автори лекції розбирають лямбди та посилання на методи за допомогою стандартної функції forEach класу ArrayList. Особисто мені було важко зроз
<p>----------------------------------------</p>
Знайомство з лямбда-виразами у квесті Java Syntax Zero починається з вкрай специфічного прикладу: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span>string<span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token string">"Вітання"</span><span class="token punctuation">,</span> <span class="token string">"як"</span><span class="token punctuation">,</span> <span class="token string">"дела?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Автори лекції розбирають лямбди та посилання на методи за допомогою стандартної функції forEach класу ArrayList. Особисто мені було важко зрозуміти зміст того, що відбувається, оскільки реалізація цієї функції, як і пов'язаного з нею інтерфейсу, залишається «під капотом». Звідки береться аргумент <strong>(s)</strong> , куди передається функція <strong>println()</strong> - питання, які нам доведеться відповідати самостійно. На щастя, за допомогою IntelliJ IDEA ми можемо легко зазирнути у внутрішній пристрій класу ArrayList і розмотати цю локшину від самого початку. Якщо ви теж нічого не зрозуміли і хочете розібратися, намагатимусь вам у цьому хоч трохи допомогти. <strong>Лямбда-вираз і ArrayList.forEach - як це працює</strong> З лекції ми вже знаємо, що<strong>Лямбда-вираз - це реалізація функціонального інтерфейсу</strong> . Тобто ми оголошуємо інтерфейс з однією функцією, а за допомогою лямбди описуємо, що ця функція робить. Для цього необхідно: 1. Створити багатофункціональний інтерфейс; 2. Створити змінну, тип якої відповідає функціональному інтерфейсу; 3. Присвоїти цій змінній лямбда-вираз, що описує реалізацію функції; 4. Викликати функцію через звернення до змінної (можливо, я грубуватий у термінології, але так найзрозуміліше). Наведу найпростіший приклад з гугла, додавши його докладними коментарями (спасибі авторам сайту metanit.com): 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">interface</span> <span class="token class-name">Operationable</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token function">calculate</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Единственная функция в интерфейсе — значит, это функциональный интерфейс,</span>
    <span class="token comment">// который можно реализовать с помощью лямбды</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LambdaApp</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment">// Создаём переменную operation типа Operationable (так называется наш функциональный интерфейс)</span>
        <span class="token class-name">Operationable</span> operation<span class="token punctuation">;</span>
        <span class="token comment">// Прописываем реализацию функции calculate с помощью лямбды, на вход подаём x и y, на выходе возвращаем их сумму</span>
        operation <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token operator">-&gt;</span>x<span class="token operator">+</span>y<span class="token punctuation">;</span>

        <span class="token comment">// Теперь мы можем обратиться к функции calculate через переменную operation</span>
        <span class="token keyword">int</span> result <span class="token operator">=</span> operation<span class="token punctuation">.</span><span class="token function">calculate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//30</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre> Тепер повернемося, наприклад, з лекції. У колекцію <strong>list</strong> додаються кілька елементів типу String. Потім елементи виводяться за допомогою стандартної функції <strong>forEach</strong> , яка викликається у об'єкта <strong>list</strong> . Як аргумент у функцію передається лямбда-вираз із якимось дивним параметром <strong>s</strong> . 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span>string<span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token string">"Вітання"</span><span class="token punctuation">,</span> <span class="token string">"як"</span><span class="token punctuation">,</span> <span class="token string">"дела?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Якщо ви відразу не зрозуміли, що тут сталося, то ви не самотні. На щастя, у IntelliJ IDEA є чудова комбінація клавіш <strong>Ctrl+Ліва_Кнопка_Миші</strong> . Якщо навести курсор на forEach і натиснути цю комбінацію, відкриється вихідний стандартний клас ArrayList, в якому ми побачимо реалізацію методу <strong>forEach</strong> : 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> action<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> es <span class="token operator">=</span> elementData<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> modCount <span class="token operator">==</span> expectedModCount <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        action<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token function">elementAt</span><span class="token punctuation">(</span>es<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre> Ми бачимо, що на вхід подається аргумент <strong>action</strong> типу <strong>Consumer</strong> . Наведемо курсор на слово <strong>Consumer</strong> і знову натиснемо чарівну комбінацію <strong>Ctrl+LMB</strong> . Відкриється опис інтерфейсу <strong>Consumer</strong> . Якщо прибрати з нього default-реалізацію (нам вона зараз не важлива), побачимо такий код: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span>t<span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
   <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre> Отже. У нас є інтерфейс <strong>Consumer</strong> з єдиною функцією <strong>accept</strong> , яка приймає один аргумент будь-якого типу. Якщо функція одна, значить функціональний інтерфейс, і його реалізацію можна прописати через лямбда-вираз. Ми вже з'ясували, що в ArrayList є функція <strong>forEach</strong> , яка приймає на вхід реалізацію інтерфейсу <strong>Consumer</strong> як аргумент <strong>action</strong> . Крім того, у функції forEach ми знаходимо такий код: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class=" language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> modCount <span class="token operator">==</span> expectedModCount <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    action<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token function">elementAt</span><span class="token punctuation">(</span>es<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Цикл for фактично перебирає всі елементи колекції ArrayList. Усередині циклу ми бачимо виклик функції <strong>accept</strong> об'єкта <strong>action</strong> — пам'ятаєте, як ми зверталися до operation.calculate? У функцію <strong>accept</strong> передається поточний елемент колекції. Тепер ми нарешті можемо повернутися до вихідного лямбда-виразу і зрозуміти, що воно робить. Зберемо весь код в одну купу: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span>t<span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
   <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Функция, которую мы реализуем лямбда-выражением</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> action<span class="token punctuation">)</span> <span class="token comment">// В action хранится об'єкт Consumer, в котором функция accept реализована нашей лямбдой {</span>
    <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> es <span class="token operator">=</span> elementData<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> modCount <span class="token operator">==</span> expectedModCount <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        action<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token function">elementAt</span><span class="token punctuation">(</span>es<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Вызываем нашу реализацию функции accept интерфейса Consumer для каждого елемента коллекции</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//...</span>

list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Наше лямбда-вираз - це реалізація функції <strong>accept</strong> , описаної в інтерфейсі <strong>Consumer</strong> . За допомогою лямбди ми прописали, що функція <strong>accept</strong> приймає аргумент <strong>і</strong> виводить його на екран. Лямбда-вираз було передано в функцію <strong>forEach</strong> в якості її аргументу <strong>action</strong> , який якраз і зберігає в собі реалізацію інтерфейсу <strong>Consumer</strong> . Тепер функція forEach може викликати нашу реалізацію інтерфейсу Consumer за допомогою такого рядка: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java">action<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token function">elementAt</span><span class="token punctuation">(</span>es<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Таким чином, вхідний аргумент <strong>s</strong> у лямбда-вираженні - це <strong>черговий елемент колекції ArrayList</strong> , який передається в нашу реалізацію <strong>інтерфейсу Consumer</strong> . На цьому все: логіку роботи лямбда-вираження в ArrayList.forEach ми розібрали. <strong>Посилання на метод ArrayList.forEach — а це як працює? </strong> Наступним кроком у лекції розбираються посилання методи. Щоправда, розбираються вони зовсім дивно — після прочитання лекції в мене не було жодних шансів зрозуміти, що ж робить цей код: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java">list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Спочатку знову трохи теорії. <strong>Посилання метод</strong> — це, якщо дуже грубо, <strong>реалізація функціонального інтерфейсу, описана інший функцією</strong> . Знову ж почну із простого прикладу: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Operationable</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token function">calculate</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Единственная функция в интерфейсе — значит, это функциональный интерфейс</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Calculator</span> <span class="token punctuation">{</span>
    <span class="token comment">// Создадим статический класс Calculator и пропишем в нём метод methodReference.</span>
    <span class="token comment">// Именно он будет реализовывать функцию calculate из интерфейса Operationable.</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">methodReference</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> x<span class="token operator">+</span>y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Создаём переменную operation типа Operationable (так называется наш функциональный интерфейс)</span>
    <span class="token class-name">Operationable</span> operation<span class="token punctuation">;</span>
    <span class="token comment">// Теперь реализацией интерфейса будет не лямбда-выражение, а метод methodReference из нашего класса Calculator</span>
    operation <span class="token operator">=</span> <span class="token class-name">Calculator</span><span class="token operator">::</span><span class="token function">methodReference</span><span class="token punctuation">;</span>

    <span class="token comment">// Теперь мы можем обратиться к функции интерфейса через переменную operation</span>
    <span class="token keyword">int</span> result <span class="token operator">=</span> operation<span class="token punctuation">.</span><span class="token function">calculate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//30</span>
<span class="token punctuation">}</span></code></pre> Повернемося, наприклад, з лекції: 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java">list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Нагадаю, що <strong>System.out</strong> - це об'єкт типу PrintStream, який має функцію <strong>println</strong> . Давайте наведемо курсор на <strong>println</strong> і натисніть <strong>Ctrl+LMB</strong> : 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">PrintStream</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">writeln</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">newLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre> Відзначимо дві ключові особливості: 1. Функція <strong>println</strong> не повертає нічого (void). 2. Функція <strong>println</strong> отримує один аргумент на вхід. Нічого не нагадує? 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span>t<span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
   <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre> Все правильно - сигнатура функції <strong>accept</strong> - це загальний випадок сигнатури методу <strong>println</strong> ! Отже, останній можна з успіхом використовувати як посилання на метод — тобто <strong>println стає конкретною реалізацією функції accept</strong> : 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java">list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> Ми передали функцію <strong>println</strong> об'єкта <strong>System.out</strong> як аргумент функції <strong>forEach</strong> . Принцип той самий, як і з лямбдою: тепер forEach може передати елемент колекції у функцію println через звернення <strong>action.accept(elementAt(es, i))</strong> . Фактично тепер це можна читати як <strong>System.out.println(elementAt(es, i))</strong> . 
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> action<span class="token punctuation">)</span> <span class="token comment">// В action хранится об'єкт Consumer, в котором функция accept реализована методом println {</span>
        <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> es <span class="token operator">=</span> elementData<span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> modCount <span class="token operator">==</span> expectedModCount <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            action<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token function">elementAt</span><span class="token punctuation">(</span>es<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Функция accept теперь реализована методом System.out.println!</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre> Сподіваюся, що я хоч трохи прояснив ситуацію для тих, хто вперше знайомиться з лямбдами та посиланнями на методи. Насамкінець порекомендую найвідомішу книгу "Java: керівництво для початківців" під авторством Роберта Шилдта - на мій погляд, лямбди і посилання на функції в ній описані досить розумно.