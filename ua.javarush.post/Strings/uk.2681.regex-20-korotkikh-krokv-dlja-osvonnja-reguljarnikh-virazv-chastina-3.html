RegEx: 20 коротких кроків для освоєння регулярних виразів. Частина 3
<p>----------------------------------------</p>
У цій частині ми перейдемо до речей ще більш складним. Але, освоїти їх, як і раніше, не складе особливих труднощів. Повторюся, що RegEx насправді легше, ніж він може здатися спочатку, і не потрібно бути семи п'ядей на лобі, щоб його освоїти
<p>----------------------------------------</p>
<a href="https://codegym.cc/groups/posts/2679-regex-20-korotkikh-shagov-dlja-osvoenija-reguljarnihkh-vihrazheniy-chastjh-1" target="_blank" rel="nofollow">RegEx: 20 коротких кроків для освоєння регулярних виразів. Частина 1. </a> <a href="https://codegym.cc/groups/posts/2680-regex-20-korotkikh-shagov-dlja-osvoenija-reguljarnihkh-vihrazheniy-chastjh-2" target="_blank" rel="nofollow">RegEx: 20 коротких кроків для освоєння регулярних виразів. Частина 2.</a> У цій частині ми перейдемо до речей ще більш складним. Але, освоїти їх, як і раніше, не складе особливих труднощів. Повторюся, що RegEx насправді легше, ніж він може здатися спочатку, і не потрібно бути семи п'ядей на лобі, щоб його освоїти, і почати застосовувати на ділі. Англомовний оригінал цієї статті <a href="https://dev.to/awwsmm/20-small-steps-to-become-a-regex-master-mpc" target="_blank" rel="nofollow">тут</a> . <img data-max-width="800" data-id="28dfd2a7-4d2d-4d0e-b44b-40ec3f7de68d" class="img-fluid" alt="20 коротких кроків для освоєння регулярних виразів.  Частина 3 - 1" src="https://cdn.javarush.com/images/article/28dfd2a7-4d2d-4d0e-b44b-40ec3f7de68d/800.jpeg" style="width: 800px;">
<h2>Крок 11: круглі дужки <code class=" language-none">()</code>як групи захоплення</h2><img data-max-width="512" data-id="5cef32b7-18e8-4c46-8c78-3798b3a4f8fa" class="img-fluid" alt="20 коротких кроків для освоєння регулярних виразів.  Частина 3 - 2" src="https://cdn.javarush.com/images/article/5cef32b7-18e8-4c46-8c78-3798b3a4f8fa/512.jpeg" style="width: 512px;">В останній задачі ми шукали різні види цілісних значень та числових значень з плаваючою комою (точкою). Але механізм регулярних виразів не робив відмінностей між цими двома типами значень, оскільки все відбито в одному великому регулярному вираженні. Ми можемо сказати движку регулярних виразів, що потрібно розрізняти різні види збігів, якщо укладемо наші міні-шаблони в круглі дужки: 
<pre>pattern: <span>([AZ])|([az])</span> 
string:   <span>The current President of Bolivia is Evo Morales</span> .
matches: <span>^^^ ^^^^^^^^ ^^^^^^^^^^ ^^ ^^^^^^^ ^^ ^^^ ^^^^^^^</span> 
group:    <span>122 2222222 122222222 22 1222222 22 122 1222222</span>  
</pre> ( <a href="https://regex101.com/r/Mf9L3O/62" target="_blank" rel="nofollow">Приклад</a> ) Наведене вище регулярне вираз визначає дві групи захоплення, які індексуються починаючи з 1. Перша група захоплення відповідає будь-якій окремій літері, а друга група захоплення відповідає будь-якій окремій рядковій літері. Використовуючи знак 'або' <code class=" language-none">|</code>та круглі дужки <code class=" language-none">()</code>як групу захоплення, ми можемо визначити один регулярний вираз, який відповідає декільком видам рядків. Якщо ми застосуємо це до нашого регулярного виразу для пошуку long/float із попередньої частини статті, то механізм регулярних виразів фіксуватиме відповідні збіги у відповідних групах. Перевіряючи, якій групі відповідає підрядок, ми можемо відразу визначити, чи є вона значенням float або long: 
<pre>pattern: <span>(\d*\.\d+[fF]|\d+\.\d*[fF]|\d+[fF])|(\d+[lL]) string: 42L</span> 
12   <span>x</span> 3.4f <span>6l</span> 3.3 <span>0F</span> LF <span>.2F</span> 0.
matches: <span>^^^ ^^^^ ^^ ^^ ^^^</span> 
group:    <span>222 1111 22 11 111</span>  
</pre> ( <a href="https://regex101.com/r/Mf9L3O/63" target="_blank" rel="nofollow">Приклад</a> ) Це регулярне вираз досить складне, і щоб його краще зрозуміти, давайте розберемо його на частини, і розглянемо кожен з цих шаблонів: 
<pre>( // збігається з будь-яким "float" підрядком
  \d*\.\d+[fF]
  |
  \d+\.\d*[fF]
  |
  \d+[fF]
)
| // OR
( // збігається з будь-яким "long" підрядком
  \d+[lL]
)
</pre> Знак <code class=" language-none">|</code>та групи захоплення в дужках <code class=" language-none">()</code>дозволяють нам зіставляти різні типи підрядків. У цьому випадку ми зіставляємо або числа з плаваючою комою "float", або довгі довгі цілі числа "long". 
<pre>(
  \d*\.\d+[fF] // 1+ цифр праворуч від десяткової точки
  |
  \d+\.\d*[fF] // 1+ цифр зліва від десяткової точки
  |
  \d+[fF] // без крапки, лише 1+ цифр
)
|
(
  \d+[lL] // без крапки, лише 1+ цифр
)
</pre> У групі захоплення "float" у нас є три варіанти: числа з мінімум 1 цифрою праворуч від десяткової точки, числа з мінімум однією цифрою зліва від десяткової точки та числа без десяткової точки. Будь-які з них є "float", за умови, що до кінця додані літери "f" або "F". Усередині групи захоплення "long" у нас є тільки одна опція - у нас має бути 1 або більше цифр, за якими слідує символ "l" або "L". Механізм регулярних виразів шукатиме ці підрядки в даному рядку і індексуватиме їх у відповідній групі захоплення. <mark>Зверніть увагу</mark>, що ми не зіставляємо жодне з чисел, до яких не додано жодного з "l", "L", "f" або "F". Як слід класифікувати ці цифри? Ну, якщо вони мають десяткову точку, за замовчуванням у Java використовується значення "double". Інакше вони мають бути "int". 
<h3>Закріпимо пройдене парою завдань:</h3>Додайте ще дві групи захоплення до наведеного вище регулярного виразу, щоб воно класифікувало числа double або int. (Це ще одне складне питання, не засмучуйтесь, якщо це займе деякий час, у крайньому випадку дивіться моє рішення.) 
<pre>pattern:
string:   <span>42L 12</span> x <span>3.4f 6l 3.3 0F</span> LF <span>.2F 0.</span> 
matches: <span>^^^ ^^ ^^^^ ^^ ^^^ ^^ ^^^ ^^</span> 
group:    <span>333 44 1111 33 222 11 111</span>
</pre> ( <a href="https://regex101.com/r/Mf9L3O/64" target="_blank" rel="nofollow">Рішення</a> ) Наступне завдання трохи простіше. Використовуйте групи захоплення у дужках <code class=" language-none">()</code>, знак 'або' <code class=" language-none">|</code>та діапазони символів для сортування наступного віку: "дозволено пити в США". (&gt;= 21) та "заборонено пити в США" (&lt;21): 
<pre>pattern:
string:   <span>7 10 17 18 19 20 21 22 23 24 30 40 100 120</span> 
matches: <span>^ ^^ ^^ ^^ ^^ ^^ ^^ ^^ ^^ ^^ ^^ ^^ ^^^ ^^^</span> 
group:    <span>2 22 22 22 22 22 11 11 11 11 11 11 111 111</span> 
</pre> ( <a href="https://regex101.com/r/Mf9L3O/65" target="_blank" rel="nofollow">Рішення</a> ) 
<h2>Крок 12: спочатку визначте конкретніші збіги</h2><img data-max-width="512" data-id="58f3b2e5-a331-4c9c-b52d-e5fa5449ad15" class="img-fluid" alt="20 коротких кроків для освоєння регулярних виразів.  Частина 3 - 3" src="https://cdn.javarush.com/images/article/58f3b2e5-a331-4c9c-b52d-e5fa5449ad15/512.jpeg" style="width: 512px;">Можливо, у вас виникли деякі проблеми з останнім завданням, якщо ви спробували визначити "законно п'ють" як першу групу захоплення, а не другу. Щоб зрозуміти чому, погляньмо на інший приклад. Припустимо, ми хочемо записати окремо прізвища, що містять менше 4 символів, та прізвища, що містять 4 або більше символів. Давайте віддамо більш короткі імена першою групою захоплення, і подивимося, що станеться: 
<pre>pattern: <span>([AZ][az]?[az]?)|([AZ][az][az][az]+) string</span> 
:   <span>Kim Job</span> s <span>Xu Clo</span> yd <span>Moh</span> r <span>Ngo Roc</span> k.
matches: <span>^^^ ^^^ ^^ ^^^ ^^^ ^^^ ^^^</span> 
group:    <span>111 111 11 111 111 111 111</span>   
</pre> ( <a href="https://regex101.com/r/Mf9L3O/66" target="_blank" rel="nofollow">Приклад</a> ) За замовчуванням більшість движків регулярних виразів використовують <a href="https://stackoverflow.com/a/2301298/2925434" target="_blank" rel="nofollow">жадібне зіставлення</a> з основними символами, які ми бачабо досі. Це означає, що механізм регулярних виразів захоплюватиме максимально довгу групу, визначену якомога раніше у наданому регулярному виразі. Таким чином, хоча друга група, наведена вище, могла б захопити більше символів в іменах, таких як, наприклад, "Jobs" і "Cloyd", але оскільки перші три символи цих імен вже були захоплені першою групою захоплення, вони не можуть бути захоплені знову другий. Тепер внесемо невелике виправлення - просто змінимо порядок груп захоплення, помістивши першу більш конкретну (довшу) групу: 
<pre>pattern: ([AZ][az][az][az]+)| ( <span>[AZ][az]?[az]?)</span> 
string:   <span>Kim Jobs Xu Cloyd Mohr Ngo Rock</span>
matches: <span>^^^ ^^^^ ^^ ^^^^^ ^^^^ ^^^ ^^^^</span> 
group:    <span>222 1111 22 11111 1111 222 1111</span>    
</pre> ( <a href="https://regex101.com/r/Mf9L3O/67" target="_blank" rel="nofollow">Приклад</a> ) 
<h3>Завдання... цього разу лише одне :)</h3>"Більш конкретний" шаблон майже завжди означає "довший". Припустимо, що ми хочемо знайти два види "слів": спочатку ті, які починаються з голосних (конкретніше), потім ті, які <b>не</b> починаються з голосних (будь-яке інше слово). Спробуйте написати регулярний вираз для захоплення та ідентифікації рядків, які відповідають цим двом групам. (Групи нижче позначені літерами, а не пронумеровані. Ви повинні визначити, яка група має відповідати першій, а яка – другий.) 
<pre>pattern:
string:   <span>pds6f uub 24r2gp ewqrty l ui_op</span> 
matches: <span>^^^^^ ^^^ ^^^^^ ^^^^^^ ^ ^^^^^</span> 
group:    <span>NNNNN VVV NNNNNN VVVVVV N VVVVV</span>
</pre> ( <a href="https://regex101.com/r/Mf9L3O/68" target="_blank" rel="nofollow">Рішення</a> ) Загалом, чим точніше ваше регулярне вираження, тим довшим воно вийде в результаті. І чим воно точніше, тим менша ймовірність, що ви захопите те, що вам не потрібно. Тому, хоча вони можуть виглядати лякаючими, довші регулярні вирази ~= кращі регулярні вирази. <a href="https://emailregex.com/" target="_blank" rel="nofollow">На жаль</a> . 
<h2>Крок 13: фігурні дужки <code class=" language-none">{}</code>для певної кількості повторень</h2><img data-max-width="512" data-id="0d148d85-2088-4c43-9ae9-77fa5cf1e221" class="img-fluid" alt="20 коротких кроків для освоєння регулярних виразів.  Частина 3 - 4" src="https://cdn.javarush.com/images/article/0d148d85-2088-4c43-9ae9-77fa5cf1e221/512.jpeg" style="width: 512px;">У прикладі з прізвищами з попереднього кроку у нас було 2 групи, що майже повторюються, в одному шаблоні: 
<pre>pattern: ([AZ][az][az][az]+)| ( <span>[AZ][az]?[az]?)</span> 
string:   <span>Kim Jobs Xu Cloyd Mohr Ngo Rock</span>
matches: <span>^^^ ^^^^ ^^ ^^^^^ ^^^^ ^^^ ^^^^</span> 
group:    <span>222 1111 22 11111 1111 222 1111</span>    
</pre> Для першої групи нам потрібні були прізвища із чотирма або більше літерами. Друга група мала захоплювати прізвища з трьома або менш літерами. Чи існує якийсь простіший спосіб написати це, ніж повторювати ці <code class=" language-none">[a-z]</code>групи знову і знову? Існує, якщо використовувати для цього фігурні дужки <code class=" language-none">{}</code>. Фігурні дужки <code class=" language-none">{}</code>дозволяють нам вказати мінімальну та (необов'язково) максимальну кількість збігів попереднього символу або групи захоплення. Є три варіанти використання <code class=" language-none">{}</code>: 
<pre>{X} // збігається точно X разів
{X,} // збігається &gt;= X разів
{X,Y} // збігається &gt;= X and &lt;= Y разів
</pre> Ось приклади цих трьох різних синтаксисів: 
<pre>pattern: <span>[az] {11}</span> 
string:   <span>humuhumunuk</span> unukuapua'a.
matches: <span>^^^^^^^^^^^^</span>   
</pre> ( <a href="https://regex101.com/r/Mf9L3O/69" target="_blank" rel="nofollow">Приклад</a> ) 
<pre>pattern: <span>[az] {18,}</span> 
string:   <span>humuhumunukunukuapua</span> 'a.
matches: <span>^^^^^^^^^^^^^^^^^^^^^</span>    
</pre> ( <a href="https://regex101.com/r/Mf9L3O/71" target="_blank" rel="nofollow">Приклад</a> ) 
<pre>pattern: <span>[az] {11,18}</span> 
string:   <span>humuhumunukunukuap</span> ua'a.
matches: <span>^^^^^^^^^^^^^^^^^^^</span>    
</pre> ( <a href="https://regex101.com/r/Mf9L3O/70" target="_blank" rel="nofollow">Приклад</a> ) У наведених вище прикладах є кілька моментів, на які слідує<mark>звернути увагу:</mark>. По-перше, використовуючи нотацію {X}, попередній символ або група відповідатиме саме цій кількості (X) разів. Якщо в "слові" є більше символів (ніж число X), які могли б відповідати шаблону (як показано в першому прикладі), вони не будуть включені у відповідність. Якщо кількість символів менша за X, то повне зіставлення завершиться невдало (спробуйте змінити 11 на 99 у першому прикладі). По-друге, позначення {X,} та {X,Y} є жадібними. Вони намагатимуться відповідати якомога більшій кількості символів, водночас задовольняючи заданому регулярному виразу. Якщо ви вкажете {3,7}, можна буде зіставити від 3 до 7 символів, і якщо наступні 7 символів дійсні, тоді будуть зіставлені всі 7 символів. Якщо ви вкажете {1,}, і всі наступні 14 000 символів збігаються, то всі 14 000 із цих символів будуть включені у відповідний рядок. Як ми можемо використовувати це знання, щоб переписати наш вираз вище? Найпростішим покращенням може бути заміна сусідніх груп<code class=" language-none">[a-z]</code>на <code class=" language-none">[a-z]{N}</code>, де N вибирається відповідним чином: 
<pre>pattern: <span>([AZ][az]{2}[az]+)|([AZ][az]?[az]?)</span>  
</pre> ... але це не робить ситуацію набагато кращою. Подивіться на першу групу захоплення: у нас є <code class=" language-none">[a-z]{2}</code>(що відповідає рівно 2 малим літерам), за якими слідує <code class=" language-none">[a-z]+</code>(що відповідає 1 або більше малим літерам). Ми можемо спростити це, запитивши 3 або більше малих літер, використовуючи фігурні дужки: 
<pre>pattern: <span>([AZ][az]{3,})|([AZ][az]?[az]?)</span> 
</pre> Друга група захоплення відрізняється. Нам потрібно не більше трьох символів у цих прізвищах, що означає, що у нас є верхня межа, але наша нижня межа дорівнює нулю: 
<pre>pattern: <span>([AZ][az]{3,})|([AZ][az]{0,2})</span> 
</pre> Специфічність завжди краще при використанні регулярних виразів, тому було б розумно зупинитися на цьому, але я не можу не помітити, що ці два діапазони символів ( <code class=" language-none">[AZ]</code>і <code class=" language-none">[az]</code>) поряд один з одним виглядають майже як клас "word character" (символ слова), <code class=" language-none">\w</code>( <code class=" language-none">[A-Za-z0-9_]</code>) . Якщо ми впевнені, що наші дані містять лише добре відформатовані прізвища, то ми могли б спростити наше регулярне вираження, і написати просто: 
<pre>pattern: <span>(\w{4,})|(\w{1,3})</span> 
</pre> Перша група захоплює будь-яку послідовність з 4 або більше "word characters" ( <code class=" language-none">[A-Za-z0-9_]</code>), а друга група захоплює будь-яку послідовність від 1 до 3 "word characters" (включно). Чи це спрацює? 
<pre>pattern: <span>(\w{4,})|(\w{1,3})</span> 
string:   <span>Kim Jobs Xu Cloyd Mohr Ngo Rock</span> .
matches: <span>^^^ ^^^^ ^^ ^^^^^ ^^^^ ^^^ ^^^^</span> 
group:    <span>222 1111 22 11111 1111 222 1111</span>    
</pre> ( <a href="https://regex101.com/r/Mf9L3O/72" target="_blank" rel="nofollow">Приклад</a> ) Спрацювало! Як щодо такого підходу? І це набагато чистіше, ніж у попередньому прикладі. Оскільки перша група захоплення відповідає всім прізвищам з чотирма або більше символами, то ми могли б навіть змінити другу групу захоплення просто на <code class=" language-none">\w+</code>, так як це дозволило б нам захопити всі прізвища, що залишабося (з 1, 2 або 3 символами): 
<pre>pattern: <span>(\w{4,})|(\w+)</span> 
string:   <span>Kim Jobs Xu Cloyd Mohr Ngo Rock</span> .
matches: <span>^^^ ^^^^ ^^ ^^^^^ ^^^^ ^^^ ^^^^</span> 
group:    <span>222 1111 22 11111 1111 222 1111</span>    
</pre> ( <a href="https://regex101.com/r/Mf9L3O/73" target="_blank" rel="nofollow">Приклад</a> ) 
<h3>Давайте допоможемо мозку засвоїти це, і вирішимо наступні 2 завдання:</h3>Використовуйте фігурні дужки <code class=" language-none">{}</code>, щоб переписати регулярний вираз для пошуку номера соціального страхування з кроку 7: 
<pre>pattern:
string: 113-25=1902 <span>182-82-0192</span> H23-_3-9982 1I1-O0-E38B
matches:              <span>^^^^^^^^^^^^</span>
</pre> ( <a href="https://regex101.com/r/Mf9L3O/74" target="_blank" rel="nofollow">Рішення</a> ) Припустимо, що система перевірки надійності пароля на веб-сайті вимагає, щоб паролі користувачів складали від 6 до 12 символів. Напишіть регулярний вираз, що позначає <strong>невірні</strong> паролі у списку нижче. Кожен пароль міститься в дужках <code class=" language-none">()</code>для зручності зіставлення, тому переконайтеся, що регулярний вираз починається і закінчується буквальними <code class=" language-none">(</code>та <code class=" language-none">)</code>символами. Підказка: переконайтеся, що ви забороняєте літеральні дужки в паролях за допомогою <code class=" language-none">[^()]</code>або аналогічних, в іншому випадку ви отримаєте зрештою відповідність всьому рядку! 
<pre>pattern:
string:   <span>(12345) (my password)</span> (Xanadu.2112) <span>(su_do)</span> (OfSalesmen!)
matches: <span>^^^^^^^ ^^^^^^^^^^^^^ ^^^^^^^</span>  
</pre> ( <a href="https://regex101.com/r/Mf9L3O/75" target="_blank" rel="nofollow">Рішення</a> ) 
<h2>Крок 14: <code class=" language-none">\b</code>символ межі нульової ширини</h2><img data-max-width="512" data-id="acd92a73-25a8-4eb9-9877-e0338362538c" class="img-fluid" alt="20 коротких кроків для освоєння регулярних виразів.  Частина 3 – 5" src="https://cdn.javarush.com/images/article/acd92a73-25a8-4eb9-9877-e0338362538c/512.jpeg" style="width: 512px;">Останнє завдання було досить складним. Але що, якщо ми ще трохи ускладнимо її, уклавши паролі в лапки <code class=" language-none">""</code>замість дужок <code class=" language-none">()</code>? Чи можемо ми написати аналогічне рішення просто замінивши всі символи круглих дужок на символи лапок? 
<pre>pattern: <span>\"[^"]{0,5}\"|\"[^"]+\s[^"]*\" string: "12345" "</span> 
my   <span>password"</span> "Xanadu.2112 <span>" "</span> su_do" " OfSalesmen!"
matches: <span>^^^^^^^ ^^^^^^^^^^^^^^ ^^^ ^^^</span>  
</pre> ( <a href="https://regex101.com/r/Mf9L3O/76" target="_blank" rel="nofollow">Приклад</a> ) Вийшло не дуже вражаюче. Ви вже здогадалися, чому? Проблема полягає в тому, що ми шукаємо тут неправильні паролі. "Xanadu.2112" - хороший пароль, тому, коли регулярний вираз розуміє, що ця послідовність не містить прогалин або літеральних символів <code class=" language-none">"</code>, воно здається безпосередньо перед символом <code class=" language-none">"</code>, який обмежує пароль у правій частині. (Оскільки ми вказали, що символи <code class=" language-none">"</code>не можуть бути знайдені всередині паролів, використовуючи <code class=" language-none">[^"]</code>.) Як тільки механізм регулярних виразів переконається, що ці символи не відповідають певному регулярному виразу, він запускається знову, саме в тому місці, де він зупинився - де був символ <code class=" language-none">"</code>, котрий обмежує "Xanadu.2112" праворуч. Звідти він бачить один символ пропуску,<code class=" language-none">"</code>– для нього це неправильний пароль! Загалом він знаходить цю послідовність <code class=" language-none">" "</code>і йде далі. Це зовсім не те, що ми хотіли б отримати... Було б чудово, якби ми могли вказати, що перший символ пароля має бути <b>не</b> пропуском. Чи є спосіб зробити це? (Наразі ви, напевно, вже зрозуміли, що відповіддю на всі мої риторичні питання є "так".) Так! Такий спосіб є! Багато движків регулярних виразів надають таку escape-послідовність як "кордон слова" <code class=" language-none">\b</code>. "Кордон слова" <code class=" language-none">\b</code>- це escape-послідовність нульової ширини, яка, як не дивно, відповідає межі слова. Пам'ятайте, що коли ми говоримо "слово", то маємо на увазі як будь-яку послідовність символів у класі <code class=" language-none">\w</code>, так і таку<code class=" language-none">[A-Za-z0-9_]</code>. Збіг за кордоном слова означає, що символ безпосередньо перед або відразу після послідовності <code class=" language-none">\b</code>повинен бути <code class=" language-none">не</code>символом слова. Однак, при порівнянні, ми не включаємо цей символ в нашу захоплену підрядок. Це і є нульова ширина. Щоб побачити, як це працює, давайте розглянемо невеликий приклад: 
<pre>pattern: <span>\b[^]+\b</span> 
string:   <span>Ve still vant ze money</span> , <span>Lebowski</span> .
matches: <span>^^ ^^^^^ ^^^^ ^^ ^^^^^ ^^^^^^^^</span>  
</pre> ( <a href="https://regex101.com/r/Mf9L3O/78" target="_blank" rel="nofollow">Приклад</a> ) Послідовність <code class=" language-none">[^ ]</code>повинна відповідати будь-якому символу, який не є символом буквального пробілу. Так чому ж це не відповідає комою <code class=" language-none">,</code>після money або точці " <code class=" language-none">.</code>після Lebowski? Це тому, що кома <code class=" language-none">,</code>і точка <code class=" language-none">.</code>не є символами слова, тому між символами слова і несловесними символами створюються межі. Вони з'являються між <code class=" language-none">y</code>в кінці слова money і комою <code class=" language-none">,</code>яка слідує за ним, і між " <code class=" language-none">i</code>словом Lebowski і точкою <code class=" language-none">.</code>(повною зупинкою / періодом), яка слідує за ним. Регулярний вираз збігається на межах цих слів (але не на несловесних символах, які лише допомагають їх визначити). Але що станеться, якщо ми не ввімкнемо послідовність<code class=" language-none">\b</code>у наш шаблон? 
<pre>pattern: <span>[^] +</span> 
string:   <span>Ve still vant ze money, Lebowski. </span>
matches: <span>^^ ^^^^^ ^^^^ ^^ ^^^^^^ ^^^^^^^^^</span>  
</pre> ( <a href="https://regex101.com/r/Mf9L3O/79" target="_blank" rel="nofollow">Приклад</a> ) Ага, тепер ми знаходимо і ці розділові знаки. Тепер давайте скористаємося межами слів, щоб виправити регулярний вираз для паролів у лапках: 
<pre>pattern: <span>\"\b[^"]{0,5}\b\"|\"\b[^"]+\s[^"]*\b\" string: "12345" "my</span> 
password   <span>"</span> " Xanadu.2112" <span>"su_do"</span> "OfSalesmen!"
matches: <span>^^^^^^^ ^^^^^^^^^^^^^ ^^^^^^^</span>  
</pre> ( <a href="https://regex101.com/r/Mf9L3O/80" target="_blank" rel="nofollow">Приклад</a> ) Розміщуючи межі слів усередині лапок ("\b...\b"), ми фактично говоримо, що перший і останній символи паролів, що збігаються, повинні бути "символами слова". Так що тут все працює нормально, але не працюватиме так само добре, якщо перший або останній символ пароля користувача не є символом слова: 
<pre>pattern: <span>\"\b[^"]{0,5}\b\"|\"\b[^"]+\s[^"]*\b\"</span>
string: "відповідно про wordwordshort" "C++"
matches:   
</pre> ( <a href="https://regex101.com/r/Mf9L3O/81" target="_blank" rel="nofollow">Приклад</a> ) Подивіться, як другий пароль не позначений як "неправильний", навіть якщо він явно занадто короткий. Ви маєте бути<mark>обережні</mark>з послідовностями <code class=" language-none">\b</code>, тому що вони відповідають кордонам тільки між символами <code class=" language-none">\w</code>і не <code class=" language-none">\w</code>. У наведеному вище прикладі, оскільки в паролях ми допустабо символи не <code class=" language-none">\w</code>, межа між <code class=" language-none">\</code>і першим/останнім символом пароля не гарантується як межа слова <code class=" language-none">\b</code>. 
<h3>На завершення цього кроку вирішимо лише одне просте завдання:</h3>Кордони слова корисні у механізмах підсвічування синтаксису, коли ми хочемо зіставити певну послідовність символів, але хочемо переконатися, що вони зустрічаються лише на початку чи наприкінці слова (або самі по собі). Припустимо, ми пишемо підсвічування синтаксису і хочемо виділити слово var, але тільки тоді, коли воно з'являється саме собою (не торкаючись інших символів слова). Чи зможете ви написати регулярний вираз для цього? Звичайно зможете, адже це дуже просте завдання ;) 
<pre>pattern:
string:   <span>var</span> varx _var ( <span>var</span> j) barvarcar * <span>var var</span> -&gt; { <span>var</span> }
matches: <span>^^^ ^^^ ^^^ ^^^ ^^^</span>  
</pre> ( <a href="https://regex101.com/r/Mf9L3O/82" target="_blank" rel="nofollow">Рішення</a> ) 
<h2>Крок 15: "caret" <code class=" language-none">^</code>як "початок рядка" та знак долара <code class=" language-none">$</code>як "кінець рядка"</h2><img data-max-width="512" data-id="2388206b-f4e6-4cd4-869b-3072cf7f931c" class="img-fluid" alt="20 коротких кроків для освоєння регулярних виразів.  Частина 3 - 6" src="https://cdn.javarush.com/images/article/2388206b-f4e6-4cd4-869b-3072cf7f931c/512.jpeg" style="width: 512px;">Послідовність меж слова <code class=" language-none">\b</code>(з останнього кроку попередньої частини статті) – не єдина спеціальна послідовність нульової ширини, доступна для використання у регулярних виразах. Двома найбільш популярними з них є "caret" <code class=" language-none">^</code>- "початок рядка" та знак долара <code class=" language-none">$</code>- "кінець рядка". Включення одного з них у ваші регулярні вирази означає, що цей збіг повинен з'явитися на початку або в кінці вихідного рядка: 
<pre>pattern: <span>^start|end$</span> 
string:   <span>start</span> end start end start end start <span>end</span> 
matches: <span>^^^^^ ^^^</span>  
</pre> ( <a href="https://regex101.com/r/Mf9L3O/83" target="_blank" rel="nofollow">Приклад</a> ) Якщо ваш рядок містить розриви рядків, то <code class=" language-none">^start</code>відповідатиме послідовності "start" на початку будь-якого рядка, а <code class=" language-none">end$</code>відповідатиме послідовності "end" наприкінці будь-якого рядка (хоча це важко показати тут). Ці символи особливо корисні при роботі з даними розділів. Повернімося до проблеми "розміру файлу" з кроку 9, використовуючи <code class=" language-none">^</code>"початок рядка". У цьому прикладі наші розміри файлів розділені пробілами " <code class=" language-none"> </code>". Тому ми хочемо, щоб кожен розмір файлу починався з цифри, якій передує символ пробілу або початок рядка: 
<pre>pattern: <span>(^| )(\d+|\d+\.\d+)[KMGT]B</span> 
string:   <span>6.6KB</span> 1..3KB <span>12KB</span> 5G <span>3.3MB</span> KB .6.2TB <span>9MB</span> .
matches: <span>^^^^^ ^^^^^ ^^^^^^ ^^^^</span> 
group:    <span>222 122 1222 12</span>    
</pre> ( <a href="https://regex101.com/r/Mf9L3O/84" target="_blank" rel="nofollow">Приклад</a> ) Ми вже так близько до мети! Але ви можете помітити, що у нас ще одна невелика проблема: ми зіставляємо символ пробілу перед допустимим розміром файлу. Тепер ми можемо просто ігнорувати цю групу захоплення (1), коли наш двигун регулярних виразів знайде її, або ми можемо використовувати групу без захоплення, яку ми побачимо на наступному кроці. 
<h3>А поки що, вирішимо ще 2 завдання для тонусу:</h3>Продовжуючи наш приклад підсвічування синтаксису з останнього кроку, деякі підсвічування синтаксису будуть відзначати кінцеві пробіли, тобто будь-які пробіли, які знаходяться між символом і кінцем рядка. Чи можете ви написати регулярний вираз для підсвічування лише кінцевих прогалин? 
<pre>pattern:
string: myvec &lt;- c(1, 2, 3, 4, 5)  
matches: <span>                         ^^^^^^^</span>  
</pre> ( <a href="https://regex101.com/r/Mf9L3O/85" target="_blank" rel="nofollow">Рішення</a> ) Простий синтаксичний аналізатор з роздільниками-комами (CSV) шукатиме "токени", розділені комами. Як правило, пробіл не має значення, якщо він не укладений у лапки <code class=" language-none">""</code>. Напишіть простий регулярний вираз для розбору CSV, який зіставляє токени між комами, але ігнорує (не захоплює) пробіл, який <strong>не</strong> знаходиться між лапками. 
<pre>pattern:
string:   <span>a, "b", "c d", e, f, "g h", dfgi,, k, "", l matches:</span> 
^^ <span>^^^^ ^^^^^^^^^^ ^^^ ^^^ ^^^^^^ ^^ ^^^ ^</span> 
group:    <span>21 2221 2222212121 222221 222211 21 221 2</span>    
</pre> ( <a href="https://regex101.com/r/Mf9L3O/114" target="_blank" rel="nofollow">Рішення</a> ) <a href="https://codegym.cc/groups/posts/2682-regex-20-korotkikh-shagov-dlja-osvoenija-reguljarnihkh-vihrazheniy-chastjh-4" target="_blank" rel="nofollow">RegEx: 20 коротких кроків для освоєння регулярних виразів. Частина 4</a>