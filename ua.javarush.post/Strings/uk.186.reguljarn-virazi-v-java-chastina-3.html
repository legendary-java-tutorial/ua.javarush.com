Регулярні вирази в Java, частина 3
<p>----------------------------------------</p>
Пропонуємо до вашої уваги переклад короткого посібника з регулярних виразів у мові Java, написаного Джеффом Фрісеном (Jeff Friesen) для сайту . Для простоти читання ми розділили статтю кілька частин. У першій та другій частинах цієї статті 
<p>----------------------------------------</p>
Пропонуємо до вашої уваги переклад короткого посібника з регулярних виразів у мові Java, написаного Джеффом Фрісеном (Jeff Friesen) для сайту <a href="https://www.javaworld.com/article/3195301/learn-java/java-101-regular-expressions-in-java-part-2.html" target="_blank" rel="nofollow">javaworld</a> . Для простоти читання ми розділабо статтю кілька частин. <img data-max-width="800" data-id="c20d7218-52bd-479a-ac66-cf328fdb387c" class="img-fluid" alt="Регулярні вирази Java, частина 3 - 1" src="https://cdn.javarush.com/images/article/c20d7218-52bd-479a-ac66-cf328fdb387c/800.jpeg" style="width: 800px;"><a href="https://codegym.cc/groups/posts/136-reguljarnihe-vihrazhenija-v-java-chastjh-1" target="_blank">Регулярні вирази в Java, частина 1 </a> <a href="https://codegym.cc/groups/posts/154-reguljarnihe-vihrazhenija-v-java-chastjh-2" target="_blank">Регулярні вирази в Java, частина 2</a>
<h2>Спрощуємо вирішення найпоширеніших завдань програмування за допомогою API Regex</h2>У першій та другій частинах цієї статті ви познайомабося з регулярними виразами та API Regex. Ви дізналися про існування класу <code class=" language-none">Pattern</code>, пройшлися за прикладами, що демонструють конструкції регулярних виразів, від найпростішого пошуку за шаблоном на основі літеральних рядків до складнішого пошуку за допомогою діапазонів, граничних зіставників та квантифікаторів. У цій та наступних частинах ми розглянемо не охоплені в першій частині питання, вивчимо відповідні методи класів <code class=" language-none">Pattern</code>, <code class=" language-none">Matcher</code>та <code class=" language-none">PatternSyntaxException</code>. Ви також познайомитеся з двома утилітами, які використовують <a href="https://codegym.cc/groups/posts/2013-reguljarnihe-vihrazhenija-v-java" target="_blank">регулярні вирази</a>для спрощення розв'язання поширених завдань програмування. Перша з них отримує коментарі з коду для документації. Друга є бібліотекою багаторазового коду, призначену для виконання лексичного аналізу — суттєвий компонент асемблерів, компіляторів тощо програмного забезпечення. 
<h4>ЗАВАНТАЖЕННЯ ПОХІДНОГО КОДУ</h4>Отримати весь вихідний код (створений Джеффом Фрізеном для сайту JavaWorld) демо-додатків з цієї статті можна <a href="http://images.techhive.com/assets/2017/04/11/jw-j101-regexp1-src.zip" target="_blank">звідси</a> . 
<h2>Вивчаємо API Regex</h2><code class=" language-none">Pattern</code>, <code class=" language-none">Matcher</code>і <code class=" language-none">PatternSyntaxException</code>– три класи, що становлять API Regex. Кожен із них надає методи, що дозволяють використовувати регулярні вирази у вашому коді. 
<h2>Методи класу Pattern</h2>Примірник класу <code class=" language-none">Pattern</code>є скомпільованим регулярним виразом, відомим також як шаблон. Регулярні вирази компілюються з метою підвищення продуктивності операцій пошуку за шаблоном. Наступні статичні способи підтримують компіляцію. 
<ul>
 <li><code class=" language-none">Pattern compile(String regex)</code>компілює вміст <code class=" language-none">regex</code>у проміжне уявлення, що зберігається в новому об'єкті <code class=" language-none">Pattern</code>. Цей метод або повертає посилання на об'єкт у разі успішного виконання або генерує виняток <code class=" language-none">PatternSyntaxException</code>у разі виявлення некоректного синтаксису регулярного виразу. Будь-який об'єкт класу <code class=" language-none">Matcher</code>, що використовується цим об'єктом <code class=" language-none">Pattern</code>або повертається з нього, використовує його за замовчуванням, наприклад, пошук з урахуванням регістру. Як приклад, фрагмент коду <code class=" language-none">Pattern p = Pattern.compile("(?m)^\\.");</code> створює об'єкт <code class=" language-none">Pattern</code>, що зберігає скомпілювання представлення регулярного виразу для пошуку рядків, що починаються з символу точки.</li>
 <br>
 <li><code class=" language-none">Pattern compile(String regex, int flags)</code>Вирішує ту ж задачу, що і <code class=" language-none">Pattern compile(String regex)</code>, але з урахуванням <code class=" language-none">flags</code>: набору бітових констант для побитових прапорів типу АБО. У класі <code class=" language-none">Pattern</code>оголошено константи <code class=" language-none">CANON_EQ, CASE_INSENSITIVE, COMMENTS, DOTALL, LITERAL, MULTILINE, UNICODE_CASE, UNICODE_CHARACTER_CLASS и UNIX_LINES</code>, які можна комбінувати за допомогою побітового АБО (наприклад, <code class=" language-none">CASE_INSENSITIVE | DOTALL</code>) і передати в аргументі <code class=" language-none">flags</code>.</li>
 <br>
  За винятком <code class=" language-none">CANON_EQ, LITERAL и UNICODE_CHARACTER_CLASS</code>, ці константи є альтернативою вкладених прапорових виразів, продемонстрованим у частині 1. При виявленні прапорової константи, яка відрізняється від визначених у класі <code class=" language-none">Pattern</code>, метод <code class=" language-none">Pattern compile(String regex, int flags) </code>генерує виняток <code class=" language-none">java.lang.IllegalArgumentException</code>. Наприклад, <code class=" language-none">Pattern p = Pattern.compile("^\\.", Pattern.MULTILINE);</code>еквівалентно попередньому прикладу, причому константа <code class=" language-none">Pattern.MULTILINE</code>і вкладене прапорне вираження <code class=" language-none">(?m)</code>роблять те саме.
</ul>Іноді буває необхідно отримати копію вихідного рядка регулярного виразу, скомпілюваного в об'єкт <code class=" language-none">Pattern</code>, разом з прапорами, що використовуються. Для цього можна викликати такі методи: 
<ul>
 <li><code class=" language-none">String pattern()</code>повертає вихідний рядок регулярного виразу, скомпільований в об'єкт <code class=" language-none">Pattern</code>.</li>
 <br>
 <li><code class=" language-none">int flags()</code>повертає прапори об'єкта <code class=" language-none">Pattern</code>.</li>
</ul>Після отримання об'єкта <code class=" language-none">Pattern</code>, він зазвичай використовується для отримання об'єкта <code class=" language-none">Matcher</code>для виконання операцій пошуку за шаблоном. Метод <code class=" language-none">Matcher matcher(Charsequence input)</code>створює об'єкт <code class=" language-none">Matcher</code>, який у тексті <code class=" language-none">input</code>відповідність шаблону об'єкта <code class=" language-none">Pattern</code>. При дзвінку він повертає посилання на цей об'єкт <code class=" language-none">Matcher</code>. Наприклад, команда <code class=" language-none">Matcher m = p.matcher(args[1]);</code>повертає <code class=" language-none">Matcher</code>об'єкт <code class=" language-none">Pattern</code>, на який посилається змінна <code class=" language-none">p</code>. 
<div class="table-container">
 <table>
  <thead>
   <tr>
    <th>Одноразовий пошук</th>
   </tr>
  </thead>
  <tbody>
   <tr>
    <td>Метод <code class=" language-none">static boolean matches(String regex, CharSequence input)</code>класу <code class=" language-none">Pattern</code>дозволяє заощадити створення об'єктів <code class=" language-none">Pattern</code>і <code class=" language-none">Matcher</code>за одноразовому пошуку за шаблоном. Цей метод повертає true, якщо <code class=" language-none">input</code>знаходиться відповідність шаблону <code class=" language-none">regex</code>, в іншому випадку він повертає false. Якщо у регулярному вираженні міститься синтаксична помилка, метод генерує виняток <code class=" language-none">PatternSyntaxException</code>. Наприклад, <code class=" language-none">System.out.println(Pattern.matches("[a-z[\\s]]*", "all lowercase letters and whitespace only"));</code>виводить <code class=" language-none">true</code>, підтверджуючи, що фраза <code class=" language-none">all lowercase letters and whitespace only</code>містить лише прогалини і символи в нижньому регістрі.</td>
   </tr>
  </tbody>
 </table>
</div><img data-max-width="800" data-id="f15849fd-cf74-4260-911a-19b8e0013c93" class="img-fluid" alt="Регулярні вирази у Java, частина 3 - 2" src="https://cdn.javarush.com/images/article/f15849fd-cf74-4260-911a-19b8e0013c93/800.jpeg" style="width: 800px;">
<h2>Розбиття тексту</h2>Більшості розробників доводилося хоч раз писати код для розбиття вхідного тексту на складові, наприклад, перетворювати текстовий обліковий запис співробітника на набір полів. Клас <code class=" language-none">Pattern</code>надає можливість зручнішого розв'язання цього стомлюючого завдання, за допомогою двох методів розбиття тексту: 
<ul>
 <li>
  <p>Метод <code class=" language-none">String[] split(CharSequence text, int limit)</code>розбиває <code class=" language-none">text</code>відповідно до знайдених відповідностей шаблон об'єкта <code class=" language-none">Pattern</code>і повертає результати в масиві. Кожен елемент масиву задає текстову послідовність, відокремлену від наступної послідовності, що відповідає шаблону фрагментом тексту (або кінцем тексту). Елементи масиву перебувають у тому порядку, де вони зустрічаються в <code class=" language-none">text</code>.</p>
  <p>У цьому методі кількість елементів масиву залежить від параметра <code class=" language-none">limit</code>, що контролює також і кількість шуканих відповідностей.</p>
  <ul>
   <li>При позитивному значенні виконується пошук лише <code class=" language-none">limit-1</code>відповідностей, а довжина масиву вбирається у <code class=" language-none">limit</code>елементів.</li>
   <li>При негативному значенні виконується пошук всіх можливих відповідностей, і довжина масиву може бути довільною.</li>
   <li>При рівному нулю значення виконується пошук всіх можливих відповідностей, довжина масиву може бути довільною, а порожні рядки в кінці відкидаються.</li>
  </ul>
  <p></p></li>
 <li>Метод <code class=" language-none">String[] split(CharSequence text)</code>викликає попередній метод з 0 як аргумент limit і повертає результат його виклику.</li>
</ul>Нижче наведено результати роботи методу <code class=" language-none">split(CharSequence text)</code>вирішення завдання розщеплення облікового запису співробітника на окремі поля імені, віку, поштової адресаи та зарплати: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">Pattern</span></span> p <span class="token operator"><span class="token operator">=</span></span> <span class="token class-name"><span class="token class-name">Pattern</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">compile</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">",\\s"</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token class-name"><span class="token class-name">String</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> fields <span class="token operator"><span class="token operator">=</span></span> p<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">split</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">"John Doe, 47, Hillsboro Road, 32000"</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token keyword"><span class="token keyword">for</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">int</span></span> i <span class="token operator"><span class="token operator">=</span></span> <span class="token number"><span class="token number">0</span></span><span class="token punctuation"><span class="token punctuation">;</span></span> i <span class="token operator"><span class="token operator">&lt;</span></span> fields<span class="token punctuation"><span class="token punctuation">.</span></span>length<span class="token punctuation"><span class="token punctuation">;</span></span> i<span class="token operator"><span class="token operator">++</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
   <span class="token class-name"><span class="token class-name">System</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>fields<span class="token punctuation"><span class="token punctuation">[</span></span>i<span class="token punctuation"><span class="token punctuation">]</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> У наведеному вище коді описано регулярне вираження для пошуку знака комою, за яким безпосередньо слідує одиночний символ пробілу. Ось результати його виконання: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">John</span></span> <span class="token class-name"><span class="token class-name">Doe</span></span>
<span class="token number"><span class="token number">47</span></span>
<span class="token class-name"><span class="token class-name">Hillsboro</span></span> <span class="token class-name"><span class="token class-name">Road</span></span>
<span class="token number"><span class="token number">32000</span></span></code></pre>
<h2>Предикати шаблонів та API Streams</h2>У Java 8 у класі <code class=" language-none">Pattern</code>з'явився метод . Цей метод створює предикат (функцію з булевим значенням), що використовується для пошуку шаблону. Використання цього методу показано в наступному фрагменті коду: <code class=" language-none">Predicate<string>
  asPredicate()
 </string></code>
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">List</span></span><string> progLangs <span class="token operator"><span class="token operator">=</span></span> <span class="token class-name"><span class="token class-name">Arrays</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">asList</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">"apl"</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token string"><span class="token string">"basic"</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token string"><span class="token string">"c"</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token string"><span class="token string">"c++"</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token string"><span class="token string">"c#"</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token string"><span class="token string">"cobol"</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token string"><span class="token string">"java"</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token string"><span class="token string">"javascript"</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token string"><span class="token string">"perl"</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token string"><span class="token string">"python"</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token string"><span class="token string">"scala"</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token class-name"><span class="token class-name">Pattern</span></span> p <span class="token operator"><span class="token operator">=</span></span> <span class="token class-name"><span class="token class-name">Pattern</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">compile</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">"^c"</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
progLangs<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">stream</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">filter</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>p<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">asPredicate</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">forEach</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">System</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token operator"><span class="token operator">::</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
</string></code></pre> Цей код створює список назв мов програмування, а потім компілює шаблон для пошуку всіх назв, що починаються з літери <code class=" language-none">c</code>. Останній з наведених вище рядків коду реалізує отримання послідовного потоку даних з цим списком як джерело. Він встановлює фільтр, що використовує булеву функцію <code class=" language-none">asPredicate()</code>, яка повертає true, коли назва починається з літери <code class=" language-none">c</code>і виконує ітерацію потоку, виводячи відповідні назви стандартний потік виведення. Цей останній рядок еквівалентний наступному звичайному циклу, знайомому вам за додатком RegexDemo з частини 1: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">for</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">String</span></span> progLang<span class="token operator"><span class="token operator">:</span></span> progLangs<span class="token punctuation"><span class="token punctuation">)</span></span>
   <span class="token keyword"><span class="token keyword">if</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span>p<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">matcher</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>progLang<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">find</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
      <span class="token class-name"><span class="token class-name">System</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>progLang<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre>
<h2>Методи класу Matcher</h2>Примірник класу <code class=" language-none">Matcher</code>описує механізм виконання операцій пошуку за шаблоном у послідовності символів шляхом інтерпретації скомпілованого регулярного виразу класу <code class=" language-none">Pattern</code>. Об'єкти класу <code class=" language-none">Matcher</code>підтримують різні види операцій пошуку за шаблоном: 
<ul>
 <li>
  <p>Метод <code class=" language-none">boolean find()</code>шукає у вхідному тексті такий збіг. Цей метод починає переглядати або на початку заданого тексту, або на першому символі після попереднього збігу. Другий варіант можливий лише якщо попередній виклик цього методу повернув true і зіставник не було скинуто. У будь-якому випадку, у разі успішного пошуку повертається булеве значення true. Приклад цього методу ви можете знайти з <code class=" language-none">RegexDemo</code>частини 1.</p></li>
 <li>
  <p>Метод <code class=" language-none">boolean find(int start)</code>скидає зіставник і шукає у тексті такий збіг. Перегляд починається з позиції, яка задається параметром <code class=" language-none">start</code>. У разі успішного пошуку повертається булеве значення true. Наприклад, <code class=" language-none">m.find(1);</code>переглядає текст починаючи з позиції <code class=" language-none">1</code>(позиція 0 ігнорується). Якщо параметр <code class=" language-none">start</code>містить негативне значення або значення, що перевищує довжину тексту зіставника, метод генерує виняток <code class=" language-none">java.lang.IndexOutOfBoundsException</code>.</p></li>
 <li>
  <p>Метод <code class=" language-none">boolean matches()</code>намагається зіставити із шаблоном весь текст. Він повертає булеве значення true, якщо весь текст відповідає шаблону. Наприклад, код <code class=" language-none">Pattern p = Pattern.compile("\\w*"); Matcher m = p.matcher("abc!"); System.out.println(p.matches());</code>виводить <code class=" language-none">false</code>, оскільки символ <code class=" language-none">!</code>не є символом.</p></li>
 <li>
  <p>Метод <code class=" language-none">boolean lookingAt()</code>намагається зіставити із шаблоном заданий текст. Цей метод повертає true, якщо будь-яка частина тексту відповідає шаблону. На відміну від методу <code class=" language-none">matches();</code>весь текст не повинен відповідати шаблону. Наприклад, <code class=" language-none">Pattern p = Pattern.compile("\\w*"); Matcher m = p.matcher("abc!"); System.out.println(p.lookingAt());</code>виведе <code class=" language-none">true</code>, оскільки початок тексту <code class=" language-none">abc!</code>складається лише з символів.</p></li>
</ul>На відміну від об'єктів класу <code class=" language-none">Pattern</code>об'єкти класу <code class=" language-none">Matcher</code>зберігають інформацію про стан. Іноді може знадобитися скинути зіставник, щоб очистити цю інформацію після пошуку за шаблоном. Для скидання порівняча існують такі методи: 
<ul>
 <li>
  <p>Метод <code class=" language-none">Matcher reset()</code>скидає стан співставника, включаючи позицію додавання в кінець (скидається в 0). Наступна операція пошуку за шаблоном починається на початку тексту зіставника. Посилання на поточний об'єкт <code class=" language-none">Matcher</code>. Наприклад, <code class=" language-none">m.reset();</code>скидає зіставник, який посилається <code class=" language-none">m</code>.</p></li>
 <li>
  <p>Метод <code class=" language-none">Matcher reset(CharSequence text)</code>скидає стан співставника та задає новий текст співставника, що дорівнює <code class=" language-none">text</code>. Наступна операція пошуку за шаблоном починається на початку нового тексту зіставника. Посилання на поточний об'єкт <code class=" language-none">Matcher</code>. Наприклад, <code class=" language-none">m.reset("new text");</code>скидає зіставник, на який посилається <code class=" language-none">m</code>і задає як новий текст зіставника значення <code class=" language-none">"new text"</code>.</p></li>
</ul><img data-max-width="800" data-id="2918bc5f-b713-49c7-932d-518f1a675234" class="img-fluid" alt="Регулярні вирази у Java, частина 3 - 3" src="https://cdn.javarush.com/images/article/2918bc5f-b713-49c7-932d-518f1a675234/800.jpeg" style="width: 800px;">
<h2>Додавання тексту до кінця</h2>Позиція порівняча для додавання в кінець визначає початок тексту зіставника, що додається в кінець об'єкта типу <code class=" language-none">java.lang.StringBuffer</code>. Цю позицію використовують такі методи: 
<ul>
 <li>
  <p>Метод <code class=" language-none">Matcher appendReplacement(StringBuffer sb, String replacement)</code>читає символи тексту співставника і приєднує в кінець об'єкта <code class=" language-none">StringBuffer</code>, який посилається аргумент <code class=" language-none">sb</code>. Цей метод припиняє читання на останньому символі, що передує попередньому відповідності шаблону. Далі метод додає символи з об'єкта типу <code class=" language-none">String</code>, на який посилається аргумент <code class=" language-none">replacement</code>, в кінець об'єкта <code class=" language-none">StringBuffer</code>(рядок <code class=" language-none">replacement</code>може містити посилання на текстові послідовності, захоплені під час попереднього пошуку; вони вказуються за допомогою символів <code class=" language-none">($)</code>і номерів груп, що захоплюються). Нарешті, метод встановлює значення позиції співставника для додавання в кінець рівним позиції останнього символу, що збігся плюс одиниця, після чого повертає посилання на поточний зіставник.</p></li>
 <p></p>
 <p>Метод <code class=" language-none">Matcher appendReplacement(StringBuffer sb, String replacement)</code>генерує виняток <code class=" language-none">java.lang.IllegalStateException</code>, якщо співставник ще не знаходив відповідності або попередня спроба пошуку завершилася невдало. Він генерує виняток <code class=" language-none">IndexOutOfBoundsException</code>, якщо рядок <code class=" language-none">replacement</code>задає відсутню в шаблоні групу, що захоплюється).</p>
 <li>
  <p>Метод <code class=" language-none">StringBuffer appendTail(StringBuffer sb)</code>додає весь текст до об'єкта <code class=" language-none">StringBuffer</code>і повертає посилання на цей об'єкт. Після останнього виклику методу <code class=" language-none">appendReplacement(StringBuffer sb, String replacement)</code>, викличте метод <code class=" language-none">appendTail(StringBuffer sb)</code>, щоб скопіювати текст, що залишився в об'єкт <code class=" language-none">StringBuffer</code>.</p></li>
</ul>
<div class="table-container">
 <table>
  <thead>
   <tr>
    <th>Захоплювані групи</th>
   </tr>
  </thead>
  <tbody>
   <tr>
    <td>Як ви пам'ятаєте з частини 1, група, що захоплюється, - це послідовність символів, укладена в метасимволи круглих дужок ( <code class=" language-none">()</code>). Ціль цієї конструкції полягає в збереженні знайдених символів для подальшого повторного використання під час пошуку за шаблоном. Всі символи з групи, що захоплюється, розглядаються під час пошуку за шаблоном як єдине ціле.</td>
   </tr>
  </tbody>
 </table>
</div>У наступному коді виконується виклик методів <code class=" language-none">appendReplacement(StringBuffer sb, String replacement)</code>та <code class=" language-none">appendTail(StringBuffer sb</code>для заміни у вихідному тексті всіх входжень послідовності символів <code class=" language-none">cat</code>на <code class=" language-none">caterpillar</code>: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">Pattern</span></span> p <span class="token operator"><span class="token operator">=</span></span> <span class="token class-name"><span class="token class-name">Pattern</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">compile</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">"(cat)"</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token class-name"><span class="token class-name">Matcher</span></span> m <span class="token operator"><span class="token operator">=</span></span> p<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">matcher</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">"one cat, two cats, or three cats on a fence"</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token class-name"><span class="token class-name">StringBuffer</span></span> sb <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">StringBuffer</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token keyword"><span class="token keyword">while</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span>m<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">find</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
   m<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">appendReplacement</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>sb<span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token string"><span class="token string">"$1erpillar"</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
m<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">appendTail</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>sb<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token class-name"><span class="token class-name">System</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>sb<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> Використання захоплюючої групи та посилання на неї в тексті, що заміщає, вказує програмі вставляти <code class=" language-none">erpillar</code>після кожного входження <code class=" language-none">cat</code>. Результат виконання цього коду виглядає так: <code class=" language-none">one caterpillar, two caterpillars, or three caterpillars on a fence</code> <a href="https://codegym.cc/welcome" target="_blank"><img id="click_banner1_articles" data-max-width="1024" data-id="3ef843a3-170e-4695-982d-26f89c259546" class="img-fluid" alt="Регулярні вирази у Java, частина 3 - 4" src="https://cdn.javarush.com/images/article/3ef843a3-170e-4695-982d-26f89c259546/1024.jpeg" style="width: 1024px;"></a>
<h2>Заміна тексту</h2>Клас <code class=" language-none">Matcher</code>надає нам два методи для текстової заміни, які доповнюють метод <code class=" language-none">appendReplacement(StringBuffer sb, String replacement)</code>. За допомогою цих методів можна замінювати або перше входження [заміщуваного тексту] або всі входження: 
<ul>
 <li>
  <p>Метод <code class=" language-none">String replaceFirst(String replacement)</code>скидає зіставник, створює новий об'єкт <code class=" language-none">String</code>, копіює у цей рядок всі символи тексту зіставника (аж до першого збігу), додає в її кінець символи з <code class=" language-none">replacement</code>, копіює в рядок символи, що залишабося, і повертає об'єкт <code class=" language-none">String</code>(у рядку <code class=" language-none">replacement</code>можна вказувати посилання на захоплені під час попереднього пошуку текстові послідовності, за допомогою символів долара та номерів груп, що захоплюються).</p></li>
 <li>
  <p>Метод <code class=" language-none">String replaceAll(String replacement)</code>діє аналогічно методу <code class=" language-none">String replaceFirst(String replacement)</code>, але замінює символами з рядка <code class=" language-none">replacement</code>всі знайдені збіги.</p></li>
</ul>Регулярне вираз <code class=" language-none">\s+</code>служить для пошуку одного або більше символів пробілу у вхідному тексті. Нижче, ми скористаємося цим регулярним виразом і викличемо метод <code class=" language-none">replaceAll(String replacement)</code>для видалення пробілів, що дублюються: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">Pattern</span></span> p <span class="token operator"><span class="token operator">=</span></span> <span class="token class-name"><span class="token class-name">Pattern</span></span><span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">compile</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">"\\s+"</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token class-name"><span class="token class-name">Matcher</span></span> m <span class="token operator"><span class="token operator">=</span></span> p<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">matcher</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">"Удаляем      \t\t лишние пробелы.   "</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token class-name"><span class="token class-name">System</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>m<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">replaceAll</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token string"><span class="token string">" "</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> Ось результати: <code class=" language-none">Удаляем лишние пробелы.</code> <a href="https://codegym.cc/groups/posts/229-reguljarnihe-vihrazhenija-v-java-chastjh-4" target="_blank">Регулярні вирази в Java, частина 4 </a> <a href="https://codegym.cc/groups/posts/247-reguljarnihe-vihrazhenija-v-java-chastjh-5" target="_blank">Регулярні вирази в Java, частина 5</a>
<div class="table-container">
 <table>
  <tbody>
   <tr>
    <th>
     <p>Що ще почитати:</p></th>
   </tr>
   <tr>
    <td>
     <ul>
      <li><a href="https://codegym.cc/groups/posts/72-kak-praviljhno-nachatjh-razrabotku-pod-subd-oracle" target="_blank">Як правильно розпочати розробку під СУБД Oracle</a></li>
      <li><a href="https://codegym.cc/groups/posts/254-top-5-bibliotek-mashinnogo-obuchenija-dlja-java" target="_blank">Топ 5 бібліотек машинного навчання для Java</a></li>
      <li><a href="https://codegym.cc/groups/posts/264-populjarno-o-ljambda-vihrazhenijakh-v-java-s-primerami-i-zadachami-chastjh-1-" target="_blank">Популярно про лямбда-вираження в Java. З прикладами та завданнями. Частина 1</a></li>
     </ul></td>
   </tr>
  </tbody>
 </table>
</div>