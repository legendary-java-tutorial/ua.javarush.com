Основи регулярних виразів у Java. Частина 3
<p>----------------------------------------</p>
Продовжуємо вивчення регулярних виразів. У цій статті ми розглянемо визначені класи символів та квантифікацію (пошук послідовностей). API класу містить визначені класи символів, що пропонують зручні скорочення регулярних виразів, що часто в
<p>----------------------------------------</p>
Продовжуємо вивчення регулярних виразів. У цій статті ми розглянемо визначені класи символів та квантифікацію (пошук послідовностей). <img data-id="ebbd73b0-2f64-44e7-8b16-22e1542cc07b" data-max-width="760" alt="Основи регулярних виразів у Java.  Частина 3 - 1" src="https://cdn.javarush.com/images/article/ebbd73b0-2f64-44e7-8b16-22e1542cc07b/512.jpeg" style="width: 760px;">
<h2>Зумовлені класи символів</h2>API класу <code class=" language-none">Pattern</code>містить визначені класи символів, що пропонують зручні скорочення регулярних виразів, що часто використовуються. <img data-id="c3d0eebf-85ab-4c01-8da0-1456cf6f881c" data-max-width="650" alt="Основи регулярних виразів у Java.  Частина 3 - 2" src="https://cdn.javarush.com/images/article/c3d0eebf-85ab-4c01-8da0-1456cf6f881c/512.jpeg" style="width: 650px;">У цій таблиці конструкції у лівій колонці – скорочене уявлення виразів із правої колонки. Наприклад, <code class=" language-none">\d</code>означає цифру (0-9), <code class=" language-none">\w</code>означає будь-яку заголовну або велику літеру, символ підкреслення або цифру). Використовуйте певні класи символів, де це можливо. Це зробить ваш код простіше для читання та виправлення помилок. Конструкції, що починаються зі зворотного слєша, називаються екранованими або захищеними. У попередніх статтях ми вже говорабо про екранування спеціальних символів зворотним слішем або символами <code class=" language-none">\Q</code>.<code class=" language-none">\E</code>для використання їх як звичайних символів. Якщо ви використовуєте зворотний сліш із звичайними символами (літералами), необхідно екранувати цей бек слєш, щоб вираз скомпілювався. 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">private</span></span> <span class="token keyword"><span class="token keyword">final</span></span> <span class="token class-name"><span class="token class-name">String</span></span> REGEX <span class="token operator"><span class="token operator">=</span></span> <span class="token string"><span class="token string">"\\d"</span></span><span class="token punctuation"><span class="token punctuation">;</span></span> <span class="token comment"><span class="token comment">// цифра</span></span></code></pre> У цьому прикладі <code class=" language-none">\d</code>- регулярне вираження; додатковий зворотний сліш необхідний для того, щоб програма скомпілювалася. Наша тестова програма читає <a href="https://codegym.cc/groups/posts/2013-reguljarnihe-vihrazhenija-v-java" target="_blank">регулярні вирази</a> прямо з консолі, тому додатковий сліш не потрібний. Наступний приклад демонструє використання зумовлених символьних класів: <img data-id="1b01383c-1811-4648-8923-b6987db5e19d" data-max-width="650" alt="Основи регулярних виразів у Java.  Частина 3 - 3" src="https://cdn.javarush.com/images/article/1b01383c-1811-4648-8923-b6987db5e19d/512.jpeg" style="width: 650px;"><img data-id="4e1c1668-4406-4488-a2ab-17d0111c8aa6" data-max-width="650" alt="Основи регулярних виразів у Java.  Частина 3 - 4" src="https://cdn.javarush.com/images/article/4e1c1668-4406-4488-a2ab-17d0111c8aa6/512.jpeg" style="width: 650px;">У перших трьох прикладах регулярне вираз — просто « <code class=" language-none">.</code>» (спеціальний символ крапка), що означає будь-який символ. Тому пошук був успішним у всіх випадках. В інших прикладах використовуються зумовлені символьні класи, значення яких ми розглянули у таблиці вище. 
<h2>Квантифікатори</h2><img data-id="46bbc180-b0c7-4fd2-964a-d74319f7838b" data-max-width="650" alt="Основи регулярних виразів у Java.  Частина 3 - 4" src="https://cdn.javarush.com/images/article/46bbc180-b0c7-4fd2-964a-d74319f7838b/512.jpeg" style="width: 650px;"><strong>Квантифікатори</strong> дозволяють вказувати кількість входжень символу в рядок. Розглянемо докладніше тонкощі роботи жадібних, лінивих і дуже жадібних квантифікаторів. На погляд може здатися, що квантифікатори X?, X?? і X?+ працюють однаково: "X є один раз чи ні зовсім". Є невеликі відмінності у реалізації цих квантифікаторів, які ми розглянемо нижче. 
<h2>Збіги нульової довжини</h2>Почнемо з жадібного. Напишемо три різні регулярні вирази: літера «a» зі спеціальними символами ?, * або +. Подивимося, що станеться, якщо тестувати ці регулярки на порожньому рядку: <img data-id="2222afd9-7255-43ef-9c29-5ebfbc56aab9" data-max-width="650" alt="Основи регулярних виразів у Java.  Частина 3 – 5" src="https://cdn.javarush.com/images/article/2222afd9-7255-43ef-9c29-5ebfbc56aab9/512.jpeg" style="width: 650px;">У прикладі вище, пошук був вдалим у перших двох випадках, тому що вирази a? та a* допускають відсутність символу a у рядку. Також зверніть увагу, що початковий та останній індекси збігу однакові (0). Так як вхідний рядок не має довжини, програма знаходить нічого :) на першій позиції. Цей випадок називається збігом нульової довжини. Такі збіги зустрічаються у кількох випадках: при порожньому вхідному рядку, на початку вхідного рядка, після останнього символу рядка або між символами рядка. Збіги нульової довжини легко виявити: вони починаються і закінчуються на одній і тій же позиції. Розглянемо ще кілька прикладів збігів нульової довжини. Let's explore zero-length матчі з більш ніж трьома examples. Змінимо вхідний рядок на символ a і спостерігаємо цікавий ефект: <img data-id="e1c808a7-5a1c-48a1-ada5-8e7398ce7711" data-max-width="650" alt="Основи регулярних виразів у Java.  Частина 3 - 6" src="https://cdn.javarush.com/images/article/e1c808a7-5a1c-48a1-ada5-8e7398ce7711/512.jpeg" style="width: 650px;">Усі три квантифікатори знайшли символ «a», але перші два, які допускають відсутність символу, знайшли збіг нульової довжини на позиції 1 після останнього символу рядка. Так відбувається, тому що програма сприймає символ «a» як рядок і «біжить» по ньому, поки збіги не закінчаться. Залежно від використовуваного квантифікатора програма буде або не знаходитиме «нічого» в кінці рядка. Тепер змінимо вхідний рядок на послідовність із п'яти букв «a»: <img data-id="01af5247-7fa0-429a-b3ea-5a5a15ef1f7f" data-max-width="650" alt="Основи регулярних виразів у Java.  Частина 3 - 7" src="https://cdn.javarush.com/images/article/01af5247-7fa0-429a-b3ea-5a5a15ef1f7f/512.jpeg" style="width: 650px;">Регулярний вираз a? знаходить збіг для кожної літери у рядку окремо. Вираз a* знаходить два збіги: послідовність символів «a» і збіг нульової довжини на 5 позиції. І, нарешті, регулярне вираження a+ знаходить лише послідовність символів «a», не знаходячи при цьому «нічого» :) Що ж відбуватиметься, якщо на вхід подати рядок, що містить різні символи? Наприклад, «ababaaaab»: <img data-id="015a8b48-4d89-4af1-987e-2a7cab1b62d3" data-max-width="650" alt="Основи регулярних виразів у Java.  Частина 3 - 8" src="https://cdn.javarush.com/images/article/015a8b48-4d89-4af1-987e-2a7cab1b62d3/512.jpeg" style="width: 650px;">Символ «b» знаходиться на 1, 3 та 8 позиціях і програма знаходить збіги нульової довжини на цих позиціях. Регулярний вираз a? не звертає увагу на «b», а просто шукає присутність (або відсутність) символу «a». Якщо квантифікатор допускає відсутність «a», всі символи в рядку, відмінні від «a», будуть показані як збіг нульової довжини. Для знаходження послідовностей заданої довжини просто вкажіть довжину у фігурних дужках: <img data-id="c871b787-760d-4a53-b3bd-6b04d4afd41e" data-max-width="650" alt="Основи регулярних виразів у Java.  Частина 3 - 9" src="https://cdn.javarush.com/images/article/c871b787-760d-4a53-b3bd-6b04d4afd41e/512.jpeg" style="width: 650px;">Регулярний вираз a{3} шукає послідовність із трьох символів «a». У першому рядку нічого не знайдено, тому що у рядку недостатньо символів a. Друга містить 3 символи, які знаходить програма. Третій тест також знаходить збіг початку рядка. Все, що знаходиться за 3 символом, не задовольняє регулярному виразу, в коді нижче - задовольняє і знайдуться кілька збігів: <img data-id="aac87994-bca7-414d-a7c1-aadf017c1281" data-max-width="650" alt="Основи регулярних виразів у Java.  Частина 3 - 10" src="https://cdn.javarush.com/images/article/aac87994-bca7-414d-a7c1-aadf017c1281/512.jpeg" style="width: 650px;">Для вказівки мінімальної довжини послідовності використовуйте: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">Enter</span></span> your regex<span class="token operator"><span class="token operator">:</span></span> a<span class="token punctuation"><span class="token punctuation">{</span></span><span class="token number"><span class="token number">3</span></span><span class="token punctuation"><span class="token punctuation">,</span></span><span class="token punctuation"><span class="token punctuation">}</span></span>
<span class="token class-name"><span class="token class-name">Enter</span></span> input string <span class="token keyword"><span class="token keyword">to</span></span> <span class="token namespace"><span class="token namespace">search</span></span><span class="token operator"><span class="token operator">:</span></span> aaaaaaaaa
<span class="token class-name"><span class="token class-name">I</span></span> found the text <span class="token string"><span class="token string">"aaaaaaaaa"</span></span> starting at index <span class="token number"><span class="token number">0</span></span> and ending at index <span class="token number"><span class="token number">9.</span></span></code></pre> У цьому прикладі програма знаходить лише один збіг, тому що рядок відповідає вимогам мінімальної довжини послідовності (3) символів «a». Нарешті завдання максимальної довжини послідовності: <img data-id="722ccf78-ee60-42b3-aae6-373aa310cc19" data-max-width="650" alt="Основи регулярних виразів у Java.  Частина 3 - 11" src="https://cdn.javarush.com/images/article/722ccf78-ee60-42b3-aae6-373aa310cc19/512.jpeg" style="width: 650px;">У цьому прикладі перший збіг закінчився на шостому символі. Друге збіг містить символи після шостого, т.к. вони задовольняють вимогу мінімальної довжини. Якби рядок був на один символ коротшим, другого збігу не було б. 
<h2>Використання груп символів та класів з квантифікаторами</h2>До цього моменту ми тестували квантифікатори на рядках, що містять один і той самий символ. Квантифікатори поширюють свою дію тільки на один символ, тому регулярне вираз «abc+» знаходитиме стоки, що містять «ab» і «c» один або більше разів. Воно не означатиме «abc» один чи більше разів. Але квантифікатори можуть застосовуватися разом з групами та класами символів, наприклад, [abc]+ (a або b або c, один або більше разів) або (abc)+ («abc» один або більше разів). Знайдемо групу символів (dog), тричі на рядку: <img data-id="0414bbda-dd55-4ac1-af29-9dcf53b20c05" data-max-width="650" alt="Основи регулярних виразів у Java.  Частина 3 - 12" src="https://cdn.javarush.com/images/article/0414bbda-dd55-4ac1-af29-9dcf53b20c05/512.jpeg" style="width: 650px;">У першому прикладі програма знаходить збіг, т.к. Квантифікатор поширюється на групу символів. Якщо прибрати дужки, квантифікатор {3} поширюватиметься лише на літеру «g». Також можна застосовувати квантифікатори з класами символів: <img data-id="8477b7f2-fdd5-4f23-9890-f2015a6ba011" data-max-width="650" alt="Основи регулярних виразів у Java.  Частина 3 - 13" src="https://cdn.javarush.com/images/article/8477b7f2-fdd5-4f23-9890-f2015a6ba011/512.jpeg" style="width: 650px;">Квантифікатор {3} поширює дію на клас символів у дужках у першому прикладі, тоді як у другому — лише символ «c». 
<h2>Відмінності жадібних, лінивих і над жадібних квантифікаторів</h2>Є невеликі відмінності між жадібними (greedy), лінивими (reluctant) та ревнивими (possessive) квантифікаторами. Жадібні квантифікатори названі так, тому що намагаються знайти максимально довгий збіг: спочатку програма намагається з'їсти весь рядок, якщо збіг не знайдено, то відкидається один символ і пошук повторюється, поки не буде знайдено збіг або не залишиться більше символів. Ліниві - навпаки, починають з початку рядка, додаючи символ за символом, поки не знайдуть збіг. Нарешті, ревнива квантифікація проглядає відразу весь рядок один раз, не прибираючи символи, як у жадібній. Для демонстрації використовуватимемо рядок xfooxxxxxxfoo. <img data-id="dab5f212-bec3-4246-bee7-d969dcb04894" data-max-width="740" alt="Основи регулярних виразів у Java.  Частина 3 - 14" src="https://cdn.javarush.com/images/article/dab5f212-bec3-4246-bee7-d969dcb04894/512.jpeg" style="width: 740px;">Перший приклад використовує жадібний квантифікатор .* для пошуку будь-якого символу, 0 або більше разів, за яким розташовані символи "f" "o" "o". Оскільки кантифікатор жадібний - знайдений збіг містить весь рядок. Жадібний квантифікатор не знайде всі збіги у рядку, т.к. на першому кроці, переглянувши весь рядок, знайде збіг і закінчить роботу. Другий приклад - лінивий і починає з початку рядка, додаючи символ за символом. Починається робота програми з перевірки «порожнечі», але т.к. послідовності «foo» немає на початку рядка, пошук продовжується з додаванням символу «x», після якого буде знайдено перший збіг між індексами 0 і 4. Пошук триває до кінця рядка і другий збіг буде знайдено між індексами 4 і 13. Третій приклад не знаходить збігів тому що квантифікатор ревнивий. У цьому випадку регулярне вираження .*+ «з'їло» весь рядок, не залишивши нічого для «foo». Використовуйте ревнивий квантифікатор, коли потрібно відкинути все не потрібне в рядку, він буде ефективнішим за еквівалентний жадібний квантифікатор. На цьому все! Посилання на першоджерело:<a href="http://easy-code.ru/lesson/java-quantifiers-regular-expressions" rel="nofollow" target="_blank">Основи регулярних виразів у Java. Частина 3</a>