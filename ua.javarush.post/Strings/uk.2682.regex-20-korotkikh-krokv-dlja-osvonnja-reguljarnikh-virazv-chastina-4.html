RegEx: 20 коротких кроків для освоєння регулярних виразів. Частина 4
<p>----------------------------------------</p>
Ця, заключна частина, у середині торкнеться таких речей, якими користуються переважно майстри регулярних висловів. Але ж вам легко давався матеріал із попередніх частин, адже правда? Значить і з цим матеріалом ви справитеся з тією ж легкіст
<p>----------------------------------------</p>
<a href="https://codegym.cc/groups/posts/2679-regex-20-korotkikh-shagov-dlja-osvoenija-reguljarnihkh-vihrazheniy-chastjh-1" target="_blank" rel="nofollow">RegEx: 20 коротких кроків для освоєння регулярних виразів. Частина 1 </a> <a href="https://codegym.cc/groups/posts/2680-regex-20-korotkikh-shagov-dlja-osvoenija-reguljarnihkh-vihrazheniy-chastjh-2" target="_blank" rel="nofollow">RegEx: 20 коротких кроків для освоєння регулярних виразів. Частина 2 </a> <a href="https://codegym.cc/groups/posts/2681-20-korotkikh-shagov-dlja-osvoenija-reguljarnihkh-vihrazheniy-chastjh-3" target="_blank" rel="nofollow">20 коротких кроків для освоєння регулярних виразів. Частина 3</a> Ця, заключна частина, у середині торкнеться таких речей, якими користуються переважно майстри регулярних висловів. Але ж вам легко давався матеріал із попередніх частин, адже правда? Значить і з цим матеріалом ви справитеся з тією ж легкістю! Оригінал <a href="https://dev.to/awwsmm/20-small-steps-to-become-a-regex-master-mpc" target="_blank" rel="nofollow">тут</a> <img data-id="6c71dc23-6186-47c8-8c79-e3f4cdd4c63f" alt="RegEx: 20 коротких кроків для освоєння регулярних виразів.  Частина 4 - 1" src="https://cdn.javarush.com/images/article/6c71dc23-6186-47c8-8c79-e3f4cdd4c63f/1080.jpeg"> &lt;h2&gt;Крок 16: групи без захоплення <code class=" language-none">(?:)</code>&lt;/h2&gt; <img data-id="b99d8e5c-d3b0-4bdc-b0ae-9f910d7476fb" alt="RegEx: 20 коротких кроків для освоєння регулярних виразів.  Частина 4 - 2" src="https://cdn.javarush.com/images/article/b99d8e5c-d3b0-4bdc-b0ae-9f910d7476fb/1080.jpeg">У двох прикладах на попередньому кроці ми захоплювали текст, який насправді нам не потрібний. У задачі "Розміри файлів" ми захопабо прогалини перед першою цифрою розмірів файлів, а в задачі "CSV" ми захопабо коми між кожним токеном. Нам не потрібно захоплювати ці символи, але нам потрібно використовувати їх для структурування нашого регулярного вираження. Це ідеальні варіанти використання групи без захоплення, <code class=" language-none">(?:)</code>. Група без захоплення робить саме те, на що це схоже за змістом - вона дозволяє групувати символи та використовувати їх у регулярних виразах, але не захоплює їх у пронумерованій групі: 
<pre>pattern: <span>(?:")([^"]+)(?:")</span> 
string: I тільки want <span>"the text inside these quotes"</span> .
matches: <span>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span> 
group:    <span>             1111111111111111111111111111</span>    
</pre> ( <a href="https://regex101.com/r/Mf9L3O/87" target="_blank" rel="nofollow">Приклад</a> ) Тепер регулярний вираз відповідає тексту в лапках, а також символам лапок, але група захоплення захопила тільки текст в лапках. Для чого нам так робити? Справа в тому, що більшість двигунів регулярних виразів дозволяють вам відновлювати текст із груп захоплення, визначених у ваших регулярних виразах. Якщо ми зможемо обрізати зайві символи, які нам не потрібні, не включивши їх у наші групи захоплення, це спростить аналіз і маніпулювання текстом пізніше. Ось як можна почистити парсер CSV з попереднього кроку: 
<pre>pattern: <span>(?:^|,)\s*(?:\"([^",]*)\"|([^", ]*)) string: a , "</span> 
b   <span>"</span> , <span>"</span> cd <span>"</span> , <span>e</span> , <span>f</span> , " <span>gh</span> ", <span>dfgi</span> ,, <span>k</span> , "", <span>l</span> 
matches: <span>^ ^ ^^^ ^ ^ ^^^ ^^^^ ^ ^</span> 
group:    <span>2 1 111 2 2 111 2222 2 2</span>    
</pre> ( <a href="https://regex101.com/r/Mf9L3O/115" target="_blank" rel="nofollow">Приклад</a> ) Тут є кілька речей, на які варто звернути увагу: По-перше, ми більше не захоплюємо коми, так як ми змінабо групу захоплення на групу <code class=" language-none">(^|,)</code>без захоплення <code class=" language-none">(?:^|,)</code>. По-друге, ми вклали групу захоплення у групу без захоплення. Це корисно, коли, наприклад, вам потрібно, щоб група символів відображалася в певному порядку, але ви дбаєте лише про підмножини цих символів. У нашому випадку нам потрібно, щоб символи <strong>не</strong> лапок і <strong>не</strong> коми <code class=" language-none">[^",]*</code>відображалися в лапках, але насправді нам не потрібні самі символи лапок, тому їх не потрібно було захоплювати. Нарешті, &lt;mark&gt;зверніть увагу&lt;/mark&gt;,<code class=" language-none">k</code><code class=" language-none">l</code>. Лапки <code class=" language-none">""</code>є підстрокою, але між лапками немає символів, тому відповідний підрядок не містить символів (має нульову довжину). &lt;h3&gt;Закріпимо знання? Ось дві з половиною завдання, які допоможуть нам у цьому:&lt;/h3&gt; Використовуючи групи без захоплення (і групи захоплення, і класи символів, і т.д.), напишіть регулярний вираз, який захоплює лише правильно відформатовані розміри файлів у рядку нижче : 
<pre>pattern:
string:   <span>6.6KB</span> 1..3KB <span>12KB</span> 5G <span>3.3MB</span> KB .6.2TB <span>9MB</span> .
matches: <span>^^^^^ ^^^^^ ^^^^^^ ^^^^</span> 
group:    <span>11111 1111 11111 111</span>    
</pre> ( <a href="https://regex101.com/r/Mf9L3O/89" target="_blank" rel="nofollow">Рішення</a> ) HTML-теги, що відкривають, починаються з символу <code class=" language-none">&lt;</code>і закінчуються символом <code class=" language-none">&gt;</code>. Теги HTML, що закривають, починаються з послідовності символів <code class=" language-none">&lt;/</code>і закінчуються символом <code class=" language-none">&gt;</code>. Ім'я тега міститься між цими символами. Чи можете ви написати регулярний вираз, щоб захопити лише імена у наступних тегах? (Можливо, вам вдасться вирішити цю проблему без використання груп без захоплення. Спробуйте вирішити це двома способами! Один раз за допомогою груп та один раз без них.) 
<pre>pattern:
string:   <span>&lt;p&gt; &lt;/span&gt; &lt;div&gt; &lt;/kbd&gt; &lt;link&gt;</span> 
matches: <span>^^^ ^^^^^^ ^^^^^ ^^^^^^ ^^^^^^</span> 
group:    <span>1 1111 111 111 1111</span>    
</pre> ( <a href="https://regex101.com/r/Mf9L3O/92" target="_blank" rel="nofollow">Рішення за допомогою груп без захоплення</a> ) ( <a href="https://regex101.com/r/Mf9L3O/91" target="_blank" rel="nofollow">Рішення без допомоги груп без захоплення</a> ) &lt;h2&gt;Крок 17: зворотні посилання <code class=" language-none">\N</code>та іменовані групи захоплення&lt;/h2&gt; <img data-id="757fac4d-bb47-4066-adef-0d8876ba46fd" alt="RegEx: 20 коротких кроків для освоєння регулярних виразів.  Частина 4 – 3" src="https://cdn.javarush.com/images/article/757fac4d-bb47-4066-adef-0d8876ba46fd/1080.jpeg">Хоча я і попереджав вас у вступі, що спроба створити HTML-парсер за допомогою регулярних виразів зазвичай призводить до душевних страждань, останній приклад - гарний перехід до іншої (іноді) корисної функції більшості регулярних виразів: зворотних посилань (backreferences). Зворотні посилання схожі на групи, що повторюються, в яких ви можете спробувати захопити один і той же текст двічі. Але вони відрізняються в одному важливому аспекті - вони будуть захоплювати лише один і той самий текст, символ за символом. У той час як група, що повторюється, дозволить нам захопити щось на кшталт цього: 
<pre>pattern: <span>(he(?:[az])+)</span> 
string:   <span>heyabcdefg hey heyo heyellow heyyyyyyyyy</span> 
matches: <span>^^^^^^^^^^^ ^^^ ^^^^ ^^^^^^^^^ ^^^ ^^^^^^^^</span> 
group:    <span>1111111111 111 1111 111111111 11111111111</span>    
</pre> ( <a href="https://regex101.com/r/Mf9L3O/93" target="_blank" rel="nofollow">Приклад</a> ) ... то зворотне посилання відповідатиме тільки цьому: 
<pre>pattern: <span>(he([az])(\2+))</span> 
string: heyabcdefg hey heyo heyellow <span>heyyyyyyyyy</span> 
matches: <span>                             ^^^^^^^^^^^</span> 
group:    <span>                             11233333333</span>    
</pre> ( <a href="https://regex101.com/r/Mf9L3O/116" target="_blank" rel="nofollow">Приклад</a> ) Групи захоплення, що повторюються, корисні, коли ви хочете повторно зіставити один і той же шаблон, тоді як зворотні посилання хороші, коли ви хочете зіставити один і той же текст. Наприклад, ми могли б використовувати зворотне посилання, щоб спробувати знайти відповідні HTML-теги: 
<pre>pattern: <span>&lt;(\w+)[^&gt;]*&gt;[^&lt;]+&lt;\/\1&gt;</span> 
string:   <span>&lt;span style="color: red"&gt;hey&lt;/span&gt;</span> 
matches: <span>^^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span> 
group:    <span>1111</span>    
</pre> ( <a href="https://regex101.com/r/Mf9L3O/95" target="_blank" rel="nofollow">Приклад</a> ) &lt;mark&gt;Зверніть увагу&lt;/mark&gt;, що це надзвичайно спрощений приклад, і я настійно рекомендую вам не намагатися писати аналізатор HTML на основі регулярних виразів. Це дуже складний синтаксис, і вам швидше за все стане погано. <strong>Іменовані групи захоплення</strong> дуже схожі на зворотні посилання, тому я коротко розповім про них тут. Єдина різниця між зворотними посиланнями та іменованою групою захоплення полягає в тому, що... іменована група захоплення має ім'я: 
<pre>pattern: <span>&lt;(?&lt;tag&gt;\w+)[^&gt;]*&gt;[^&lt;]+&lt;\/(?P=tag)&gt;&lt;/tag&gt; string: &lt;</span> 
span   <span>style="color: red"&gt;hey&lt; /span&gt;</span> 
matches: <span>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span> 
group:    <span>1111</span>    
</pre> ( <a href="https://regex101.com/r/Mf9L3O/103" target="_blank" rel="nofollow">Приклад</a> ) Ви можете створити іменовану групу захоплення за допомогою (?&lt;name&gt;...) або (?'name'...) синтаксису (.NET-сумісний регулярний вираз) або з таким синтаксисом (?P&lt;name&gt;). ..) або (?P'name'...) (Python-сумісний регулярний вираз). Оскільки ми використовуємо PCRE (Perl-сумісний регулярний вираз), що підтримує обидві версії, ми можемо використовувати будь-який з них тут. <em>(Java 7 скопіювала синтаксис</em> . name) (Python). Знову ж таки, PCRE підтримує всі ці різні варіанти. Ви можете прочитати більше про іменовані групи захоплення <a href="https://www.regular-expressions.info/named.html" target="_blank" rel="nofollow">тут</a>але це була велика частина того, що вам дійсно потрібно знати про них. &lt;h3&gt;Завдання нам на допомогу:&lt;/h3&gt; Використовуйте зворотні посилання, щоб допомогти мені згадати ... еммм ... ім'я цієї людини. 
<pre>pattern:
string: "Hi my <span>name's Joe." [later] "What's that guy's name? Joe</span> ?".
matches: <span>       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^</span> 
group:    <span>              111</span>    
</pre> ( <a href="https://regex101.com/r/Mf9L3O/96" target="_blank" rel="nofollow">Рішення</a> ) &lt;h2&gt;Крок 18: погляд вперед (lookahead) і погляд назад (lookbehind)&lt;/h2&gt; <img data-id="969316e1-3be0-4492-a61a-60da25f4309c" alt="RegEx: 20 коротких кроків для освоєння регулярних виразів.  Частина 4 - 4" src="https://cdn.javarush.com/images/article/969316e1-3be0-4492-a61a-60da25f4309c/1080.jpeg">Зараз ми заглибимося у деякі розширені функції регулярних виразів. Все, аж до кроку 16, я використовую досить часто. Але ці останні кілька кроків призначені тільки для людей, які дуже серйозно використовують regex для порівняння складних виразів. Іншими словами, майстри регулярних виразів. "Погляд уперед" і "погляд назад" можуть здатися досить складними, але насправді вони не надто складні. Вони дозволяють зробити щось схоже на те, що ми робабо з групами без захоплення раніше - перевіряти, чи існує якийсь текст безпосередньо перед або відразу після фактичного тексту, який ми хочемо зіставити. Наприклад, припустимо, що ми хочемо зіставляти лише назви речей, які люди люблять, але тільки якщо вони з ентузіазмом ставляться до цього (тільки якщо вони закінчують свою пропозицію знаком оклику). Ми могли б зробити щось на зразок: 
<pre>pattern: <span>(\w+)(?=!)</span> 
string: I like desk. I appreciate stapler. I love <span>lamp</span> !
matches: <span>                                          ^^^^</span> 
group:    <span>                                          1111</span>    
</pre> ( <a href="https://regex101.com/r/Mf9L3O/97" target="_blank" rel="nofollow">Приклад</a> ) Ви можете бачити, як зазначена вище група захоплення <code class=" language-none">(\w+)</code>, яка зазвичай відповідає будь-якому з слів у уривку, відповідає тільки слову lamp. Позитивний "погляд вперед" <code class=" language-none">(?=!)</code>означає, що ми можемо порівнювати лише ті послідовності, які закінчуються на<code class=" language-none">!</code>але, насправді, ми не зіставляємо сам символ знака оклику. Це важлива відмінність, тому що з групами без захоплення ми зіставляємо символ, але не захоплюємо його. За допомогою lookaheads та lookbehinds ми використовуємо символ для побудови нашого регулярного виразу, але потім ми навіть не зіставляємо його з ним самим. Ми можемо порівняти його пізніше у нашому регулярному вираженні. Усього існує чотири види lookaheads і lookbehinds: позитивний погляд вперед (?=...), негативний погляд вперед (?!...), позитивний погляд назад (?&lt;=...) і негативний погляд назад (?&lt;!.) ..). Вони роблять те, на що вони схожі - позитивні lookahead і lookbehind дозволяють обробнику регулярних виразів продовжувати зіставлення, тільки коли текст, що міститься в lookahead / lookbehind, дійсно збігається. Негативні lookahead і lookbehind роблять протилежне - вони дозволяють регулярному виразу збігатися лише тоді, коли текст, що міститься в lookahead/lookbehind, не збігається. Наприклад, хочемо зіставити імена методів лише у ланцюжку послідовностей методів, а чи не об'єкт, з якого вони працюють. І тут кожному імені методу має передувати символ<code class=" language-none">.</code>. Тут може допомогти регулярне вираження, що використовує простий погляд: 
<pre>pattern: <span>(?&lt;=\.)(\w+)</span> 
string: myArray. <span>flatMap.aggregate.summarise.print</span> !
matches: <span>        ^^^^^^^ ^^^^^^^^^^ ^^^^^^^^^ ^^^^^</span> 
group:    <span>        11111111 111111111 111111111 11111</span>    
</pre> ( <a href="https://regex101.com/r/Mf9L3O/98" target="_blank" rel="nofollow">Приклад</a> ) У наведеному вище тексті ми зіставляємо будь-яку послідовність символів слова <code class=" language-none">\w+</code>, але тільки в тому випадку, якщо їм передує символ <code class=" language-none">.</code>. Ми могли б досягти чогось подібного, використовуючи групи без захоплення, але результат вийде трохи брудніше: 
<pre>pattern: <span>(?:\.)(\w+)</span> 
string: myArray <span>.flatMap.aggregate.summarise.print</span> !
matches: <span>       ^^^^^^^^^ ^^^^^^^^^ ^^^^^^^^^ ^^^^^</span> 
group:    <span>        11111111 111111111 111111111 11111</span>    
</pre> ( <a href="https://regex101.com/r/Mf9L3O/99" target="_blank" rel="nofollow">Приклад</a> ) Незважаючи на те, що він коротший, він відповідає символам, які нам не потрібні. Хоча цей приклад може здатися тривіальним, lookaheads і lookbehinds дійсно можуть допомогти нам очистити наші регулярні вирази. &lt;h3&gt;Залишилося зовсім небагато до фінішу! Наступні 2 завдання наблизять нас до нього ще на 1 крок: Негативний lookbehind (?&lt;!...) дозволяє движку регулярних виразів продовжувати спроби знайти збіг, тільки якщо текст, що міститься всередині негативного lookbehind, не відображається до частини тексту, що залишилася. , з якою потрібно знайти відповідність. Наприклад, ми могли б використовувати регулярний вираз, щоб знайти відповідності лише прізвищам жінок, які відвідують конференцію. Для цього ми хотіли б переконатися, що прізвища людини не передує<code class=" language-none">Mr.</code>. Чи можете ви написати регулярний вираз для цього? (Можна припустити, що прізвища мають довжину не менше чотирьох символів.) 
<pre>pattern:
string: Mr. Brown, Ms. <span>Smith</span> , Mrs. <span>Jones</span> , Miss <span>Daisy</span> , Mr. Green
matches: <span>               ^^^^^ ^^^^^ ^^^^^</span> 
group:    <span>               11111 11111 11111</span>    
</pre> ( <a href="https://regex101.com/r/Mf9L3O/100" target="_blank" rel="nofollow">Рішення</a> ) Припустимо, що ми очищаємо базу даних і ми маємо стовпець інформації, який позначає відсотки. На жаль, деякі люди записали числа у вигляді десяткових значень у діапазоні [0,0, 1,0], у той час як інші написали відсотки в діапазоні [0,0%, 100,0%], а треті написали відсоткові значення, але забули літерал знак відсотка <code class=" language-none">%</code>. Використовуючи негативний погляд вперед (?!...), чи можете ви помітити ті значення, які мають бути відсотками, але у яких відсутні знаки <code class=" language-none">%</code>? Це повинні бути значення, що строго перевищують 1,00, але без кінцевого <code class=" language-none">%</code>. (Жодне число не може містити більше двох цифр до або після десяткової точки.) &lt;mark&gt;Зверніть увагу&lt;/mark&gt;, що це рішення <strong>надзвичайно складне</strong>. Якщо ви зможете вирішити цю проблему, не заглядаючи у мою відповідь, то у вас вже є величезні навички у регулярних виразах! 
<pre>pattern:
string: 0.32 <span>100.00 5.6</span> 0.27 98% 12.2% <span>1.01</span> 0.99% 0.99 <span>13.13 1.10</span> 
matches: <span>     ^^^^^^ ^^^ ^^^^ ^^^^^ ^^^^</span> 
group:    <span>     111111 111 1111 11111 1111</span>    
</pre> ( <a href="https://regex101.com/r/Mf9L3O/101" target="_blank" rel="nofollow">Рішення</a> ) &lt;h2&gt;Крок 19: умови в регулярних виразах&lt;/h2&gt; <img data-id="f54bd4aa-a349-4200-a92b-825cbf5cd35d" alt="RegEx: 20 коротких кроків для освоєння регулярних виразів.  Частина 4 – 5" src="https://cdn.javarush.com/images/article/f54bd4aa-a349-4200-a92b-825cbf5cd35d/1080.jpeg">Зараз перейшли до того етапу, коли більшість людей вже не використовуватимуть регулярні висловлювання. Ми розглянули, ймовірно, 95% сценаріїв використання простих регулярних виразів, і все, що робиться на кроках 19 і 20 зазвичай виконується більш повнофункціональною мовою маніпулювання текстом, таким як awk або sed (або мовою програмування загального призначення). Тим не менш, давайте продовжимо, просто щоб ви знали, на що дійсно здатне регулярне вираження. Хоча <a href="https://stackoverflow.com/questions/7983115/are-perl-regexes-turing-complete" target="_blank" rel="nofollow">регулярні вирази не є повними за Тьюрингом</a>, Деякі движки регулярних виразів пропонують функції, які дуже схожі на повну мову програмування. Одна з таких особливостей є "умовою". Умовні висловлювання Regex допускають оператори if-then-else, де обрана гілка визначається або "поглядом вперед", або "поглядом назад", про які ми дізналися на попередньому кроці. Наприклад, ви можете захотіти порівняти лише дійсні записи у списку дат: 
<pre>pattern: <span>(?&lt;=Feb )([1-2][0-9])|(?&lt;=Mar )([1-2][0-9]|3[0-1]) string: Dates</span> 
worked : Feb <span>28</span> , Feb <span>29</span> , Feb 30, Mar <span>30</span> , Mar <span>31</span>  
матчі: <span>                  ^^ ^^ ^^ ^^</span> 
group:    <span>                  11 11 22 22</span>    
</pre> ( <a href="https://regex101.com/r/Mf9L3O/104" target="_blank" rel="nofollow">Приклад</a> ) &lt;mark&gt;Зверніть увагу&lt;/mark&gt;, що зазначені вище групи також індексуються за місяцями. Ми могли б написати регулярний вираз для всіх 12 місяців і зафіксувати лише дійсні дати, які потім були б об'єднані у групи, що проіндексовані за місяцем року. Вище використовується свого роду структура, подібна до if, яка шукатиме збіги в першій групі, тільки якщо "Feb" передує числу (і аналогічно для другої). Але що, якби ми хотіли використовувати спеціальну обробку лише для лютого? Щось на кшталт "якщо передує "Feb", зробіть це, інакше зробіть цю іншу річ". Ось як це роблять умовні вирази: 
<pre>pattern: <span>(?(?&lt;=Feb )([1-2][0-9])|([1-2][0-9]|3[0-1]))</span> 
string: Dates worked: Feb <span>28</span> , Feb <span>29</span> , Feb 30, Mar <span>30</span> , Mar <span>31</span>  
матчі: <span>                  ^^ ^^ ^^ ^^</span> 
group:    <span>                  11 11 22 22</span>    
</pre> ( <a href="https://regex101.com/r/Mf9L3O/105" target="_blank" rel="nofollow">Приклад</a> ) Структура if-then-else виглядає як (?(If)then|else), де (if) замінюється "поглядом вперед" або "поглядом назад". У наведеному прикладі (if) записаний як <code class=" language-none">(?&lt;=Feb)</code>. Ви можете бачити, що ми зіставляли дати більше 29, але тільки якщо вони не йшли за "Feb". Використання ж lookbehinds ("поглядів назад") в умовних виразах корисно, якщо ви хочете переконатися, що збіг передує будь-який текст. Позитивні lookahead умовні вирази можуть збивати з пантелику, тому що сама умова не відповідає жодному тексту. Тому, якщо ви хочете, щоб умова if коли-небудь мало значення, вона повинна бути порівнянна з lookahead, як показано нижче: 
<pre>pattern: <span>(?(?=exact)exact|else)wo</span> 
string: exact else <span>exactwo elsewo</span>  
matches: <span>           ^^^^^^^ ^^^^^^</span>
</pre> ( <a href="https://regex101.com/r/Mf9L3O/106" target="_blank" rel="nofollow">Приклад</a> ) Це означає, що позитивні lookahead умовні вислови марні. Ви перевіряєте, чи знаходиться цей текст попереду, а потім надаєте шаблон відповідності, щоб слідувати йому, коли він є. Умовне вираження не допомагає нам тут взагалі. Ви також можете просто замінити вищенаведене на більш простий регулярний вираз: 
<pre>pattern: <span>(?:exact|else)wo</span> 
string: exact else <span>exactwo elsewo</span>  
matches: <span>           ^^^^^^^ ^^^^^^</span>
</pre> ( <a href="https://regex101.com/r/Mf9L3O/107" target="_blank" rel="nofollow">Приклад</a> ) Отже, емпіричне правило для висловлювань з умовами: тест, тест, і ще раз тест. Інакше рішення, які ви вважаєте очевидними, зазнають невдачі найбільш захоплюючими та несподіваними способами :) &lt;h3&gt;Ось ми і підійшли до останнього блоку завдань, який відокремлює нас від завершального, 20-го кроку:&lt;/h3&gt; Напишіть регулярний вираз, який використовує негативний lookahead умовний вираз, щоб перевірити, чи починається наступне слово з великої літери. Якщо це так, захопіть лише одну заголовну літеру, а потім малі літери. Якщо це не так, то захопіть будь-які символи слова. 
<pre>pattern:
string:   <span>Jones Smith 9sfjn Hobbes 23r4tgr9h</span> CSV <span>Csv vVv</span> 
matches: <span>^^^^^ ^^^^^ ^^^^^ ^^^^^^^^^^^^^^^^ ^^^ ^^^</span> 
group:    <span>22222 22222 11111 222222 111111111 222 111</span>    
</pre> ( <a href="https://regex101.com/r/Mf9L3O/108" target="_blank" rel="nofollow">Рішення</a> ) Напишіть негативний lookbehind умовний вираз, який захоплює текст <code class=" language-none">owns</code>, тільки якщо йому не передує текст <code class=" language-none">cl</code>, і яке захоплює текст <code class=" language-none">ouds</code>, тільки коли йому передує текст <code class=" language-none">cl</code>. (Трохи надуманий приклад, але що поробиш...) 
<pre>pattern:
string: Those clowns <span>owns</span> some cl <span>ouds</span> . ouds.
matches: <span>             ^^^^ ^^^^</span>   
</pre> ( <a href="https://regex101.com/r/Mf9L3O/109" target="_blank" rel="nofollow">Рішення</a> ) &lt;h2&gt;Крок 20: рекурсія та подальше навчання&lt;/h2&gt; <img data-id="b2b3dc7c-5072-4cbe-9c6f-e24a1b39e207" alt="RegEx: 20 коротких кроків для освоєння регулярних виразів.  Частина 4 – 6" src="https://cdn.javarush.com/images/article/b2b3dc7c-5072-4cbe-9c6f-e24a1b39e207/1080.jpeg">Насправді, є дуже багато всього, що можна втиснути в 20-крокове введення в будь-яку тему, і регулярні висловлювання не є винятком. Існує безліч різних <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D1%8B%D0%B5_%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F#%D0%A0%D0%B0%D0%B7%D0%BD%D0%BE%D0%B2%D0%B8%D0%B4%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D1%80%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D1%8B%D1%85_%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9" target="_blank" rel="nofollow">реалізацій та стандартів для регулярних виразів</a> , які можна знайти в Інтернеті. Якщо ви хочете дізнатися більше, я пропоную вам відвідати чудовий сайт <a href="https://www.regular-expressions.info/" target="_blank" rel="nofollow">regularexpressions.info</a> , це фантастичний довідник, і я, звичайно, багато дізнався від туди про регулярні висловлювання. Я настійно рекомендую його, а також <a href="https://regex101.com/" target="_blank" rel="nofollow">regex101.com</a>для тестування та публікації ваших творінь. На цьому завершальному кроці я дам вам ще трохи знання про регулярні вирази, а саме: як писати рекурсивні вирази. Прості рекурсії досить прості, але подумаємо, що це означає в контексті регулярного вираження. <a href="https://www.regular-expressions.info/" target="_blank" rel="nofollow">Синтаксис простий рекурсії</a> у регулярному вираженні записується так: <code class=" language-none">(?R)?</code>. Але, звичайно, цей синтаксис має з'являтися усередині самого виразу. Те, що ми зробимо, це вкладемо вираз у себе, довільну кількість разів. Наприклад: 
<pre>pattern: <span>(hey(?R)?oh)</span> 
string:   <span>heyoh</span> heyyoh <span>heyheyohoh</span> hey oh heyhey <span>heyheyyohoh</span>  
matches: <span>^^^^^ ^^^^^^^^^^ ^^^^^^^^^^^</span> 
group:    <span>11111 11111111111 11111111111</span>    
</pre> ( <a href="https://regex101.com/r/Mf9L3O/110" target="_blank" rel="nofollow">Приклад</a> ) Оскільки вкладене вираз є необов'язковим ( <code class=" language-none">(?R)</code>супроводжується <code class=" language-none">?</code>), то найпростіший збіг - просто повністю ігнорувати рекурсію. Отже, <code class=" language-none">hey</code>, а потім <code class=" language-none">oh</code>збігається ( <code class=" language-none">heyoh</code>). Щоб порівняти будь-який складніший вираз, ніж це, ми повинні знайти цю збігаючу підрядок, вкладену всередину себе в тій точці виразу, в яку ми вставабо <code class=" language-none">(?R)</code>послідовність. Іншими словами, ми могли б знайти heyheyohoh або heyheyheyohohoh, і так далі. Одна з чудових особливостей цих вкладених виразів полягає в тому, що, на відміну від зворотних посилань та іменованих груп захоплення, вони не обмежують вас відповідно до точного тексту, який ви зіставляли раніше, символ за символом. Наприклад: 
<pre>pattern: <span>([Hh][Ee][Yy](?R)?oh)</span> 
string:   <span>heyoh</span> heyyoh <span>hEyHeYohoh</span> hey oh heyhey <span>hEyHeYHEyohohoh</span>  
matches: <span>^^^^^ ^^^^^^^^^^^^^^ ^^^^^^^^^^</span> 
group:    <span>11111 1111111111 111111111111111</span>    
</pre> ( <a href="https://regex101.com/r/Mf9L3O/111" target="_blank" rel="nofollow">Приклад</a> ) Ви можете собі уявити, що механізм регулярних виразів буквально копіює і вставляє ваш регулярний вираз довільну кількість разів. Звичайно, це означає, що іноді воно може робити не те, на що ви могли сподіватися: 
<pre>pattern: <span>((?:\(\*)[^*)]*(?R)?(?:\*\)))</span> 
string: (* comment <span>(* nested *)</span> not *)
matches: <span>           ^^^^^^^^^^^^^</span> 
group:    <span>           111111111111</span>    
</pre> ( <a href="https://regex101.com/r/Mf9L3O/113" target="_blank" rel="nofollow">Приклад</a> ) Чи можете ви сказати, чому цей регулярний вираз захопив лише вкладений коментар, а не зовнішній коментар? Одне можна сказати, напевно: при написанні складних регулярних виразів завжди перевіряйте їх, щоб переконатися, що вони працюють так, як ви думаєте. Ось і добігло кінця це швидкісне ралі по дорогах регулярних виразів. Сподіваюся, вам сподобалася ця подорож. Ну, і насамкінець, я залишу тут, як і обіцяв на початку, кілька корисних посилань для більш поглибленого вивчення матеріалу: 
<ul>
 <li><a href="https://codegym.cc/groups/posts/regulyarnye-vyrazheniya-v-java" target="_blank" rel="nofollow">Регулярні вирази в Java</a> (Стаття від користувача Alex)</li>
 <li><a href="https://codegym.cc/groups/posts/136-reguljarnihe-vihrazhenija-v-java-chastjh-1" target="_blank" rel="nofollow">Регулярні вирази в Java</a> (Переклад статті Джеффа Фрісена від Еллеонори Керрі)</li>
 <li><a href="https://hr-vector.com/java/regulyarnye-vyrazheniya-primery" target="_blank" rel="nofollow">Регулярні вирази java приклади</a> (зі зручною таблицею за синтакісом)</li>
 <li><a href="https://learn.javascript.ru/regexp-greedy-and-lazy" target="_blank" rel="nofollow">Жадібні та ліниві квантифікатори</a> (приклади на JavaScript)</li>
 <li><a href="https://proglib.io/p/25-java-regex/" target="_blank" rel="nofollow">25 найпоширеніших регулярних виразів у Java</a></li>
 <li><a href="https://regexone.com/" target="_blank" rel="nofollow">RegexOne</a> (Завдання з перевіряльником)</li>
 <li><a href="https://www.youtube.com/watch?v=_pLpx6btq6U" target="_blank" rel="nofollow">Не бійтеся регулярних виразів. Regex за 20 хвабон! </a>(Для тих, кому більше подобаються відеоуроки)</li>
</ul>