Регулярні вирази в Java, частина 2
<p>----------------------------------------</p>
Пропонуємо до вашої уваги переклад короткого посібника з регулярних виразів у мові Java, написаного Джеффом Фрісеном (Jeff Friesen) для сайту . Для простоти читання ми розділили статтю кілька частин. Можна зливати кілька діапазонів в один д
<p>----------------------------------------</p>
Пропонуємо до вашої уваги переклад короткого посібника з регулярних виразів у мові Java, написаного Джеффом Фрісеном (Jeff Friesen) для сайту <a href="https://www.javaworld.com/article/3188545/learn-java/java-101-regular-expressions-in-java-part-1.html" target="_blank">javaworld</a> . Для простоти читання ми розділабо статтю кілька частин. <img data-max-width="800" data-id="25466d03-ef3d-422f-bc4c-ef1f4b6d97fe" class="img-fluid" alt="Регулярні вирази у Java, частина 2 - 1" src="https://cdn.javarush.com/images/article/25466d03-ef3d-422f-bc4c-ef1f4b6d97fe/800.jpeg" style="width: 800px;"><a href="https://codegym.cc/groups/posts/136-reguljarnihe-vihrazhenija-v-java-chastjh-1" target="_blank">Регулярні вирази в Java, частина 1</a>
<div class="table-container">
 <table>
  <thead>
   <tr>
    <th>Злиття кількох діапазонів</th>
   </tr>
  </thead>
  <tbody>
   <tr>
    <td>Можна зливати кілька діапазонів в один діапазонний клас символів, розміщуючи їх пліч-о-пліч. Наприклад, клас <code class=" language-none">[a-zA-Z]</code>відповідає всім латинським алфавітним символам у нижньому або верхньому регістрі.</td>
   </tr>
  </tbody>
 </table>
</div>
<h2>Злиття кількох діапазонів</h2>Можна зливати кілька діапазонів в один діапазонний клас символів шляхом розміщення їх пліч-о-пліч. Наприклад, клас <code class=" language-none">[a-zA-Z]</code>відповідає всім латинським алфавітним символам у нижньому або верхньому регістрі. 
<h3>Об'єднання класів символів</h3>Об'єднання класів символів складається з кількох вкладених класів символів і відповідає всім символам, що входять у результуюче об'єднання. Наприклад, клас <code class=" language-none">[a-d[m-p]]</code>відповідає символам від <code class=" language-none">a</code>до <code class=" language-none">d</code>та від <code class=" language-none">m</code>до <code class=" language-none">p</code>. Розглянемо наступний приклад: <code class=" language-none">java RegexDemo [ab[c-e]] abcdef</code> У цьому прикладі будуть знайдені символи <code class=" language-none">a</code>, <code class=" language-none">b</code>, <code class=" language-none">c</code>, <code class=" language-none">d</code>і <code class=" language-none">e</code>для яких є відповідності в <code class=" language-none">abcdef</code>: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java">regex <span class="token operator"><span class="token operator">=</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span>ab<span class="token punctuation"><span class="token punctuation">[</span></span>c<span class="token operator"><span class="token operator">-</span></span>e<span class="token punctuation"><span class="token punctuation">]</span></span><span class="token punctuation"><span class="token punctuation">]</span></span>
input <span class="token operator"><span class="token operator">=</span></span> abcdef
<span class="token class-name"><span class="token class-name">Found</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span>a<span class="token punctuation"><span class="token punctuation">]</span></span> starting at <span class="token number"><span class="token number">0</span></span> and ending at <span class="token number"><span class="token number">0</span></span>
<span class="token class-name"><span class="token class-name">Found</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span>b<span class="token punctuation"><span class="token punctuation">]</span></span> starting at <span class="token number"><span class="token number">1</span></span> and ending at <span class="token number"><span class="token number">1</span></span>
<span class="token class-name"><span class="token class-name">Found</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span>c<span class="token punctuation"><span class="token punctuation">]</span></span> starting at <span class="token number"><span class="token number">2</span></span> and ending at <span class="token number"><span class="token number">2</span></span>
<span class="token class-name"><span class="token class-name">Found</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span>d<span class="token punctuation"><span class="token punctuation">]</span></span> starting at <span class="token number"><span class="token number">3</span></span> and ending at <span class="token number"><span class="token number">3</span></span>
<span class="token class-name"><span class="token class-name">Found</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span>e<span class="token punctuation"><span class="token punctuation">]</span></span> starting at <span class="token number"><span class="token number">4</span></span> and ending at <span class="token number"><span class="token number">4</span></span></code></pre>
<h3>Перетин класів символів</h3>Перетин класів символів складається з символів, загальних всім вкладених класів і відповідає лише загальним символам. Наприклад, клас <code class=" language-none">[a-z&amp;&amp;[d-f]]</code>відповідає символам <code class=" language-none">d</code>, <code class=" language-none">e</code>та <code class=" language-none">f</code>. Розглянемо наступний приклад: <code class=" language-none">java RegexDemo "[aeiouy&amp;&amp;[y]]" party</code> Зверніть увагу, що на моїй операційній системі Windows потрібні подвійні лапки, оскільки командна оболонка розглядає <code class=" language-none">&amp;</code>як роздільник команд. У цьому прикладі буде знайдено лише символ <code class=" language-none">y</code>, для якого є відповідність до <code class=" language-none">party</code>: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class="  language-java">regex <span class="token operator"><span class="token operator">=</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span>aeiouy<span class="token operator"><span class="token operator">&amp;&amp;</span></span><span class="token punctuation"><span class="token punctuation">[</span></span>y<span class="token punctuation"><span class="token punctuation">]</span></span><span class="token punctuation"><span class="token punctuation">]</span></span>
input <span class="token operator"><span class="token operator">=</span></span> party
<span class="token class-name"><span class="token class-name">Found</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span>y<span class="token punctuation"><span class="token punctuation">]</span></span> starting at <span class="token number"><span class="token number">4</span></span> and ending at <span class="token number"><span class="token number">4</span></span></code></pre>
<h3>Віднімання класів символів</h3>Віднімання класів символів складається з усіх символів, крім тих, які містяться у вкладених класах символів, і відповідає лише цим символам. Наприклад, клас <code class=" language-none">[a-z&amp;&amp;[^m-p]]</code>відповідає символам від <code class=" language-none">a</code>до <code class=" language-none">l</code>і від <code class=" language-none">q</code>до <code class=" language-none">z</code>: <code class=" language-none">java RegexDemo "[a-f&amp;&amp;[^a-c]&amp;&amp;[^e]]" abcdefg</code> У цьому прикладі буде знайдено символи <code class=" language-none">d</code>і <code class=" language-none">f</code>для яких є відповідності в <code class=" language-none">abcdefg</code>: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span><code class="  language-java">regex <span class="token operator"><span class="token operator">=</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span>a<span class="token operator"><span class="token operator">-</span></span>f<span class="token operator"><span class="token operator">&amp;&amp;</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token operator"><span class="token operator">^</span></span>a<span class="token operator"><span class="token operator">-</span></span>c<span class="token punctuation"><span class="token punctuation">]</span></span><span class="token operator"><span class="token operator">&amp;&amp;</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token operator"><span class="token operator">^</span></span>e<span class="token punctuation"><span class="token punctuation">]</span></span><span class="token punctuation"><span class="token punctuation">]</span></span>
input <span class="token operator"><span class="token operator">=</span></span> abcdefg
<span class="token class-name"><span class="token class-name">Found</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span>d<span class="token punctuation"><span class="token punctuation">]</span></span> starting at <span class="token number"><span class="token number">3</span></span> and ending at <span class="token number"><span class="token number">3</span></span>
<span class="token class-name"><span class="token class-name">Found</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span>f<span class="token punctuation"><span class="token punctuation">]</span></span> starting at <span class="token number"><span class="token number">5</span></span> and ending at <span class="token number"><span class="token number">5</span></span></code></pre>
<h3>Зумовлені класи символів</h3>Деякі класи символів зустрічаються у <a href="https://codegym.cc/groups/posts/2013-reguljarnihe-vihrazhenija-v-java" target="_blank">регулярних виразах</a> досить часто, щоб виправдати використання скорочених позначень. Клас <code class=" language-none">Pattern</code>пропонує як подібні скорочення визначені класи символів. Ви можете скористатися ними, щоб спростити свої регулярні вирази та мінімізувати синтаксичні помилки. Є кілька категорій визначених класів символів: стандартні, POSIX, <code class=" language-none">java.lang.Character</code>та такі властивості Unicode, як сценарій, блок, категорія та двійкова властивість. У наступному списку наведено лише категорію стандартних класів: 
<ul>
 <li><code class=" language-none">\d</code>: Цифра. Еквівалентно <code class=" language-none">[0-9]</code>.</li>
 <li><code class=" language-none">\D</code>: Нецифровий символ Еквівалентно <code class=" language-none">[^0-9]</code>.</li>
 <li><code class=" language-none">\s</code>: символ пробілу. Еквівалентно <code class=" language-none">[ \t\n\x0B\f\r]</code>.</li>
 <li><code class=" language-none">\S</code>: Не символ пробілу. Еквівалентно <code class=" language-none">[^\s]</code>.</li>
 <li><code class=" language-none">\w</code>: Словотворчий символ Еквівалентно <code class=" language-none">[a-zA-Z_0-9]</code>.</li>
 <li><code class=" language-none">\W</code>: Не словотворний символ Еквівалентно <code class=" language-none">[^\w]</code>.</li>
</ul>У наступному прикладі використовується визначений клас символів <code class=" language-none">\w</code>для опису всіх словотворчих символів у вхідному тексті: <code class=" language-none">java RegexDemo \w "aZ.8 _"</code> Уважно подивіться на наступні результати виконання, які показують, що символи точки і пробілу не вважаються словотворчим: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java">regex <span class="token operator"><span class="token operator">=</span></span> \w
input <span class="token operator"><span class="token operator">=</span></span> aZ<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token number"><span class="token number">8</span></span> _
<span class="token class-name"><span class="token class-name">Found</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span>a<span class="token punctuation"><span class="token punctuation">]</span></span> starting at <span class="token number"><span class="token number">0</span></span> and ending at <span class="token number"><span class="token number">0</span></span>
<span class="token class-name"><span class="token class-name">Found</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span><span class="token class-name"><span class="token class-name">Z</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> starting at <span class="token number"><span class="token number">1</span></span> and ending at <span class="token number"><span class="token number">1</span></span>
<span class="token class-name"><span class="token class-name">Found</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span><span class="token number"><span class="token number">8</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> starting at <span class="token number"><span class="token number">3</span></span> and ending at <span class="token number"><span class="token number">3</span></span>
<span class="token class-name"><span class="token class-name">Found</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span>_<span class="token punctuation"><span class="token punctuation">]</span></span> starting at <span class="token number"><span class="token number">5</span></span> and ending at <span class="token number"><span class="token number">5</span></span></code></pre>
<div class="table-container">
 <table>
  <thead>
   <tr>
    <th>Розділювачі рядків</th>
   </tr>
  </thead>
  <tbody>
   <tr>
    <td>Документація по SDK класу <code class=" language-none">Pattern</code>описує метасимвол точки як зумовлений клас символів, що відповідає будь-якому символу, крім роздільників рядків (одно-або двосимвольні послідовності, що відзначають кінець рядка). Виняток становить режим dotall (який ми обговоримо далі), у якому точка відповідають роздільникам рядків. Клас <code class=" language-none">Pattern</code>розрізняє наступні роздільники рядків: 
     <ul>
      <li>символ повернення каретки ( <code class=" language-none">\r</code>);</li>
      <li>символ нового рядка (символ протягування паперу на один рядок) ( <code class=" language-none">\n</code>);</li>
      <li>символ повернення каретки, за яким безпосередньо слідує символ нового рядка ( <code class=" language-none">\r\n</code>);</li>
      <li>символ наступного рядка ( <code class=" language-none">\u0085</code>);</li>
      <li>символ поділу рядків ( <code class=" language-none">\u2028</code>);</li>
      <li>символ розділення абзаців ( <code class=" language-none">\u2029</code>)</li>
     </ul></td>
   </tr>
  </tbody>
 </table>
</div>
<h3>Захоплювані групи</h3>Захоплювана група (capturing group) служить збереження знайденого набору символів з подальшого використання під час пошуку за шаблоном. Ця конструкція є послідовністю символів, укладеною в метасимволи круглих дужок ( <code class=" language-none">( )</code>). Всі символи всередині групи, що захоплюється, розглядаються при пошуку за шаблоном як єдине ціле. Наприклад, захоплююча група ( <code class=" language-none">Java</code>) поєднує літери <code class=" language-none">J</code>, <code class=" language-none">a</code>, <code class=" language-none">v</code>і <code class=" language-none">a</code>єдине ціле. Ця захоплива група знаходить усі входження шаблону <code class=" language-none">Java</code>у вхідний текст. При кожному збігу попередні збережені символи <code class=" language-none">Java</code>замінюються на наступні. Захоплювані групи можуть бути вкладені в інші групи, що захоплюються. Наприклад, у регулярному вираженні <code class=" language-none">(Java( language))</code>група <code class=" language-none">(language)</code>вкладена всередину групи<code class=" language-none">(Java)</code>. Кожній вкладеній або не вкладеній групі, що захоплюється, присвоюється свій номер, починаючи з 1, причому нумерація йде зліва направо. У попередньому прикладі <code class=" language-none">(Java( language))</code>відповідає групі номер 1, а <code class=" language-none">(language)</code>– групі номер 2. У регулярному виразі відповідає групі номер 1, а групі номер 2 <code class=" language-none">(a)(b)</code>.<code class=" language-none">(a)</code><code class=" language-none">(b)</code><img data-max-width="800" data-id="3cc6fb1e-090e-416e-a342-6af3c8e7986a" class="img-fluid" alt="Регулярні вирази в Java, частина 2 - 2" src="https://cdn.javarush.com/images/article/3cc6fb1e-090e-416e-a342-6af3c8e7986a/800.jpeg" style="width: 800px;">До збережених захоплюваних груп збігів можна пізніше звернутися за допомогою зворотних посилань. Зворотне посилання, що задається у вигляді символу зворотної косої риси з наступним цифровим символом, що відповідає номеру захоплюючої групи, зворотне посилання дозволяє звернутися до символів захопленого групою тексту. Наявність зворотного посилання призводить до звернення зіставника до збереженого захоплюваною групою результату пошуку, на основі номера з неї, з подальшим використанням символів цього результату для спроби подальшого пошуку. У цьому прикладі показано використання зворотного посилання для пошуку граматичних помилок у тексті: <code class=" language-none">java RegexDemo "(Java( language)\2)" "The Java language language"</code> У цьому прикладі регулярне вираження <code class=" language-none">(Java( language)\2)</code>використовується для пошуку граматичної помилки з дублюванням слова <code class=" language-none">language</code>безпосередньо після <code class=" language-none">Java</code>у вхідному тексті<code class=" language-none">"The Java language language"</code>. У цьому регулярному виразі задані дві захоплюючі групи: номер 1 – <code class=" language-none">(Java( language)\2)</code>, відповідної <code class=" language-none">Java language language</code>та номер 2 – <code class=" language-none">(language)</code>, що відповідає символу пропуску, за яким слідує <code class=" language-none">language</code>. Зворотне посилання <code class=" language-none">\2</code>дозволяє повторно звернутися до збереженого результату групи номер 2, завдяки чому співставник може виконати пошук другого входження пробілу, за яким слідує <code class=" language-none">language</code>, безпосередньо після першого входження пробілу та <code class=" language-none">language</code>. Результати роботи співставника <code class=" language-none">RegexDemo</code>є таким: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class="  language-java">regex <span class="token operator"><span class="token operator">=</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">Java</span></span><span class="token punctuation"><span class="token punctuation">(</span></span> language<span class="token punctuation"><span class="token punctuation">)</span></span>\<span class="token number"><span class="token number">2</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
input <span class="token operator"><span class="token operator">=</span></span> <span class="token class-name"><span class="token class-name">The</span></span> <span class="token class-name"><span class="token class-name">Java</span></span> language language
<span class="token class-name"><span class="token class-name">Found</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span><span class="token class-name"><span class="token class-name">Java</span></span> language language<span class="token punctuation"><span class="token punctuation">]</span></span> starting at <span class="token number"><span class="token number">4</span></span> and ending at <span class="token number"><span class="token number">25</span></span></code></pre>
<h3>Граничні зіставники</h3>Іноді буває потрібно виконати зіставлення з шаблоном на початку рядка, межі слів, наприкінці тексту тощо. Зробити це можна за допомогою одного з граничних зіставників класу <code class=" language-none">Pattern</code>, що являють собою конструкції регулярних виразів для пошуку збігів у наступних місцях: 
<ul>
 <li><code class=" language-none">^</code>: Початок рядка;</li>
 <li><code class=" language-none">$</code>: Кінець рядка;</li>
 <li><code class=" language-none">\b</code>: Кордон слова;</li>
 <li><code class=" language-none">\B</code>: Кордон псевдослова;</li>
 <li><code class=" language-none">\A</code>: Початок тексту;</li>
 <li><code class=" language-none">\G</code>: Кінець попереднього збігу;</li>
 <li><code class=" language-none">\Z</code>: Кінець тексту, крім підсумкового роздільника рядків (якщо є);</li>
 <li><code class=" language-none">\z</code>: Кінець тексту</li>
</ul>У наступному прикладі використовується метасимвол <code class=" language-none">^</code>граничного співставника для пошуку рядків, що починаються з <code class=" language-none">The</code>, за яким слідує нуль або більше словотворних символів: <code class=" language-none">java RegexDemo "^The\w*" Therefore</code> Символ <code class=" language-none">^</code>вказує на те, що перші три символи вхідного тексту повинні відповідати символам шаблону , що йдуть один за одним <code class=" language-none">T</code>, <code class=" language-none">h</code>і <code class=" language-none">e</code>, за якими може слідувати будь-яке число словотворних символів. Ось результат виконання: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class="  language-java">regex <span class="token operator"><span class="token operator">=</span></span> <span class="token operator"><span class="token operator">^</span></span><span class="token class-name"><span class="token class-name">The</span></span>\w<span class="token operator"><span class="token operator">*</span></span>
input <span class="token operator"><span class="token operator">=</span></span> <span class="token class-name"><span class="token class-name">Therefore</span></span>
<span class="token class-name"><span class="token class-name">Found</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span><span class="token class-name"><span class="token class-name">Therefore</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> starting at <span class="token number"><span class="token number">0</span></span> and ending at <span class="token number"><span class="token number">8</span></span></code></pre> Що станеться, якщо змінити командний рядок на <code class=" language-none">java RegexDemo "^The\w*" " Therefore"</code>? Збігу знайдено не буде, оскільки перед <code class=" language-none">Therefore</code>у вхідному тексті стоїть символ пропуску. 
<h3>Збіги нульової довжини</h3>Іноді при роботі з граничними співставниками ви зустрічатиметеся з збігами нульової довжини. <code class=" language-none">Совпадение нулевой длины</code>- Це збіг, що не містить символів. Вони можуть зустрітися в порожньому вхідному тексті, на початку вхідного тексту, після останнього символу вхідного тексту та між будь-якими двома символами цього тексту. Збіги нульової довжини легко розпізнати, оскільки вони завжди починаються і закінчуються на одній позиції. Розглянемо наступний приклад: <code class=" language-none">java RegExDemo \b\b "Java is"</code> У цьому прикладі відбувається пошук двох послідовних меж слова, його результати виглядають так: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java">regex <span class="token operator"><span class="token operator">=</span></span> \b\b
input <span class="token operator"><span class="token operator">=</span></span> <span class="token class-name"><span class="token class-name">Java</span></span> is
<span class="token class-name"><span class="token class-name">Found</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> starting at <span class="token number"><span class="token number">0</span></span> and ending at <span class="token operator"><span class="token operator">-</span></span><span class="token number"><span class="token number">1</span></span>
<span class="token class-name"><span class="token class-name">Found</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> starting at <span class="token number"><span class="token number">4</span></span> and ending at <span class="token number"><span class="token number">3</span></span>
<span class="token class-name"><span class="token class-name">Found</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> starting at <span class="token number"><span class="token number">5</span></span> and ending at <span class="token number"><span class="token number">4</span></span>
<span class="token class-name"><span class="token class-name">Found</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> starting at <span class="token number"><span class="token number">7</span></span> and ending at <span class="token number"><span class="token number">6</span></span></code></pre> Ми бачимо у результатах кілька збігів нульової довжини. Кінцеві позиції тут на одиницю менші за початкові, оскільки у вихідному коді <code class=" language-none">RegexDemo</code>в лістингу 1 я вказав <code class=" language-none">end() – 1</code>. <img data-max-width="800" data-id="52109426-a6d4-42f2-8c31-05805a5d6b9a" class="img-fluid" alt="Регулярні вирази у Java, частина 2 - 3" src="https://cdn.javarush.com/images/article/52109426-a6d4-42f2-8c31-05805a5d6b9a/800.jpeg" style="width: 800px;">
<h3>Квантифікатори</h3>Квантифікатор - це конструкція регулярного виразу, що явно або неявно пов'язує шаблон з числовим значенням. Це числове значення визначає, скільки разів шукати шаблон. Квантифікатори поділяються на жадібні, ліниві та над жадібні: 
<ul>
 <li>Жадібний квантифікатор ( <code class=" language-none">?</code>, <code class=" language-none">*</code>або <code class=" language-none">+</code>) призначений для пошуку найдовшого збігу. Можна задати <code class=" language-none">X</code>? для пошуку одного або менших входжень <code class=" language-none">X</code>, <code class=" language-none">X*</code>для пошуку нуля або більше входжень <code class=" language-none">X</code>, <code class=" language-none">X+</code>для пошуку одного або більше входжень <code class=" language-none">X</code>, <code class=" language-none">X{n}</code>для пошуку <code class=" language-none">n</code>входжень <code class=" language-none">X</code>, <code class=" language-none">X{n,}</code>для пошуку не менше (а можливо, і більше) <code class=" language-none">n</code>входжень <code class=" language-none">X</code>і <code class=" language-none">X{n,m}</code>для пошуку не менше <code class=" language-none">n</code>, але не більше <code class=" language-none">m</code>входжень <code class=" language-none">X</code>.</li>
 <li>Лінивий квантифікатор ( <code class=" language-none">??</code>, <code class=" language-none">*?</code>або <code class=" language-none">+?</code>) призначений для пошуку найкоротшого збігу. Чи можна задати <code class=" language-none">X??</code>для пошуку одного або менш входжень <code class=" language-none">X</code>, <code class=" language-none">X*</code>? для пошуку нуля або більше входжень <code class=" language-none">X</code>, <code class=" language-none">X+?</code>для пошуку одного або більше входжень <code class=" language-none">X</code>, <code class=" language-none">X{n}?</code>для пошуку <code class=" language-none">n</code>входження <code class=" language-none">X</code>, <code class=" language-none">X{n,}?</code>для пошуку не менше (а можливо, і більше) <code class=" language-none">n</code>входжень <code class=" language-none">X</code>і <code class=" language-none">X{n,m}?</code>для пошуку не менше <code class=" language-none">n</code>, але не більше <code class=" language-none">m</code>входжень <code class=" language-none">X</code>.</li>
 <li>Над жадібний квантифікатор ( <code class=" language-none">?+</code>, <code class=" language-none">*+</code>або <code class=" language-none">++</code>) аналогічний жадібному, за винятком того, що наджадібний квантифікатор виконує тільки одну спробу знайти найдовший збіг, в той час як жадібний може виконувати кілька спроб. Можна задати <code class=" language-none">X?+</code>для пошуку одного або менш входжень <code class=" language-none">X</code>, <code class=" language-none">X*+</code>для пошуку нуля або більше входжень <code class=" language-none">X</code>, <code class=" language-none">X++</code>для пошуку одного або більше входжень <code class=" language-none">X</code>, <code class=" language-none">X{n}+</code>для пошуку <code class=" language-none">n</code>входжень <code class=" language-none">X</code>, <code class=" language-none">X{n,}+</code>для пошуку не менше (а можливо, і більше) <code class=" language-none">n</code>входжень <code class=" language-none">X</code>і <code class=" language-none">X{n,m}+ </code>для пошуку не менше <code class=" language-none">n</code>, але не більше <code class=" language-none">m</code>входжень <code class=" language-none">X</code>.</li>
</ul>Наступний приклад ілюструє використання жадібного квантифікатора: <code class=" language-none">java RegexDemo .*ox "fox box pox"</code> Ось його результати: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class="  language-java">regex <span class="token operator"><span class="token operator">=</span></span> <span class="token punctuation"><span class="token punctuation">.</span></span>*ox
input <span class="token operator"><span class="token operator">=</span></span> fox box pox
<span class="token class-name"><span class="token class-name">Found</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span>fox box pox<span class="token punctuation"><span class="token punctuation">]</span></span> starting at <span class="token number"><span class="token number">0</span></span> and ending at <span class="token number"><span class="token number">10</span></span></code></pre> Жадібний квантифікатор ( <code class=" language-none">.*</code>) знаходить найдовшу послідовність символів, що завершується на <code class=" language-none">ox</code>. Він поглинає весь вхідний текст, після чого відкочується до виявлення того, що вхідний текст закінчується цими символами. Розглянемо тепер лінивий квантифікатор: <code class=" language-none">java RegexDemo .*?ox "fox box pox"</code> Його результати: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java">regex <span class="token operator"><span class="token operator">=</span></span> <span class="token punctuation"><span class="token punctuation">.</span></span>*<span class="token operator"><span class="token operator">?</span></span>ox
input <span class="token operator"><span class="token operator">=</span></span> fox box pox
<span class="token class-name"><span class="token class-name">Found</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span>fox<span class="token punctuation"><span class="token punctuation">]</span></span> starting at <span class="token number"><span class="token number">0</span></span> and ending at <span class="token number"><span class="token number">2</span></span>
<span class="token class-name"><span class="token class-name">Found</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span> box<span class="token punctuation"><span class="token punctuation">]</span></span> starting at <span class="token number"><span class="token number">3</span></span> and ending at <span class="token number"><span class="token number">6</span></span>
<span class="token class-name"><span class="token class-name">Found</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span> pox<span class="token punctuation"><span class="token punctuation">]</span></span> starting at <span class="token number"><span class="token number">7</span></span> and ending at <span class="token number"><span class="token number">10</span></span></code></pre> Лінивий квантифікатор ( <code class=" language-none">.*?</code>) знаходить найкоротшу послідовність символів, що завершується на <code class=" language-none">ox</code>. Він починає з порожнього рядка і поступово поглинає символи доти, доки знаходить відповідність. А потім продовжує роботу до вичерпання вхідного тексту. Нарешті, розглянемо надмірний квантифікатор: <code class=" language-none">java RegexDemo .*+ox "fox box pox"</code> І ось його результати: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span><code class="  language-java">regex <span class="token operator"><span class="token operator">=</span></span> <span class="token punctuation"><span class="token punctuation">.</span></span>*<span class="token operator"><span class="token operator">+</span></span>ox
input <span class="token operator"><span class="token operator">=</span></span> fox box pox</code></pre> Надто жадібний квантифікатор ( <code class=" language-none">.*+</code>) не знаходить збігів, оскільки він поглинає весь вхідний текст і не залишається нічого, що могло б відповідати <code class=" language-none">ox</code>в кінці регулярного виразу. На відміну від жадібного квантифікатора, наджадібний квантифікатор не виконує відкат назад. 
<h3>Збіги нульової довжини</h3>Іноді при роботі з квантифікаторами ви стикатиметеся з збігами нульової довжини. Наприклад, використання наступного жадібного квантифікатора призводить до кількох збігів нульової довжини: <code class=" language-none">java RegexDemo a? abaa</code> Результати виконання цього прикладу: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java">regex <span class="token operator"><span class="token operator">=</span></span> a<span class="token operator"><span class="token operator">?</span></span>
input <span class="token operator"><span class="token operator">=</span></span> abaa
<span class="token class-name"><span class="token class-name">Found</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span>a<span class="token punctuation"><span class="token punctuation">]</span></span> starting at <span class="token number"><span class="token number">0</span></span> and ending at <span class="token number"><span class="token number">0</span></span>
<span class="token class-name"><span class="token class-name">Found</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> starting at <span class="token number"><span class="token number">1</span></span> and ending at <span class="token number"><span class="token number">0</span></span>
<span class="token class-name"><span class="token class-name">Found</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span>a<span class="token punctuation"><span class="token punctuation">]</span></span> starting at <span class="token number"><span class="token number">2</span></span> and ending at <span class="token number"><span class="token number">2</span></span>
<span class="token class-name"><span class="token class-name">Found</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span>a<span class="token punctuation"><span class="token punctuation">]</span></span> starting at <span class="token number"><span class="token number">3</span></span> and ending at <span class="token number"><span class="token number">3</span></span>
<span class="token class-name"><span class="token class-name">Found</span></span> <span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> starting at <span class="token number"><span class="token number">4</span></span> and ending at <span class="token number"><span class="token number">3</span></span></code></pre> У результатах виконання є п'ять збігів. Хоча перше, третє і четверте цілком очікувані (вони відповідають позиціям трьох літер <code class=" language-none">a</code>у <code class=" language-none">abaa</code>), друге та п'яте може вас здивувати. Створюється таке враження, ніби вони вказують, що <code class=" language-none">a</code>відповідає <code class=" language-none">b</code>й кінцю тексту, але насправді не так. Регулярний вираз <code class=" language-none">a?</code>не шукає <code class=" language-none">b</code>наприкінці тексту. Воно виконує пошук наявності чи відсутності <code class=" language-none">a</code>. Коли <code class=" language-none">a?</code>не виявляє <code class=" language-none">a</code>, повідомляє про це у вигляді збігу нульової довжини. 
<h3>Вкладені прапори</h3>Зіставники приймають деякі припущення за умовчанням, які можна перекрити при компіляції регулярного виразу шаблону. Ми обговоримо це питання згодом. Регулярний вираз дозволяє перекрити будь-яке із умовчань, використовуючи вкладений прапор. Ця конструкція регулярного виразу задається у вигляді метасимволів круглих дужок навколо метасимволу знака питання ( <code class=" language-none">?</code>), з наступною латинською літерою в нижньому регістрі. Клас <code class=" language-none">Pattern</code>розуміє такі вкладені прапорові вирази: 
<ul>
 <li><code class=" language-none">(?i)</code>: активує нечутливий до регістру пошук шаблону. Наприклад, під час використання команди <code class=" language-none">java RegexDemo (?i)tree Treehouse</code>послідовність символів <code class=" language-none">Tree</code>відповідає шаблону <code class=" language-none">tree</code>. За промовчанням використовується пошук за шаблоном з урахуванням регістру.</li>
 <li><code class=" language-none">(?x)</code>: дозволяє використовувати всередині шаблону пробілові символи та коментарі, що починаються з метасимволу <code class=" language-none">#</code>. Зіставник ігноруватиме і ті, й інші. Наприклад, <code class=" language-none">java RegexDemo ".at(?x)#match hat, cat, and so on" matter</code>послідовність символів <code class=" language-none">mat</code>відповідає шаблону <code class=" language-none">.at</code>. За промовчанням пробілові символи та коментарі заборонені, співставник розглядає їх як символи, що беруть участь у пошуку.</li>
 <li><code class=" language-none">(?s)</code>: активує режим dotall, у якому метасимвол точки відповідає роздільникам рядків, крім іншого символу. Наприклад, при команді <code class=" language-none">java RegexDemo (?s). \n</code>буде знайдено символ нового рядка. За замовчуванням використовується протилежний режим dotall: роздільники рядків не будуть перебувати. Наприклад, при команді <code class=" language-none">Java RegexDemo . \n</code>символ нового рядка не знайдено.</li>
 <li><code class=" language-none">(?m)</code>: активує багаторядковий режим, у якому <code class=" language-none">^</code>відповідає початку, а <code class=" language-none">$</code>– кінця кожного рядка. Наприклад, <code class=" language-none">java RegexDemo "(?m)^abc$" abc\nabc</code>знаходить у вхідному тексті обидві послідовності <code class=" language-none">abc</code>. За замовчуванням використовується однорядковий режим: <code class=" language-none">^</code>відповідає початку всього вхідного тексту, а <code class=" language-none">$</code>його кінця. Наприклад, <code class=" language-none">java RegexDemo "^abc$" abc\nabc</code>повертає відповідь про відсутність збігів.</li>
 <li><code class=" language-none">(?u)</code>: активує вирівнювання регістру з урахуванням Unicode. Цей прапор, при спільному використанні з <code class=" language-none">(?i)</code>дозволяє здійснювати пошук за шаблоном без урахування регістру відповідно до стандарту Unicode. Налаштування за замовчуванням — пошук з урахуванням регістру і лише за символами US-ASCII.</li>
 <li><code class=" language-none">(?d)</code>: активує режим рядків у стилі Unix, у якому зіставник розпізнає у тих метасимволів <code class=" language-none">.</code>, <code class=" language-none">^</code>і <code class=" language-none">$</code>лише роздільник рядків <code class=" language-none">\n</code>. За замовчуванням використовується режим рядків у стилі не-Unix: зіставник розпізнає у контексті вищезазначених метасимволів усі роздільники рядків.</li>
</ul>Вкладені прапорові вирази нагадують групи, що захоплюються, оскільки їх символи оточуються метасимволами круглих дужок. На відміну від груп, що захоплюються, вкладені прапорові вирази – приклад не захоплюваних груп, що є конструкцією регулярних виразів, що не захоплює текстові символи. Вони визначаються як послідовності символів, оточені метасимволами круглих дужок. 
<div class="table-container">
 <table>
  <thead>
   <tr>
    <th>Вказівка ​​кількох вкладених прапорових виразів</th>
   </tr>
  </thead>
  <tbody>
   <tr>
    <td>Існує можливість вказівки кількох вкладених прапорових виразів у регулярному виразі шляхом або розташування їх пліч-о-пліч ( <code class=" language-none">(?m)(?i))</code>), або розміщення послідовно визначальних їх літер ( <code class=" language-none">(?mi)</code>).</td>
   </tr>
  </tbody>
 </table>
</div><a href="https://codegym.cc/welcome" target="_blank"><img id="click_banner1_articles" data-max-width="1024" data-id="9bbbd154-3fc3-4726-ac7a-64e8cd67d9b6" class="img-fluid" alt="Регулярні вирази у Java, частина 2 - 4" src="https://cdn.javarush.com/images/article/9bbbd154-3fc3-4726-ac7a-64e8cd67d9b6/1024.jpeg" style="width: 1024px;"></a>
<h2>Висновок</h2>Як ви вже, напевно, зрозуміли, регулярні висловлювання надзвичайно корисні і стають ще кориснішими в міру освоєння нюансів їхнього синтаксису. Досі я познайомив вас із основами регулярних виразів та класом <code class=" language-none">Pattern</code>. У другій частині ми заглянемо глибше в API Regex і вивчимо методи класів <code class=" language-none">Pattern</code>і <code class=" language-none">Matcher</code>. <code class=" language-none">PatternSyntaxException</code>Я також продемонструю вам дві практичні програми API Regex, які ви зможете відразу ж використовувати у своїх програмах. <a href="https://codegym.cc/groups/posts/186-reguljarnihe-vihrazhenija-v-java-chastjh-3" target="_blank">Регулярні вирази в Java, частина 3 </a> <a href="https://codegym.cc/groups/posts/229-reguljarnihe-vihrazhenija-v-java-chastjh-4" target="_blank">Регулярні вирази в Java, частина 4 </a> <a href="https://codegym.cc/groups/posts/247-reguljarnihe-vihrazhenija-v-java-chastjh-5" target="_blank">Регулярні вирази в Java, частина 5</a>
<div class="table-container">
 <table>
  <tbody>
   <tr>
    <th>
     <p>Що ще почитати:</p></th>
   </tr>
   <tr>
    <td>
     <ul>
      <li><a href="https://codegym.cc/groups/posts/72-kak-praviljhno-nachatjh-razrabotku-pod-subd-oracle" target="_blank">Як правильно розпочати розробку під СУБД Oracle</a></li>
      <li><a href="https://codegym.cc/groups/posts/254-top-5-bibliotek-mashinnogo-obuchenija-dlja-java" target="_blank">Топ 5 бібліотек машинного навчання для Java</a></li>
      <li><a href="https://codegym.cc/groups/posts/264-populjarno-o-ljambda-vihrazhenijakh-v-java-s-primerami-i-zadachami-chastjh-1-" target="_blank">Популярно про лямбда-вираження в Java. З прикладами та завданнями. Частина 1</a></li>
     </ul></td>
   </tr>
  </tbody>
 </table>
</div>