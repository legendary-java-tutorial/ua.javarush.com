Регулярні вирази у Java. Частина 1
<p>----------------------------------------</p>
У цій серії уроків ми навчимося використовувати java.util.regex API для регулярних виразів. Також вивчимо синтаксис регулярних виразів. Регулярні вирази - це спосіб описати набір рядків із загальними характеристиками, які є у кожного рядка 
<p>----------------------------------------</p>
У цій серії уроків ми навчимося використовувати java.util.regex API для регулярних виразів. Також вивчимо синтаксис регулярних виразів. <img data-id="83d9bb84-2e65-43dc-8648-460e5c8fcbfb" data-max-width="850" alt="Регулярні вирази у Java.  Частина 1 - 1" src="https://cdn.javarush.com/images/article/83d9bb84-2e65-43dc-8648-460e5c8fcbfb/800.jpeg" style="width: 850px;">
<h2>Що таке регулярні вирази.</h2>Регулярні вирази - це спосіб описати набір рядків із загальними характеристиками, які є у кожного рядка в наборі. <a href="https://codegym.cc/groups/posts/2013-reguljarnihe-vihrazhenija-v-java" target="_blank">Регулярні вирази</a> можуть використовуватися для пошуку та керування даними. Ви повинні вивчити спеціальний синтаксис, щоб створювати регулярні вирази, який виходить за межі звичайного синтаксису мови Java. Регулярні вирази можуть бути різної складності, але як тільки ви зрозумієте основи, ви зможете створювати будь-які регулярні вирази. У цих уроках ми розглянемо синтаксис регулярних виразів, а також приклади програм, що працюють з <em>java.util.regex API</em> , щоб зрозуміти, як усе це працює. 
<h2>Як регулярні вирази представлені Java?</h2>Пакет <em>java.util.regex</em> містить три основні класи <code class=" language-none">Pattern</code>, <code class=" language-none">Matcher</code>, і <code class=" language-none">PatternSyntaxException</code>. 
<ul>
 <li>
  <p>Об'єкт <code class=" language-none">Pattern</code> — це регулярне скомпілювання вираз. <code class=" language-none">Pattern</code>не надає громадських конструкторів. Щоб створити, <code class=" language-none">pattern</code>необхідно викликати <code class=" language-none">public static compile</code>метод, який поверне об'єкт <code class=" language-none">Pattern</code>. Перший аргумент цієї функції – регулярне вираження.</p></li>
 <li>
  <p>Об'єкт <code class=" language-none">Matcher</code>- це "движок", який інтерпретує регулярне вираження і зіставляє його з вхідним рядком. Як і клас <code class=" language-none">Pattern</code>, <code class=" language-none">Matcher</code>немає публічних конструкторів. Отримати об'єкт <code class=" language-none">Matcher</code>можна викликавши метод <code class=" language-none">matcher</code>об'єкта <code class=" language-none">Pattern</code>.</p></li>
 <li>
  <p><code class=" language-none">PatternSyntaxException</code>- Виняток, що означає синтаксичну помилку у виразі.</p></li>
 <li>
  <p>Згодом ми докладно розглянемо кожен із цих класів. Але спочатку необхідно розуміти, як влаштовані регулярні вирази. Розглянемо тестову програму розуміння синтаксису регулярних выражений.</p></li>
</ul><img data-id="e9d71348-4039-4bf8-8389-54bf76f8bc8f" data-max-width="650" alt="Регулярні вирази у Java.  Частина 1 - 2" src="https://cdn.javarush.com/images/article/e9d71348-4039-4bf8-8389-54bf76f8bc8f/512.jpeg" style="width: 650px;">Створіть програму <code class=" language-none">RegexTestHarness.java</code>для вивчення регулярних виразів. Команда для запуску програми: <code class=" language-none">java RegexTestHarness</code>можна без аргументів. Цикл програми повторюється, дозволяючи користувача вводити регулярний вираз та рядок для пошуку. Ви можете не використовувати цю програму, однак вона може бути корисною для тестування прикладів, які ми будемо розглядати. 
<h2>Рядкові літерали</h2>Основним завданням шаблонів є порівняння рядків. Наприклад, якщо регулярне вираз <code class=" language-none">foo</code>і вхідний рядок <code class=" language-none">foo</code>, то програма знайде збіг, тому що рядки однакові. Спробуйте цей приклад у нашій тестовій програмі. 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">Enter</span></span> your regex<span class="token operator"><span class="token operator">:</span></span> foo
<span class="token class-name"><span class="token class-name">Enter</span></span> input string <span class="token keyword"><span class="token keyword">to</span></span> <span class="token namespace"><span class="token namespace">search</span></span><span class="token operator"><span class="token operator">:</span></span> foo
<span class="token class-name"><span class="token class-name">I</span></span> found the text foo starting at index <span class="token number"><span class="token number">0</span></span> and ending at index <span class="token number"><span class="token number">3.</span></span></code></pre> Зверніть увагу, що довжина вхідного рядка дорівнює 3, початковий індекс 0, кінцевий 3: <img data-id="5ac9abdf-613f-46fa-b50e-c374109f5ea1" data-max-width="335" alt="Регулярні вирази у Java.  Частина 1 - 3" src="https://cdn.javarush.com/images/article/5ac9abdf-613f-46fa-b50e-c374109f5ea1/256.jpeg" style="width: 335px;">Кожен символ рядка розташований у своєму осередку з індексами, що вказують між осередків. Рядок foo починається на індексі 0 і закінчується на 3, незважаючи на те, що займає комірки 0, 1, 2. У наступному прикладі ви помітите деякі особливості: наступний збіг починається там, де закінчується попереднє: <img data-id="f2e3e6db-fcd8-455f-8054-73e9cd623058" data-max-width="650" alt="Регулярні вирази у Java.  Частина 1 - 4" src="https://cdn.javarush.com/images/article/f2e3e6db-fcd8-455f-8054-73e9cd623058/512.jpeg" style="width: 650px;">
<h2>Метасимволи</h2>Дане API також підтримує деякі спеціальні символи, які визначають «поведінку» регулярного виразу. Спробуємо змінити вхідний рядок на <code class=" language-none">cats</code>, а регулярний вираз на <code class=" language-none">cat.</code>. Висновок: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class="  language-java"><span class="token class-name"><span class="token class-name">Enter</span></span> your regex<span class="token operator"><span class="token operator">:</span></span> <span class="token class-name"><span class="token namespace"></span><span class="token class-name"><span class="token namespace"><span class="token namespace">cat<span class="token punctuation"><span class="token punctuation">.</span></span></span><span class="token punctuation"></span></span>
Enter</span></span> input string <span class="token keyword"><span class="token keyword">to</span></span> <span class="token namespace"><span class="token namespace">search</span></span><span class="token operator"><span class="token operator">:</span></span> cats
<span class="token class-name"><span class="token class-name">I</span></span> found the text cats starting at index <span class="token number"><span class="token number">0</span></span> and ending at index <span class="token number"><span class="token number">4.</span></span></code></pre> Порівняння, як і раніше, успішне, навіть незважаючи на точку у вхідному рядку. Так сталося, тому що точка – метасимвол – спеціальний символ, який має якесь значення для <code class=" language-none">matcher</code>'а. Метасимвол точка має сенс «будь-який символ», тому порівняння виявилося успішним у цьому прикладі. Метасимволи, що підтримуються API: <code class=" language-none">&lt;([{\^-=$!|]})?*+.&gt;</code> Існує два способи позначити метасимволи, щоб вони сприймалися як звичайні: 
<ul>
 <li>екранувати метасимвол зворотним слешем</li>
 <li>укласти в <code class=" language-none">\Q</code>(початок) та <code class=" language-none">\E</code>(кінець).</li>
</ul>Використовуючи даний прийом, ви можете помістити <code class=" language-none">\Q</code>і <code class=" language-none">\E</code>в будь-яке місце вираження, <code class=" language-none">\Q</code>необхідно розташовувати перед <code class=" language-none">\E</code>. На цьому все, у <a href="https://codegym.cc/groups/posts/1416-reguljarnihe-vihrazhenija-v-java-chastjh-2" target="_blank">наступних уроках,</a> ми продовжимо вивчення регулярних виразів у Java. Посилання на першоджерело: <a href="http://easy-code.ru/lesson/java-regular-expressions" rel="nofollow" target="_blank">Регулярні вирази Java. Частина 1</a>