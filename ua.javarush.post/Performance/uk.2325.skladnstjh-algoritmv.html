Складність алгоритмів
<p>----------------------------------------</p>
Вітання! Сьогоднішня лекція трохи відрізнятиметься від інших. Відрізнятися вона буде тим, що має непряме відношення до Java. Тим не менш, ця тема є дуже важливою для кожного програміста. Ми поговоримо про . Що таке алгоритм? Говорячи просто
<p>----------------------------------------</p>
Вітання! Сьогоднішня лекція трохи відрізнятиметься від інших. Відрізнятися вона буде тим, що має непряме відношення до Java. <img data-max-width="800" data-id="6f3c8c4e-be9d-4c36-9eda-64086b94e507" class="img-fluid" alt="Складність алгоритмів – 1" src="https://cdn.javarush.com/images/article/6f3c8c4e-be9d-4c36-9eda-64086b94e507/800.jpeg" style="width: 800px;">Тим не менш, ця тема є дуже важливою для кожного програміста. Ми поговоримо про <span class="text-bold">алгоритми</span> . Що таке алгоритм? Говорячи простою мовою, <span class="text-bold">це деяка послідовність дій, які необхідно зробити для досягнення потрібного результату</span> . Ми часто використовуємо алгоритми у повсякденному житті. Наприклад, щоранку перед тобою стоїть завдання: прийти на навчання чи роботу, і бути при цьому: 
<ul>
 <li>Одягненим</li>
 <li>Чистим</li>
 <li>Ситим</li>
</ul>Який <span class="text-bold">алгоритм</span> дозволить тобі досягти цього результату? 
<ol>
 <li>Прокинутися будильником.</li>
 <li>Прийняти душ, вмитися.</li>
 <li>Приготувати сніданок, зварити каву/заварити чай.</li>
 <li>Поїсти.</li>
 <li>Якщо не погладив одяг із вечора — погладити.</li>
 <li>Одягтися.</li>
 <li>Вийти з будинку.</li>
</ol>Ця послідовність дій дозволить тобі отримати необхідний результат. У програмуванні вся суть нашої роботи полягає у постійному вирішенні завдань. Значну частину цих завдань можна виконати, використовуючи відомі алгоритми. Наприклад, перед тобою стоїть завдання: <span class="text-bold">відсортувати список зі 100 імен у масиві</span> . Завдання це досить просте, але вирішити його можна різними способами. Ось один з варіантів рішення: <span class="text-bold">Алгоритм сортування імен за абеткою:</span>
<ol>
 <li>Купити або завантажити в Інтернеті "Словник російських особистих імен" 1966 видання.</li>
 <li>Знаходити кожне ім'я з нашого списку у цьому словнику.</li>
 <li>Записувати на папірець, на якій сторінці словника є ім'я.</li>
 <li>Розставити імена по порядку, використовуючи записи на папірці.</li>
</ol><span class="text-bold">Чи дозволить така послідовність дій вирішити наше завдання? </span>Так, цілком дозволить. Чи буде це рішення <span class="text-bold">ефективним</span> ? Навряд чи. Тут ми підійшли до ще однієї дуже важливої ​​властивості алгоритмів — їхньої <span class="text-bold">ефективності</span> . Розв'язати завдання можна у різний спосіб. Але і в програмуванні, і в звичайному житті ми вибираємо спосіб, який буде найефективнішим. Якщо твоє завдання зробити бутерброд з вершковим маслом, ти, звичайно, можеш почати з того, що посієш пшеницю і подоїш корову. Але це буде <span class="text-bold">неефективне</span>рішення - воно займе дуже багато часу і коштуватиме багато грошей. Для вирішення твого простого завдання хліб і масло можна просто купити. А алгоритм із пшеницею та коровою хоч і дозволяє вирішити завдання, надто складне, щоб застосовувати його на практиці. Для оцінки складності алгоритмів у програмуванні створабо спеціальне позначення під назвою <span class="text-bold">Big-O (“велика”)</span> . <span class="text-bold">Big-O дозволяє оцінити, наскільки час виконання алгоритму залежить від переданих до нього даних</span>. Давай розглянемо найпростіший приклад – передачу даних. Уяви, що тобі потрібно передати деяку інформацію у вигляді файлу на велику відстань (наприклад, 5000 км). Який алгоритм буде найефективнішим? Це залежить від тих даних, з якими він має працювати. Наприклад, ми маємо аудіофайл розміром 10 мегабайт. <img data-max-width="800" data-id="c9ad6b49-836b-4619-9c00-faf40e401812" class="img-fluid" alt="Складність алгоритмів – 2" src="https://cdn.javarush.com/images/article/c9ad6b49-836b-4619-9c00-faf40e401812/800.jpeg" style="width: 800px;">У цьому випадку найефективнішим алгоритмом буде передати файл через Інтернет. Це займе максимум кілька хвабон! Отже, ще раз озвучимо наш алгоритм: <span class="text-bold">“Якщо потрібно передати інформацію у вигляді файлів на відстань 5000 кілометрів, потрібно використовувати передачу даних через Інтернет”. </span> Чудово. Тепер проаналізуємо його. <span class="text-bold">Чи вирішує він наше завдання?</span>Загалом так, цілком вирішує. А ось що можна сказати щодо його складності? Хм, а ось тут уже все цікавіше. Справа в тому, що наш алгоритм дуже залежить від вхідних даних, а саме — від розміру файлів. Зараз у нас 10 мегабайт, і все гаразд. А якщо нам потрібно буде передати 500 мегабайт? 20 гігабайт? 500 терабайт? 30 петабайт? Чи перестане наш алгоритм працювати? Ні, всі ці обсяги даних все одно можна передати. <span class="text-bold">Чи стане він виконуватися довше? </span>Так, стане! Тепер нам відома важлива особливість нашого алгоритму: <span class="text-bold">чим більший розмір даних для передачі, тим довше займе виконання алгоритму</span>. Але нам хотілося б більш точно розуміти, як виглядає ця залежність (між розміром даних та часом на їх передачу). У нашому випадку складність алгоритму буде <span class="text-bold">лінійною</span> . "Лінійна" означає, що при збільшенні обсягу даних час на їх передачу зросте приблизно пропорційно. Якщо даних стане вдвічі більше, і часу на їх передачу знадобиться вдвічі більше. Якщо даних побільшає в 10 разів, і час передачі збільшиться в 10 разів. Використовуючи позначення Big-O, складність нашого алгоритму визначається як <span class="text-bold">O(N)</span>. Це позначення найкраще запам'ятати на майбутнє – воно завжди використовується для алгоритмів із лінійною складністю. Зверни увагу: ми взагалі не говоримо тут про різні “змінні” речі: швидкість інтернету, потужність нашого комп'ютера тощо. При оцінці складності алгоритму в цьому немає сенсу — ми в жодному разі не можемо це контролювати. <span class="text-bold">Big-O оцінює саме сам алгоритм, незалежно від “довкілля” у якому йому доведеться працювати.</span> Продовжимо працювати з нашим прикладом. Припустимо, у результаті з'ясувалося, що обсяг файлів передачі становить 800 терабайт. Якщо ми передаватимемо їх через Інтернет, завдання, звичайно, буде вирішено. Є тільки одна проблема: передача стандартним сучасним каналом (зі швидкістю 100 мегабіт в секунду), який використовується вдома у більшості з нас, займе приблизно 708 днів. <span class="text-bold">Майже 2 роки! :O</span> Так, наш алгоритм тут явно не підходить. Потрібне якесь інше рішення! Несподівано на допомогу до нас приходить IT-гігант – компанія Amazon! Її сервіс Amazon Snowmobile дозволяє завантажити великий обсяг даних у пересувні сховища та доставити за потрібною адресаою на вантажівці! <img data-max-width="800" data-id="9b827fb9-6c82-4c1c-98d1-dc57783a7d6c" class="img-fluid" alt="Складність алгоритмів – 3" src="https://cdn.javarush.com/images/article/9b827fb9-6c82-4c1c-98d1-dc57783a7d6c/800.jpeg" style="width: 800px;">Отже, ми маємо новий алгоритм! <span class="text-bold">Якщо потрібно передати інформацію у вигляді файлів на відстань 5000 кілометрів і цей процес займе більше 14 днів при передачі через Інтернет, потрібно використовувати перевезення даних на вантажівці Amazon.</span> Цифра 14 днів тут обрана випадково: припустимо, це максимальний термін, який ми можемо собі дозволити. Давай проаналізуємо наш алгоритм. Що щодо швидкості? Навіть якщо вантажівка поїде зі швидкістю всього 50 км/год, вона подолає 5000 кілометрів всього за 100 годин. Це трохи більше чотирьох днів! Це набагато краще, ніж варіант із передачею по інтернету. А що зі складністю цього алгоритму? Чи буде вона також лінійною, O(N)? Ні не буде. Адже вантажівці не має значення, як сильно ти її навантажиш — вона все одно поїде приблизно з тією ж швидкістю і приїде вчасно. Чи буде у нас 800 терабайт, чи в 10 разів більше даних, вантажівка все одно доїде до місця за 5 днів. Іншими словами, алгоритм доставки даних через вантажівку <span class="text-bold">має постійну складність.</span>. "Постійна" означає, що вона не залежить від даних, що передаються в алгоритм. Поклади у вантажівку флешку на 1Гб - він доїде за 5 днів. Поклади туди диски з 800 терабайт даних - він доїде за 5 днів. При використанні Big-O постійна складність позначається як <span class="text-bold">O(1)</span> . Якщо ми познайомабося з <span class="text-bold">O(N)</span> і <span class="text-bold">O(1)</span> , давай тепер розглянемо більш "програмістські" приклади :) Припустимо, тобі дано масив зі 100 чисел, і завдання - вивести в консоль кожне з них. Ти пишеш звичайний цикл <code class=" language-none">for</code>, який виконує це завдання 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">int</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> numbers <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token keyword"><span class="token keyword">int</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token number"><span class="token number">100</span></span><span class="token punctuation"><span class="token punctuation">]</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token comment"><span class="token comment">// ..заполняем массив числами</span></span>

<span class="token keyword"><span class="token keyword">for</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">int</span></span> i<span class="token operator"><span class="token operator">:</span></span> numbers<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
   <span class="token class-name"><span class="token class-name">System</span></span><span class="token punctuation"><span class="token punctuation">.</span></span>out<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">println</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>i<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> Яка складність написаного алгоритму? <span class="text-bold">Лінійна, O(N). </span> Число дій, які має зробити програма, залежить від того, скільки саме чисел у неї передали. Якщо в масиві буде 100 чисел, дій (висновків на екран) буде 100. Якщо чисел у масиві буде 10000, потрібно буде здійснити 10000 дій. Чи можна покращити наш алгоритм? Ні. Нам у будь-якому випадку доведеться здійснити <span class="text-bold">N проходів масивом</span> і виконати N висновків в консоль. Розглянемо інший приклад. 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">static</span></span> <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">main</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token class-name"><span class="token class-name">String</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> args<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>

   <span class="token class-name"><span class="token class-name">LinkedList</span></span><span class="token generics"><span class="token punctuation"></span><span class="token generics"><span class="token punctuation"><span class="token punctuation">&lt;</span></span><span class="token class-name"><span class="token class-name">Integer</span></span><span class="token punctuation"><span class="token punctuation">&gt;</span></span></span><span class="token punctuation"></span></span> numbers <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">new</span></span> <span class="token class-name"><span class="token class-name">LinkedList</span></span><span class="token generics"><span class="token punctuation"></span><span class="token generics"><span class="token punctuation"><span class="token punctuation">&lt;</span></span><span class="token punctuation"><span class="token punctuation">&gt;</span></span></span><span class="token punctuation"></span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
   numbers<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">add</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token number"><span class="token number">0</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token number"><span class="token number">20202</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
   numbers<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">add</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token number"><span class="token number">0</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token number"><span class="token number">123</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
   numbers<span class="token punctuation"><span class="token punctuation">.</span></span><span class="token function"><span class="token function">add</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token number"><span class="token number">0</span></span><span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token number"><span class="token number">8283</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
<span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> У нас є порожній <code class=" language-none">LinkedList</code>, в який ми вставляємо кілька чисел. Нам потрібно оцінити складність алгоритму вставки одного числа у <code class=" language-none">LinkedList</code>нашому прикладі, і як вона залежить від числа елементів, що знаходяться в списку. Відповіддю буде <span class="text-bold">O(1) — постійна складність</span> . Чому? Зверніть увагу: щоразу ми вставляємо число на початок списку. До того ж, як ти пам'ятаєш, при вставці числа в <code class=" language-none">LinkedList</code>елементи нікуди не зрушуються - відбувається перевизначення посилань (якщо раптом забув, як працює LinkedList, зазирни в одну з наших <a href="https://codegym.cc/groups/posts/1938-linkedlist" target="_blank">старих лекцій</a> ). Якщо зараз перше число в нашому списку - число <code class=" language-none">х</code>, а ми вставляємо на початок списку число y, все, що для цього потрібно: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span><code class="  language-java">x<span class="token punctuation"><span class="token punctuation">.</span></span>previous  <span class="token operator"><span class="token operator">=</span></span> y<span class="token punctuation"><span class="token punctuation">;</span></span>
y<span class="token punctuation"><span class="token punctuation">.</span></span>previous <span class="token operator"><span class="token operator">=</span></span> <span class="token keyword"><span class="token keyword">null</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
y<span class="token punctuation"><span class="token punctuation">.</span></span>next <span class="token operator"><span class="token operator">=</span></span> x<span class="token punctuation"><span class="token punctuation">;</span></span></code></pre> Для цього перевизначення посилань <span class="text-bold">нам неважливо, скільки чисел зараз у<code class=" language-none">LinkedList</code></span> хоч одне, хоч мільярд. Складність алгоритму буде постійною – O(1). <a href="https://codegym.cc/welcome" target="_blank"><img id="click_banner1_articles" data-max-width="1024" data-id="c8d74fee-f9b4-4a80-b70b-426f574d3e52" class="img-fluid" alt="Складність алгоритмів – 4" src="https://cdn.javarush.com/images/article/c8d74fee-f9b4-4a80-b70b-426f574d3e52/1024.jpeg" style="width: 1024px;"></a>
<h2>Логарифмічна складність</h2><span class="text-bold">Без паніки! :)</span> Якщо при слові "логарифмічний" тобі захотілося закрити лекцію і не читати далі - почекай пару хвабон. Жодних математичних складнощів тут не буде (таких пояснень повно і в інших місцях), а всі приклади розберемо "на пальцях". Уяви, що твоє завдання знайти одне конкретне число в масиві зі 100 чисел. Точніше, перевірити, чи воно там взагалі. Як тільки потрібне число знайдено, пошук припинити, а в консоль вивести запис “Потрібне число виявлено! Його індекс у масиві = ....” Як би ти вирішив таке завдання? Тут рішення очевидне: потрібно перебрати елементи масиву по черзі починаючи з першого (або з останнього) і перевіряти, чи поточне число збігається з шуканим. Відповідно, кількість дій прямо залежить від кількості елементів у масиві. Якщо у нас 100 чисел, значить, нам потрібно 100 разів перейти до наступного елементу та 100 разів перевірити число на збіг. Якщо чисел буде 1000, то й кроків-перевірок буде 1000. Це очевидно лінійна складність,<span class="text-bold">O(N)</span> . А тепер ми додамо до нашого прикладу одне уточнення: <span class="text-bold">масив, в якому тобі потрібно знайти число, відсортований за зростанням</span> . Чи змінює це щось для нашого завдання? Ми, як і раніше, можемо шукати потрібну кількість перебором. Але натомість ми можемо використовувати відомий <span class="text-bold">алгоритм двійкового пошуку</span> . <img data-max-width="800" data-id="cff243f7-1b8e-45d3-8882-c73f60d732ca" alt="Складність алгоритмів – 5" src="https://cdn.javarush.com/images/article/cff243f7-1b8e-45d3-8882-c73f60d732ca/800.jpeg" style="width: 800px;">У верхньому ряду на зображенні бачимо відсортований масив. У ньому нам необхідно знайти число 23. Замість того щоб перебирати числа, ми просто ділимо масив на 2 частини і перевіряємо середнє число в масиві. Знаходимо число, яке розташовується в комірці 4 і перевіряємо його (другий рядок на картинці). Це число рівне 16, а ми шукаємо 23. Поточне число менше. Що це означає? Що <span class="text-bold">всі попередні числа (які розташовані до числа 16) можна не перевіряти</span>: вони точно будуть меншими за те, яке ми шукаємо, адже наш масив відсортований! Продовжимо пошук серед 5 елементів, що залишабося. <mark>Зверни увагу:</mark>ми зробабо лише одну перевірку, але вже міли половину можливих варіантів. У нас залишилося лише 5 елементів. Ми повторимо наш крок - знову розділимо масив, що залишився на 2 і знову візьмемо середній елемент (рядок 3 на малюнку). Це число 56, і воно більше за те, яке ми шукаємо. Що це означає? Що ми відкидаємо ще три варіанти - саме число 56, і два числа після нього (вони точно більше 23, адже масив відсортований). У нас залишилося всього 2 числа для перевірки (останній ряд на малюнку) — числа з індексами масиву 5 та 6. Перевіряємо перше з них, і це те, що ми шукали, — число 23! Його індекс = 5! Давайте розглянемо результати роботи нашого алгоритму, а потім розберемося з його складністю. (До речі, тепер ти розумієш, чому його називають двійковим: його суть полягає у постійному розподілі даних на 2). Результат вражає! Якби ми шукали потрібну кількість лінійним пошуком, нам знадобилося б 10 перевірок, а з двійковим пошуком ми вклалися у 3! У гіршому випадку їх було б 4, якби на останньому кроці необхідним числом виявилося друге, а не перше. А що з його складністю? Це дуже цікавий момент:) <span class="text-bold">Алгоритм двійкового пошуку набагато менше залежить від кількості елементів у масиві, ніж алгоритм лінійного пошуку (тобто простого перебору). </span> При <span class="text-bold">10</span> елементах у масиві лінійному пошуку знадобиться максимум 10 перевірок, а двійковому – максимум 4 перевірки. Різниця у 2,5 рази. Але для масиву в <span class="text-bold">1000 елементів</span> лінійному пошуку знадобиться 1000 перевірок, а двійковому – <span class="text-bold">всього 10</span> ! Різниця вже у 100 разів! <mark>Зверни увагу:</mark>кількість елементів у масиві збільшилася в 100 разів (з 10 до 1000), а кількість необхідних перевірок для двійкового пошуку збільшилася всього в 2,5 рази — з 4 до 10. Якщо ми дійдемо до 10000 елементів, різниця буде ще більш вражаючою: <span class="text-bold">10000</span> перевірок для лінійного пошуку, і <span class="text-bold">лише 14 перевірок</span> для двійкового. І знову: кількість елементів збільшилася в 1000 разів (з 10 до 10000), а кількість перевірок збільшилася лише у 3,5 рази (з 4 до 14). <span class="text-bold">Складність алгоритму двійкового пошуку логарифмічна</span> , або, якщо використовувати позначення Big-O, - <span class="text-bold">O (log n)</span>. Чому вона так називається? Логарифм - це така штуковина, обернена до зведення в ступінь. Двійковий логарифм використовує для підрахунку ступеня числа 2. Ось, наприклад, ми маємо 10000 елементів, які нам треба перебрати двійковим пошуком. <img data-max-width="850" alt="Складність алгоритмів – 6" src="https://cdn.javarush.com/images/article/399a6189-5734-41fb-9dca-7871e86bfe59/original.jpeg">Зараз у тебе є картинка перед очима, і ти знаєш, що для цього потрібно максимум 14 перевірок. Але якщо картинки перед очима не буде, а тобі потрібно порахувати точну кількість необхідних перевірок? Досить відповісти на просте запитання: <span class="text-bold">в який ступінь треба звести число 2, щоб отриманий результат був числу елементів, що перевіряються? </span> Для 10000 це буде 14 ступінь. 2 в 13 ступені - це занадто мало (8192) А ось <span class="text-bold">2 в 14 ступені = 16384</span>, це число задовольняє нашій умові (воно &gt;= числу елементів у масиві). Ми знайшли логарифм — 14. Стільки перевірок нам потрібно! :) Алгоритми та їх складність - тема занадто велика, щоб вмістити її в одну лекцію. Але знати її дуже важливо: на багатьох співбесідах ти матимеш алгоритмічні завдання. Для теорії я можу порадити тобі кілька книжок. Почати можна з “ <a href="https://www.chitai-gorod.ru/catalog/book/960907/" rel="nofollow" target="_blank">Грокуємо алгоритми</a> ”: хоча приклади в книзі написані на Python, мова книги та приклади дуже прості. Найкращий варіант для новачка, до того ж вона невелика за обсягом. З серйознішого читання — книги <a href="https://www.amazon.com/Data-Structures-Algorithms-Java-2nd/dp/0672324539" rel="nofollow" target="_blank">Роберта Лафоре</a> і <a href="https://www.amazon.com/Algorithms-Java-Parts-1-4-Pts-1-4/dp/0201361205" rel="nofollow" target="_blank">Роберта Седжвіка</a>. Обидві написані на Java, що зробить вивчення для тебе трохи простіше. Адже ти непогано знайомий із цією мовою! :) Для учнів з гарною математичною підготовкою найкращим варіантом буде <a href="https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844" rel="nofollow" target="_blank">книга Томаса Кормена</a> . Але однією теорією ситий не будеш! <span class="text-bold">"Знати" != "вміти"</span> Практикувати рішення задач на алгоритми можна на <a href="https://www.hackerrank.com/" rel="nofollow" target="_blank">HackerRank</a> та <a href="https://leetcode.com/" rel="nofollow" target="_blank">Leetcode</a> . Завдання звідти часто використовують навіть на співбесідах в Google і Facebook, так що нудно тобі точно не буде :) Для закріплення матеріалу лекції, раджу подивитися чудове <a href="https://www.youtube.com/watch?v=ZRdOb4yR0kk" rel="nofollow" target="_blank">відео про Big-O</a> на YouTube. Побачимося на наступних лекціях! :)