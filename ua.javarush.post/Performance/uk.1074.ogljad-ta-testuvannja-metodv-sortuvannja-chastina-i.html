Огляд та тестування методів сортування. Частина I
<p>----------------------------------------</p>
Днями у коментарях вконтакті у мене виникла суперечка з одним із інших студентів проекту. Суть суперечки полягала в тому, «хто кого» — метод із класу або самописні реалізації простих алгоритмів: (бульбашкова), (вставками), (вибором), (алгор
<p>----------------------------------------</p>
Днями у коментарях вконтакті у мене виникла суперечка з одним із інших студентів проекту. Суть суперечки полягала в тому, «хто кого» — метод <code class=" language-none">sort()</code>із класу <code class=" language-none">java.util.Arrays</code>або самописні реалізації простих алгоритмів: <strong>bubble</strong> (бульбашкова), <strong>insertion</strong> (вставками), <strong>selection</strong> (вибором), <strong>shell</strong> (алгоритм Шелла). <img data-id="f5ac0442-1efa-4ea0-b92a-7bc653705dc2" data-max-width="850" alt="Огляд та тестування методів сортування.  Частина I - 1" src="https://cdn.javarush.com/images/article/f5ac0442-1efa-4ea0-b92a-7bc653705dc2/800.jpeg" style="width: 850px;">Для деяких відповідь на це питання може бути очевидною, але якщо суперечка виникла, при тому, що у кожної зі сторін були «шановні джерела» на користь своєї точки зору, було прийнято рішення провести дослідження, порозімнявши в процесі сіру речовину, реалізуючи різні алгоритми. <em>TL; DR:</em> <code class=" language-none">java.util.Arrays.sort()</code> <em>беззастережно лідирує на масивах від 100 000 елементів, при меншому розмірі з ним може потягатися метод Шелла. Інші розглянуті алгоритми зливають начисто і можуть бути корисні лише за якихось екзотичних умов. </em> Тепер давайте розглянемо, як здійснюється сортування масивів в наших убер-девайсах з кремнію. 
<h2>Selection sort. Сортування вибором</h2>Почнемо з найпростішого та очевидного способу. Суть його нам чудово демонструє <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D0%B4%D0%B6%D0%B2%D0%B8%D0%BA,_%D0%A0%D0%BE%D0%B1%D0%B5%D1%80%D1%82" rel="nofollow" target="_blank">Роберт Седжвік</a> у своїй <a href="https://www.coursera.org/learn/algorithms-part1" rel="nofollow" target="_blank">відеолекції на coursera</a> (наводжу погано перетиснуту в gif мною анімацію звідти): <a href="https://www.dropbox.com/s/otq3781oeae2h42/selectionSort.gif" rel="nofollow" target="_blank">Подивитися</a> Пробігаючи по масиву з першого елемента, ми на кожному кроці шукаємо у правій частині мінімальний елемент, з яким і міняємо місцями поточний. В результаті ми залишаємо за собою остаточний варіант нашого масиву у відсортованому вигляді. Ось код, що реалізує цей алгоритм на Java: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">sort</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">int</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> array<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
        <span class="token keyword"><span class="token keyword">int</span></span> n <span class="token operator"><span class="token operator">=</span></span> array<span class="token punctuation"><span class="token punctuation">.</span></span>length<span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token keyword"><span class="token keyword">for</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">int</span></span> i <span class="token operator"><span class="token operator">=</span></span> <span class="token number"><span class="token number">0</span></span><span class="token punctuation"><span class="token punctuation">;</span></span> i <span class="token operator"><span class="token operator">&lt;</span></span> n<span class="token punctuation"><span class="token punctuation">;</span></span> i <span class="token operator"><span class="token operator">++</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
            <span class="token keyword"><span class="token keyword">int</span></span> minIndex <span class="token operator"><span class="token operator">=</span></span> <span class="token function"><span class="token function">min</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>array<span class="token punctuation"><span class="token punctuation">,</span></span> i<span class="token punctuation"><span class="token punctuation">,</span></span> n <span class="token operator"><span class="token operator">-</span></span> <span class="token number"><span class="token number">1</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
            <span class="token function"><span class="token function">swap</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>array<span class="token punctuation"><span class="token punctuation">,</span></span> i<span class="token punctuation"><span class="token punctuation">,</span></span> minIndex<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token punctuation"><span class="token punctuation">}</span></span>
    <span class="token punctuation"><span class="token punctuation">}</span></span>

<span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">static</span></span> <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">swap</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">int</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> array<span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token keyword"><span class="token keyword">int</span></span> i<span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token keyword"><span class="token keyword">int</span></span> j<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
        <span class="token keyword"><span class="token keyword">int</span></span> temp <span class="token operator"><span class="token operator">=</span></span> array<span class="token punctuation"><span class="token punctuation">[</span></span>i<span class="token punctuation"><span class="token punctuation">]</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
        array<span class="token punctuation"><span class="token punctuation">[</span></span>i<span class="token punctuation"><span class="token punctuation">]</span></span> <span class="token operator"><span class="token operator">=</span></span> array<span class="token punctuation"><span class="token punctuation">[</span></span>j<span class="token punctuation"><span class="token punctuation">]</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
        array<span class="token punctuation"><span class="token punctuation">[</span></span>j<span class="token punctuation"><span class="token punctuation">]</span></span> <span class="token operator"><span class="token operator">=</span></span> temp<span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token punctuation"><span class="token punctuation">}</span></span>
<span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">static</span></span> <span class="token keyword"><span class="token keyword">int</span></span> <span class="token function"><span class="token function">min</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">int</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> array<span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token keyword"><span class="token keyword">int</span></span> begin<span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token keyword"><span class="token keyword">int</span></span> end<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
        <span class="token keyword"><span class="token keyword">int</span></span> minVal <span class="token operator"><span class="token operator">=</span></span> array<span class="token punctuation"><span class="token punctuation">[</span></span>begin<span class="token punctuation"><span class="token punctuation">]</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token keyword"><span class="token keyword">int</span></span> minIndex <span class="token operator"><span class="token operator">=</span></span> begin<span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token keyword"><span class="token keyword">for</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">int</span></span> i <span class="token operator"><span class="token operator">=</span></span> begin <span class="token operator"><span class="token operator">+</span></span> <span class="token number"><span class="token number">1</span></span><span class="token punctuation"><span class="token punctuation">;</span></span> i <span class="token operator"><span class="token operator">&lt;=</span></span> end<span class="token punctuation"><span class="token punctuation">;</span></span> i<span class="token operator"><span class="token operator">++</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
            <span class="token keyword"><span class="token keyword">if</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span>array<span class="token punctuation"><span class="token punctuation">[</span></span>i<span class="token punctuation"><span class="token punctuation">]</span></span> <span class="token operator"><span class="token operator">&lt;</span></span> minVal<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
                minVal <span class="token operator"><span class="token operator">=</span></span> array<span class="token punctuation"><span class="token punctuation">[</span></span>i<span class="token punctuation"><span class="token punctuation">]</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
                minIndex <span class="token operator"><span class="token operator">=</span></span> i<span class="token punctuation"><span class="token punctuation">;</span></span>
            <span class="token punctuation"><span class="token punctuation">}</span></span>
        <span class="token punctuation"><span class="token punctuation">}</span></span>
        <span class="token keyword"><span class="token keyword">return</span></span> minIndex<span class="token punctuation"><span class="token punctuation">;</span></span>
    <span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> Аналіз алгоритму показує, що необхідно на кожному проході прошерстить звістку залишок масиву, тобто нам знадобиться рівно N + (N-1) + (N-2) + … + 1 = N ^ 2/2 порівнянь. Отже, складність алгоритму становить O(N^2). Що це означає? А означає це, що, збільшивши кількість елементів у масиві (N) у 2 рази, ми збільшимо час роботи алгоритму не в 2, а в 22 = 4 рази. Збільшивши N у 10 разів, час роботи збільшимо у 100 разів і так далі. На моєму ноутбуці 2012 з процесором Core i3 під Ubuntu 14.4 я отримав наступний час роботи: <img data-id="33df253d-95c9-4d3a-b238-bac50eaf0e7b" data-max-width="850" alt="Огляд та тестування методів сортування.  Частина I - 2" src="https://cdn.javarush.com/images/article/33df253d-95c9-4d3a-b238-bac50eaf0e7b/800.jpeg" style="width: 850px;">
<h2>Insertion sort. Сортування вставками</h2>Тут ідея дещо інша. Знову ж таки, звернемося до анімації від Доктора Седжвіка: <a href="https://www.dropbox.com/s/xrr5f6xk5korv0s/insertionSort_optimized.gif?dl=0" rel="nofollow" target="_blank">Подивитися</a> Те, що попереду, нами ще навіть не переглянуто, а все, що залишаємо позаду себе, завжди залишається збудованим по порядку. Суть у тому, що кожен новий елемент вихідного масиву ми «повертаємо» до початку, доки він не «упреться» у менший елемент. Таким чином, у нас знову N проходів (для кожного елемента вихідного масиву), але в кожному проході здебільшого ми переглядаємо не весь залишок, а лише частину. Тобто варіант 1 + (N-1) + (N-2) + … + N = N^2/2 ми отримаємо тільки якщо кожен наступний елемент нам доведеться повертати до самого початку, тобто у випадку відсортованого «навпаки» вхідного масиву (не щастить, так нещастить). У разі вже відсортованого масиву (ось везуха ваще) буде повна халява – на кожному проході лише одне порівняння та залишення елемента на місці, тобто відпрацює алгоритм за час, пропорційне N. Складність алгоритму буде визначатися гіршим теоретичним випадком, тобто O(N^2). Середньо ж, час роботи буде пропорційно N^2/4, тобто, вдвічі швидше попереднього алгоритму. У моїй реалізації через неоптимальне використання перестановки час роботи вийшов більшим, ніж у Selection. Планую найближчим часом виправити та оновити пост. Ось код та результат його роботи на тій же машині: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">sort</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">int</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> array<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
        <span class="token keyword"><span class="token keyword">int</span></span> length <span class="token operator"><span class="token operator">=</span></span> array<span class="token punctuation"><span class="token punctuation">.</span></span>length<span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token keyword"><span class="token keyword">for</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">int</span></span> i <span class="token operator"><span class="token operator">=</span></span> <span class="token number"><span class="token number">1</span></span><span class="token punctuation"><span class="token punctuation">;</span></span> i <span class="token operator"><span class="token operator">&lt;</span></span> length<span class="token punctuation"><span class="token punctuation">;</span></span> i<span class="token operator"><span class="token operator">++</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
            <span class="token keyword"><span class="token keyword">for</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">int</span></span> j <span class="token operator"><span class="token operator">=</span></span> i<span class="token punctuation"><span class="token punctuation">;</span></span> j <span class="token operator"><span class="token operator">&gt;=</span></span> <span class="token number"><span class="token number">1</span></span><span class="token punctuation"><span class="token punctuation">;</span></span> j<span class="token operator"><span class="token operator">--</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
                <span class="token keyword"><span class="token keyword">if</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span>array<span class="token punctuation"><span class="token punctuation">[</span></span>j<span class="token punctuation"><span class="token punctuation">]</span></span> <span class="token operator"><span class="token operator">&lt;</span></span> array<span class="token punctuation"><span class="token punctuation">[</span></span>j <span class="token operator"><span class="token operator">-</span></span> <span class="token number"><span class="token number">1</span></span><span class="token punctuation"><span class="token punctuation">]</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
                    <span class="token function"><span class="token function">swap</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>array<span class="token punctuation"><span class="token punctuation">,</span></span> j<span class="token punctuation"><span class="token punctuation">,</span></span> j <span class="token operator"><span class="token operator">-</span></span> <span class="token number"><span class="token number">1</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
                <span class="token keyword"><span class="token keyword">else</span></span>
                    <span class="token keyword"><span class="token keyword">break</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
            <span class="token punctuation"><span class="token punctuation">}</span></span>
        <span class="token punctuation"><span class="token punctuation">}</span></span>
    <span class="token punctuation"><span class="token punctuation">}</span></span></code></pre><img data-id="5aedb9d4-6688-4519-ae15-65f0cc14c840" data-max-width="850" alt="Огляд та тестування методів сортування.  Частина I - 3" src="https://cdn.javarush.com/images/article/5aedb9d4-6688-4519-ae15-65f0cc14c840/800.jpeg" style="width: 850px;">
<h2>Shell sort. Сортування Шелла</h2>Розумний мужик Дональд Шелл аж у 1959-му році зауважив, що в алгоритмі вставками найдорожче обходяться випадки, коли елемент повертається дуже далеко до початку масиву: на якомусь проході ми повернемо елемент до початку на пару позицій, а на іншому проході майже через весь масив на початок – далеко й довго. Чи не можна це зробити одразу, стрибаючи через кілька елементів? І такий спосіб знайшов. Полягає він у послідовному виконанні спеціальних часткових сортувань, званих у загальному вигляді d-sort або, у Седжвіка, h-sort (підозрюю, h означає hop – стрибок). 3-sort, наприклад, порівнюватиме аналізований елемент не з попереднім, а пропустить два і порівняє з віддаленим на 3 позиції назад. Якщо змінабо, він його порівняє знову з елементом на 3 позиції тому й таке інше. Суть у тому, що отриманий у результаті масив буде «3-відсортований», тобто неправильність становища елементів становитиме менше 3х позицій. Працювати з таким алгоритмом вставки буде легко та приємно. До речі, «1-sort» є нічим іншим, як просто алгоритмом вставки =) Послідовно застосовуючи до масиву h-sort зі зменшенням значення h, ми зможемо відсортувати великий масив швидше. Ось як це виглядає: <a href="https://www.dropbox.com/s/cs1eig2glqecz8l/ShellSort_optimized.gif?dl=0" rel="nofollow" target="_blank">Складність</a> тут полягає в тому, як вибрати правильну послідовність часткових сортувань. Від цього, у результаті залежить продуктивність алгоритму. Найбільш поширеною є послідовність, запропонована Дональдом Батігом: h = h*3 + 1, тобто 1, 4, 13, 40, … і так до 1/3 розміру масиву. Така послідовність забезпечує гідну продуктивність, і навіть проста у реалізації. Аналіз алгоритму вимагає тонн матану і мною не заможний. Обширність аналізу як і визначається безліччю варіантів послідовностей h. Емпірично можна сказати, що швидкість алгоритму дуже хороша – дивіться самі: <img data-id="18e19ced-75aa-4fbe-adb0-3e643737d021" data-max-width="850" alt="Огляд та тестування методів сортування.  Частина I - 4" src="https://cdn.javarush.com/images/article/18e19ced-75aa-4fbe-adb0-3e643737d021/800.jpeg" style="width: 850px;">Мільйон елементів менше, ніж за секунду! А ось код на Java з батоговою послідовністю. 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">sort</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">int</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> array<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
        <span class="token keyword"><span class="token keyword">int</span></span> h <span class="token operator"><span class="token operator">=</span></span> <span class="token number"><span class="token number">1</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token keyword"><span class="token keyword">while</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span>h<span class="token operator"><span class="token operator">*</span></span><span class="token number"><span class="token number">3</span></span> <span class="token operator"><span class="token operator">&lt;</span></span> array<span class="token punctuation"><span class="token punctuation">.</span></span>length<span class="token punctuation"><span class="token punctuation">)</span></span>
            h <span class="token operator"><span class="token operator">=</span></span> h <span class="token operator"><span class="token operator">*</span></span> <span class="token number"><span class="token number">3</span></span> <span class="token operator"><span class="token operator">+</span></span> <span class="token number"><span class="token number">1</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>

        <span class="token keyword"><span class="token keyword">while</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>h <span class="token operator"><span class="token operator">&gt;=</span></span> <span class="token number"><span class="token number">1</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
            <span class="token function"><span class="token function">hSort</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>array<span class="token punctuation"><span class="token punctuation">,</span></span> h<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
            h <span class="token operator"><span class="token operator">=</span></span> h<span class="token operator"><span class="token operator">/</span></span><span class="token number"><span class="token number">3</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token punctuation"><span class="token punctuation">}</span></span>
    <span class="token punctuation"><span class="token punctuation">}</span></span>

    <span class="token keyword"><span class="token keyword">private</span></span> <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">hSort</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">int</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> array<span class="token punctuation"><span class="token punctuation">,</span></span> <span class="token keyword"><span class="token keyword">int</span></span> h<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
        <span class="token keyword"><span class="token keyword">int</span></span> length <span class="token operator"><span class="token operator">=</span></span> array<span class="token punctuation"><span class="token punctuation">.</span></span>length<span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token keyword"><span class="token keyword">for</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">int</span></span> i <span class="token operator"><span class="token operator">=</span></span> h<span class="token punctuation"><span class="token punctuation">;</span></span> i <span class="token operator"><span class="token operator">&lt;</span></span> length<span class="token punctuation"><span class="token punctuation">;</span></span> i<span class="token operator"><span class="token operator">++</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
            <span class="token keyword"><span class="token keyword">for</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">int</span></span> j <span class="token operator"><span class="token operator">=</span></span> i<span class="token punctuation"><span class="token punctuation">;</span></span> j <span class="token operator"><span class="token operator">&gt;=</span></span> h<span class="token punctuation"><span class="token punctuation">;</span></span> j <span class="token operator"><span class="token operator">=</span></span> j <span class="token operator"><span class="token operator">-</span></span> h<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
                <span class="token keyword"><span class="token keyword">if</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span>array<span class="token punctuation"><span class="token punctuation">[</span></span>j<span class="token punctuation"><span class="token punctuation">]</span></span> <span class="token operator"><span class="token operator">&lt;</span></span> array<span class="token punctuation"><span class="token punctuation">[</span></span>j <span class="token operator"><span class="token operator">-</span></span> h<span class="token punctuation"><span class="token punctuation">]</span></span><span class="token punctuation"><span class="token punctuation">)</span></span>
                    <span class="token function"><span class="token function">swap</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>array<span class="token punctuation"><span class="token punctuation">,</span></span> j<span class="token punctuation"><span class="token punctuation">,</span></span> j <span class="token operator"><span class="token operator">-</span></span> h<span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
                <span class="token keyword"><span class="token keyword">else</span></span>
                    <span class="token keyword"><span class="token keyword">break</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
            <span class="token punctuation"><span class="token punctuation">}</span></span>
        <span class="token punctuation"><span class="token punctuation">}</span></span>
    <span class="token punctuation"><span class="token punctuation">}</span></span></code></pre>
<h2>Bubble sort. Метод бульбашки</h2>Це класика! Цей алгоритм реалізує майже кожен програміст-початківець. Це настільки класика, що в Доктора Седжвіка навіть не знайшлося анімації для нього, тому мені довелося попрацювати самому. <a href="https://www.dropbox.com/s/b8nrxx5qdprm8gn/bubbleSort.gif?dl=0" rel="nofollow" target="_blank">Тут</a> на кожному проході ми обходимо масив з початку до кінця, змінюючи місцями сусідні елементи, що стоять не по порядку. В результаті найбільші елементи «спливають» (звідси і назва) наприкінці масиву. Кожен новий прохід ми починаємо, оптимістично сподіваючись, що масив уже відсортований (<code class=" language-none">sorted = true</code>). Наприкінці проходу, якщо бачимо, що помаболися, починаємо новий прохід. Складність тут полягає в тому, що ми знову ж таки обходимо весь (майже) масив на кожному проході. Порівняння відбувається на кожному кроці, обмін - майже на кожному, що робить даний алгоритм одним з найповільніших (якщо розглядати раціонально реалізовані, а не "сортування струшуванням" та інші). Цікаво, що формально складність і тут дорівнюватиме O(N^2), тільки коефіцієнт набагато вищий, ніж у вставок і виборів. Код алгоритму: 
<pre class=" line-numbers  language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class="  language-java"><span class="token keyword"><span class="token keyword">public</span></span> <span class="token keyword"><span class="token keyword">void</span></span> <span class="token function"><span class="token function">sort</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">int</span></span><span class="token punctuation"><span class="token punctuation">[</span></span><span class="token punctuation"><span class="token punctuation">]</span></span> array<span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
        <span class="token keyword"><span class="token keyword">boolean</span></span> isSorted<span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token keyword"><span class="token keyword">int</span></span> nMinusOne <span class="token operator"><span class="token operator">=</span></span> array<span class="token punctuation"><span class="token punctuation">.</span></span>length <span class="token operator"><span class="token operator">-</span></span> <span class="token number"><span class="token number">1</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token keyword"><span class="token keyword">for</span></span><span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">int</span></span> i <span class="token operator"><span class="token operator">=</span></span> <span class="token number"><span class="token number">0</span></span><span class="token punctuation"><span class="token punctuation">;</span></span> i <span class="token operator"><span class="token operator">&lt;</span></span> nMinusOne<span class="token punctuation"><span class="token punctuation">;</span></span> i<span class="token operator"><span class="token operator">++</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
            isSorted <span class="token operator"><span class="token operator">=</span></span> <span class="token boolean"><span class="token boolean">true</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
            <span class="token keyword"><span class="token keyword">for</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span><span class="token keyword"><span class="token keyword">int</span></span> j <span class="token operator"><span class="token operator">=</span></span> <span class="token number"><span class="token number">0</span></span><span class="token punctuation"><span class="token punctuation">;</span></span> j <span class="token operator"><span class="token operator">&lt;</span></span> nMinusOne <span class="token operator"><span class="token operator">-</span></span> i<span class="token punctuation"><span class="token punctuation">;</span></span> j<span class="token operator"><span class="token operator">++</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
                <span class="token keyword"><span class="token keyword">if</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span>array<span class="token punctuation"><span class="token punctuation">[</span></span>j<span class="token punctuation"><span class="token punctuation">]</span></span> <span class="token operator"><span class="token operator">&gt;</span></span> array<span class="token punctuation"><span class="token punctuation">[</span></span>j <span class="token operator"><span class="token operator">+</span></span> <span class="token number"><span class="token number">1</span></span><span class="token punctuation"><span class="token punctuation">]</span></span><span class="token punctuation"><span class="token punctuation">)</span></span> <span class="token punctuation"><span class="token punctuation">{</span></span>
                    <span class="token function"><span class="token function">swap</span></span><span class="token punctuation"><span class="token punctuation">(</span></span>array<span class="token punctuation"><span class="token punctuation">,</span></span> j<span class="token punctuation"><span class="token punctuation">,</span></span> j <span class="token operator"><span class="token operator">+</span></span> <span class="token number"><span class="token number">1</span></span><span class="token punctuation"><span class="token punctuation">)</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
                    isSorted <span class="token operator"><span class="token operator">=</span></span> <span class="token boolean"><span class="token boolean">false</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
                <span class="token punctuation"><span class="token punctuation">}</span></span>
            <span class="token punctuation"><span class="token punctuation">}</span></span>
            <span class="token keyword"><span class="token keyword">if</span></span> <span class="token punctuation"><span class="token punctuation">(</span></span>isSorted<span class="token punctuation"><span class="token punctuation">)</span></span>
                <span class="token keyword"><span class="token keyword">return</span></span><span class="token punctuation"><span class="token punctuation">;</span></span>
        <span class="token punctuation"><span class="token punctuation">}</span></span>
    <span class="token punctuation"><span class="token punctuation">}</span></span></code></pre> Час роботи: <img data-id="028e0b08-330c-4d2d-9500-c4d5fd19f7f6" data-max-width="850" alt="Огляд та тестування методів сортування.  Частина I - 5" src="https://cdn.javarush.com/images/article/028e0b08-330c-4d2d-9500-c4d5fd19f7f6/800.jpeg" style="width: 850px;">Відчуйте різницю: більше півгодини на мільйон елементів! Висновок: <strong>Ніколи не використовуйте цей алгоритм!</strong>
<h2>Резюме першої частини</h2>Як підсумок пропоную подивитися загальну таблицю цих алгоритмів. <img data-id="60a459c1-70da-41da-b8f8-7f75f3ce273e" data-max-width="850" alt="Огляд та тестування методів сортування.  Частина I - 6" src="https://cdn.javarush.com/images/article/60a459c1-70da-41da-b8f8-7f75f3ce273e/800.jpeg" style="width: 850px;">Можете також порівняти з результатами для вбудованого методу <code class=" language-none">java.util.Arrays.sort()</code>. Схоже на якусь магію — що ж може бути швидшим за Шелла? Про це напишу у наступній частині. Там ми розглянемо широко застосовувані алгоритми швидкого сортування, а також сортування злиттям, дізнаємося про різницю в методах сортування масивів з примітивів і типів посилань, а також познайомимося з дуже важливим у цій справі інтерфейсом. Нижче можете вивчити графік, побудований в логарифмічному масштабі за <code class=" language-none">Comparable</code>даними таблиці. Чим більш порожня йде лінія, тим краще алгоритм =) <img data-id="9b914d14-628a-48b2-80dd-3cb608aec195" data-max-width="850" alt="Огляд та тестування методів сортування.  Частина I - 7" src="https://cdn.javarush.com/images/article/9b914d14-628a-48b2-80dd-3cb608aec195/800.jpeg" style="width: 850px;">Хто хоче скачати весь проект і прогнати тести у себе, тримайте посилання: <a href="https://www.dropbox.com/s/7wof1cq60ixan0i/sort.zip?dl=0" rel="nofollow" target="_blank">Java</a> До зустрічі в наступній частині! =)