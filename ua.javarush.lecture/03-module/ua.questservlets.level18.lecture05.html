<h2>Serial GC</h2>
<p>Складання сміття підвищує ефективність роботи з пам'яттю в Java, так як об'єкти, що не мають посилань, видаляються з купи і звільняється місце для новостворених об'єктів.</p>
<p>Java віртуальна машина має вісім типів збирачів сміття. Розглянемо кожен із них у деталях.</p>
<p><strong>Серійний GC</strong> – це найпростіша реалізація GC. Вона призначена для невеликих програм, що працюють в однопотокових середовищах. Усі події складання сміття виконуються послідовно в одному потоці. Ущільнення виконується після кожного складання сміття.</p><img data-max-width="1024" data-id="3cbe67b6-3553-40cf-90a8-6df5080f300f" alt="Serial GC" src="https://cdn.javarush.com/images/article/3cbe67b6-3553-40cf-90a8-6df5080f300f/1024.jpeg" style="width: 1024px;">
<p>Запуск збирача призводить до події “зупинки миру”, коли вся програма припиняє роботу. Оскільки на час складання сміття вся програма заморожується, не слід вдаватися до такої в реальному житті, якщо потрібно, щоб затримки були мінімальними.</p>
<p>Аргумент JVM для використання послідовного збирача сміття <strong>-XX:+UseSerialGC</strong> .</p>
<h2>Parallel GC</h2>
<p><strong>Паралельний збирач сміття</strong> призначений для додатків із середніми та великими наборами даних, які виконуються на багатопотоковому або багатопроцесорному устаткуванні. Це реалізація GC за замовчуванням і вона також відома як збирач пропускної спроможності.</p>
<p>Декілька потоків призначаються для малого складання сміття в молодому поколінні. Єдиний потік зайнятий основним складанням сміття у старшому поколінні.</p><img data-max-width="1024" data-id="9253feb3-a0e1-4ef0-9696-25926c18df42" alt="Parallel GC" src="https://cdn.javarush.com/images/article/9253feb3-a0e1-4ef0-9696-25926c18df42/1024.jpeg" style="width: 1024px;">
<p>Запуск паралельного GC також викликає “зупинку миру” і програма зависає. Така поведінка більше підходить для багатопотокового середовища, коли потрібно завершити багато завдань і допустимі тривалі паузи, наприклад при виконанні пакетного завдання.</p>
<p>Аргумент JVM для використання паралельного збирача сміття: <strong>-XX:+UseParallelGC</strong> .</p>
<h2>CMS GC</h2>
<p>Також відомий нам як <strong>паралельний збирач низьких пауз</strong> .</p>
<p>Тут для малого складання сміття задіяно кілька потоків, відбувається це через такий самий алгоритм, як і в паралельному збирачі. Основне складання сміття багатопоточне, як і в старому паралельному GC, але CMS працює одночасно з процесами додатків, щоб звести до мінімуму події “зупинки світу”.</p><img data-max-width="1024" data-id="ba41fb23-bd47-4051-8264-a95a9c9849ad" alt="CMS GC" src="https://cdn.javarush.com/images/article/ba41fb23-bd47-4051-8264-a95a9c9849ad/1024.jpeg" style="width: 1024px;">
<p>Через це збирач CMS споживає більше ресурсів процесора, ніж інші збирачі. Якщо у вас є можливість виділити більше ЦП для підвищення продуктивності, то CMS краще, ніж простий паралельний збирач. CMS GC не виконує ущільнення.</p>
<p>Аргумент JVM для використання паралельного збирача сміття з розгорткою міток: <strong>-XX:+UseConcMarkSweepGC</strong> .</p>
<h2>G1 (Garbage first) GC</h2>
<p><strong>G1GC</strong> був задуманий як заміна CMS і розроблявся для багатопотокових додатків, що характеризуються великим розміром купи (більше 4 ГБ). Він паралельний і конкурентний, як CMS, але під капотом працює зовсім інакше, ніж старі збирачі сміття.</p>
<p>Хоча G1 також діє за принципом поколінь, він не має окремих просторів для молодого і старшого поколінь. Натомість кожне покоління є набір областей, що дозволяє гнучко змінювати розмір молодого покоління.</p>
<p>G1 розбиває купу на набір областей однакового розміру (залежно від розміру купи) та сканує їх у кілька потоків. Область під час виконання програми може неодноразово ставати як старою, і молодою.</p>
<p>Після завершення етапу розмітки G1 знає, в яких областях міститься найбільше сміття. Якщо користувач зацікавлений у мінімізації пауз, G1 може вибрати лише кілька областей. Якщо час паузи неважливий для користувача або межа цього часу встановлена ​​висока, G1 пройде по більшій кількості областей.</p>
<p>Оскільки G1 GC ідентифікує регіони з найбільшою кількістю сміття і спочатку виконує збирання сміття в них, він і називається: "Сміття першим".</p><img data-max-width="800" data-id="a2c26fd4-2e6b-4d2c-a646-473db59d44a6" alt="" src="https://cdn.javarush.com/images/article/a2c26fd4-2e6b-4d2c-a646-473db59d44a6/800.jpeg" style="width: 800px;">
<p>Крім областей Едему, що вижабо та Старої пам'яті, в G1GC присутні ще два типи.</p>
<ul>
 <li><strong>Humongous</strong> (Велика) – для об'єктів великого розміру (понад 50% розміру купи).</li>
 <li><strong>Available</strong> (Доступна) — простір, що не використовується або не виділений.</li>
</ul>
<p>Аргумент JVM для використання збирача сміття G1: <strong>-XX:+UseG1GC</strong> .</p>
<h2>Shenandoah (Шандара)</h2>
<p><strong>Shenandoah</strong> - новий GC, випущений як частина JDK 12. Ключова перевага Shenandoah перед G1 полягає в тому, що більшість циклу складання сміття виконується одночасно з потоками додатків. G1 може евакуювати області купи тільки тоді, коли програма припинена, а Shenandoah переміщає об'єкти одночасно з додатком.</p>
<p>Shenandoah може компактувати живі об'єкти, очищати сміття та звільняти оперативну пам'ять майже відразу після виявлення вільної пам'яті. Оскільки все це відбувається одночасно, без припинення роботи програми, то Shenandoah більш інтенсивно навантажує процесор.</p><o>
 Аргумент JVM для збирача сміття Шенандоа: 
 <strong>-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC</strong> .
 <p></p>
 <h2>ZGC</h2>
 <p><strong>ZGC</strong> - ще один GC, випущений як частина JDK 11 і покращений JDK 12.</p>
 <p>Він призначений для додатків, які вимагають швидкодії та низької затримки (паузи менш ніж 10 мс) та/або задіяють дуже велику купу (кілька терабайт).</p>
 <p>Основні цілі ZGC - низька затримка, масштабованість та простота в застосуванні. Для цього він дозволяє Java-додатку продовжувати роботу, незважаючи на те, що виконуються операції зі збору сміття. За умовчанням ZGC звільняє пам'ять, що не використовується, і повертає її в операційну систему.</p>
 <p>Таким чином, ZGC приносить значне поліпшення порівняно з іншими традиційними GC, забезпечуючи надзвичайно низький час паузи (зазвичай у межах 2 мс).</p>
 <img data-max-width="512" data-id="3ca77686-5b92-46ad-ab67-f8623caa9c71" alt="Основні цілі ZGC " src="https://cdn.javarush.com/images/article/3ca77686-5b92-46ad-ab67-f8623caa9c71/512.jpeg" style="width: 512px;">
 <p>Аргумент JVM для використання збирача сміття ZGC: <strong>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</strong> .</p>
</o>