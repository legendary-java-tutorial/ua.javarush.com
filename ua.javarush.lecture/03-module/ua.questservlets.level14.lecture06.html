<h2>Ієрархічна декомпозиція</h2>
<p>Ніколи не варто відразу починати писати класи вашої програми. Спершу його треба спроектувати. Проектування має закінчитись продуманою архітектурою. І щоб одержати цю архітектуру, тобі потрібно послідовно виконати декомпозицію системи.</p>
<p>Декомпозицію треба проводити ієрархічно - спочатку систему розбивають на великі функціональні модулі/підсистеми, що описують її роботу в загальному вигляді. Потім отримані модулі аналізуються більш детально і поділяються на підмодулі чи об'єкти.</p>
<p>Перед тим як виділяти об'єкти, розділіть систему на основні смислові блоки хоча б подумки. У невеликих додатках зазвичай це дуже просто: пару рівнів ієрархії буває цілком достатньо, оскільки система спочатку ділиться на підсистеми/пакети, а пакети діляться на класи.</p><img data-max-width="800" data-id="ab05085b-576e-4306-8d95-24ef33eb86c9" alt="Ієрархічна декомпозиція" src="https://cdn.javarush.com/images/article/ab05085b-576e-4306-8d95-24ef33eb86c9/800.jpeg" style="width: 800px;">
<p>Ця думка не така банальна, як здається. Наприклад, у чому полягає суть такого поширеного "архітектурного шаблону" як Модель-Вид-Контролер (MVC)?</p>
<p>Всього лише у <span class="text-bold">відділенні уявлення від бізнес-логіки</span> . Спочатку будь-який додаток користувача ділиться на два модулі - один відповідає за реалізацію самої бізнес логіки (Модель), а другий - за взаємодію з користувачем (Інтерфейс користувача або Подання).</p>
<p>Потім з'ясовується, що модулі повинні взаємодіяти, для цього в них додають Контролер, завдання якого керувати взаємодією модулів. Також у мобільній (класичній) версії MVC до нього додають патерн Спостерігач, щоб View міг отримувати події з моделі та змінювати відображені дані в реальному часі.</p>
<p>Типовими модулями верхнього рівня, отриманими в результаті першого поділу системи на найбільші складові частини, якраз і є:</p>
<ul>
 <li>Бізнес-логіка;</li>
 <li>Користувальницький інтерфейс;</li>
 <li>База даних;</li>
 <li>Система обміну повідомленнями;</li>
 <li>Контейнер об'єктів.</li>
</ul>
<p>При першому розбиття зазвичай вся програма розбивається на 2-7 (максимум 10 частин). Якщо розбити більшу кількість частин, потім виникне бажання їх згрупувати, і ми отримаємо знову-таки 2-7 модулів верхнього рівня.</p>
<h2>Функціональна декомпозиція</h2>
<p>Розподіл на модулі/підсистеми найкраще проводити <span class="text-green">з тих завдань, які вирішує система</span> . Основне завдання розбивається на складові підзавдання, які можуть вирішуватися/виконуватися автономно, незалежно один від одного.</p>
<p>Кожен модуль повинен відповідати за вирішення якоїсь підзадачі та виконувати відповідну їй <span class="text-bold">функцію</span> . Крім функціонального призначення модуль характеризується також набором даних, необхідних для виконання його функції, тобто:</p>
<p><span class="text-bold">Модуль = Функція + Дані</span> , необхідні її виконання.</p>
<p>Якщо декомпозиція на модулі виконана правильно, то взаємодія з іншими модулями (що відповідають інші функції) буде мінімальною. Воно може бути, але його відсутність не повинна бути критично важливою для вашого модуля.</p>
<p><span class="text-green">Модуль - це не довільний шматок коду, а окрема функціонально осмислена та закінчена програмна одиниця (підпрограма), яка забезпечує вирішення деякого завдання та в ідеалі може працювати самостійно або в іншому оточенні та бути перевикористовуваною. Модуль має бути якоюсь "цілісністю, здатною до відносної самостійності в поведінці та розвитку". </span>(Крістофер Александер)</p>
<p>Отже, грамотна декомпозиція грунтується, передусім, на <span class="text-bold">аналізі функцій</span> системи та необхідні виконання цих функцій даних. Функції в цьому випадку – це не функції класу та модулі, адже це не об'єкти. Якщо у тебе в модулі всієї пари класів, значить ти перестарався.</p>
<h2>Сильна та слабка зв'язність</h2>
<p>Дуже важливо не перестаратися із розбиттям на модулі. Якщо дати новачкові монолітне Spring-додаток і попросити розбити його на модулі, то він винесе кожен Spring Bean в окремий модуль і вважатиме, що його робота закінчена. Але це не так.</p>
<p><span class="text-green">Головним критерієм якості декомпозиції є те, наскільки модулі сфокусовані на вирішенні своїх завдань та є незалежними.</span></p>
<p><span class="text-neon">Зазвичай це формулюють так: "Модулі, отримані в результаті декомпозиції, повинні бути максимально пов'язані всередині (high internal cohesion) і мінімально пов'язані один з одним (low external coupling)."</span></p>
<p><span class="text-bold">High Cohesion, висока сполученість</span> або "згуртованість" усередині модуля, говорить про те, що модуль сфокусований на вирішенні однієї вузької проблеми, а не займається виконанням різнорідних функцій або незв'язаних між собою обов'язків.</p>
<p>Сполученість - cohesion, характеризує ступінь, в якій завдання, що виконуються модулем, пов'язані один з одним.</p>
<p>Наслідком High Cohesion є <span class="text-bold">принцип єдиної відповідальності</span> ( <span class="text-green">Single Responsibility Principle — перший із п'яти принципів SOLID</span> ), згідно з яким будь-який об'єкт/модуль повинен мати лише один обов'язок і не має бути більше однієї причини для його зміни.</p>
<p><span class="text-bold">Low Coupling</span> , слабка пов'язаність, означає, що модулі, на які розбивається система, повинні бути, по можливості, <span class="text-bold">незалежні</span> або слабо пов'язані один з одним. Вони повинні мати можливість взаємодіяти, але при цьому якнайменше знати один про одного.</p>
<p>Кожен модуль не повинен знати, як влаштований інший модуль, якою мовою він написаний і як він працює. Часто для організації взаємодії таких модулів використовують якийсь контейнер, який ці модулі і завантажуються.</p>
<p>При правильному проектуванні, при зміні одного модуля не доведеться правити інші або ці зміни будуть мінімальними. Чим слабша пов'язаність, тим легше писати/розуміти/розширювати/лагодити програму.</p>
<p>Вважається, що добре спроектовані модулі повинні мати такі властивості:</p>
<ul>
 <li><span class="text-bold">Функціональна цілісність і завершеність</span> - кожен модуль реалізує одну функцію, але реалізує добре і повністю, модуль самостійно виконує повний набір операцій для реалізації своєї функції.</li>
 <li><span class="text-bold">Один вхід і один вихід</span> - на вході програмний модуль отримує певний набір вихідних даних, виконує змістовну обробку та повертає один набір результатних даних, тобто реалізується стандартний принцип IPO - вхід-&gt;процес-&gt;вихід.</li>
 <li><span class="text-bold">Логічна незалежність</span> — результат роботи програмного модуля залежить від вихідних даних, але з залежить від роботи інших модулів.</li>
 <li><span class="text-bold">Слабкі інформаційні зв'язки з іншими модулями</span> - обмін інформацією між модулями має бути, по можливості, мінімізований.</li>
</ul>
<p>Новачку дуже складно зрозуміти, як знизити зв'язність модулів ще сильніше. Частково це знання приходить із досвідом, частково після читання розумних книг. Але найкраще допомагає аналіз архітектур існуючих додатків.</p>
<h2>Композиція замість успадкування</h2>
<p>Грамотна декомпозиція - це своєрідне мистецтво і складне завдання для більшості програмістів. Простота тут оманлива, а помилки коштують дорого.</p><img data-max-width="512" data-id="eaa5a7c9-4bb0-4c8f-8e73-97a82484f23b" alt="" src="https://cdn.javarush.com/images/article/eaa5a7c9-4bb0-4c8f-8e73-97a82484f23b/512.jpeg" style="width: 512px;">
<p>Буває, що виділені модулі виявляються сильно зчеплені один з одним, і їх не вдається розробляти незалежно. Або не зрозуміло за яку функцію кожен із них відповідає. Якщо ти зіткнувся зі схожою проблемою, то швидше за все розбиття на модулі неправильно.</p>
<p>Завжди має бути зрозуміло, <span class="text-green">яку роль виконує кожний модуль</span> . Найнадійніший критерій того, що декомпозиція робиться правильно, це якщо модулі виходять самостійними та цінними підпрограмами, які можуть бути використані у відриві від решти програми (а значить, можуть бути перевикористовувані).</p>
<p>Роблячи декомпозицію системи, бажано перевіряти її якість, задаючи собі питання: "Яке завдання виконує кожен модуль?", "Наскільки модулі легко тестувати?", "Чи можливо використовувати модулі самостійно або в іншому оточенні?", "Як сильно зміни в одному модулі позначаться інших?”.</p>
<p>Потрібно намагатися, щоб модулі були гранично <span class="text-bold">автономними</span> . Як було сказано раніше, це <span class="text-green">є ключовим параметром правильної декомпозиції</span> . Тому проводити її потрібно таким чином, щоб модулі спочатку слабко залежали один від одного. Якщо це в тебе вийшло, то молодець.</p>
<p>Якщо ні, то тут також не все втрачено. Є ряд спеціальних технік та шаблонів, що дозволяють додатково мінімізувати та послабити зв'язки між підсистемами. Наприклад, у випадку MVC для цієї мети використовувався шаблон "Спостерігач", але можливі інші рішення.</p>
<p>Можна сміливо сказати, що техніки зменшення пов'язаності, таки становлять основний “інструментарій архітектора”. Тільки необхідно розуміти, що йдеться про всі підсистеми і <span class="text-bold">послаблювати пов'язаність потрібно на всіх рівнях ієрархії</span> , тобто не тільки між класами, але також між модулями на кожному ієрархічному рівні.</p>