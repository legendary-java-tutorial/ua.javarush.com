<h2>Заміна прямих залежностей на обмін повідомленнями</h2>
<p>Іноді модулю потрібно лише сповістити інших про те, що в ньому відбулися якісь події/зміни і йому не важливо, що з цією інформацією відбуватиметься потім.</p>
<p>У цьому випадку модулям зовсім немає необхідності "знати один про одного", тобто містити прямі посилання і взаємодіяти безпосередньо, а достатньо лише обмінюватися повідомленнями (messages) або подіями (events).</p>
<p>Іноді здається, що зв'язок модулів через обмін повідомленнями є набагато слабшим, ніж пряма залежність. Справді, адже методи не викликаються, інформації про класи немає. Але це не більше ніж ілюзія.</p>
<p>Замість імен методів логіка починає прив'язуватися до типів повідомлень, їх параметрів і даних, що передаються. <span class="text-red">Зв'язок таких модулів розмазується.</span></p>
<p>Раніше було як: викликаємо методи – є зв'язність, не викликаємо методи – немає зв'язності. А тепер уяви, що модуль A став надсилати трохи інші дані у своїх повідомленнях. І при цьому всі залежні від цих повідомлень модулі працюватимуть неправильно.</p>
<p>Допустимо, раніше, при додаванні нового користувача модуль авторизації надсилав повідомлення <span class="text-bold">USER_ADDED, а після апдейту він почав надсилати це повідомлення при спробі реєстрації та додатково в параметрах вказувати успішна реєстрація чи ні.</span></p>
<p>Тому дуже важливо реалізовувати механізм повідомлень дуже грамотно. І тому є різні шаблони.</p>
<p><span class="text-bold">Спостерігач (Observer). </span>Застосовується у разі залежності "один-багатьом", коли безліч модулів залежать від стану одного - основного. Використовує механізм розсилки, який полягає в тому, що основний модуль просто розсилає однакові повідомлення всім своїм передплатникам, а модулі, зацікавлені в цій інформації, реалізують інтерфейс “передплатника” і підписуються на розсилку.</p>
<p>Цей підхід знаходить широке застосування в системах з інтерфейсом користувача, дозволяючи ядру програми (моделі) залишатися незалежним і при цьому інформувати пов'язані з ним інтерфейси про те, що відбулися якісь зміни і потрібно оновитися.</p>
<p>Тут формат повідомлень стандартизується лише на рівні операційної системи, розробники якої мають подбати про зворотної сумісності та хорошої документації.</p>
<p>Організація взаємодії у вигляді розсилки повідомлень має додатковий “бонус” — необов'язковість існування “передплатників” на “опубліковані” (тобто розсилаються) повідомлення. Якісно спроектована подібна система допускає додавання/видалення модулів у будь-який час.</p>
<h2>Шина обміну повідомленнями</h2>
<p>Можна організувати обмін повідомленнями та по-іншому використовувати для цього патерн <span class="text-bold">Посередник (Mediator)</span> .</p>
<p>Він застосовується, коли між модулями є залежність "багато хто до багатьох". Медіатор виступає як посередник у спілкуванні між модулями, діючи як центр зв'язку і позбавляє модулі необхідності явно посилатися один на одного.</p>
<p>Через війну взаємодія модулів друг з одним (“все з усіма”) замінюється взаємодією модулів лише з посередником (“один із усіма”). Говорять, що посередник інкапсулює взаємодію між безліччю модулів.</p><img data-max-width="1024" data-id="68cdf298-e0c1-40cf-8e0e-afb3508ae104" alt="Шина обміну повідомленнями" src="https://cdn.javarush.com/images/article/68cdf298-e0c1-40cf-8e0e-afb3508ae104/1024.jpeg" style="width: 1024px;">
<p>Це так званий <span class="text-bold">розумний посередник</span> . Саме там найчастіше розробники починають додавати свої мабоці, ніж впливають на поведінку окремих модулів через включення/вимкнення отримання певних повідомлень.</p>
<p>Типовий приклад із життя – контроль трафіку в аеропорту. Всі повідомлення, що походять від літаків, надходять у вежу управління диспетчеру замість того, щоб пересилатися між літаками безпосередньо. А диспетчер вже приймає рішення про те, які літаки можуть злітати чи сідати, і, своєю чергою, надсилає літакам відповідні повідомлення.</p>
<p><span class="text-bold"><span class="text-red">Важливо! </span></span>Модулі можуть пересилати один одному не лише прості повідомлення, а й об'єкти-команди. Така взаємодія описується шаблоном Команда (<span class="text-bold"> Command</span> ). Суть полягає в інкапсулюванні запиту виконання певної дії у вигляді окремого об'єкта.</p>
<p>Фактично цей об'єкт містить один єдиний метод <span class="code text-orange">execute()</span> , що дозволяє потім передавати цю дію іншим модулям виконання як параметр і взагалі проводити з об'єктом-командою будь-які операції, які можуть бути зроблені над звичайними об'єктами.</p>
<h2>Закон Деметри (Law of Demeter)</h2>
<p><a href="https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD_%D0%94%D0%B5%D0%BC%D0%B5%D1%82%D1%80%D1%8B" target="_blank">Закон Деметри</a> забороняє використання неявних залежностей: "Об'єкт A не повинен мати можливість отримати безпосередній доступ до об'єкта C, якщо об'єкт A має доступ до об'єкта B і об'єкт B має доступ до об'єкта C".</p>
<p>Це означає, що всі залежності в коді мають бути "явними" - класи/модулі можуть використовувати в роботі лише "свої залежності" і не повинні лізти через них до інших. Хороший приклад – це трирівнева архітектура. Рівень інтерфейсу повинен працювати з рівнем логіки, але не повинен взаємодіяти безпосередньо з рівнем бази даних.</p>
<p>Коротко цей принцип формулюють ще таким чином: "Взаємодія тільки з безпосередніми друзями, а не з друзями друзів". Тим самим досягається менша зв'язаність коду, а також більша наочність та прозорість його дизайну.</p>
<p>Закон Деметри реалізує вже згадуваний "принцип мінімального знання", що є основою слабкої зв'язаності і полягає в тому, що об'єкт/модуль повинен знати якнайменше деталей про структуру та властивості інших об'єктів/модулів і взагалі завгодно, включаючи власні <span class="text-bold">компоненти</span> .</p>
<p>Аналогія з життя: якщо ти хочеш, щоб собака побіг, безглуздо командувати її лапами, краще віддати команду собаці, а вона вже розбереться зі своїми лапами сама.</p>
<h2>Композиція замість успадкування</h2>
<p>Це дуже велика та цікава тема і вона варта як мінімум окремої лекції. На цю тему в інтернеті було зламано чимало копій, поки не було досягнуто консенсусу — успадкування використовуємо за мінімумом, композицію — по максимуму.</p>
<p>Вся справа в тому, що успадкування дає фактично найсильніший зв'язок між класами, тому його слід уникати. Ця тема добре розкрита у статті Герба Саттера - " <a href="http://programming-lang.com/ru/comp_programming/satter/0/j84.html" target="_blank">Вважайте за краще композицію успадкування</a> ".</p>
<p>Коли ти почнеш вивчати патерни проектування, зіткнешся з цілою купою патернів, які керують створенням об'єкта або його внутрішнім пристроєм. До речі, можу порадити в даному контексті звернути увагу на шаблон <span class="text-bold">Делегат (Delegation/Delegate)</span> і шаблон <span class="text-bold">Компонент (Component)</span> , що прийшов з ігор .</p>
<p>Детальніше про патерни ми поговоримо трохи згодом.</p>