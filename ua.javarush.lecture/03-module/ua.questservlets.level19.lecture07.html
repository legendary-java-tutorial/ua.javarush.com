<h2>ReentrantLock</h2><img data-max-width="1024" data-id="ee2cd199-b06a-4310-93c0-67f113b8ba93" alt="" src="https://cdn.javarush.com/images/article/ee2cd199-b06a-4310-93c0-67f113b8ba93/1024.jpeg" style="width: 1024px;">
<p><span class="text-neon"><span class="text-bold"><em>Condition</em></span></span> — застосування умов блокування дозволяє добитися контролю над керуванням доступу до потоків. Умова блокування є об'єктом інтерфейсу<span class="text-neon"><span class="text-bold"><em> Condition</em></span></span> з пакету<strong>java.util.concurrent.locks</strong>. Застосування об'єктів<span class="text-neon"><span class="text-bold"><em> Condition</em></span></span> багато в чому аналогічне використанню методів<span class="code text-orange">wait</span>/<span class="code text-orange">notify</span>/<span class="code text-orange">notifyAll</span>класу<span class="code"><span class="text-green"> Object</span></span> , які були розглянуті в одній з минулих тем.</p>
<p><span class="text-neon"><span class="text-bold"><em>Lock</em></span></span> — інтерфейс із<strong>lock framework</strong>, що надає гнучкий підхід щодо обмеження доступу до ресурсів/блоків у порівнянні з synchronized. При використанні кількох локів порядок їхнього звільнення може бути довільним, плюс його також можна налаштувати. Ще є можливість обробити ситуацію, коли лок вже захоплено.</p>
<p><span class="code"><span class="text-green">ReentrantLock</span></span> - одна з реалізацій інтерфейсу<span class="text-neon"><span class="text-bold"><em> Lock</em></span></span> - клас<span class="code"><span class="text-green"> ReenterantLock</span></span> . Він дозволяє одному й тому потоку викликати метод lock, навіть якщо він його викликав раніше, без звільнення блокування.</p>
<p>У класу <span class="code"><span class="text-green">ReentrantLock</span></span> , крім методів інтерфейсу <span class="text-neon"><span class="text-bold"><em>Lock</em></span></span> , є фабричний метод <span class="code text-orange">newCondition()</span> . Цей метод повертає об'єкт<mark class="green">Condition</mark>, який дозволяє додати поточний потік у wait set даного об'єкта<mark class="green">Condition</mark>.</p>
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Lock</span> R_LOCK <span class="token operator">=</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
R_LOCK<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
   <span class="token comment">//тут відбуваються якісь дії</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
   R_LOCK<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><span class="text-neon"><span class="text-bold"><em>ReadWriteLock</em></span></span> — інтерфейс створення read/write локов. Локи надзвичайно корисні, коли в системі багато операцій читання та мало операцій запису.</p>
<p><span class="code"><span class="text-green">ReentrantReadWriteLock</span></span> - використовується в багатопотокових сервісах і кешах, мають гарний приріст продуктивності в порівнянні з блоками synchronized. По суті, клас працює в 2-х взаємовиключних режимах: багато читачів читають дані в паралель і коли лише один райтер пише дані.</p>
<p>ReentrantReadWriteLock.ReadLock - read lock для reader'ів, що отримується через readWriteLock.readLock().</p>
<p>ReentrantReadWriteLock.WriteLock — write lock для writer'ів, одержуваний через readWriteLock.writeLock().</p>
<h2>Synchronizer</h2><img data-max-width="512" data-id="cb9ae844-7dce-459b-b8af-55a1830c5fb1" alt="" src="https://cdn.javarush.com/images/article/cb9ae844-7dce-459b-b8af-55a1830c5fb1/512.jpeg" style="width: 512px;">
<p><span class="code"><span class="text-green">AbstractOwnableSynchronizer</span></span> — базовий клас, який відповідає за побудову механізмів синхронізації. Містить геттер/сетер для запам'ятовування та читання ексклюзивного потоку, який може працювати з вашими даними.</p>
<p><span class="code"><span class="text-green">AbstractQueuedSynchronizer</span></span> — базовий клас для механізму синхронізації у FutureTask, CountDownLatch, Semaphore, ReentrantLock, ReentrantReadWriteLock. Також він застосовується при створенні нових механізмів синхронізації, що покладаються на одиночне та атомарне значення int.</p>
<p><span class="code"><span class="text-green">AbstractQueuedLongSynchronizer</span></span> - різновид<span class="code"><span class="text-green"> AbstractQueuedSynchronizer</span></span> , що підтримує атомарне значення long.</p>