<h2>2.1 State</h2>
<p><strong>Стан (State)</strong> – поведінковий шаблон проектування. Використовується в тих випадках, коли під час виконання програми об'єкт повинен змінювати свою поведінку залежно від стану.</p><img data-max-width="800" data-id="643b446c-be6c-4841-a190-37ccdec4fd71" alt="Стан (State)" src="https://cdn.javarush.com/images/article/643b446c-be6c-4841-a190-37ccdec4fd71/800.jpeg" style="width: 800px;">
<p>Паттерн складається із 3 блоків:</p>
<p>Context - клас, об'єкти якого повинні змінювати свою поведінку залежно від стану.</p>
<p>State — інтерфейс, який має реалізувати кожен із конкретних станів. Через цей інтерфейс об'єкт Context взаємодіє зі станом, делегуючи виклики методів. Інтерфейс повинен містити засоби для зворотного зв'язку з об'єктом, поведінку якого необхідно змінити.</p>
<p>Для цього використовується <strong>подія</strong> (паттерн Publisher - Subscriber). Це необхідно для того, щоб у процесі виконання програми замінювати об'єкт стану з появою подій. Можливі випадки коли сам Context періодично опитує об'єкт стану на наявність переходу.</p>
<p>ConcreteState1, ConcreteState2 - класи конкретних станів. Повинні містити інформацію про те, за яких умов і стани може переходити об'єкт з поточного стану. Наприклад, з ConcreteState1 об'єкт може переходити в стан ConcreteState2 і ConcreteState3, а з ConcreteState2 - назад у ConcreteState1 і так далі. Об'єкт одного з них повинен містити Context під час створення.</p>
<p>Наприклад, ти пишеш гру, де персонаж може бігати, плавати та літати. Якщо твій персонаж потрапив у воду, то розумно обмежити його поведінку у воді: він тепер не може стріляти, але в нього збереглися якісь дії: плисти вперед, праворуч, ліворуч тощо.</p>
<p>Стан твого персонажа можна описати об'єктом State, який має методи, які можна викликати і які щось робити. І після того, як твій персонаж заліз у воду, ти просто змінюєш у нього всередині посилання на інший об'єкт State і він змінює свій стан.</p>
<h2>2.2 Strategy</h2>
<p><strong>Стратегія (Strategy)</strong> - поведінковий шаблон проектування, призначений для визначення сімейства алгоритмів, інкапсуляції кожного з них та забезпечення їх взаємозамінності. Це дозволяє вибирати алгоритм шляхом визначення відповідного класу.</p>
<p>Шаблон Strategy дозволяє змінювати обраний алгоритм незалежно від об'єктів-клієнтів, що його використовують.</p><img data-max-width="800" data-id="aba01b4f-cb28-4f98-849d-5df79c83f61f" alt="Стратегія (Strategy)" src="https://cdn.javarush.com/images/article/aba01b4f-cb28-4f98-849d-5df79c83f61f/800.jpeg" style="width: 800px;">
<p>Стратегія Паттерн дозволяє використовувати різні бізнес-правила або алгоритми в залежності від контексту. Застосовується у випадках, коли в тому самому місці в залежності від поточного стану системи (або її оточення) повинні використовуватися різні алгоритми.</p>
<p><strong>Сильні сторони:</strong></p>
<ul>
 <li>інкапсуляція реалізації різних алгоритмів; система стає незалежною від можливих змін бізнес-правил;</li>
 <li>виклик всіх алгоритмів одним стандартним чином;</li>
 <li>відмова від використання перемикачів та/або умовних операторів.</li>
</ul>
<p>Цей патерн чимось схожий на патерн State, проте тут акцент зроблено не на стан, а на поведінку. Допустимо, персонаж у твоїй грі може змінювати зброю. Тоді при зміні зброї можна просто поміняти посилання на об'єкт, який описує, як ця зброя працює.</p>
<h2>2.3 Template Method</h2><img data-max-width="800" data-id="2e185d04-7701-4c65-a4ce-ba3c52449afb" alt="Template Method" src="https://cdn.javarush.com/images/article/2e185d04-7701-4c65-a4ce-ba3c52449afb/800.jpeg" style="width: 800px;">
<p><strong>Abstract class</strong> (абстрактний клас) - визначає абстрактні операції, що заміщуються у спадкоємцях для реалізації кроків алгоритму; реалізує шаблонний метод, що визначає скелет алгоритму. Шаблонний метод викликає заміщувані та інші, визначені в Abstract class, операції.</p>
<p><strong>Concrete class</strong> (конкретний клас) - реалізує заміщувані операції необхідним для реалізації способом. Concrete class передбачає, що інваріантні кроки алгоритму будуть виконані в AbstractClass.</p>
<p>Цей патерн часто використовується, коли треба:</p>
<ul>
 <li>Одноразове використання інваріантної частини алгоритму з залишенням частини, що змінюється на розсуд спадкоємцям.</li>
 <li>Локалізація та вичленування загального для кількох класів коду для уникнення дублювання.</li>
 <li>Дозвіл розширення коду спадкоємцями лише у певних місцях.</li>
</ul>
<p>Так, цей патерн визначає використання пари: абстрактний клас та її реалізація.</p>
<h2>2.4 Chain of Responsibility</h2>
<p><strong>Ланцюжок обов'язків (Chain of responsibility)</strong> - поведінковий шаблон проектування, призначений для організації в системі рівнів відповідальності</p><img data-max-width="800" data-id="6567c227-7bcc-425e-83ac-2fee211fea97" alt="Ланцюжок обов'язків (Chain of responsibility)" src="https://cdn.javarush.com/images/article/6567c227-7bcc-425e-83ac-2fee211fea97/800.jpeg" style="width: 800px;">
<p>Шаблон рекомендований для використання в умовах, коли:</p>
<ul>
 <li>у системі, що розробляється, є група об'єктів, які можуть обробляти повідомлення певного типу;</li>
 <li>всі повідомлення мають бути оброблені хоча б одним об'єктом системи;</li>
 <li>повідомлення у системі обробляються за схемою “оброби сам чи перейшли іншому”, тобто одні повідомлення обробляються тому рівні, де вони отримані, інші пересилаються об'єктам іншого рівня.</li>
</ul>
<h2>2.5 Memento</h2>
<p><strong>Зберігач (Memento)</strong> - поведінковий шаблон проектування, що дозволяє не порушуючи інкапсуляцію зафіксувати та зберегти внутрішній стан об'єкта так, щоб пізніше відновити його в цей стан.</p><img data-max-width="800" data-id="251fd61c-5a0a-4626-b206-e09129af58ad" alt="Зберігач (Memento)" src="https://cdn.javarush.com/images/article/251fd61c-5a0a-4626-b206-e09129af58ad/800.jpeg" style="width: 800px;">
<p>Шаблон Зберігач використовується, коли:</p>
<ul>
 <li>необхідно зберегти знімок стану об'єкта (або його частини) для подальшого відновлення;</li>
 <li>прямий інтерфейс отримання стану об'єкта розкриває деталі реалізації та порушує інкапсуляцію об'єкта.</li>
</ul>