<h2>Згадуємо, що таке складання сміття в Java</h2>
<p>Складання сміття - це процес відновлення заповненої пам'яті середовища виконання шляхом знищення об'єктів, що не використовуються.</p>
<p>Іноді програміст може забути знищити непотрібні об'єкти, і виділена ним пам'ять не звільняється. Витрачається дедалі більше системної пам'яті, і зрештою вона більше виділяється. Такі програми страждають від “відпливу пам'яті”.</p>
<p>Після певного моменту пам'яті вже не вистачає для створення нових об'єктів і програма завершується через <span class="text-red"><span class="text-bold">OutOfMemoryError</span></span> .</p><img data-max-width="800" data-id="3000851c-d7b0-48c1-a1b0-42fc199942d5" alt="" src="https://cdn.javarush.com/images/article/3000851c-d7b0-48c1-a1b0-42fc199942d5/800.jpeg" style="width: 800px;">
<p>Складання сміття в Java - це процес, за допомогою якого програми Java автоматично керують пам'яттю. Java-програми компілюються в байт-код, який запускається на віртуальній машині Java (JVM).</p>
<p>Коли Java-програми виконуються на JVM, об'єкти створюються у купі, яка є частиною пам'яті, виділену їм.</p>
<p>Поки Java-програма працює, в ній створюються нові об'єкти. Зрештою, деякі об'єкти перестають бути потрібними. Можна сказати, що будь-якої миті часу пам'ять купи складається з двох типів об'єктів.</p>
<ul>
 <li><strong>Живі</strong> — ці об'єкти використовуються, на них посилаються ще звідкись.</li>
 <li><strong>Мертві</strong> ці об'єкти більше ніде не використовуються, посилань на них немає.</li>
</ul>
<p>Складальник сміття знаходить ці об'єкти, що не використовуються, і видаляє їх, щоб звільнити пам'ять.</p>
<p>Складання сміття в Java - <strong>автоматичний процес</strong> . Програмістові не потрібно явно відзначати об'єкти, що підлягають видаленню.</p>
<p>Кожна JVM може реалізувати власну версію складання сміття. Однак збирач повинен відповідати стандартній специфікації JVM для роботи з об'єктами, що є у пам'яті купи, для маркування або ідентифікації недосяжних об'єктів та їх знищення через ущільнення.</p>
<h2>Досяжність об'єктів</h2>
<p>Щоб визнати об'єкт живим — наявності посилань недостатньо. Все тому, що одні мертві об'єкти можуть посилатися інші мертві об'єкти. Саме тому потрібно, щоб серед усіх посилань на об'єкт була хоча б одна від “живого” об'єкта.</p><img data-max-width="800" data-id="eb12b7bc-7401-440e-a551-9b4461ba3b5d" alt="Досяжність об'єктів" src="https://cdn.javarush.com/images/article/eb12b7bc-7401-440e-a551-9b4461ba3b5d/800.jpeg" style="width: 800px;">
<p>Складачі сміття працюють з концепцією GC Roots ( <strong>коренів збору сміття</strong> ) у тому, щоб розрізняти живі і мертві об'єкти. Є 100% живих об'єктів і від них йдуть посилання, які пожвавлюють інші об'єкти і так далі.</p>
<p>Приклади такого коріння:</p>
<ul>
 <li>Класи, які завантажуються системним завантажувачем класів.</li>
 <li>Живі потоки.</li>
 <li>Параметри методів, які виконуються на даний момент та локальні змінні.</li>
 <li>Об'єкти, які застосовуються як монітор для синхронізації.</li>
 <li>Об'єкти, які утримуються зі складання сміття для деяких цілей.</li>
 <li>Складальник сміття переглядає весь граф об'єктів у пам'яті, починаючи з цього коріння і слідуючи посиланням на інші об'єкти.</li>
</ul>
<h2>Етапи складання сміття в Java</h2>
<p>Стандартна реалізація складання сміття має три етапи.</p>
<h4>1. Позначаємо об'єкти як живі</h4>
<p>На цьому етапі збирач сміття повинен ідентифікувати всі живі об'єкти в пам'яті шляхом обходу графа об'єктів.</p>
<p>Коли він відвідує об'єкт, то позначає його як доступний і, отже, живий. Усі об'єкти, недоступні з коріння GC, розглядаються як кандидати на збирання сміття.</p><img data-max-width="800" data-id="483e8406-ce8f-458a-8217-c6c2e2c70b2c" alt="" src="https://cdn.javarush.com/images/article/483e8406-ce8f-458a-8217-c6c2e2c70b2c/800.jpeg" style="width: 800px;">
<h4>2. Зачистка мертвих об'єктів</h4>
<p>Після фази розмітки простір пам'яті зайнятий або живими (відвіданими) або мертвими (не відвіданими) об'єктами. Фаза зачистки звільняє фрагменти пам'яті, які містять мертві об'єкти.</p><img data-max-width="800" data-id="f10e166d-d9bf-462d-9d65-2c81df1b3457" alt="" src="https://cdn.javarush.com/images/article/f10e166d-d9bf-462d-9d65-2c81df1b3457/800.jpeg" style="width: 800px;">
<h4>3. Компактне розташування об'єктів, що залишабося в пам'яті</h4>
<p>Не обов'язково, щоб мертві об'єкти, які були видалені на попередній фазі, були поруч один з одним. Таким чином, ти ризикуєш отримати фрагментований (напівпорожній) простір пам'яті.</p>
<p>Але, звичайно, передбачивши це, є можливість ущільнити пам'ять у момент, коли збирач сміття видаляє мертві об'єкти. Ті, хто залишився, будуть розташовуватися в безперервному блоці на початку купи.</p>
<p>Процес ущільнення полегшує послідовне виділення пам'яті нових об'єктів.</p><img data-max-width="800" data-id="7008ce12-e886-44e5-8812-8431b4f7c741" alt="" src="https://cdn.javarush.com/images/article/7008ce12-e886-44e5-8812-8431b4f7c741/800.jpeg" style="width: 800px;">