<h2>9.1 Dependency Inversion</h2>
<p>Пам'ятаєш, ми колись говорабо, що в серверній програмі не можна просто так створювати потоки через <code>new Thread().start()</code>? Потоки повинен створювати лише контейнер. Тепер ми розвинемо цю думку ще сильніше.</p>
<p><span class="text-green">Усі об'єкти теж повинен створювати лише контейнер</span> . Звичайно, не йдеться про всі об'єкти, а скоріше про так звані бізнес-об'єкти. Їх часто називають бінами. Ноги цього підходу ростуть з п'ятого принципу SOLID, який вимагає позбавлятися класів і переходити на інтерфейси:</p>
<ul>
 <li>Модулі верхнього рівня повинні залежати від модулів нижнього рівня. І ті, й інші мають залежати від абстракцій.</li>
 <li>Абстракції не повинні залежати від деталей. Реалізація має залежати від абстракції.</li>
</ul>
<p>Модулі не повинні містити посилання на конкретні реалізації, а всі залежності та взаємодія між ними мають будуватися виключно на основі абстракцій (тобто інтерфейсів). Саму суть цього правила можна записати однією фразою: <span class="text-red">всі залежності мають бути у вигляді інтерфейсів</span> .</p>
<p>Незважаючи на свою фундаментальність і простоту, це правило порушується найчастіше. А саме, щоразу, коли в коді програми/модуля ми використовуємо оператор new і створюємо новий об'єкт конкретного типу, тим замість залежності від інтерфейсу утворюється залежність від реалізації.</p>
<p>Зрозуміло, цього не можна уникнути і об'єкти десь мають створюватися. Але, принаймні, потрібно звести до мінімуму кількість місць, де це робиться і в яких явно вказуються класи, а також локалізувати та ізолювати такі місця, щоб вони не були розкидані по всьому програмному коду.</p>
<p>Дуже хорошим рішенням є шалена ідея про те, щоб сконцентрувати створення нових об'єктів у рамках спеціалізованих об'єктів та модулів – фабрик, сервіс локаторів, IoC-контейнерів.</p>
<p>У якомусь сенсі таке рішення слідує Принципу єдиного вибору (Single Choice Principle), який говорить: <span class="text-red">"Кожного разу, коли система програмного забезпечення повинна підтримувати безліч альтернатив, їх повний список має бути відомий лише одному модулю системи"</span> .</p>
<p>Тому, якщо в майбутньому доведеться додати нові варіанти (або нові реалізації, як у наведеному нами випадку створення нових об'єктів), то достатньо буде провести оновлення тільки того модуля, в якому міститься ця інформація, а всі інші модулі залишаться незайманими і зможуть продовжувати свою роботу як зазвичай.</p>
<h3>Приклад 1</h3>
<p>Було б розумно замість <code>new ArrayList </code>писати щось типу <code>List.new()</code>, JDK підставила б вам правильну реалізацію аркуша: ArrayList, LinkedList або навіть ConcurrentList.</p>
<p>Наприклад, компілятор дивиться, що об'єкт є звернення з різних потоків і ставить туди потоко-безопасную реалізацію. Або занадто багато вставок у середину аркуша, тоді реалізація буде заснована на LinkedList.</p>
<h3>Приклад 2</h3>
<p>Це вже сталося із сортуваннями, наприклад. Коли ти востаннє писав алгоритм сортування для сортування колекції? Натомість тепер всі користуються методом <code>Collections.sort()</code>, а елементи колекції повинні підтримувати інтерфейс Comparable (порівнюваний).</p>
<p>Якщо метод <code>sort()</code>передати колекцію з менше ніж 10 елементів, її цілком можна відсортувати сортуванням бульбашкою (Bubble sort), а не Quicksort.</p>
<h3>Приклад 3</h3>
<p>Компілятор вже стежить за тим, як ти конкатенуєш рядки та заміниш ваш код на <code>StringBuilder.append()</code>.</p>
<h2>9.2 Інвертування залежностей практично</h2>
<p>Тепер найцікавіше: давай подумаємо, як нам поєднати теорію та практику. Яким чином модулі можуть коректно створювати та отримувати свої “залежності” та не порушувати Dependency Inversion?</p>
<p>Для цього при проектуванні модуля ти маєш вирішити для себе:</p>
<ul>
 <li>що модуль виконує, яку функцію виконує;</li>
 <li>то модулю потрібно від його оточення, тобто з якими об'єктами/модулями йому доведеться мати справу;</li>
 <li>і як він це отримуватиме.</li>
</ul>
<p>Щоб дотриматися принципів Dependency Inversion, тобі обов'язково потрібно визначитися з тим, які зовнішні об'єкти використовує ваш модуль і як він буде отримати на них посилання.</p>
<p>І тут можливі такі варіанти:</p>
<ul>
 <li>модуль сам створює об'єкти;</li>
 <li>модуль бере об'єкти із контейнера;</li>
 <li>модуль поняття немає звідки беруться об'єкти.</li>
</ul>
<p>Проблема в тому, що для створення об'єкта необхідно викликати конструктор конкретного типу і в результаті модуль залежатиме не від інтерфейсу, а від конкретної реалізації. Але якщо ми не хочемо, щоб у коді модуля об'єкти створювалися явно, то можна використовувати патерн Фабричний Метод (Factory Method <strong>)</strong> .</p>
<p><span class="text-user">"Суть полягає в тому, що замість безпосереднього інстанцування об'єкта через new, ми надаємо класу-клієнту деякий інтерфейс для створення об'єктів. Оскільки такий інтерфейс при правильному дизайні завжди може бути перевизначений, ми отримуємо певну гнучкість при використанні низькорівневих модулів у модулях високого рівня"</span> .</p>
<p>У випадках, коли потрібно створювати групи або сімейства взаємопов'язаних об'єктів, замість Фабричного Методу використовується абстрактна фабрика (abstract factory <strong>)</strong> .</p>
<h2>9.3 Використання Service Locator</h2>
<p>Модуль бере необхідні об'єкти у того, хто вже має. Передбачається, що у системі є певний репозиторій об'єктів, у якому модулі можуть “класти” свої об'єкти і “брати” об'єкти з репозиторію.</p>
<p>Цей підхід реалізується шаблоном Локатор Сервісів ( <strong>Service Locator</strong> ), основна ідея якого полягає в тому, що в програмі є об'єкт, який знає, як отримати всі залежності (сервіси), які можуть знадобитися.</p>
<p>Головна відмінність від фабрик в тому, що Service Locator не створює об'єкти, а фактично вже містить інстанційовані об'єкти (або знає де/як їх отримати, а якщо і створює, то тільки один раз при першому зверненні). Фабрика при кожному зверненні створює новий об'єкт, який ти отримуєш у повну власність і можеш робити з ним, що хочеш.</p>
<p><strong>Важливо</strong> ! <span class="text-green">Локатор сервісів видає посилання на ті самі вже існуючі об'єкти</span> . Тому з об'єктами, виданими Service Locator, потрібно бути дуже обережним, оскільки одночасно з тобою ними може скористатися ще хтось.</p>
<p>Об'єкти в Service Locator можуть бути додані безпосередньо через конфігураційний файл та взагалі будь-яким зручним програмістом способом. Сам Service Locator може стати статичним класом із набором статичних методів, синглетоном чи інтерфейсом і передаватися необхідним класам через конструктор чи метод.</p>
<p>Service Locator іноді називають антипаттерном і не рекомендують використовувати (бо він створює неявні зв'язки і дає лише видимість гарного дизайну). Докладно можна почитати у Марка Сімана:</p>
<ul>
 <li><a href="http://blog.ploeh.dk/2010/02/03/ServiceLocatorIsAnAntiPattern.aspx" target="_blank">Service Locator is an Anti-Pattern</a></li>
 <li><a href="http://blog.ploeh.dk/2010/11/01/PatternRecognitionAbstractFactoryOrServiceLocator.aspx" target="_blank">Abstract Factory or Service Locator?</a></li>
</ul>
<h2>9.4 Dependency Injection</h2>
<p>Модуль взагалі не дбає про “добування” залежностей. Він лише визначає, що йому потрібно до роботи, проте необхідні залежності йому поставляються (впроваджуються) ззовні кимось іншим.</p>
<p>Це так і називається - <strong>Впровадження залежностей</strong> (Dependency Injection). Зазвичай необхідні залежності передаються або як параметри конструктора (Constructor Injection), або через методи класу (Setter injection).</p>
<p>Такий підхід інвертує процес створення залежності – замість самого модуля створення залежностей контролює хтось ззовні. Модуль із активного емітента об'єктів стає пасивним — не він створює, а для нього створюють інші.</p>
<p>Така зміна напряму дії називається <strong>Інверсія Контролю (Inversion of Control)</strong> , або Принцип Голлівуду - "Не дзвоніть нам, ми самі вам подзвонимо".</p>
<p>Це <span class="text-green">гнучке рішення, що дає модулям найбільшу автономність</span> . Можна сказати, що тільки воно повною мірою реалізує "Принцип єдиної відповідальності" - модуль має бути повністю сфокусований на тому, щоб добре виконувати свою функцію і не дбати ні про що інше.</p>
<p>Забезпечення модуля всім необхідним для роботи - це окреме завдання, яким повинен займатися відповідний "фахівець" (зазвичай управлінням залежностями та їх впровадження займається якийсь контейнер - IoC-контейнер).</p>
<p>По суті, тут все як у житті: у добре організованій компанії програмісти програмують, а столи, комп'ютери та все необхідне їм для роботи купує та забезпечує офіс-менеджер. Або якщо використовувати метафору програми як конструктора — модуль не повинен думати про проводи, збіркою конструктора займається хтось інший, а не самі деталі.</p>
<p>Не буде перебільшенням сказати, що використання інтерфейсів для опису залежностей між модулями (Dependency Inversion) + коректне створення та впровадження цих залежностей (насамперед Dependency Injection) є ключовими техніками зниження <strong>зв'язаності</strong> .</p>
<p>Вони є тим фундаментом, у якому взагалі тримається слабка пов'язаність коду, його гнучкість, стійкість до змін, перевикористання, і якого всі інші техніки мають мало сенсу. Це основа основ слабкої зв'язності та гарної архітектури.</p>
<p>Принцип Inversion of Control (разом з Dependency Injection та Service Locator) детально розуміється Мартіном Фаулером. Є переклади обох його статей: <a href="http://yugeon-dev.blogspot.com.es/2010/07/inversion-of-control-containers-and_21.html" target="_blank">"Inversion of Control Containers and the Dependency Injection pattern"</a> та <a href="http://habrahabr.ru/post/116232/" target="_blank">"Inversion of Control"</a> .</p>