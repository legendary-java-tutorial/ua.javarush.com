<h2>Iterator</h2>
<p><span class="text-bold">Iterator</span> – поведінковий шаблон проектування. Є об'єктом, що дозволяє отримати послідовний доступ до елементів об'єкта-агрегата без використання описів кожного з агрегованих об'єктів.</p><img data-max-width="800" data-id="a5c6aaa0-2382-4756-a67d-016b446e4b32" alt="Iterator" src="https://cdn.javarush.com/images/article/a5c6aaa0-2382-4756-a67d-016b446e4b32/800.jpeg" style="width: 800px;">
<p>Наприклад, такі елементи як дерево, пов'язаний список, хеш-таблиця та масив можуть бути прогортані (і модифіковані) за допомогою об'єкта Ітератор.</p>
<p>Перебір елементів виконується об'єктом ітератора, а не колекцією. Це спрощує інтерфейс та реалізацію колекції, а також сприяє більш логічному поділу обов'язків.</p>
<p>Особливістю повноцінно реалізованого ітератора є те, що код, який використовує ітератор, може нічого не знати про тип агрегату, що ітерується.</p>
<p>Такий підхід використовується дуже часто. Наприклад, ти надсилаєш базі даних SQL-запит, а у відповідь вона повертає тобі ітератор (у термінах SQL його зазвичай називають курсором). І ти за допомогою отриманого ітератора можеш по черзі брати стоки із SQL-відповіді.</p>
<h2>Command</h2>
<p><span class="text-bold">Команда (Command)</span> - поведінковий шаблон проектування, що використовується при об'єктно-орієнтованому програмуванні, що представляє дію. Об'єкт команди містить у собі саму дію та її параметри.</p><img data-max-width="800" data-id="79b0150a-e986-414f-a259-5ad472343eb7" alt="Команда (Command)" src="https://cdn.javarush.com/images/article/79b0150a-e986-414f-a259-5ad472343eb7/800.jpeg" style="width: 800px;">
<p>Щоб викликати якийсь метод, зазвичай потрібно:</p>
<ul>
 <li>посилання на об'єкт</li>
 <li>ім'я методу (посилання на метод)</li>
 <li>значення параметрів методу</li>
 <li>посилання на контекст, який містить об'єкти, що використовуються</li>
</ul>
<p>Всі ці дані потрібно запакувати в один об'єкт - Команда ( <span class="text-bold">command</span> ).</p>
<p>Але й це ще не все: адже команду має хтось виконати. Так що до складу цього патерну входять ще чотири сутності: команди ( <span class="text-bold">command</span> ), приймач команд ( <span class="text-bold">receiver</span> ), що викликає команди ( <span class="text-bold">invoker</span> ) та клієнт ( <span class="text-bold">client</span> ).</p>
<p>Об'єкт<mark class="green">Command</mark>знає про приймач і викликає метод приймача. Значення параметрів приймача зберігаються у команді. Викликаючий об'єкт (invoker) знає, як виконати команду і, можливо, робить облік та запис виконаних команд. Об'єкт, що викликає, (invoker) нічого не знає про конкретну команду, він знає тільки про інтерфейс.</p>
<p>Обидва об'єкти (об'єкт, що викликає, і кілька об'єктів команд) належать об'єкту клієнта (client). Клієнт вирішує, які команди виконати і коли. Щоб виконати команду, він передає об'єкт команди об'єкту, що викликає, (invoker).</p>
<p>Використання командних об'єктів спрощує побудову загальних компонентів, які необхідно делегувати або виконувати виклики методів у будь-який час без необхідності знати методи класу чи параметрів методу.</p>
<p>Використання об'єкта, що викликає, (invoker) дозволяє вести облік виконаних команд без необхідності знати клієнту про цю модель обліку (такий облік може стати в нагоді, наприклад, для реалізації скасування та повтору команд).</p>
<p>Наприклад, ти пишеш програму, яка дозволяє виконувати різні завдання за розкладом. З одного боку, твоя програма веде облік завдань і керує їх запуском, з іншого у неї може бути кілька виконавців, кожен з яких вміє виконувати команди свого типу. Наприклад, розсилка SMS, розсилка листів, розсилка повідомлень у Telegram тощо.</p>
<h2>Observer</h2>
<p><span class="text-bold">Спостерігач (Observer)</span> – поведінковий шаблон проектування. Реалізує механізм класу, який дозволяє об'єкту цього класу отримувати сповіщення про зміну стану інших об'єктів і цим спостерігати за ними.</p><img data-max-width="800" data-id="c312130f-fa93-408f-b324-54b2d542d837" alt="Спостерігач (Observer)" src="https://cdn.javarush.com/images/article/c312130f-fa93-408f-b324-54b2d542d837/800.jpeg" style="width: 800px;">
<p>Класи, на події яких інші класи підписуються, називаються суб'єктами ( <span class="text-bold">Subjects</span> ), а класи, що підписуються, називаються спостерігачами ( <span class="text-bold">Observers</span> ).</p>
<p>При реалізації шаблону спостерігач зазвичай використовуються такі класи:</p>
<ul>
 <li><span class="text-neon"><span class="text-bold"><em>Observable</em></span></span> - інтерфейс, що визначає методи для додавання, видалення та оповіщення спостерігачів;</li>
 <li><span class="text-neon"><span class="text-bold"><em>Observer</em></span></span> - інтерфейс, за допомогою якого спостерігач отримує оповіщення;</li>
 <li><span class="text-neon"><span class="text-bold"><em>ConcreteObservable</em></span></span> - конкретний клас, який реалізує інтерфейс<span class="text-neon"><span class="text-bold"><em> Observable</em></span></span> ;</li>
 <li><span class="text-neon"><span class="text-bold"><em>ConcreteObserver</em></span></span> - конкретний клас, який реалізує інтерфейс<span class="text-neon"><span class="text-bold"><em> Observer</em></span></span> .</li>
</ul>
<p>Шаблон Спостерігач застосовується у тих випадках, коли в системі:</p>
<ul>
 <li>існує як мінімум один об'єкт, що розсилає повідомлення;</li>
 <li>є не менше одного одержувача повідомлень, причому їх кількість та склад можуть змінюватися під час роботи програми;</li>
 <li>дозволяє уникнути сильного зачеплення взаємодіючих класів.</li>
</ul>
<p>Цей шаблон часто застосовують у ситуаціях, коли відправника повідомлень не цікавить, що роблять одержувачі з наданою їм інформацією.</p>
<h2>Visitor</h2>
<p><span class="text-bold">Відвідувач (Visitor)</span> – поведінковий шаблон проектування, що описує операцію, яка виконується над об'єктами інших класів. При зміні visitor немає необхідності змінювати класи, що обслуговуються.</p>
<p>Шаблон демонструє класичний прийом відновлення інформації про втрачені типи, не вдаючись до знижуючого приведення типів за допомогою подвійної диспетчеризації.</p><img data-max-width="800" data-id="c9ff643d-3d9f-4f65-b257-486723c24078" alt="Відвідувач (Visitor)" src="https://cdn.javarush.com/images/article/c9ff643d-3d9f-4f65-b257-486723c24078/800.jpeg" style="width: 800px;">
<p>Необхідно зробити якісь нескладні операції над рядом об'єктів, але треба уникнути забруднення їхнього коду. І немає можливості чи бажання запитувати тип кожного вузла та здійснювати приведення покажчика до правильного типу, перш ніж виконати потрібну операцію.</p>
<p>Шаблон слід використовувати, якщо:</p>
<ul>
 <li>є різні об'єкти різних класів із різними інтерфейсами, але з них необхідно здійснювати операції, залежні від конкретних класів;</li>
 <li>над структурою необхідно виконати різні ускладнюючі структуру операції;</li>
 <li>часто додаються нові операції структурою.</li>
</ul>
<h2>Mediator</h2>
<p><span class="text-bold">Посередник (Mediator)</span> - поведінковий шаблон проектування, що забезпечує взаємодію безлічі об'єктів, формуючи при цьому слабке зачеплення і позбавляючи об'єкти необхідності явно посилатися один на одного.</p><img data-max-width="800" data-id="c0565a96-358c-449c-9cd7-cd15c21e85ce" alt="Посередник (Mediator)" src="https://cdn.javarush.com/images/article/c0565a96-358c-449c-9cd7-cd15c21e85ce/800.jpeg" style="width: 800px;">
<p>Паттерн Посередник дозволяє забезпечити взаємодію безлічі об'єктів, сформувавши при цьому слабку пов'язаність і позбавивши об'єкти необхідності явно посилатися один на одного.</p>
<p><span class="text-bold">Посередник</span> визначає інтерфейс обміну інформацією з об'єктами<mark class="green">Колеги</mark>, <span class="text-bold">Конкретний посередник</span> координує дії об'єктів<mark class="green">Колеги</mark>.</p>
<p>Кожен клас <span class="code"><span class="text-green">Колеги</span></span> знає про свій об'єкт<mark class="green">Посередник</mark>, всі <span class="code"><span class="text-green">Колеги</span></span> обмінюються інформацією лише з посередником, за його відсутності їм довелося обмінюватися інформацією безпосередньо.</p>
<p><mark class="green">Колеги</mark>посилають запити <span class="text-bold">Посереднику і отримують запити від нього. <span class="text-bold">Посередник</span> реалізує кооперативну поведінку, надсилаючи кожен запит одному або декільком<mark class="green">Колегам</mark>.</span></p>