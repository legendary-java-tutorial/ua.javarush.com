<h2>Робота з поколіннями об'єктів</h2>
<p>Java-складальники сміття реалізують деяку стратегію збору сміття поколінь, яка вміє класифікувати об'єкти за віком.</p>
<p>Таку необхідність (відзначати та ущільнювати всі об'єкти) у JVM можна назвати неефективною. Оскільки в міру виділення великої кількості об'єктів їх перелік зростає, що призводить до збільшення часу збору сміття. Емпіричний аналіз додатків показав, що більшість об'єктів у Java недовговічні.</p>
<p>Область пам'яті купи JVM розділена на три секції:</p><img data-max-width="1024" data-id="8aab6bd2-292b-4ecd-9ecc-9ee2a44d3c82" alt="Робота з поколіннями об'єктів" src="https://cdn.javarush.com/images/article/8aab6bd2-292b-4ecd-9ecc-9ee2a44d3c82/1024.jpeg" style="width: 1024px;">
<h2>Молоде покоління</h2>
<p>Новостворені об'єкти починаються у молодому поколінні. Молоде покоління далі поділяється на дві категорії.</p>
<ul>
 <li><strong>Простір Едему</strong> — нові об'єкти починають тут, їм виділяється початкова пам'ять.</li>
 <p><strong>Об'єкти , що вижабо</strong> (FromSpace і ToSpace), переміщуються сюди з Едему після того, як пережабо один цикл складання сміття.</p>
</ul>
<p>Процес, коли об'єкти збираються на сміття з молодого покоління, називається малою подією складання сміття.</p>
<p>Коли простір Едему заповнено об'єктами, виконується мале складання сміття. Всі мертві об'єкти видаляються, а всі живі — переміщаються в один із двох просторів, що залишабося. Мала GC також перевіряє об'єкти в просторі тих, хто вижив, і переміщає їх в інший (наступний) простір тих, що вижабо.</p>
<p>Візьмемо як приклад наступну послідовність.</p>
<ol>
 <li>В Едемі є об'єкти обох типів (живі та мертві).</li>
 <li>Відбувається мала GC - всі мертві об'єкти видаляються з Едему. Усі живі об'єкти переміщуються у простір-1 (FromSpace). Едем та простір-2 тепер порожні.</li>
 <li>Нові об'єкти створюються та додаються до Едему. Деякі об'єкти в Едемі та просторі-1 стають мертвими.</li>
 <li>Відбувається мала GC - всі мертві об'єкти видаляються з Едему та простору-1. Усі живі об'єкти переміщуються у простір-2 (ToSpace). Едем та простір-1 порожні.</li>
</ol>
<p>Таким чином у будь-який час один із просторів для тих, хто вижив, завжди порожній. Коли об'єкти, що вижабо, досягають певного порогу переміщення по просторах тих, хто вижив, вони переходять у старше покоління.</p>
<p>Для встановлення розміру молодого покоління можна скористатися прапором <strong>-Xmn</strong> .</p>
<h2>Старше покоління</h2>
<p>Об'єкти, які живуть значний час (наприклад, більшу частину життя програми) зрештою стають старшими об'єктами – довгожителі. Воно також відоме як штатне покоління і містить об'єкти, які тривалий час залишалися в просторах тих, хто вижив.</p>
<p>Порогове значення терміну служби об'єкта визначає, скільки циклів складання сміття він повинен пережити, перш ніж буде переміщено до старшого покоління. Процес, коли об'єкти вирушають у сміття зі старшого покоління, називається основною подією складання сміття.</p>
<p>Для встановлення початкового та максимального розміру пам'яті купи можна скористатися прапорами <strong>-Xms</strong> та <strong>-Xmx</strong> .</p>
<p>Так як Java задіяє складання сміття по поколінням, то чим більше подій складання сміття переживає об'єкт, тим далі він просувається в купі. Він починає в молодому поколінні і зрештою закінчує у штатному поколінні, якщо проживе досить довго.</p>
<p>Щоб зрозуміти просування об'єктів між просторами та поколіннями, розглянемо наступний приклад:</p>
<p>Коли об'єкт створюється, він спочатку поміщається у простір Едему молодого покоління.</p>
<p>Щойно відбудеться невелике складання сміття, живі об'єкти з Едему переміщаються у простір FromSpace. Коли відбувається наступне мале складання сміття, живі об'єкти як з Едему, так і з простору переміщуються в простір ToSpace.</p>
<p>Цей цикл триває певну кількість разів. Якщо об'єкт все ще "в строю" після цього моменту, наступний цикл складання сміття перемістить його в простір старшого покоління.</p>
<h2>Постійне покоління та мета-простір</h2>
<p>Метадані, такі як класи та методи, зберігаються у постійному поколінні. JVM заповнює його під час виконання на основі класів, що використовуються програмою. Класи, які більше не використовуються, можуть переходити із постійного покоління у сміття.</p>
<p>Для встановлення початкового та максимального розміру постійного покоління ви можете скористатися прапорами <strong>-XX:PermGen</strong> та <strong>-XX:MaxPermGen</strong> .</p>
<h4>Мета-простір</h4>
<p>Починаючи з Java 8, на зміну простору постійного покоління (PermGen) приходить простір пам'яті MetaSpace. Реалізація відрізняється від PermGen – цей простір купи тепер змінюється автоматично.</p>
<p>Це дозволяє уникнути проблеми нестачі пам'яті у додатків, яка виникає через обмежений розмір простору PermGen в купі. Пам'ять мета-простору може бути зібрана як сміття, і класи, які більше не використовуються, будуть автоматично очищені, коли мета-простір досягне максимального розміру.</p>