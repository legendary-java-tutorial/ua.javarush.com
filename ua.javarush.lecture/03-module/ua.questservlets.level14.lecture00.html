<h2>1.1 Архітектура програми</h2>
<p>Цей курс розрахований на новачків, тому що проектувати архітектуру серйозної програми ти ще довго не будеш. Але не треба засмучуватися, хороша архітектура – ​​це скоріше виняток, ніж правило. Дуже складно вибрати правильну архітектуру програми <strong>до</strong> створення програми.</p>
<p>Приклади популярних архітектур великих серверних програм:</p>
<ul>
 <li>Багатошарова архітектура (Layered Architecture).</li>
 <li>Багаторівнева архітектура (Tiered architecture).</li>
 <li>Сервіс-орієнтована архітектура (Service Oriented Architecture - SOA).</li>
 <li>Мікросервісна архітектура (Microservice Architecture).</li>
</ul>
<p>Кожна з них має свої плюси та свої мінуси. Але вивчення їх тобі нічого не дасть. Архітектура – ​​це відповідь на питання <strong>«як організувати взаємодію тисяч об'єктів усередині системи»</strong> . І доки ти на своєму досвіді не відчуєш усю складність проблеми, ти не зможеш зрозуміти і всю багатогранність розв'язання.</p>
<p>Всі додатки використовують якусь архітектуру або хоча б вдають. Тому знання популярних підходів до проектування програм дозволить тобі швидше і краще розуміти, як додаток влаштований. А отже, вносити зміни саме в ті місця, куди потрібно.</p>
<p>А що означає «вносити зміни, куди потрібно?». Чи є місця, куди не потрібно вносити зміни? Саме.</p>
<p>Щоб додати конкретики, припустимо, що ти працюєш над <strong>середнім backend-проектом</strong> . Він пишеться ось уже 5 років командою із 20 осіб. На проект витрачено 100 людино-років, у ньому близько 100 тисяч рядків коду. Сумарно він складається із двох тисяч класів, які розбиті на 10 модулів різного розміру.</p>
<p>І додамо серйозної дійсності. Логіка деяких завдань розмазана кількома модулями. Також бізнес-логіка може бути у фронтенді (написаному на JavaScript) та/або записана у вигляді stored procedure прямо в базі даних. Ти все ще впевнений, що одразу зможеш визначити місце, <strong>куди саме вносити зміни</strong> ?</p>
<p>Це не якийсь кошмар, який я вигадав, щоб вас налякати. Це типовий проект. Буває ще й гірше. Чому так відбувається? Причин може бути скільки завгодно, але майже завжди є такі:</p>
<ul>
 <li>На проекті працює купа людей – кожен із них бачить його трохи по-своєму.</li>
 <li>За 5 років у проекті змінилося 10 людей, новачки не стали сильно в ньому розумітися.</li>
 <li>Створення софту – це постійне внесення змін, які постійно змінюють.</li>
 <li>П'ять років тому, коли визначалися з архітектурою, задум проекту був дещо іншим.</li>
</ul><img data-max-width="512" data-id="bb4dc295-bea7-4d16-b33e-a81e7f3993a8" alt="" src="https://cdn.javarush.com/images/article/bb4dc295-bea7-4d16-b33e-a81e7f3993a8/512.jpeg" style="width: 512px;">
<p>Але головне, що незалежно від архітектури проекту, всі програмісти, які працюють над ним, дотримувалися одного і того ж розуміння, як цей проект влаштований. Почнемо із найпростішого поняття – клієнт-серверної архітектури.</p>
<h2>1.2 Концепція взаємодії клієнт-сервер</h2>
<p>Зараз ми розберемося з концепцією, яка лежить в основі архітектури <strong>клієнт-сервер</strong> і дозволить вам краще зрозуміти, як організовано взаємодію мільйонів програм у мережі інтернет.</p>
<p>Як відомо з назви, у цій концепції беруть участь дві сторони: <strong>клієнт</strong> і <strong>сервер</strong> . Тут все як у житті: клієнт – це замовник тієї чи іншої послуги, а сервер – постачальник послуг. Клієнт і сервер фізично являють собою <strong>програми</strong> , наприклад, <span class="text-green">типовим клієнтом є браузер</span> .</p>
<p>Як сервер можна навести такі приклади:</p>
<ul>
 <li>Веб-сервера, наприклад Tomcat.</li>
 <li>Сервера баз даних, наприклад, MySQL.</li>
 <li>Платіжні шлюзи, наприклад, Stripe.</li>
</ul>
<p>Клієнт із сервером зазвичай спілкуються через інтернет (хоча можуть працювати і в одній локальній мережі та взагалі в будь-яких інших типах мереж). Спілкування відбувається за стандартними протоколами, такими як HTTP, FTP або більш низькорівневими, такими як TCP або UDP.</p>
<p>Протокол зазвичай вибирається під тип послуги, яку надають сервера. Наприклад, якщо це відеозв'язок, зазвичай використовується UDP.</p>
<p>Пам'ятаєте, як працює Tomcat та його сервлети? Сервер отримує HTTP-повідомлення, розпаковує його, дістає звідти всю потрібну інформацію та передає сервлету на обробку. Потім результат обробки упаковує назад у HTTP-response та надсилає клієнту.</p>
<p>Це і є типова взаємодія клієнт-сервер. Браузер – це веб-клієнт, а Tomcat – веб-сервер. Tomcat навіть так і називається – веб-сервер.</p>
<p>Але якщо подумати, то важлива не назва, а суть – розподіл ролей між програмами. Твій JS-скрипт, що працює в HTML-сторінці, цілком можна назвати <strong>клієнтом</strong> , а твій сервлет - <strong>сервером</strong> . Адже вони працюють у парі в рамках <strong>концепції клієнт-сервер</strong> .</p>
<h2>1.3 Важливий аспект</h2>
<p>Ще варто відзначити, що в <strong>основі взаємодії клієнт-сервер лежить принцип того, що така взаємодія починає клієнт</strong> : сервер лише відповідає клієнту і повідомляє про те, чи може він надати послугу клієнту і якщо може, то на яких умовах.</p>
<p>Немає значення, де фізично знаходиться клієнт і де сервер. Клієнтське програмне забезпечення та серверне програмне забезпечення зазвичай встановлені на різних машинах, але також вони можуть працювати і на одному комп'ютері.</p>
<p>Цю концепцію розробабо як перший крок у бік спрощення складної системи. Має такі сильні сторони:</p>
<ul>
 <li><strong>Спрощення логіки</strong> : сервер нічого не знає про клієнта і як він використовуватиме його дані надалі.</li>
 <li>Можуть бути <strong>слабкі клієнти</strong> : всі ресурсомісткі завдання можна перенести на сервер.</li>
 <li>Незалежний розвиток коду клієнтів та коду сервера.</li>
 <li>Багато різних клієнтів, приклад - Tomcat і різні браузери.</li>
</ul>
<p>Найбільш базовий варіант взаємодії клієнта та сервера представлений на малюнку:</p><img data-max-width="512" data-id="20aca3ae-a74c-4cbc-9caa-e5ab1447c1a5" alt="клієнт-сервер" src="https://cdn.javarush.com/images/article/20aca3ae-a74c-4cbc-9caa-e5ab1447c1a5/512.jpeg" style="width: 512px;">
<p>Тут важливо відзначити дві деталі. По-перше, з картинки видно, що одного серверу можуть звертатися безліч клієнтів. По-друге, вони можуть до нього звертатися одночасно. Це також важлива частина роботи сервера.</p>
<p>Один клієнт зазвичай взаємодіє з одним користувачем, тому часто навіть авторизація не потрібна. Однак сервер обробляє запити тисяч клієнтів і розробляючи для нього код, потрібно вміти відрізняти авторизацію від аутентифікації.</p>
<p>Ще важливо, що сервер обробляє тисячі запитів паралельно. А це означає, що, розробляючи код бекенда, тобі завжди потрібно буде думати над завданням одночасного доступу до ресурсів. Також у коду сервера дуже висока ймовірність race condition (перегони потоків), deadlock (взаємне блокування потоків).</p>
<p><strong>Життєвий цикл важливих об'єктів потрібно обов'язково контролювати:</strong></p>
<p>Ти не можеш просто так запустити на сервері новий потік через <code>new Thread().start()</code>. Натомість тобі потрібно мати ThreadPool, який буде нишпоритися між усіма сервісними потоками.</p>
<p>Також не можна просто так запустити асинхронне завдання, адже вони теж виконуються в окремих потоках. Створюючи таку задачу, ти завжди маєш знати, який пул-потоків її виконує і що станеться, якщо такий пул переповниться.</p>
<p>Усі роботи з файлуми та директоріями потрібно робити через try-with-resources. Якщо у звичайному додатку ти забув закрити потік чи файл, то хіба це проблема? Закриється сам при виході із програми. А от якщо ти десь у коді забув закрити файл на сервері, і ваш сервер працює місяцями… Скоро таких незакритих файлів накопичаться тисячі і ОС перестане відкривати нові файли на читання (роботу з файлуми контролює ОС). Тімлід вас по голівці не погладить.</p>
<h2>1.4 Архітектура «клієнт-сервер»</h2>
<p>ще один важливий момент. <strong>Архітектура клієнт-сервер визначає лише загальні принципи взаємодії між комп'ютерами</strong> , деталі взаємодії визначають різні протоколи.</p>
<p>Ця концепція (клієнт-сервер) говорить нам, що потрібно розділяти машини в мережі на клієнтські, яким завжди щось треба і на серверні, які дають те, що треба. У цьому взаємодія завжди починає клієнт, а правила, якими відбувається взаємодія визначає протокол.</p>
<p>Існує два види архітектури взаємодії клієнт-сервер: перший отримав назву <strong>дворівнева архітектура</strong> клієнт-серверної взаємодії, другий – багаторівнева архітектура клієнт-сервер (іноді його називають <strong>трирівневою архітектурою</strong> або триланковою архітектурою, але це окремий випадок).</p>
<p>Принцип роботи дворівневої архітектури взаємодії клієнт-сервер у тому, що обробка запиту відбувається одному сервері без звернення до іншим серверам у процесі цієї обробки.</p>
<p>Двохрівневу модель взаємодії клієнт-сервер можна намалювати у вигляді простої схеми.</p><img data-max-width="800" data-id="fc9e05b7-e396-4057-96ac-e8417be7b534" alt="дворівневої архітектури взаємодії клієнт-сервер" src="https://cdn.javarush.com/images/article/fc9e05b7-e396-4057-96ac-e8417be7b534/800.jpeg" style="width: 800px;">
<p>Тут видно, що перший рівень – це все, що стосується клієнта, а другий рівень – це все, що стосується сервера.</p>