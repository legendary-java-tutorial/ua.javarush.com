<h2>4.1 Builder</h2>
<p><strong>Будівельник (Builder)</strong> — шаблон проектування, що породжує, який надає спосіб створення складеного об'єкта.</p>
<p>Відокремлює конструювання складного об'єкта від його уявлення так, що в результаті того самого процесу конструювання можуть виходити різні уявлення.</p><img data-max-width="800" data-id="99aeba59-79ef-4340-b9e3-ebdb2ae3a6b8" alt="Будівельник (Builder)" src="https://cdn.javarush.com/images/article/99aeba59-79ef-4340-b9e3-ebdb2ae3a6b8/800.jpeg" style="width: 800px;">
<p><strong>Сильні сторони:</strong></p>
<ul>
 <li>дозволяє змінювати внутрішнє уявлення продукту;</li>
 <li>ізолює код, що реалізує конструювання та подання;</li>
 <li>дає більш тонкий контроль за процесом конструювання.</li>
</ul>
<p><strong>Слабкі сторони:</strong></p>
<ul>
 <li>алгоритм створення складного об'єкта не повинен залежати від того, з яких частин складається об'єкт і як вони стикуються між собою;</li>
 <li>процес конструювання повинен забезпечувати різні уявлення об'єкта, що конструюється.</li>
</ul>
<p>Хороший приклад – це клас HttpRequest, у нього є підклас HttpRequest.Builder, за допомогою якого можна створювати екземпляри класу HttpRequest та гарантувати їхню валідність.</p>
<h2>4.2 Lazy Initialization</h2>
<p><strong>Відкладена (лінива) ініціалізація (Lazy initialization)</strong> - прийом у програмуванні, коли деяка ресурсомістка операція (створення об'єкта, обчислення значення) виконується безпосередньо перед тим, як буде використано її результат.</p>
<p>Отже ініціалізація виконується “на вимогу”, а чи не заздалегідь. Аналогічна ідея знаходить застосування в різних областях: наприклад, компіляція "на льоту" і логістична концепція "Точно в термін".</p><img data-max-width="800" data-id="fa045df5-58b9-4433-bc35-45548f452406" alt="Lazy Initialization" src="https://cdn.javarush.com/images/article/fa045df5-58b9-4433-bc35-45548f452406/800.jpeg" style="width: 800px;">
<p>Окремий випадок лінивої ініціалізації - створення об'єкта в момент звернення до нього - є одним із шаблонів проектування, що породжують. Як правило, він використовується в поєднанні з такими шаблонами, як Фабричний метод, Одинак ​​і Заступник.</p>
<p><strong>Сильні сторони:</strong></p>
<ul>
 <li>Ініціалізація виконується лише у випадках, коли вона дійсно необхідна;</li>
 <li>Прискорюється початкова ініціалізація програми: усе, що можна відкласти, відкладаємо.</li>
</ul>
<p><strong>Слабкі сторони:</strong></p>
<ul>
 <li>Неможливо явно задати порядок ініціалізації об'єктів;</li>
 <li>Виникає затримка при першому зверненні до об'єкта, що може стати критичним при паралельному виконанні іншої ресурсомісткої операції. Через це потрібно ретельно прораховувати доцільність використання “лінивої” ініціалізації у багатопотокових програмних системах.</li>
</ul>
<p>Пам'ятаєш, як під час написання web.xml там можна було вказати порядок старту сервлетів? Це якраз і є наслідком лінивого завантаження. Tomcat створить об'єкти сервлетів при першому зверненні до них.</p>
<h2>4.3 Object pool</h2>
<p><strong>Об'єктний пул (object pool)</strong> — шаблон проектування, що породжує, набір ініціалізованих і готових до використання об'єктів. Коли системі потрібно об'єкт, він створюється, а береться з пула. Коли об'єкт більше не потрібний, він не знищується, а повертається до пулу.</p><img data-max-width="512" data-id="780f7d14-5ad3-42e2-bbfe-409cef49851e" alt="Object pool" src="https://cdn.javarush.com/images/article/780f7d14-5ad3-42e2-bbfe-409cef49851e/512.jpeg" style="width: 512px;">
<p>Об'єктний пул застосовується підвищення продуктивності, коли створення об'єкта на початку роботи і знищення його в кінці призводить до великих витрат. Особливо помітно підвищення продуктивності, коли об'єкти часто створюються-знищуються, але одночасно існує лише невелика їхня кількість.</p>
<p>Об'єктний пул зручний, якщо об'єкт володіє іншими ресурсами, крім пам'яті - наприклад, мережевими сокетами. Або якщо колекція об'єктів забирає значну частину пам'яті комп'ютера і сміття створюється дійсно багато.</p>
<p>Як ти пам'ятаєш, Tomcat виконує кожен запит окремого потоку. Але потоки не створюються щоразу заново, а зберігаються у пулі потоків. Це дозволяє швидше виконувати запити: коли потрібний потік, він просто береться з пула. До речі, питання: а як би ти помістив запущений потік у пул і взяв його з пула?</p>