<h2>2.1 Adapter</h2>
<p><strong>Адаптер (Adapter)</strong> — структурний шаблон проектування, призначений організації використання функцій об'єкта, недоступного модифікації, через спеціально створений інтерфейс.</p>
<p>Офіційне визначення трохи складно сприймається, але якщо описати його своїми словами, то адаптер - це патерн проектування, який <span class="text-red">дозволяє об'єктам з несумісними інтерфейсами працювати разом</span> .</p><img data-max-width="800" data-id="16b33563-4c66-4b1c-bb21-cebc6331e598" alt="Adapter pattern" src="https://cdn.javarush.com/images/article/16b33563-4c66-4b1c-bb21-cebc6331e598/800.jpeg" style="width: 800px;">
<p><strong>Використовується</strong> для організації використання функцій об'єкта, недоступного для модифікації через спеціально створений інтерфейс. Створюється додатковий клас, який має потрібний інтерфейс, а цей клас вже у свою чергу викликає методи потрібного об'єкта (який не має необхідного інтерфейсу).</p>
<p><strong>Важливо! </strong>Якщо в коді ти зустрічаєш у класу суфікс Adapter, маєш повне право вважати, що цей клас виконує роль адаптера і пов'язаний з групою класів, які працюють за описаною вище схемою.</p>
<p><strong>Використовується у випадках</strong> , коли система підтримує необхідні дані та поведінку, але має невідповідний інтерфейс. Найчастіше шаблон Адаптер застосовується, якщо необхідно створити клас, успадкований від нового або вже існуючого абстрактного класу.</p>
<p><strong>Сильні сторони: </strong></p>
<ul>
 <li>Перехід використання інших зовнішніх класів не вимагає переробки самої системи, досить реалізувати ще один клас Adapter.</li>
 <li>Незалежність від реалізації зовнішніх класів (класів із бібліотек, код яких ми можемо поміняти). Ваша програма стає незалежною від інтерфейсу зовнішніх класів.</li>
</ul>
<h2>2.2 Decorator</h2>
<p><strong>Декоратор (Decorator)</strong> — структурний шаблон проектування, призначений динамічного підключення додаткової поведінки до об'єкту. Шаблон Декоратор надає хорошу та гнучку альтернативу практиці створення підкласів з метою розширення функціональності.</p><img data-max-width="800" data-id="a4f5f64a-fb28-494b-8c21-f8086ac55ce4" alt="Декоратор (Decorator) pattern" src="https://cdn.javarush.com/images/article/a4f5f64a-fb28-494b-8c21-f8086ac55ce4/800.jpeg" style="width: 800px;">
<p><strong>Використовується для</strong> динамічного підключення до об'єкта додаткових зобов'язань.</p>
<p>Багато хто з вас запитає: як можна динамічно (під час роботи програми) додати об'єкту нову поведінку? Об'єкт можна зібрати зі шматочків, тобто невеликих об'єктів. Пам'ятаєш ланцюжки фільтрів у сервлетах? Або Stream API, коли ти писав запит із використанням filter(), map(), list()?</p>
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span></span><code class=" language-java"><span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>x <span class="token operator">-&gt;</span> x <span class="token operator">&lt;</span> <span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>x <span class="token operator">-&gt;</span> x <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">print</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><strong>Сильні сторони патерну Decorator:</strong></p>
<ul>
 <li>Не потрібно створювати підкласи для розширення функціональності об'єкта.</li>
 <li>Можливість динамічно підключати нову функціональність у будь-якому місці: до або після основної функціональності об'єкта ConcreteComponent.</li>
</ul>
<h2>2.3 Proxy</h2>
<p><strong>Заступник (Proxy)</strong> — структурний шаблон проектування, що надає об'єкт, який контролює доступ до іншого об'єкта, перехоплюючи і пропускаючи всі його виклики.</p><img data-max-width="800" data-id="3e687962-786e-4b54-8f30-5b4b2d5fad1c" alt="Заступник (Proxy)" src="https://cdn.javarush.com/images/article/3e687962-786e-4b54-8f30-5b4b2d5fad1c/800.jpeg" style="width: 800px;">
<p>Паттерн Proxy надає об'єкт-замінник замість цього об'єкта. Цей об'єкт контролює доступ до оригінального об'єкта. Використовується дуже часто.</p>
<p>Пам'ятаєш, як ми використовували фреймворк Mockito та перехоплювали звернення до реального об'єкта за допомогою методу Mockito.spy() чи анотації @Spy? Саме тоді й створювався спеціальний Proxy-об'єкт, через який проходабо усі виклики до оригінального об'єкту.</p>
<p>І тоді за допомогою додавання об'єкту правил могли цими викликами управляти. Саме так – оригінальний об'єкт не змінюється, а робота з ним стає значно гнучкішою. Особливо корисно буває, коли ми з нашого коду викликаємо proxy-об'єкт, а передаємо його кудись. Контролюючи в такий спосіб спілкування двох незалежних від нас об'єктів.</p>
<p><strong>Види проксі</strong> за призначенням:</p>
<ul>
 <li><strong>Протокол проксі</strong> : зберігає в лог всі виклики "Суб'єкта" з їх параметрами.</li>
 <li><strong>Видалений заступник</strong> (remote proxies): забезпечує зв'язок із “Суб'єктом”, який знаходиться в іншому адресаному просторі або на віддаленій машині. Також може відповідати за кодування запиту та його аргументів та надсилання закодованого запиту реальному "Суб'єкту".</li>
 <li><strong>Віртуальний заступник</strong> (virtual proxies): забезпечує створення реального “Суб'єкта” лише тоді, коли він справді знадобиться. Також може кешувати частину інформації про реальний Суб'єкт, щоб відкласти його створення.</li>
 <li><strong>Копіювати-при-записі</strong> : забезпечує копіювання "суб'єкта" при виконанні клієнтом певних дій (частковий випадок "віртуального проксі").</li>
 <li><strong>Захищаючий заступник</strong> (protection proxies): може перевіряти, чи має об'єкт, що викликає, необхідні для виконання запиту права.</li>
 <li><strong>Кешируючий проксі</strong> : забезпечує тимчасове зберігання результатів розрахунку до віддачі їх множинним клієнтам, які можуть поділити ці результати.</li>
 <li>Екрануючий проксі: захищає "Суб'єкт" від небезпечних клієнтів (або навпаки).</li>
 <li><strong>Синхронізуючий проксі</strong> : здійснює синхронізований контроль доступу до "Суб'єкта" в асинхронному багатопотоковому середовищі.</li>
 <li><strong>"Розумне" посилання</strong> (smart reference proxy): робить додаткові дії, коли на "Суб'єкт" створюється посилання, наприклад, розраховує кількість активних посилань на "Суб'єкт".</li>
</ul>
<h2>2.4 Bridge</h2>
<p><strong>Шаблон Міст (Bridge)</strong> — структурний шаблон проектування, який використовується для розділення абстракції та реалізації так, щоб вони могли змінюватися незалежно.</p>
<p>Шаблон міст використовує інкапсуляцію, агрегування і може використовувати успадкування, щоб розділити відповідальність між класами.</p><img data-max-width="800" data-id="679b0f01-4e75-4a06-be9d-21baf2a51f94" alt="Міст (Bridge)" src="https://cdn.javarush.com/images/article/679b0f01-4e75-4a06-be9d-21baf2a51f94/800.jpeg" style="width: 800px;">
<p>Коли абстракція та реалізація розділені, вони можуть змінюватись незалежно. Іншими словами, при реалізації через шаблон міст, зміна структури інтерфейсу не заважає зміні структури реалізації.</p>
<p>Розглянемо таку абстракцію як фігура. Існує безліч типів фігур, кожна зі своїми властивостями та методами. Однак є щось, що поєднує всі фігури. Наприклад, кожна фігура повинна вміти малювати себе, масштабуватись і так далі.</p>
<p>У той самий час малювання графіки може відрізнятися залежно від типу ОС чи графічної бібліотеки. Фігури повинні мати можливість малювати себе у різних графічних середовищах. Але реалізовувати у кожній фігурі всі способи малювання або модифікувати фігуру щоразу при зміні способу малювання непрактично.</p>
<p>У цьому випадку шаблон допомагає міст, дозволяючи створювати нові класи, які будуть реалізовувати малювання в різних графічних середовищах. При використанні такого підходу легко можна додавати як нові фігури, так і способи їх малювання.</p>
<p>Зв'язок, що зображується стрілкою на діаграмах, може мати 2 сенси: а) "різновид", відповідно до принципу підстановки Лиск і б) одна з можливих реалізацій абстракції. Зазвичай у мовах використовується успадкування для реалізації як а), і б), що призводить до набухання ієрархій класів.</p>
<p>Міст служить саме для вирішення цієї проблеми: <strong>об'єкти створюються парами</strong> з об'єкта класу ієрархії А та ієрархії B, успадкування всередині ієрархії А має сенс "різновид" по Лисков, а для поняття "реалізація абстракції" використовується посилання з об'єкта A в парний об'єкт B.</p>
<h2>2.5 Facade</h2>
<p><strong>Шаблон Фасад (Facade)</strong> — структурний шаблон проектування, що дозволяє приховати складність системи шляхом зведення всіх можливих зовнішніх викликів до одного об'єкта, який делегує їх відповідним об'єктам системи.</p><img data-max-width="800" data-id="55d9994f-3185-49a2-94e2-6686e342e528" alt="Шаблон Фасад (Facade)" src="https://cdn.javarush.com/images/article/55d9994f-3185-49a2-94e2-6686e342e528/800.jpeg" style="width: 800px;">
<p>Як забезпечити уніфікований інтерфейс із набором розрізнених реалізацій чи інтерфейсів, наприклад, з підсистемою, якщо небажано сильне зв'язування з цією підсистемою чи реалізація підсистеми може змінитися?</p>
<p>Визначити одну точку взаємодії з підсистемою — фасадний об'єкт, що забезпечує спільний інтерфейс із підсистемою, та покласти на нього обов'язок взаємодії з її компонентами. Фасад - це зовнішній об'єкт, який забезпечує єдину точку входу для служб підсистеми.</p>
<p>Реалізація інших компонентів підсистеми закрита і не помітна зовнішнім компонентам. Фасадний об'єкт забезпечує реалізацію GRASP патерну Стійкий до змін з погляду захисту від змін у реалізації підсистеми.</p>
<p><strong>Важливо! </strong>Цей шаблон застосовується, коли ми хочемо повністю приховати якусь групу об'єктів та всю комунікацію з ними пропустити через наш об'єкт. Якщо ж ви просто хочете забезпечити деякий контроль процесу комунікації об'єктів і приховувати їх не обов'язково, краще скористатися патерном Proxy.</p>