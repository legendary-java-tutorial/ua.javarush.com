<h2>Критерії поганого дизайну</h2>
<p>Життя влаштоване досить просто: найчастіше, щоб бути розумним, потрібно просто не робити дурні речі. Розробки ПЗ це також стосується: в більшості випадків, щоб щось зробити добре, потрібно просто не робити погано.</p>
<p>Більшість програмістів мали досвід роботи з фрагментами системи, які мали поганий дизайн. Але що ще сумніше, у більшості з вас буде сумний досвід усвідомлення того, що саме ви були авторами такої системи. Хотіли якнайкраще, а вийшло як завжди.</p>
<p>Більшість розробників не прагнуть поганої архітектури, при цьому для багатьох систем настає момент, коли починають говорити, що її архітектура жахлива. Чому так відбувається? Чи був дизайн архітектури поганим із самого початку чи став таким із часом?</p>
<p>Коренем цієї проблеми є відсутність визначення "поганого" дизайну.</p>
<p>Мені здається, що саме розуміння якості дизайну та причин його "загнивання" є найважливішими якостями для будь-якого програміста. Як і в більшості інших випадків, головне — ідентифікувати проблему, а вирішити її буде справою техніки.</p><img data-max-width="512" data-id="66399989-15b7-441d-bd24-a1670a49976a" alt="" src="https://cdn.javarush.com/images/article/66399989-15b7-441d-bd24-a1670a49976a/512.jpeg" style="width: 512px;">
<h2>Визначення "поганого дизайну"</h2>
<p>Якщо ти вирішиш похвалитися своїм кодом перед колегою-програмістом, то швидше за все отримаєш у відповідь глузування: "Хто ж так робить?", "А чому саме так?" і “Я зробив би все по-іншому”. Таке дуже часто трапляється.</p>
<p>Всі люди різні, але код ти пишеш все-таки для своїх колег-програмістів, тому в процесі розробки кожної фічі завжди потрібна фаза review, коли на твій код дивляться інші люди.</p>
<p>Але навіть якщо масу речей можна зробити різними способами, є набір критеріїв, з яким погодабося б усі розробники. Будь-який шматок коду, який задовольняє своїм вимогам, але все ж таки, виявляє одну (або кілька) характеристик, має поганий дизайн.</p>
<p>Поганий дизайн:</p>
<ul>
 <li>Важко змінити, оскільки будь-яка зміна впливає занадто багато інших частин системи. ( <span class="text-bold">Жорсткість</span> , Rigidity).</li>
 <li>При внесенні змін зненацька ламаються інші частини системи. ( <span class="text-bold">Крихкість</span> , Fragility).</li>
 <li>Код важко використовувати повторно в іншій програмі, оскільки його занадто важко "виплутати" з поточної програми. ( <span class="text-bold">Нерухомість</span> , Immobility).</li>
</ul>
<p>А найсмішніше в тому, що практично <span class="text-red">неможливо знайти шматок системи</span> , який не містить жодної з цих характеристик (тобто є гнучким, надійним і повторно використовується), відповідає вимогам, і при цьому дизайн його поганий.</p>
<p>Таким чином, ми можемо використовувати ці три характеристики для однозначного визначення, чи є дизайн "поганим" або "хорошим".</p>
<h2>Причини "поганого дизайну"</h2>
<p>Що робить дизайн жорстким, тендітним та нерухомим? <span class="text-bold">Жорстка взаємозалежність модулів.</span></p>
<p><span class="text-bold">Дизайн є жорстким (rigid)</span> , якщо його не можна легко змінити. Ця жорсткість пов'язана з тим, що єдина зміна шматка коду переплетеної системи призводить до каскадних змін в залежних модулях. Це завжди відбувається, коли над кодом працює одна людина.</p>
<p>Це відразу ж ускладнює весь процес комерційної розробки: коли кількість каскадних змін не може бути передбачена проектувальником або розробником, оцінити вплив такої зміни неможливо. Тому такі зміни намагаються відкладати у довгу скриньку.</p>
<p>І це, у свою чергу, робить вартість змін непередбачуваною. Менеджери, які зіткнулися з такою невизначеністю, неохоче погоджуються на внесення змін, таким чином дизайн офіційно стає жорстким.</p>
<p>Якоїсь миті ваш проект проходить "горизонт подій" і приречений на звалювання в "чорну дірку" жорсткої архітектури.</p>
<p><span class="text-bold">Крихкість (fragility)</span> - це схильність системи до поломок у багатьох місцях після єдиної зміни. Зазвичай нові проблеми відбуваються у місцях, які концептуально не пов'язані з місцем змін. Така крихкість серйозно підриває віру в дизайн та супровід системи.</p>
<p>Таке зазвичай було, коли не було приватних методів. Досить зробити всі методи публічними, і ти будеш приречений на виникнення тендітної архітектури. Інкапсуляція допомагає боротися із цим на мікрорівні. Але на макрорівні тобі потрібна модульна архітектура.</p>
<p>Коли проект має тендітну архітектуру, то розробники не можуть гарантувати якості продукту.</p>
<p>Прості зміни в одній частині програми призводять до помилок в інших незв'язаних частинах. Виправлення цих помилок призводить до ще більшої кількості проблем, і процес супроводу перетворюється на відомого пса, що ганяється за власним хвостом.</p>
<p><span class="text-bold">Дизайн є нерухомим (immobile)</span> , коли потрібні частини системи сильно зав'язані інші небажані подробиці. Занадто багато свого коду, своїх унікальних підходів та рішень.</p>
<p>Пам'ятаєш логер JUL, розробники якого без вагомих на те підстав вигадали свої рівні логування? Це саме той випадок.</p>
<p>Щоб уявити проектувальнику, наскільки легко використати існуючий дизайн повторно, достатньо подумати про те, наскільки його буде використовувати в новому додатку.</p>
<p>Якщо дизайн сильно пов'язаний, то цей проектувальник жахнеться кількості роботи, необхідної для відокремлення необхідних частин системи від непотрібних подробиць. У більшості випадків такий дизайн не повторно використовується, оскільки вартість його відділення перевищує його розробку з нуля.</p>
<h2>Актуальність</h2>
<p><span class="text-bold">Все змінюється, але все залишається незмінним. </span>(Китайське прислів'я)</p>
<p>Вище були порушені дуже добрі питання. Чим небезпечні крихкі та жорсткі системи? Та тим, що процес управління подібним проектом стає непередбачуваним та некерованим. А ціна — надхмарна.</p>
<p>Як менеджер може давати чи не давати добро на додавання певної фічі, якщо він не знає, скільки насправді на це потрібно часу? Як пріоритезувати завдання, якщо не можна адекватно оцінити час та складність їх виконання?</p>
<p><span class="text-green">А як розробникам виплачувати той самий технічний борг, коли при його виплаті ми пограбуємо, причому зрозуміти, скільки саме пограбуємо, ми не можемо, поки не пограбуємо?</span></p>
<p>Проблеми з повторним використанням коду або тестування теж дуже актуальні. Юніт-тести служать не тільки для перевірки деяких припущень щодо модуля, але й для визначення ступеня його зв'язаності і можуть служити показником повторного використання.</p>
<p>Ось тобі цитата Боба Мартіна на цей випадок: <span class="text-neon">“Для того, щоб використовувати ваш код повторно, потрібно щоб витрати на його повторне використання були меншими, ніж вартість розробки з нуля”</span> . В іншому випадку ніхто з цією справою навіть не морочитиметься.</p>
<p>Використання принципів і патернів проектування є однією метою - зробити дизайн хорошим. Якщо їхнє використання не дає тобі ніякої вигоди (або навпаки, порушує принципи “хорошого дизайну”), значить щось у твоїй консерваторії не те й, можливо, інструмент почали використовувати не за призначенням.</p>