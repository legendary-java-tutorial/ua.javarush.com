<h2>Знайомство з архітектурою MVC</h2>
<p>Найпопулярніша архітектура додатків, про яку знає кожен програміст, - це <span class="text-bold">MVC</span> . MVC розшифровується як <span class="text-bold">Model-View-Controller</span> .</p>
<p>Не стільки архітектура додатків, як архітектура компонентів докладання, але цього нюансу повернемося пізніше. Що таке MVC?</p>
<p>MVC - це схема поділу даних програми та керуючої логіки на три окремі компоненти: <span class="text-bold">модель, уявлення та контролер</span> - таким чином, що модифікація кожного компонента може здійснюватися незалежно.</p>
<ul>
 <li><span class="text-bold">Модель (Model)</span> надає дані та реагує на команди контролера, змінюючи свій стан.</li>
 <li><span class="text-bold">Подання (View)</span> відповідає за відображення даних моделі користувача, реагуючи на зміни моделі.</li>
 <li><span class="text-bold">Контролер (Controller)</span> інтерпретує дії користувача, сповіщаючи модель необхідність змін.</li>
</ul>
<p>Цю модель вигадали ще в 1978 (!) році. Так, проблеми з правильною архітектурою ПЗ були актуальні ще 50 років тому. Ось як ця модель описується діаграмою в оригіналі:</p><img width="800" alt="Знайомство з архітектурою MVC" src="https://cdn.javarush.com/images/article/4bc8c5a2-d140-4b72-8fa8-74f1bcb802ed/original.jpeg">
<p><span class="text-bold">Модель</span> надає дані та методи роботи з ними: запити до бази даних, перевірку на коректність. <span class="text-bold">Модель не залежить від подання</span> (не знає як дані візуалізувати) та контролера (не має точок взаємодії з користувачем), надаючи доступ до даних та управління ними.</p>
<p>Модель будується таким чином, щоб відповідати на запити, змінюючи свій стан, при цьому може бути вбудоване повідомлення "спостерігачів". Модель, за рахунок незалежності від візуального подання, <span class="text-bold">може мати кілька різних уявлень</span> для однієї моделі.</p>
<p><span class="text-bold">Подання</span> відповідає за отримання необхідних даних з моделі та надсилає їх користувачу. Подання не опрацьовує введені дані користувача.</p>
<p><span class="text-bold">Контролер</span> забезпечує “зв'язок” між користувачем та системою. Контролює та спрямовує дані від користувача до системи та навпаки. Використовує модель та подання для реалізації необхідної дії.</p>
<p>Певна складність полягає в тому, що дана модель за десятки років трохи еволюціонувала. Тобто назва залишилася тією ж, а призначення частин почало змінюватися.</p>
<h2>Архітектура MVC у вебі</h2>
<p>Ідея, яка лежить в основі конструкційного шаблону MVC, дуже проста: потрібно чітко розділяти відповідальність за різне функціонування наших додатків:</p>
<p><mark class="green">Model</mark>- Обробка даних і логіка програми.</p>
<p><mark class="orange">View</mark>— надання даних користувачеві в будь-якому форматі, що підтримується.</p>
<p><mark class="viola">Controller</mark>— обробка запитів користувача та виклик відповідних ресурсів.</p>
<p>Додаток поділяється на три основні компоненти, кожен з яких відповідає за різні завдання. Давай докладно розберемо компоненти клієнт-серверної програми на прикладі.</p>
<h4>Контролер (Controller)</h4>
<p>Користувач натискає на різні елементи на сторінці в браузері, в результаті чого браузер надсилає різні HTTP запити: GET, POST або інші. До контролера можна віднести браузер та JS-код, які працюють усередині сторінки.</p>
<p>Основна функція контролера у разі — викликати методи в необхідних об'єктів, управляти доступом до ресурсів виконання завдань, заданих користувачем. Зазвичай контролер викликає відповідну модель завдання і вибирає відповідний вид.</p>
<h4>Модель (Model)</h4>
<p><span class="text-bold">Модель у широкому розумінні</span> – це дані та правила, які використовуються для роботи з даними – разом вони становлять бізнес-логіку програми. Проектування програми завжди починається з побудови моделей об'єктів, якими вона оперує.</p>
<p>Припустимо, у нас є інтернет-магазин, який торгує книгами, тоді людина — це лише користувач програми чи ще й авторка книги? Ці важливі питання слід вирішити під час проектування моделі.</p>
<p>Далі йдуть набори правил: що можна робити, що не можна, які набори даних є допустимими, а які ні. Чи може книга бути без автора? А автор без книжок? Чи може дата народження користувача бути у 300 році тощо.</p>
<p>Модель дає контролеру подання даних, які запитив користувач (повідомлення, сторінку книги, картинки тощо). Модель даних буде однаковою, незалежно від того, як ми хочемо представляти їх користувачеві. Тому ми вибираємо будь-який доступний вид для відображення даних.</p>
<p><span class="text-bold">Модель містить найбільш важливу частину логіки нашого додатку</span> , логіку, яка вирішує завдання, з яким ми маємо справу (форум, магазин, банк тощо). Контролер містить в основному організаційну логіку для самої програми (як твій Project Manager).</p>
<h4>Вид (View)</h4>
<p>View забезпечує різні способи представлення даних, отриманих з моделі. Він може бути шаблоном, що заповнюється даними. Можливо кілька різних views і контролер вибирає, який підходить найкраще для поточної ситуації.</p>
<p>Веб-додаток зазвичай складається з набору контролерів, моделей та видів (views). Контролер може бути тільки на бекенді, але також може бути варіант кількох контролерів, коли його логіка розмазується і по frontend'у теж. Хороший приклад такого підходу – будь-який мобільний додаток.</p>
<h2>Приклад MVC у Інтернеті</h2>
<p>Допустимо тобі потрібно розробити інтернет-магазин, який займатиметься продажем книг. Користувач може виконувати такі дії: переглядати книги, реєструватися, купувати, додавати пункти до поточного замовлення, відзначати книги, що сподобалися, і купувати їх.</p>
<p>У твоєму додатку має бути <span class="text-bold">модель</span> , яка відповідає за всю бізнес-логіку. Також потрібен <span class="text-bold">контролер</span> , який оброблятиме всі дії користувачів і перетворюватиме їх на виклики методів з бізнес-логіки. При цьому один метод контролера може спричинити багато різних методів моделі.</p>
<p>Також потрібні набори views: список книг, інформація про одну книгу, кошик, список замовлень. Кожна сторінка веб-застосунку — це фактично і є окремий view, який відображає користувачеві певний аспект моделі.</p>
<p>Давайте подивимося, що станеться, якщо користувач відкриє список рекомендованих магазином книг для перегляду назв. Всю послідовність дій можна описати у вигляді 6 кроків:</p><img data-max-width="800" data-id="a7f52906-62ff-44d9-8cb4-3357b5b9fe63" alt="Приклад MVC у Інтернеті" src="https://cdn.javarush.com/images/article/a7f52906-62ff-44d9-8cb4-3357b5b9fe63/800.jpeg" style="width: 800px;">
<p>Кроки:</p>
<ol>
 <li>Користувач натискає на посилання «рекомендовані» і <span class="text-bold">браузер відправляє запит</span> на, припустимо, /books/recommendations.</li>
 <li><span class="text-bold">Контролер перевіряє запит</span> : користувач повинен бути залогінений. Або в нас мають бути добірки книг для незалогінених користувачів. Потім контролер звертається до моделі та просить її віддати список книг, рекомендованих користувачеві N.</li>
 <li><span class="text-bold">Модель</span> звертається до бази даних, дістає звідти інформацію про книжки: популярні зараз книжки, книжки, куплені користувачем, книжки, куплені його друзями, книжки з його wish list. На основі цих даних модель будує список із 10 рекомендованих книг та повертає їх контролеру.</li>
 <li><span class="text-bold">Контролер</span> одержує список рекомендованих книг і дивиться на нього. На цьому етапі контролер ухвалює рішення! Якщо книг мало або список взагалі порожній, він запитує список книг для незалогенного користувача. Якщо зараз триває акція, то контролер може додати до списку акційні книги.</li>
 <li><span class="text-bold">Контролер</span> визначається тим, яку сторінку показати користувачеві. Це може бути сторінка з помилкою, сторінка зі списком книг, сторінка привітання, що користувач став мільйонним відвідувачем.</li>
 <li>Сервер віддає клієнту сторінку ( <span class="text-bold">view</span> ), обрану контролером. Вона заповнюється потрібними даними (ім'я користувача, список книг) і йде до клієнта.</li>
 <li>Клієнт отримує сторінку та відображає її користувачеві.</li>
</ol>
<p><span class="text-bold">У чому переваги такого підходу?</span></p>
<p>Найочевидніша перевага, яку ми отримуємо від використання концепції MVC – це чіткий поділ логіки уявлення (інтерфейсу користувача) та логіки програми (серверна частина).</p>
<p>Друга перевага - це поділ серверної частини на дві: розумна модель ( <span class="text-bold">виконавець</span> ) і контролер ( <span class="text-bold">центр прийняття рішень</span> ).</p>
<p>У попередньому прикладі був момент, коли контролер міг отримати від моделі порожній список рекомендованих книг і вирішував, що з ним робити. Теоретично цю логіку можна було б засунути відразу до моделі.</p>
<p>Спочатку при запиті рекомендованих книг модель вирішувала б, що робити, якщо список порожній. Потім довелося б у це місце додати код, що робити, якщо зараз йде акція, потім ще різні варіанти.</p>
<p>Потім виявилося, що адмін магазину хоче подивитися, як виглядатиме сторінка користувача без акції, чи навпаки зараз акції немає, а він хоче подивитися, як відображатиметься майбутня акція. А методів для цього немає. Тому було вирішено відокремити центр прийняття рішень (контролер) від бізнес-логіки (модель).</p>
<p>Крім ізолювання видів від логіки програми, концепція MVC істотно зменшує складність великих додатків. Код виходить набагато структурованішим, і, тим самим, полегшується підтримка, тестування та повторне використання рішень.</p>
<p>Розуміючи концепцію MVC, ти як розробник усвідомлюєш, де потрібно додати сортування списку книг:</p>
<ul>
 <li>На рівні запиту до бази даних.</li>
 <li>На рівні бізнес-логіки (моделі).</li>
 <li>На рівні бізнес-логіки (контролер).</li>
 <li>У виставі — на стороні клієнта.</li>
</ul>
<p>І це не риторичне питання. Ось прямо зараз і подумай: де і чому потрібно додати код сортування списку книг.</p>
<h2>Класична модель MVC</h2>
<p>Взаємодія між компонентами MVC реалізується по-різному у веб-додатках та мобільних додатках. Це відбувається через те, що веб-додаток є короткоживучим, обробляє один запит користувача і завершується, а мобільний додаток обробляє багато запитів без перезапуску.</p>
<p>У веб-застосунках зазвичай використовується "пасивна" модель, а в мобільних додатках - "активна". Активна модель, на відміну від пасивної, дозволяє підписуватись і отримувати повідомлення про зміну в ній. У випадку з веб-застосунками цього не потрібно.</p>
<p>Приблизно так виглядає взаємодія компонентів у різних моделях:</p><img data-max-width="1024" data-id="1c742354-ab89-423e-85e5-40dfdc9d0691" alt="Класична модель MVC" src="https://cdn.javarush.com/images/article/1c742354-ab89-423e-85e5-40dfdc9d0691/1024.jpeg" style="width: 1024px;">
<p>У мобільних програмах (активна модель) активно використовуються <span class="text-bold">події</span> та механізм підписки на події. При такому підході view ( <span class="text-bold">вид</span> ) підписується зміни моделі. Потім, коли відбувається якесь подія (наприклад, користувач натискає кнопку), викликається <span class="text-bold">контролер</span> . Він дає і <span class="text-bold">моделі</span> команду зміну даних.</p>
<p>Якщо якісь дані змінабося, модель генерує подію про зміну цих даних. Всі view, які підписалися на цю подію (для яких важлива зміна саме цих даних), отримують цю подію та оновлюють дані у своєму інтерфейсі.</p>
<p>У веб-додатках все організовано трохи інакше. Основна технічна відмінність - це те, що <span class="text-red">клієнт не може отримувати повідомлення з боку сервера з ініціативи сервера</span> .</p>
<p>Тому контролер у веб-застосунку зазвичай не надсилає view будь-які повідомлення, а віддає клієнту нову сторінку, яка технічно є новим view або навіть новим клієнтським додатком (якщо одна сторінка нічого не знає про іншу).</p>
<p>Нині ця проблема частково вирішена за допомогою таких підходів:</p>
<ul>
 <li>Регулярне опитування сервера щодо зміни важливих даних (раз на хвабону або частіше).</li>
 <li>WebSocket'и дозволяють клієнтку підписуватись на повідомлення сервера.</li>
 <li>Web-push-повідомлення з боку сервера.</li>
 <li>Протокол HTTP/2 дозволяє серверу ініціювати надсилання повідомлень клієнту.</li>
</ul>