<h2>3.1 Singleton</h2>
<p><strong>Одинак ​​(Singleton)</strong> — шаблон проектування, що породжує, що гарантує, що в однопоточному додатку буде єдиний екземпляр деякого класу, і надає глобальну точку доступу до цього екземпляра.</p><img data-max-width="800" data-id="89e3023d-4033-48a2-8ca9-8752bf2a92dc" alt="Одинак ​​(Singleton)" src="https://cdn.javarush.com/images/article/89e3023d-4033-48a2-8ca9-8752bf2a92dc/800.jpeg" style="width: 800px;">
<p>Дуже часто програмісти-початківці люблять зібрати утилітні методи в деякий статичний клас – клас, що містить тільки статичні методи. Такий підхід має низку мінусів – наприклад, не можна передати посилання на об'єкт такого класу, такі методи важко тестувати тощо.</p>
<p>В якості альтернативи запропонували рішення клас-синглетон: клас, який може мати лише один об'єкт. При спробі створення цього об'єкта він створюється тільки в тому випадку, якщо ще не існує, інакше повертається посилання на існуючий екземпляр.</p>
<p>Істотно те, що можна користуватися саме екземпляром класу, тому що при цьому в багатьох випадках стає доступнішою широка функціональність. Наприклад, цей клас може реалізовувати деякі інтерфейси та його об'єкт можна передати в інші методи, як імплементацію інтерфейсу. Що не можна зробити із набором статичних методів.</p>
<p><strong>Плюси:</strong></p>
<ul>
 <li>Методи прив'язані до об'єкта, а чи не до статичного класу – можна передавати об'єкт за посиланням.</li>
 <li>Методи об'єкта значно легше тестувати та мокувати.</li>
 <li>Об'єкт створюється лише за потребою: відкладена ініціалізація об'єкта.</li>
 <li>Прискорення початкового запуску програми, якщо є безліч одиниць, які не потрібні для запуску.</li>
 <li>Одинаку можна надалі перетворити на шаблон-стратегію або кілька таких об'єктів.</li>
</ul>
<p><strong>Мінуси:</strong></p>
<ul>
 <li>Ускладнюється контроль над міжпотоковими гонками та затримками.</li>
 <li>Багатопотокового "одиначка" складно писати "з голови": доступ до давно побудованого одинаку в ідеалі не повинен відкривати м'ютекс. Краще перевірені рішення.</li>
 <li>Конфлікт двох потоків через недобудований поодинці призведе до затримки.</li>
 <li>Якщо об'єкт створюється довго, затримка може заважати користувачеві або порушувати час. У разі його створення краще перенести на стадію ініціалізації програми.</li>
 <li>Потрібні особливі функції для модульного тестування - наприклад, щоб перевести бібліотеку в "не одинокий" режим і повністю ізолювати тести один від одного.</li>
 <li>Потрібна особлива тактика тестування готової програми, адже пропадає навіть поняття "найпростіша запускність", адже запуск залежить від конфігурації.</li>
</ul>
<h2>3.2 Factory [Method]</h2>
<p><strong>Фабричний метод (Factory Method)</strong> — шаблон проектування, що породжує, що надає підкласам (класам-спадкоємцям) інтерфейс для створення екземплярів деякого класу. На момент створення спадкоємці можуть визначити, який клас створювати.</p>
<p>Іншими словами, цей шаблон делегує створення об'єктів спадкоємцям батьківського класу. Це дозволяє використовувати у коді програми не конкретні класи, а маніпулювати абстрактними об'єктами більш рівні.</p><img data-max-width="800" data-id="db65aca4-64e8-4622-8d7e-f71d93695269" alt="Фабричний метод (Factory Method)" src="https://cdn.javarush.com/images/article/db65aca4-64e8-4622-8d7e-f71d93695269/800.jpeg" style="width: 800px;">
<p>Цей патерн визначає інтерфейс для створення об'єкта, але залишає підклас рішення про те, на підставі якого класу створювати об'єкт. Фабричний метод дозволяє класу делегувати створення підкласів. Використовується, коли:</p>
<ul>
 <li>класу заздалегідь невідомо, об'єкти якихось підкласів йому потрібно створювати.</li>
 <li>клас спроектований так, щоб об'єкти, що він створює, специфікувалися підкласами.</li>
 <li>клас делегує свої обов'язки одному з кількох допоміжних підкласів, і планується визначити, який клас приймає ці обов'язки він.</li>
</ul>
<h2>3.3 Abstract Factory</h2>
<p><strong>Абстрактна фабрика (Abstract factory)</strong> — шаблон проектування, що породжує, надає інтерфейс для створення сімейств взаємопов'язаних або взаємозалежних об'єктів, не специфікуючи їх конкретних класів.</p>
<p>Шаблон реалізується створенням абстрактного класу Factory, який є інтерфейсом для створення компонентів системи (наприклад, для віконного інтерфейсу він може створювати вікна та кнопки). Потім пишуться класи, які реалізують цей інтерфейс.</p><img data-max-width="800" data-id="0d872d57-68cb-4d8f-b8ef-951740561f2e" alt="Абстрактна фабрика (Abstract factory" src="https://cdn.javarush.com/images/article/0d872d57-68cb-4d8f-b8ef-951740561f2e/800.jpeg" style="width: 800px;">
<p>Застосовується у випадках, коли програма має бути незалежною від процесу та типів створюваних нових об'єктів. Коли необхідно створити сімейства або групи взаємопов'язаних об'єктів, виключаючи можливість одночасного використання об'єктів із різних цих наборів в одному контексті.</p>
<p>Сильні сторони:</p>
<ul>
 <li>ізолює конкретні класи;</li>
 <li>полегшує заміну сімейств товарів;</li>
 <li>гарантує поєднання продуктів.</li>
</ul>
<p>Допустимо, твоя програма працює з файловою системою. Тоді для роботи в Linux тобі потрібні об'єкти LinuxFile, LinuxDirectory, LinuxFileSystem. А для роботи у Windwos тобі потрібні класи WindowsFile, WindowsDirectory, WindowsFileSystem.</p>
<p>Клас Path, який створюється через Path.of(), - це саме той випадок. Path — це насправді не клас, а інтерфейс і має реалізації WindowsPath і LinuxPath. А який саме об'єкт буде створено, приховано від твого коду і вирішуватиметься під час роботи програми.</p>
<h2>3.4 Prototype</h2>
<p><strong>Прототип (Prototype)</strong> - шаблон проектування, що породжує.</p>
<p>Цей патерн задає види створюваних об'єктів за допомогою екземпляра-прототипу та створює нові об'єкти шляхом копіювання цього прототипу. Він дозволяє уникнути реалізації і дотримуватися принципу “програмування через інтерфейси”.</p>
<p>Як повертаючий тип вказується інтерфейс/абстрактний клас на вершині ієрархії, а класи-спадкоємці можуть підставити туди спадкоємця, який реалізує цей тип. Простіше кажучи, це патерн створення об'єкта через клонування іншого об'єкта замість створення через конструктор.</p><img data-max-width="800" data-id="58cb0797-b692-45a1-9bb3-ea72e0dfe0e4" alt="Прототип (Prototype)" src="https://cdn.javarush.com/images/article/58cb0797-b692-45a1-9bb3-ea72e0dfe0e4/800.jpeg" style="width: 800px;">
<p>Паттерн використовується для:</p>
<ul>
 <li>уникнути додаткових зусиль щодо створення об'єкта стандартним шляхом (мається на увазі використання конструктора, тому що в цьому випадку також будуть викликані конструктори всієї ієрархії предків об'єкта), коли це недозволено дорого додатку.</li>
 <li>уникнути успадкування творця об'єкта (object creator) у клієнтському додатку, як це робить паттерн abstract factory.</li>
</ul>
<p>Використовуй цей шаблон проектування, коли твоїй програмі байдуже, як саме в ній створюються, компонуються та видаються продукти:</p>
<ul>
 <li>класи, що інстанцюються, визначаються під час виконання, наприклад, за допомогою динамічного завантаження;</li>
 <li>ти хочеш уникнути побудови ієрархій класів чи фабрик, паралельних до ієрархії класів продуктів;</li>
 <li>екземпляри класу можуть бути в одному з декількох різних станів. Може виявитися зручнішим встановити відповідну кількість прототипів і клонувати їх, а не інстанціювати щоразу клас вручну у відповідному стані.</li>
</ul>