<h2>Багатопоточність у Java</h2>
<p>Java Virtual Machine підтримує <strong>паралельні обчислення</strong> . Усі обчислення можуть бути виконані в контексті одного або кількох потоків. Ми легко можемо налаштувати доступ до одного ресурсу або об'єкта для кількох потоків, а також налаштувати потік виконання окремого блоку коду.</p>
<p>Будь-якому розробнику необхідно синхронізувати роботу з потоками при операціях читання та запису для ресурсів, на які виділено кілька потоків.</p>
<p>Це важливо, щоб на момент звернення до ресурсу в тебе були актуальні дані, щоб інший потік міг змінити їх і ти отримав найновішу інформацію. Навіть якщо взяти приклад банківського рахунку, доки на нього не прийшли гроші, користуватися ними ти не можеш, тому важливо завжди мати актуальні дані. У Java є спеціальні класи для синхронізації потоків та управління ними.</p>
<h3>Об'єкти потоку</h3>
<p>Все починається з головного (основного) потоку, тобто мінімально у твоїй програмі вже є один потік, що виконується. Основний потік може створювати інші потоки за допомогою <span class="text-green"><span class="text-bold">Callable</span></span> або <span class="text-green"><span class="text-bold">Runnable</span></span> . Створення відрізняється тільки повертається результатом, <span class="text-green"><span class="text-bold">Runnable</span></span> не повертає результату і не може викинути виняток, що перевіряється. Тому у тебе виходить хороша можливість побудувати ефективну роботу з файлуми, але це дуже небезпечно і потрібно бути обережним.</p>
<p>Також можна планувати виконання потоку на окремому ядрі центрального процесора. Система може легко переміщатися між потоками і виконувати певний потік при правильних налаштуваннях: тобто виконується спочатку потік, який читає дані, як тільки у нас з'явабося дані, далі ми передаємо їх потоку, який відповідає за валідацію, після цього передаємо потоку для виконання якої- то бізнес-логіки та новим потоком записуємо їх назад. У такій ситуації 4 потоки по черзі обробляють дані і все працюватиме швидше, ніж один потік. Кожен такий потік перетворюється на нативний потік ОС, а ось, яким способом його перетворюватимуть, залежить від реалізації JVM.</p>
<p>Клас <span class="code"><span class="text-green">Thread</span></span> служить для створення потоків та роботи з ними. У ньому є як стандартні механізми управління, так і абстрактні, наприклад, класи та колекції з <strong>java.util.concurrent</strong> .</p>
<h2>Синхронізація потоків у Java</h2>
<p>Комунікація забезпечується за рахунок розподілу доступу до об'єктів. Це дуже ефективно, але в той же час дуже легко припуститися помилки при роботі. Помилки бувають двох випадків: thread interference - коли інший потік втручається в твій потік, і memory consistency errors - консистентності пам'яті. Для вирішення та запобігання цим помилкам у нас є різні методи синхронізації.</p>
<p>Синхронізацією потоків у Java займаються монітори, це високорівневий механізм, що дозволяє одночасно тільки одному потоку виконувати блок коду, захищений цим же монітором. Поведінка моніторів розглянута у термінах блокувань; один монітор - одне блокування.</p>
<p>Синхронізація має кілька важливих моментів, на яких слід звернути увагу. Перший момент - це взаємне виключення (mutual exclusion) - тільки один потік може володіти монітором, таким чином, синхронізація на моніторі передбачає, що як тільки один потік входить до synchronized-блок, захищений монітором, ніякий інший потік не може увійти в блок, захищений цим монітором, поки перший потік не вийде із synchronized-блоку. Тобто кілька потоків не можуть звернутися до одного блоку synchronized одночасно.</p>
<p>Але синхронізація – це не лише взаємний виняток. Синхронізація гарантує, що дані, записані в пам'ять до або всередині синхронізованого блоку, стають видимими для інших потоків, які синхронізуються на тому ж моніторі. Після виходу з блоку ми звільняємо монітор та інший потік може захопити його та почати виконання цього блоку коду.</p>
<p>Коли новий потік захоплює монітор, ми отримуємо доступ і можливість виконання цього блоку коду, і в цей момент змінні будуть завантажені з основної пам'яті. Тоді ми зможемо побачити всі записи, зроблені видимим попереднім звільненням монітора.</p> Читання-запис у полі - це атомарна операція, якщо поле оголошено <span class="text-orange">volatile</span> , або захищене унікальним блокуванням, яке отримується перед будь-яким читанням-записом. Але якщо ти все-таки зіткнувся з помилкою, то отримуєш помилку про перевпорядкування (зміна порядку прямування, reordering). Вона проявляється у некоректно синхронізованих багатопотокових програмах, де один потік може спостерігати ефекти, які виробляють інші потоки.
<p></p>
<p>Ефект взаємного виключення та синхронізації потоків, тобто їх коректна робота досягається лише входженням у synchronized-блок або метод, що неявно отримує блокування, або отриманням блокування явним чином. Ми поговоримо про це нижче. Обидва способи роботи впливають на твою пам'ять і важливо не забувати про роботу з <span class="text-orange">volatile</span> -змінними.</p>
<h2>Volatile поля в Java</h2>
<p>Якщо змінна позначена, як <span class="text-orange">volatile</span> , вона доступна глобально. Це означає те, що якщо потік звертається до <span class="text-orange">volatile</span> змінної, то отримає його значення перед тим, щоб використовувати значення з кешу.</p>
<p>Запис працює як звільнення монітора, а читання як захоплення монітора. Доступ здійснюється стосовно типу “виконується раніше”. Якщо розібратися, то все, що буде видно для потоку A, коли він звертався до <span class="text-orange">volatile</span> змінної, це змінна для потоку B. Тобто ви гарантовано не втратите ваші зміни з інших потоків.</p>
<p><span class="text-orange">Volatile</span> - змінні атомарни, тобто при читанні такої змінної використовується такий самий ефект, як і при отриманні блокування - дані в пам'яті оголошуються недійсними або некоректними і значення <span class="text-orange">volatile</span> змінної знову читається з пам'яті. При записі використовується ефект пам'яті, як і звільнення блокування — <span class="text-orange">volatile</span> -поле записується у пам'ять.</p>
<h2>Java Concurrent</h2>
<p>Якщо ти хочеш зробити суперефективну та багатопоточну програму, необхідно використовувати класи з бібліотеки <strong>JavaConcurrent</strong> , які знаходяться в пакеті <strong>java.util.concurrent</strong> .</p>
<p>Бібліотека дуже об'ємна і має різний функціонал, тому давайте розберемо, що є всередині та поділимо на деякі модулі:</p><img data-max-width="1024" data-id="5490390d-0701-4845-807a-a7441f865074" alt="Java Concurrent" src="https://cdn.javarush.com/images/article/5490390d-0701-4845-807a-a7441f865074/1024.jpeg" style="width: 1024px;">
<p><span class="text-neon"><span class="text-bold">Concurrent Collections</span></span> – набір колекцій для роботи у багатопотоковому середовищі. Замість базового враппера Collections.synchronizedList з блокуванням доступу до всієї колекції використовуються блокування сегментів даних або використовуються wait-free алгоритми для паралельного читання даних.</p>
<p><span class="text-neon"><span class="text-bold">Queues</span></span> - неблокуючі та блокуючі черги для роботи в багатопотоковому середовищі. Неблокуючі черги зосереджені на швидкості та роботі без блокування потоків. Блокуючі черги підходять для роботи, коли потрібно пригальмувати потоки<span class="text-green"><span class="text-bold"> Producer</span></span> або<span class="text-green"><span class="text-bold"> Consumer</span></span> . Наприклад, у тій ситуації, коли не виконані якісь з умов, черга порожня чи переповнена, чи немає вільного<span class="text-green"><span class="text-bold"> Consumer</span></span> 'a.</p>
<p><span class="text-neon"><span class="text-bold">Synchronizers</span></span> – допоміжні утиліти для синхронізації потоків. Є потужною зброєю в “паралельних” обчисленнях.</p>
<p><span class="text-neon"><span class="text-bold">Executors</span></span> - фреймворк для зручнішого та легкого створення пулів потоків, легко налаштувати планування роботи асинхронних задач з отриманням результатів.</p>
<p><span class="text-neon"><span class="text-bold">Locks</span></span> - багато гнучких механізмів синхронізації потоків у порівнянні з базовими<span class="code text-orange"> synchronized</span> ,<span class="code text-orange"> wait</span> ,<span class="code text-orange"> notify</span> ,<span class="code text-orange"> notifyAll</span> .</p>
<p><span class="text-neon"><span class="text-bold">Atomics</span></span> – класи, які можуть підтримувати атомарні операції над примітивами та посиланнями.</p>