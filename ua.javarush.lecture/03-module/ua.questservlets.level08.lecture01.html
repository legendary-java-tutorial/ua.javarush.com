<h2>Знайомство з OSI</h2>
<p>Коли ARPA-мережа тільки розроблялася, дуже хотілося зробити її якомога розумнішою. Але чим складніше мережу, тим складніше її розвивати та підтримувати. Як рішення було запропоновано поділити всі функції мережі на логічні верстви.</p>
<p>Модель функціонування мережі називається мережна модель базової еталонної моделі взаємодії відкритих систем ISO/OSI. Коротко <span class="text-bold">модель OSI</span> (Open Systems Interconnection).</p><img data-max-width="512" data-id="bed54500-5085-48f3-89e7-900265dd6eb9" alt="модель OSI" src="https://cdn.javarush.com/images/article/bed54500-5085-48f3-89e7-900265dd6eb9/512.jpeg" style="width: 512px;">
<p>Загалом у такій моделі 7 рівнів. Взаємодія рівнів жорстко стандартизована та зведена до мінімуму. Нижній рівень поняття не має про наявність вищих рівнів та їх пристрій.</p>
<p>Найнижчий рівень вміє просто <span class="text-bold">посилати біти</span> . Навіть не передавати, а саме надсилати. Він поняття не має дійдуть вони чи ні. Послав і забув.</p>
<p>Вищий рівень оперує вже групами біт — <span class="text-bold">кадрами</span> і трохи знає про фізичний пристрій мережі, розуміє MAC-адресаи тощо.</p>
<p>Наступний рівень – пакетний. Він ще розумніший і вміє оперувати IP-адресаами мережі. І так далі.</p>
<p>Навіщо це все потрібне? Для максимізації гнучкості.</p>
<p>Уяви, що кожен рівень це Java-інтерфейс і в нього може бути кілька різних реалізацій. Так і тут. На фізичному рівні ви можете пересилати біти по дроту, слати повітрям (Wi-Fi), відправляти через супутник, а всі інші рівні навіть знати про це нічого не будуть. І все працюватиме, як і було задумано.</p>
<h2>Стек протоколів OSI</h2>
<p>Більш детально стек протоколів ти можеш вивчити <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%82%D0%B5%D0%B2%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_OSI#%D0%A3%D1%80%D0%BE%D0%B2%D0%BD%D0%B8_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8_OSI" target="_blank">на малюнку нижче</a> :</p><img data-max-width="1024" data-id="b70f1c3d-cb4e-45ba-9e9b-613628d71b4f" alt="" src="https://cdn.javarush.com/images/article/b70f1c3d-cb4e-45ba-9e9b-613628d71b4f/1024.jpeg" style="width: 1024px;">
<p>Але якщо ви не системний адміністратор, то така деталізація протоколів вам ні до чого. Цікавішим може бути вивчення стека протоколів TCP (Transmission Control Protocol)/IP (Internet Protocol).</p>
<p>Три верхніх рівня в моделі OSI, тобто рівень програми, рівень подання та рівень сеансу, окремо не різняться в моделі TCP/IP, яка має прикладний рівень над транспортним рівнем:</p>
<h3>Розподіл протоколів за рівнями моделі OSI</h3>
<div class="table-container">
 <table>
  <tbody>
   <tr>
    <th>TCP/IP</th>
    <th>OSI</th>
    <th></th>
   </tr>
   <tr>
    <td rowspan="3">Прикладний</td>
    <td>Прикладний</td>
    <td>HTTP, SMTP, SNMP, FTP, Telnet, SSH, SCP, SMB, NFS, RTSP, BGP</td>
   </tr>
   <tr>
    <td>Уявлення</td>
    <td>XDR, AFP, TLS, SSL</td>
   </tr>
   <tr>
    <td>Сеансовий</td>
    <td>ISO 8327 / CCITT X.225, RPC, NetBIOS, PPTP, L2TP, ASP</td>
   </tr>
   <tr>
    <td>Транспортний</td>
    <td>Транспортний</td>
    <td>TCP, UDP, SCTP, SPX, ATP, DCCP, GRE</td>
   </tr>
   <tr>
    <td>Мережевий</td>
    <td>Мережевий</td>
    <td>IP, ICMP, IGMP, CLNP, OSPF, RIP, IPX, DDP</td>
   </tr>
   <tr>
    <td rowspan="2">Канальний</td>
    <td>Канальний</td>
    <td>Ethernet, Token ring, HDLC, PPP, X.25, Frame Relay, ISDN, ATM, SPB, MPLS, ARP/td&gt;</td>
   </tr>
   <tr>
    <td>Фізичний</td>
    <td>електричні дроти, радіозв'язок, волоконно-оптичні дроти, інфрачервоне випромінювання</td>
   </tr>
  </tbody>
 </table>
</div>
<h2>Стек протоколів TCP/IP</h2>
<p>Стек протоколів TCP/IP включає чотири рівні:</p>
<ul>
 <li><span class="text-bold">Прикладний рівень</span> (Application Layer)</li>
 <li><span class="text-bold">Транспортний рівень</span> (Transport Layer)</li>
 <li><span class="text-bold">Міжмережевий рівень</span> (Мережевий рівень) (Internet Layer)</li>
 <li><span class="text-bold">Канальний рівень</span> (Network Access Layer)</li>
</ul>
<p>Протоколи цих рівнів повністю реалізують усі функціональні можливості OSI. На стеку протоколів TCP/IP побудовано всю взаємодію користувачів в IP-мережах.</p>
<p>Стек протоколів TCP/IP є незалежним від фізичного обладнання завдяки чому, зокрема, забезпечується повністю прозора взаємодія між провідними та бездротовими мережами.</p>
<p>На прикладному рівні (Application layer) працює більшість мережевих програм.</p>
<h3>Прикладний рівень</h3>
<p>Для взаємодії програм є високорівневі протоколи обміну інформацією. Наприклад, браузери працюють за протоколом HTTP, пошта відправляється за протоколом SMTP, Телеграм працює за власним зашифрованим протоколом.</p>
<p>Але приватні протоколи нам не дуже цікаві. Найчастіше ти стикатимешся з масовими протоколами, такими як ftp-клієнт для протоколу FTP (передача файлів), SSH (безпечне з'єднання з віддаленою машиною), DNS (перетворення символьних імен в IP-адресаи) та багато інших.</p>
<p>Майже всі ці протоколи працюють поверх протоколу TCP, хоча деякі для прискорення роботи працюють за UDP (User Datagram Protocol). Але, що важливо, ці протоколи мають порти за замовчуванням. Приклад:</p>
<ul>
 <li>20 FTP на TCP-порт 20 (для передачі даних) та 21 (для керуючих команд)</li>
 <li>22 – SSH</li>
 <li>23 – Telnet</li>
 <li>53 – запити DNS</li>
 <li>80 – HTTP</li>
 <li>443 – HTTPS</li>
</ul>
<p>Ці порти визначені Агентством із виділення імен та унікальних параметрів протоколів (IANA).</p>
<p>Є ще кілька популярних протоколів прикладного рівня: Echo, Finger, Gopher, HTTP, HTTPS, IMAP, IMAPS, IRC, NNTP, NTP, POP3, POPS, QOTD, RTSP, SNMP, SSH, Telnet, XDMCP.</p>
<h3>Транспортний рівень</h3>
<p>Протоколи транспортного рівня створені для вирішення проблеми гарантованої доставки повідомлень.</p>
<p>Повідомлення (пакет даних) може бути надіслано та втрачено десь у мережі. У цьому випадку на плечі транспортного рівня лягає завдання моніторингу таких ситуацій та повторного надсилання повідомлення, якщо потрібно.</p>
<p>Ще одним важливим завданням протоколу транспортного рівня є контроль за порядком надходження повідомлень. Часто буває так, що повідомлення були надіслані в одному порядку, а прийшли в іншому. І якщо зібрати з таких шматочків спочатку велике повідомлення, то вийде нісенітниця.</p>
<p>Щоб такого не було, транспортний рівень або нумерує повідомлення, або не надсилає нове, доки не отримав підтвердження отримання попереднього. Протоколи автоматичної маршрутизації, логічно представлені цьому рівні (оскільки працюють поверх IP), насправді є частиною протоколів мережного рівня.</p>
<p><span class="text-bold">Протокол TCP</span> - "гарантований" транспортний механізм з попереднім встановленням з'єднання, який надає додатку надійний потік даних, дає впевненість у безпомилковості одержуваних даних, перезапитує дані у разі втрати та усуває дублювання даних.</p>
<p>TCP дозволяє регулювати навантаження на мережу, а також зменшувати час очікування даних під час передачі на великі відстані. Більше того, TCP гарантує, що отримані дані були надіслані точно в такій послідовності. У цьому його основна відмінність від UDP.</p>
<p><span class="text-bold">Протокол UDP</span> – це протокол передачі датаграм без встановлення з'єднання. Також його називають протоколом “ненадійної” передачі, у сенсі неможливості впевнитись у доставці повідомлення адресаату, а також можливого перемішування пакетів. У програмах, які потребують гарантованої передачі даних, використовується протокол TCP.</p>
<p>UDP зазвичай використовується в таких додатках, як потокове відео та комп'ютерні ігри, де допускається втрата пакетів, а повторний запит утруднений або не виправданий, або в додатках виду запит-відповідь (наприклад, запити до DNS), де створення з'єднання займає більше ресурсів, ніж повторна відправка.</p>
<p>І TCP, і UDP використовують визначення протоколу верхнього рівня число, зване портом.</p>