<h2>1.1 Знайомство з патернами</h2>
<p>Як уже згадувалося раніше, програміст починає роботу над програмою з проектування її моделі: складання списку сутностей, якими оперуватиме програма. І що більше у програмі сутностей, то складніша програма.</p>
<p>Тому, щоб знизити складність програми, взаємодії об'єктів намагаються стандартизувати. І в цьому програмісту дуже допомагають <strong>шаблони проектування</strong> або <strong>патерни</strong> проектування. Від англійської design <strong>pattern</strong> .</p>
<p><strong>Важливо! </strong>У російській мові під словом дизайн зазвичай мають на увазі графічний дизайн, в англійській це не так. Англійське слово design за змістом ближче до слова “проектування” та/або “пристрій”. Наприклад, дизайн двигуна — це його зовнішній вигляд, яке внутрішній пристрій.</p>
<p>Тому design pattern – це саме патерн/шаблон проектування. Рекомендую взагалі перестати вживати слово дизайн у сенсі "зовнішній вигляд". Ти – майбутній Software Engineer, і тобі дизайн – це саме проектування.</p>
<p>То що таке цей design pattern? Насамперед патерн проектування – це <strong>стандартне вирішення стандартної проблеми</strong> . Хороше, ефективне та перевірене часом рішення.</p>
<p>Допустимо, тобі задали спроектувати велосипед, ти можеш зробити йому два колеса, три чи навіть п'ять. Так до речі на зорі проектування й було. Але перевірений часом підхід – два колеса. Адже до нинішнього очевидного підходу йшли через біль та помилки:</p><img data-max-width="800" data-id="5d016cef-bd5d-42a7-8874-07e416f7f55f" alt="" src="https://cdn.javarush.com/images/article/5d016cef-bd5d-42a7-8874-07e416f7f55f/800.jpeg" style="width: 800px;">
<p>Зазвичай шаблон не є закінченим рішенням, який може бути прямо перетворений на код, це лише приклад хорошого рішення задачі, який можна використовувати в різних ситуаціях.</p>
<p>Об'єктно-орієнтовані шаблони <strong>показують відносини та взаємодії між класами або об'єктами</strong> без визначення того, які кінцеві класи або об'єкти програми будуть використовуватися.</p>
<h2>1.2 Історія появи патернів проектування</h2>
<p>Ще в 70-ті роки програмісти зіткнулися з необхідністю розробляти великі програми, над якими мали працювати цілі команди розробників. Було випробувано різні методи організації роботи, але найсильніше на розробку вплинула будівельна сфера.</p>
<p>Для організації роботи великої групи людей використовували практики та підходи зі сфери будівництва. До речі, саме звідти до програмування прийшли такі терміни як складання (build), Software Developer (будівельник) та поняття архітектури.</p>
<p>І як ти вже здогадуєшся, ідею design pattern теж почерпнули зі сфери будівництва. Концепцію патернів вперше описав Крістофер Александер у книзі “Мова шаблонів. Міста. Будинки. Будівництво”. У цій книзі для опису процесів проектування міст була використана спеціальна мова – патерни.</p>
<p>Паттерни у будівництві описували типові перевірені часом рішення: якої висоти зробити вікна, скільки поверхів має бути у будівлі, скільки площі у мікрорайоні відвести під дерева та газони.</p>
<p>Тому нічого дивного, що 1994 року вийшла книга “Прийоми об'єктно-орієнтованого проектування. Паттерни проектування”, до якої увійшли 23 патерни, які вирішують різні проблеми об'єктно-орієнтованого дизайну.</p>
<p>Книгу написали 4 автори: Еріх Гамма, Річард Хелм, Ральф Джонсон та Джон Вліссідес. Назва книги була занадто довгою, щоб хтось зміг її запам'ятати. Тому невдовзі всі почали називати її "book by the gang of four", тобто <strong>"книга від банди чотирьох"</strong> , а потім і зовсім "GoF book".</p>
<p>І з того часу було відкрито ще інші патерни проектування. "Паттерновий" підхід став популярним у всіх галузях програмування, тому зараз можна зустріти всілякі патерни і за межами об'єктного проектування.</p>
<p><strong>Важливо! </strong>Паттерни - це не якісь супер-оригінальні рішення, а навпаки, типові рішення однієї й тієї ж проблеми, що часто зустрічаються. Хороші перевірені часом рішення.</p>
<h2>1.3 Список патернів</h2>
<p>Багато програмістів за все життя не вивчабо жодного патерну, що, втім, не заважає їм застосовувати. Як ми вже говорабо раніше, патерни – це хороші перевірені часом рішення і якщо програміст не дурень, то з досвідом сам знаходить такі рішення.</p>
<p>Але навіщо через десятки спроб і помилок приходити до оптимальних рішень, коли є люди, які вже пройшли цей шлях і написали книги з квінтесенцією набутого досвіду та життєвої мудрості?</p>
<p>Можна забити цвях гайковим ключем, але навіщо? Можна навіть дрилем, якщо сильно постаратися. Але гарне усвідомлене володіння інструментом якраз і відрізняє професіонала від аматора. І фахівець знає, що головна фішка дрилі зовсім не в цьому. Отже, навіщо знати патерни?</p>
<ul>
 <li>Перевірені рішення. Ти витрачаєш менше часу, використовуючи готові рішення замість повторного винаходу велосипеда. До деяких рішень ти зміг би додуматися і сам, але багато хто може бути для тебе відкриттям.</li>
 <li>Стандартизація коду. Ти робиш менше прорахунків при проектуванні, використовуючи типові уніфіковані рішення, тому що всі приховані проблеми в них давно знайдені.</li>
 <li>Загальний програмістський словник. Ти вимовляєш назву патерна замість того, щоб час пояснювати іншим програмістам, який крутий дизайн ти придумав і які класи для цього потрібні.</li>
</ul>
<h3>Які бувають патерни?</h3>
<p>Паттерни відрізняються за рівнем складності, деталізації та охоплення проектованої системи. Проводячи аналогію з будівництвом, ти можеш підвищити безпеку перехрестя, поставивши світлофор, а можеш замінити перехрестя цілою автомобільною розв'язкою із підземними переходами.</p>
<p>Найбільш низькорівневі та прості патерни – ідіоми. Вони не є універсальними, оскільки застосовні лише в рамках однієї мови програмування.</p>
<p>Найуніверсальніші — архітектурні патерни, які можна реалізувати практично будь-якою мовою. Вони потрібні для проектування всієї програми, а чи не окремих її елементів.</p>
<p>Але головне – патерни відрізняються призначенням. Патерни, з якими ми познайомимося, можна розбити на три основні групи:</p>
<ul>
 <li><strong>Патерни, що породжують,</strong> піклуються про гнучке створення об'єктів без внесення в програму зайвих залежностей.</li>
 <li><strong>Структурні патерни</strong> показують різні способи побудови зв'язків між об'єктами.</li>
 <li><strong>Поведінкові патерни</strong> дбають про ефективну комунікацію між об'єктами.</li>
</ul>
<h2>1.4 Знайомство з UML</h2>
<p>Почнемо з розгляду тих 23 патернів, які були описані в книзі банди чотирьох. І самі патерни, і їх назви – це знайомі речі навіть для програміста-початківця. Я тебе з ними познайомлю, але рекомендую прочитати ту саму книгу про патерни.</p>
<p>Паттерни проектування не прив'язані до конкретної мови програмування, тому для їх опису зазвичай використовується мова UML. Він був дуже популярним років 20 тому, але й зараз ним іноді користуються. До речі, опис патернів – це саме те місце, де використання UML – стандарт.</p>
<p>За допомогою UML ти можеш описати стосунки між різними сутностями. У нашому випадку – це об'єкти та класи.</p>
<p>Відносини між класами описуються чотирма типами стрілок:</p>
<div class="table-container">
 <table>
  <tbody>
   <tr>
    <th width="200"></th>
    <th></th>
   </tr>
   <tr>
    <td><img data-max-width="256" data-id="44c7f5c6-dfbe-4e88-932c-4e2cac65f11b" alt="" src="https://cdn.javarush.com/images/article/44c7f5c6-dfbe-4e88-932c-4e2cac65f11b/256.jpeg" style="width: 256px;"></td>
    <td><strong>композиція (composition)</strong> - підвид агрегації, в якій "частини" не можуть існувати окремо від "цілого".</td>
   </tr>
   <tr>
    <td></td>
    <td></td>
   </tr>
   <tr>
    <td><img data-max-width="256" data-id="eb023a81-2235-42ed-933d-924a939b754f" alt="" src="https://cdn.javarush.com/images/article/eb023a81-2235-42ed-933d-924a939b754f/256.jpeg" style="width: 256px;"></td>
    <td><strong>агрегація (aggregation)</strong> - описує зв'язок "частина" - "ціле", в якому "частина" може існувати окремо від "цілого". Ромб вказується із боку “цілого”.</td>
   </tr>
   <tr>
    <td></td>
    <td></td>
   </tr>
   <tr>
    <td><img data-max-width="256" data-id="90c1a1ca-7e72-4b02-bdb3-56ab481e1262" alt="" src="https://cdn.javarush.com/images/article/90c1a1ca-7e72-4b02-bdb3-56ab481e1262/256.jpeg" style="width: 256px;"></td>
    <td><strong>залежність (dependency)</strong> - зміна в одній сутності (незалежній) може впливати на стан або поведінку іншої сутності (залежної). З боку стрілки зазначається незалежна сутність.</td>
   </tr>
   <tr>
    <td></td>
    <td></td>
   </tr>
   <tr>
    <td><img data-max-width="256" data-id="93837811-6d75-4992-ae1c-608677eb7114" alt="" src="https://cdn.javarush.com/images/article/93837811-6d75-4992-ae1c-608677eb7114/256.jpeg" style="width: 256px;"></td>
    <td><strong>узагальнення (generalization)</strong> - ставлення наслідування чи реалізації інтерфейсу. З боку стрілки знаходиться суперклас чи інтерфейс.</td>
   </tr>
  </tbody>
 </table>
</div>
<p>Насправді, тут все дуже просто. Остання стрілочка фактично означає, що один клас успадковується від іншого класу. А перша та друга стрілочки – це те, що один об'єкт зберігає посилання на другий об'єкт. І це все.</p>
<p>Якщо ромбик у посилання чорний, то слабке посилання: об'єкти можуть існувати один без одного. Якщо ромбик білий, то об'єкти пов'язані сильно, як, наприклад, клас <code>HttpRequest</code>та його дочірній клас <code>HttpRequest.Builder</code>.</p>
<h2>1.5 Список патернів</h2>
<p>Види патернів будемо позначати різними кольорами та літерами:</p>
<p><mark class="green">B</mark>- Поведінкові (behavioral);</p>
<p><mark class="user">C</mark>- Що породжують (creational);</p>
<p><mark class="orange">S</mark>- Структурні (structural).</p>
<p>І нарешті список із 23-х патернів проектування:</p>
<div class="table-container">
 <table>
  <tbody>
   <tr>
    <td>
     <p><mark class="user">C</mark>- Абстрактна фабрика</p>
     <p><mark class="orange">S</mark>- Адаптер</p>
     <p><mark class="orange">S</mark>- Міст</p>
     <p><mark class="user">C</mark>- Будівельник</p>
     <p><mark class="green">B</mark>— Ланцюжок обов'язків</p>
     <p><mark class="green">B</mark>- Команда</p>
     <p><mark class="orange">S</mark>- Компонувальник</p>
     <p><mark class="orange">S</mark>- Декоратор</p></td>
    <td>
     <p><mark class="orange">S</mark>- Фасад</p>
     <p><mark class="user">C</mark>- Фабричний метод</p>
     <p><mark class="orange">S</mark>— Пристосуванець</p>
     <p><mark class="green">B</mark>- Інтерпретатор</p>
     <p><mark class="green">B</mark>- Ітератор</p>
     <p><mark class="green">B</mark>- Посередник</p>
     <p><mark class="green">B</mark>- Зберігач</p>
     <p><mark class="user">C</mark>- Прототип</p></td>
    <td>
     <p><mark class="orange">S</mark>- Проксі</p>
     <p><mark class="green">B</mark>- Спостерігач</p>
     <p><mark class="user">C</mark>- Одинак</p>
     <p><mark class="green">B</mark>- Стан</p>
     <p><mark class="green">B</mark>- Стратегія</p>
     <p><mark class="green">B</mark>- Шаблонний метод</p>
     <p><mark class="green">B</mark>- Відвідувач</p></td>
   </tr>
  </tbody>
 </table>
</div>