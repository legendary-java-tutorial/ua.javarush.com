<h2>Ефективність</h2>
<p>Досвідчені програмісти легко можуть відрізнити хорошу архітектуру від поганої, але якщо їх попросити описати її кількома словами, вони навряд чи зможуть це зробити. Немає єдиного критерію хорошої архітектури та немає єдиного визначення.</p>
<p>Проте, якщо подумати, можна написати ряд критеріїв, яким має задовольняти хороша архітектура. <span class="text-bold">Хороша архітектура</span> — це, перш за все, логічна архітектура, що робить процес розробки та супроводу програми більш простим та ефективним.</p>
<p>Коли програма має гарну архітектуру, то завжди досить легко зрозуміти, як вона влаштована і де писати код. Програму з гарною архітектурою легше змінювати, тестувати, налагоджувати та розвивати. Розумні люди сформулювали такі критерії гарної архітектури:</p>
<ul>
 <li>Ефективність;</li>
 <li>Гнучкість;</li>
 <li>Розширюваність;</li>
 <li>Масштабованість;</li>
 <li>Тестованість;</li>
 <li>Супроводжуваність коду.</li>
</ul>
<p><span class="text-bold">Ефективність системи. </span>Програма, звичайно ж, повинна вирішувати поставлені завдання та добре виконувати свої функції, причому у різних умовах. Здається, що будь-яка програма робить те, що має робити (якщо вона написана), але часто це зовсім не так.</p>
<p>Ти постійно зустрічатимеш програми, які не роблять, те, що заявлено.</p>
<ul>
 <li>Libre Office – повноцінна заміна Microsoft Office (насправді ні);</li>
 <li>Браузер Edge підтримує всі web-стандарти (насправді ні);</li>
 <li>Банк дбає про безпеку особистих даних своїх користувачів (насправді ні).</li>
</ul>
<p>І це ми ще не торкнулися продуктивності, надійності, своєчасного виправлення багів чи публікації інформації про відомі вразливості.</p>
<p>Зрозуміло, що ніхто не ідеальний, але програма має вирішувати поставлені перед нею першочергові завдання. Тож без ефективності нікуди.</p>
<h2>Гнучкість</h2>
<p>Єдина річ, яка на мою думку ще важливіша за ефективність, — це гнучкість. Будь-який додаток доводиться змінювати з часом, оскільки змінюються вимоги, додаються нові. Чим швидше і зручніше можна внести зміни до існуючого функціоналу, чим менше проблем та помилок це викличе, тим <span class="text-bold">гнучкіша</span> архітектура системи.</p>
<p>Дуже часто програмісти/архітектори-початківці думають, що їм потрібна ідеальна архітектура під поточні завдання. Ні. <span class="text-green">Тобі потрібна ідеальна архітектура під завдання, які озвучать тобі через рік. </span>Ти, вже зараз не знаючи майбутніх завдань, мусиш знати, що вони будуть.</p>
<p>Нема рації намагатися їх передбачити, адже завжди буде щось несподіване. Але ти маєш враховувати, що такі завдання з'являться. Тому в процесі розробки намагайся оцінювати те, що виходить щодо того, як це треба буде змінювати.</p>
<p>Запитай у себе: "А що буде, якщо поточне архітектурне рішення виявиться неправильним?", "Яка кількість коду зазнає при цьому змін?". Зміна одного фрагмента системи має впливати на її інші фрагменти.</p>
<p>По можливості архітектурні рішення не повинні «вирубуватись у камені», і наслідки архітектурних помилок мають бути в розумній мірі обмежені. "Гарна архітектура дозволяє відкладати прийняття ключових рішень" (Боб Мартін) і мінімізує "ціну" помилок.</p>
<p>Один із таких підходів — розбиття програми на мікросервіси: легко розбити вже існуючу логіку на окремі частини. Але найбільша проблема - це внесення майбутніх змін відразу в десяток сервісів для реалізації однієї маленької фічі.</p>
<h3>Масштабованість</h3>
<p>Масштабованість - це можливість скоротити термін розробки за рахунок додавання до проекту нових людей. Архітектура повинна дозволяти розпаралелити процес розробки, щоб багато людей могли працювати над програмою одночасно.</p>
<p>Здається, що це правило само собою виконується, але на практиці все з точністю та навпаки. Є навіть суперпопулярна книга " <span class="text-bold">Міфічний людино-місяць</span> ", де пояснюється, чому при додаванні в проект нових людей час його розробки збільшується.</p>
<h2>Розширюваність</h2>
<p><span class="text-bold">Розширюваність</span> - це можливість додавати в систему нові функції та сутності, не порушуючи її основної структури. На початковому етапі у систему має сенс закладати лише основний та найнеобхідніший функціонал.</p>
<p>Це так званий принцип <span class="text-bold">YAGNI - you ain't gonna need it</span> , "тобі це не знадобиться". При цьому архітектура повинна дозволяти легко нарощувати додатковий функціонал у міру потреби. Причому так, щоб внесення найімовірніших змін потребувало найменших зусиль.</p>
<p>Вимога, щоб архітектура системи мала гнучкість і розширюваність (тобто була здатна до змін та еволюції), є настільки важливою, що вона навіть сформульована у вигляді окремого принципу - "Принципу відкритості/ <span class="text-bold">закритості</span> ". <span class="text-bold">Open-Closed Principle</span> — другий із п'яти принципів SOLID: <span class="text-green">програмні сутності (класи, модулі, функції) мають бути відкритими для розширення, але закритими для модифікації</span> .</p>
<p>Іншими словами: <span class="text-bold">повинна бути можливість змінити та розширювати поведінку системи <span class="text-red">без переписування</span> вже існуючих частин системи</span> .</p>
<p>Це означає, що додаток слід проектувати так, щоб зміна його поведінки і додавання нової функціональності досягалося за рахунок написання нового коду (розширення), і при цьому не доводилося б змінювати вже існуючий код.</p>
<p>У такому разі поява нових вимог не спричинить модифікацію існуючої логіки, а зможе бути реалізована насамперед за рахунок її розширення. Саме цей принцип є основою "плагінної архітектури" (Plugin Architecture). Про те, за рахунок яких технік це може бути досягнуто, буде наведено далі.</p>
<p>Пам'ятаєш сервлети та фільтри? Навіщо потрібні були фільтри, та ще й з окремими інтерфейсами, якщо, по суті, ту саму логіку можна було реалізувати за допомогою сервлетів?</p>
<p>Саме винахід концепції фільтрів (службових сервлетів) дозволило винести різні службові функції окремий шар. І в майбутньому при зміні поведінки фільтрів не потрібно було змінювати сервлет.</p>
<p>До винаходу фільтрів вся службова логіка, яка відповідала за перенаправлення запитів, розміщувалася у самих сервлетах. І часто одна маленька зміна в логіці призводила до того, що потрібно було пройтися всім сервлетам і внести всі зміни.</p>
<h2>Тестованість</h2>
<p>Якщо ти Java Backend Developer, то твої серверні програми часто віддають назовні набір методів у вигляді REST API. І щоби перевірити, що всі твої методи працюють як задумано, їх потрібно покрити тестами.</p>
<p>Взагалі покриття тестами API – це добрий стиль. Він дозволяє переконатися, що твоє API справді робить те, що було задумано. А також, що ще важливіше, <span class="text-green">ти можеш вносити зміни до серверної логіки і легко перевірити, що ти випадково нічого не зламав</span> .</p>
<p>Як тільки ти почнеш писати тести, зрозумієш, що більшість коду взагалі неможливо тестувати: private методи, сильна зв'язність, статичні класи та змінні.</p>
<p>"Навіщо потрібні тести, якщо код працює?", - Запитає новачок.</p>
<p>"Навіщо потрібен робочий код, якщо його неможливо тестувати?", - Запитає професіонал.</p>
<p>Код, який легко тестувати, міститиме менше помилок і надійніше працюватиме. Але тести не просто покращують якість коду. Майже всі розробники згодом приходять до висновку, що вимога "хорошої тестованості" є також спрямовуючою силою, що автоматично веде до гарного дизайну.</p>
<p>Наведу цитату з книги “Ідеальна Архітектура”: "Використовуйте принцип "тестованості" класу як "лакмусовий папірець" гарного дизайну класу. Навіть якщо ви не напишіть жодного рядка тестового коду, відповідь на це питання в 90% випадків допоможе зрозуміти, наскільки всі" добре” чи “погано” з його дизайном”.</p>
<p>Існує ціла методологія розробки програм на основі тестів, яка так і називається – розробка через тестування (Test-Driven Development, TDD). Це вже, звичайно, інша крайність: напиши код, перш ніж писати код.</p>
<h2>Супроводжуваність коду</h2>
<p>Над програмою, як правило, працює багато людей — одні йдуть, приходять нові. Середній час роботи програміста в IT-компанії – півтора роки. Тож якщо ти прийшов на проект, якому 5 років, то лише 20% твоїх колег працювали над ним із самого початку.</p>
<p>Підтримувати та розвивати програму, яку писали інші, дуже важко. Навіть якщо програма вже написана, часто потрібно продовжити її супроводжувати: фіксувати помилки та вносити дрібні виправлення. І найчастіше це доводиться робити людям, які не брали участі у її написанні.</p>
<p>Тому хороша архітектура має давати можливість відносно <span class="text-green">легко та швидко розібратися в системі новим людям</span> . Проект має бути:</p>
<ul>
 <li>Добре структурований.</li>
 <li>Не містити дублювання.</li>
 <li>Мати добре оформлений код.</li>
 <li>Бажано утримувати документацію.</li>
 <li>Потрібно застосовувати стандартні та звичні рішення для програмістів.</li>
</ul>
<p>Ти можеш легко оцінити проект, над яким працюєш, <span class="text-bold">за 5-бальною системою</span> . Просто нарахуй за кожну з цих вимог по <span class="text-bold">два бали</span> . І якщо отримаєш 5 і більше, то ти щасливчик.</p>
<p>У програмістів є навіть <span class="text-bold">принцип найменшого подиву</span> : чим екзотичніша система, тим складніше її зрозуміти іншим. Зазвичай, він використовується щодо інтерфейсу користувача, але застосовний і до написання коду.</p>