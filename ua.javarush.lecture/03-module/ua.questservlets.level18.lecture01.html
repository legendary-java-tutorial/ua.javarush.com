<h2>Апаратна архітектура пам'яті</h2>
<p>Сучасна апаратна архітектура пам'яті відрізняється від внутрішньої Java моделі пам'яті. Тому потрібно апаратну архітектуру розуміти, щоб знати, як Java модель працює з нею. У цьому розділі описується загальна апаратна архітектура пам'яті, а наступний розділ описує, як з нею працює Java.</p>
<p>Ось спрощена схема апаратної архітектури сучасного комп'ютера:</p><img data-max-width="512" data-id="0a28b119-0299-42d8-aab3-fba135d16288" alt="Апаратна архітектура пам'яті" src="https://cdn.javarush.com/images/article/0a28b119-0299-42d8-aab3-fba135d16288/512.jpeg" style="width: 512px;">
<p>У сучасному світі комп'ютер має 2 або більше процесорів і це вже норма. Деякі з цих процесорів можуть мати кілька ядер. На таких комп'ютерах можливе одночасне виконання кількох потоків. Кожне ядро ​​процесора здатне виконувати один потік у будь-який час. Це означає, що будь-яка Java-додаток є апріорі багатопоточним і всередині вашої програми може бути запущено по одному потоку на ядро ​​процесора одночасно.</p>
<p>Ядро процесора містить набір регістрів, які знаходяться у його пам'яті (всередині ядра). Воно виконує операції над даними регістру набагато швидше, ніж над даними, що у основної пам'яті комп'ютера (ОЗУ). Це пов'язано з тим, що процесор може отримати доступ до цих регістрів набагато швидше.</p>
<p>Кожен ЦП також може мати свій шар кеш-пам'яті. Більшість сучасних процесорів його мають. До своєї кеш-пам'яті процесор може отримати доступ набагато швидше, ніж до основної пам'яті, але не так швидко, як до своїх внутрішніх регістрів. Значення швидкості доступу до кеш-пам'яті приблизно між швидкостями доступу до основної пам'яті та внутрішніх регістрів.</p>
<p>Більше того, у процесорів має місце багаторівневий кеш. Але це не так важливо знати, щоб зрозуміти, як Java модель пам'яті взаємодіє з апаратною пам'яттю. Важливо знати, що процесори можуть мати певний рівень кеш-пам'яті.</p>
<p>Будь-який комп'ютер також містить ОЗУ (область основної пам'яті). Усі ядра можуть отримати доступ до основної пам'яті. Основна область пам'яті зазвичай набагато більша, ніж кеш-пам'ять ядер процесорів.</p>
<p>У момент, коли процесору потрібен доступ до основної пам'яті, він зчитує її частину до своєї кеш-пам'яті. Він може також зчитувати частину даних з кешу у свої внутрішні регістри і виконувати операції над ними. Коли ЦПУ необхідно буде записати результат знову в основну пам'ять, він скине дані зі свого внутрішнього регістру в кеш-пам'ять і в якийсь момент в основну пам'ять.</p>
<p>Дані, що зберігаються в кеш-пам'яті, зазвичай скидаються назад в основну пам'ять, коли процесору необхідно зберегти в кеш-пам'яті щось ще. Кеш може очищати свою пам'ять і записувати дані одночасно. У процесора немає необхідності читати або записувати повний кеш щоразу під час оновлення. Зазвичай кеш оновлюється невеликими блоками пам'яті, вони називаються рядком кешу. Одна або кілька рядків кешу можуть бути раховані в кеш-пам'ять, і один або більше рядків кешу можуть бути скинуті назад в основну пам'ять.</p>
<h2>Поєднання Java-моделі пам'яті та апаратної архітектури пам'яті</h2>
<p>Як згадувалося, Java-модель пам'яті і апаратна архітектура пам'яті різні. Апаратна архітектура не розрізняє стеки потоків та купу. На обладнанні стек потоків та HEAP (купа) знаходяться в основній пам'яті.</p>
<p>Частини стеків і купи потоків можуть бути присутніми в кешах і внутрішніх регістрах ЦП. Це показано на діаграмі:</p><img data-max-width="1024" data-id="7b653255-07de-4c9b-b6c0-9c47c7e6cd44" alt="стек потоків та HEAP" src="https://cdn.javarush.com/images/article/7b653255-07de-4c9b-b6c0-9c47c7e6cd44/1024.jpeg" style="width: 1024px;">
<p>Якщо об'єкти та змінні можуть зберігатися в різних сферах пам'яті комп'ютера, можуть виникнути певні проблеми. Ось дві основні:</p>
<ul>
 <li>Видимість змін, які здійснив потік над загальними змінними.</li>
 <li>Стан гонки під час читання, перевірки та запису загальних змінних.</li>
</ul>
<p>Обидві ці проблеми поясню далі.</p>
<h2>Видимість загальних об'єктів</h2>
<p>Якщо два або більше потоку ділять між собою об'єкт без належного використання volatile-оголошення або синхронізації, то зміни загального об'єкта, зроблені одним потоком, можуть бути невидимі для інших потоків.</p>
<p>Уяви, що загальний об'єкт спочатку зберігається в основній пам'яті. Потік, що виконується на ЦП, зчитує загальний об'єкт у кеш цього ЦП. Там він вносить зміни до об'єкта. Поки кеш ЦП не було скинуто в основну пам'ять, змінена версія загального об'єкта не видно потоків, що працюють на інших ЦП. Таким чином, кожен потік може отримати власну копію загального об'єкта, кожна копія буде знаходитися в окремому кеші ЦП.</p>
<p>Наступна діаграма ілюструє малюнок цієї ситуації. Один потік, що працює на лівому ЦП, копіює в його кеш загальний об'єкт і змінює значення змінної count на 2. Ця зміна невидима для інших потоків, що працюють на правому ЦП, оскільки оновлення для count ще не було скинуто назад в основну пам'ять.</p><img data-max-width="800" data-id="c4ba107f-a25e-496d-af1a-4e7128d00d0e" alt="" src="https://cdn.javarush.com/images/article/c4ba107f-a25e-496d-af1a-4e7128d00d0e/800.jpeg" style="width: 800px;">
<p>Щоб вирішити цю проблему, ви можете використовувати ключове слово volatile при оголошенні змінної. Воно може гарантувати, що ця змінна зчитується безпосередньо з основної пам'яті і завжди записується назад в основну пам'ять, коли оновлюється.</p>
<h2>Стан гонки (Race Condition)</h2>
<p>Якщо два або більше потоків спільно використовують один об'єкт і більше одного потоку оновлюють змінні в цьому загальному об'єкті, може виникнути стан гонки.</p>
<p>Уявіть, що потік A зчитує змінну count загального об'єкта в кеш свого процесора. Уявіть також, що потік B робить те саме, але в кеш іншого процесора. Тепер потік A додає 1 до значення змінної count, і потік B робить те саме. Тепер змінну було збільшено двічі — окремо по +1 у кеші кожного процесора.</p>
<p>Якби ці збільшення були виконані послідовно, змінна count була б збільшена вдвічі і назад в основну пам'ять було б записано (вихідне значення + 2).</p>
<p>Тим не менш, два збільшення були виконані одночасно без належної синхронізації. Незалежно від того, який з потоків (A або B) записує свою оновлену версію count в основну пам'ять, нове значення буде тільки на 1 більше вихідного значення, незважаючи на два збільшення.</p>
<p>Ця діаграма ілюструє виникнення проблеми зі станом гонки, що описано вище:</p><img data-max-width="800" data-id="37347ace-af3d-4648-a218-18f8c1576289" alt="" src="https://cdn.javarush.com/images/article/37347ace-af3d-4648-a218-18f8c1576289/800.jpeg" style="width: 800px;">
<p>Для вирішення цієї проблеми можна використовувати синхронізований блок Java. Синхронізований блок гарантує, що тільки один потік може увійти до критичного розділу коду в будь-який момент часу.</p>
<p><span class="text-green">Синхронізовані блоки також гарантують, що всі змінні, до яких звертаються всередині синхронізованого блоку, будуть зчитані з основної пам'яті, і коли вийде потік з синхронізованого блоку, всі оновлені змінні будуть знову скинуті в основну пам'ять, незалежно від того, чи оголошена змінна як volatile або ні.</span></p>