<h2>8.1 Декомпозиція – наше все</h2>
<p>Для наочності картинка з непоганої статті "Decoupling of Object-Oriented Systems", що ілюструє основні моменти, про які йтиметься.</p><img data-max-width="800" data-id="583c2148-3bd5-4256-abdd-8f098bd4bd6d" alt="Декомпозиція" src="https://cdn.javarush.com/images/article/583c2148-3bd5-4256-abdd-8f098bd4bd6d/800.jpeg" style="width: 800px;">
<p>Тобі все ще здається, що проектування архітектури програми – це просто?</p>
<h2>8.2 Інтерфейси, приховування реалізації</h2>
<p>Головними для зменшення зв'язаності системи є принципи ООП і принцип Інкапсуляція + Абстракція + Поліморфізм.</p>
<p>Саме тому:</p>
<ul>
 <li><span class="text-green">Модулі повинні бути один для одного "чорними ящиками" (інкапсуляція)</span> . Це означає, що один модуль не повинен "лізти" всередину іншого модуля і що-небудь знати про його внутрішню структуру. Об'єкти однієї підсистеми не повинні безпосередньо звертатися до об'єктів іншої підсистеми.</li>
 <li><span class="text-user">Модулі/підсистеми повинні взаємодіяти один з одним лише за допомогою інтерфейсів</span> (тобто <strong>абстракцій</strong> , які не залежать від деталей реалізації). Відповідно, кожен модуль повинен мати чітко визначений інтерфейс або інтерфейси для взаємодії з іншими модулями.</li>
</ul>
<p><strong>Принцип "чорної скриньки"</strong> (інкапсуляція) дозволяє розглядати структуру кожної підсистеми незалежно від інших підсистем. Модуль, що є “чорною скринькою”, можна відносно вільно змінювати. Проблеми можуть виникнути лише на стику різних модулів (або модуля та оточення).</p>
<p>І ось цю взаємодію потрібно описувати у максимально загальній (абстрактній) формі, тобто у формі інтерфейсу. У цьому випадку код працюватиме однаково з будь-якою реалізацією, що відповідає контракту інтерфейсу. Саме ця можливість працювати з різними реалізаціями (модулями чи об'єктами) через уніфікований інтерфейс і називається поліморфізмом.</p>
<p>Саме тому <span class="text-green">Servlet – це інтерфейс</span> : веб-контейнер нічого не знає про сервлети, для нього це якісь об'єкти, які реалізує інтерфейс Servlet та все. Сервлети теж трохи знають про влаштування контейнера. Інтерфейс Servlet – це той контракт, той стандарт, та мінімальна взаємодія, яку потрібно, щоб Java-веб-додатки завоювали світ.</p>
<p><strong>Поліморфізм</strong> — це зовсім не перевизначення методів, як іноді помилково вважають, а насамперед взаємозамінність модулів/об'єктів з однаковим інтерфейсом або «один інтерфейс, безліч реалізацій». Задля реалізації поліморфізму механізм успадкування не потрібен. Це важливо розуміти, оскільки <span class="text-red">успадкування взагалі, по можливості, слід уникати</span> .</p>
<p>Завдяки <span class="text-green">інтерфейсам та поліморфізму</span> якраз і досягається можливість модифікувати та розширювати код без зміни того, що вже написано (Open-Closed Principle).</p>
<p>Доки взаємодія модулів описана виключно у вигляді інтерфейсів і не зав'язана на конкретні реалізації, ти маєш можливість абсолютно "безболісно" для системи замінити один модуль на будь-який інший, що реалізує той же інтерфейс, а також додати новий і тим самим розширити функціональність.</p>
<p>Це як у конструкторі LEGO — інтерфейс стандартизує взаємодію та служить свого роду конектором, куди може бути підключений будь-який модуль з відповідним роз'ємом.</p>
<p>Гнучкість конструктора забезпечується тим, що ми можемо просто замінити одні модулі або деталі на інші з такими ж роз'ємами (з тим самим інтерфейсом), а також додати скільки завгодно нових деталей (при цьому вже існуючі деталі не змінюються і не переробляються).</p>
<p>Інтерфейси дозволяють будувати простішу систему, розглядаючи кожну підсистему як єдине ціле та ігноруючи її внутрішній пристрій. Вони дають можливість модулям взаємодіяти і при цьому нічого не знати про внутрішню структуру один одного, тим самим повністю реалізуючи принцип мінімального знання, що є основою слабкої зв'язаності.</p>
<p>Чим більш загальної/абстрактної формі визначені інтерфейси і що менше обмежень вони накладають на взаємодію, тим гнучкіша система. Звідси фактично випливає ще один із принципів SOLID - <strong>Принцип поділу інтерфейсу</strong> (Interface Segregation Principle), який виступає проти "товстих інтерфейсів".</p>
<p>Він каже, що великі, об'ємні інтерфейси треба розбивати більш маленькі і специфічні, щоб клієнти маленьких інтерфейсів (залежні модулі) знали лише про методи, які їм у роботі.</p>
<p>Формулюється цей принцип так: "Клієнти не повинні залежати від методів (знати про методи), які вони не використовують" або "Багато спеціалізованих інтерфейсів краще, ніж один універсальний".</p>
<p>Виходить, що слабка зв'язність забезпечується лише тоді, коли взаємодія та залежності модулів описуються лише за допомогою інтерфейсів, тобто абстракцій, без використання знань про їх внутрішній устрій та структуру. І фактично цим реалізується інкапсуляція. Плюс ми маємо можливість розширювати/змінювати поведінку системи за рахунок додавання та використання різних реалізацій, тобто за рахунок поліморфізму. Так, ми знову прийшли до ООП – Інкапсуляція, Абстракція, Поліморфізм.</p>
<h2>8.3 Фасад: інтерфейс модуля</h2>
<p>Тут досвідчений програміст запитає: якщо проектування йде не так на рівні об'єктів, які самі й реалізують відповідні інтерфейси, але в рівні модулів, те що є реалізацією інтерфейсу модуля?</p>
<p>Відповідь: якщо говорити мовою патернів проектування, то за реалізацію інтерфейсу модуля може відповідати спеціальний об'єкт — <strong>Фасад</strong> . Якщо ти викликаєш методи об'єкта, що містить суфікс Gateway (наприклад MobileApiGateway), то, швидше за все, це фасад.</p>
<p><span class="text-green"><strong>Фасад - це об'єкт-інтерфейс</strong> , що акумулює в собі високорівневий набір операцій для роботи з деякою підсистемою, що приховує її внутрішню структуру і справжню складність</span> . Забезпечує захист від змін у реалізації підсистеми. Служить єдиною точкою входу - "ти штурхаєш фасад, а він знає, кого там треба штовхнути в цій підсистемі, щоб отримати потрібне".</p>
<p>Ти щойно познайомився з одним із найважливіших патернів проектування, що дозволяє використовувати концепцію інтерфейсів при проектуванні модулів і тим самим послаблювати їхню пов'язаність - "Фасад".</p>
<p>Крім цього, "Фасад" дає можливість працювати з модулями так само, як зі звичайними об'єктами і застосовувати при проектуванні модулів всі ті корисні принципи та техніки, які використовуються при проектуванні класів.</p><img data-max-width="1024" data-id="6ab91681-8155-4b59-b05f-7f01cdef7d10" alt="Фасад: інтерфейс модуля" src="https://cdn.javarush.com/images/article/6ab91681-8155-4b59-b05f-7f01cdef7d10/1024.jpeg" style="width: 1024px;">
<p><strong>Зауваження</strong> : хоча більшість програмістів розуміють важливість інтерфейсів при проектуванні класів (об'єктів), складається враження, що ідею необхідності використовувати інтерфейси також і на рівні модулів багато хто відкриває сам.</p>