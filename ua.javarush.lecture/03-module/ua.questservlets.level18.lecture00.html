<h2>Знайомство з пам'яттю в JVM</h2>
<p>Як ти вже знаєш, JVM запускає Java-програми у собі. Як і будь-яка віртуальна машина вона має власну систему організації пам'яті.</p>
<p>Схема організації внутрішньої пам'яті вказує на принцип роботи вашого Java-програми. Таким чином можна визначити вузькі місця у роботі додатків та алгоритмів. Давай розберемося, як вона влаштована.</p><img data-max-width="800" data-id="1180008a-b863-4007-b14b-10c0a106ecb8" alt="Знайомство з пам'яттю в JVM" src="https://cdn.javarush.com/images/article/1180008a-b863-4007-b14b-10c0a106ecb8/800.jpeg" style="width: 800px;">
<p><strong>Важливо! </strong>Модель Java в початковому вигляді була недостатньо хороша, тому вона була переглянута Java 1.5. Ця версія використовується досі (Java 14+).</p>
<h2>Стек потоку</h2>
<p>Модель пам'яті Java, що використовується всередині JVM, ділить пам'ять на стеки потоків (thread stacks) і купу (heap). Подивимося на Java-модель пам'яті, логічно розділену на блоки:</p><img data-max-width="512" data-id="06c9cf70-8f47-463d-b6bd-e19ae1f5d72a" alt="Стек потоку" src="https://cdn.javarush.com/images/article/06c9cf70-8f47-463d-b6bd-e19ae1f5d72a/512.jpeg" style="width: 512px;">
<p><strong>Всі потоки</strong> , що працюють у JVM, мають <strong>свій стек</strong> . Стек у свою чергу містить інформацію про те, які методи викликав потік. Я називатиму це “стеком викликів”. Стек дзвінків відновлюється, коли потік виконує свій код.</p>
<p>Стек потоку містить у собі <strong>всі локальні змінні</strong> , необхідні виконання методів зі стека потоку. Потік може отримати доступ лише до стека. Локальні змінні не видно іншим потокам, тільки потоку, який їх створив. У ситуації, коли два потоки виконують той самий код, вони обидва створюють свої локальні змінні. Таким чином, кожен потік має свою версію кожної локальної змінної.</p>
<p>Всі локальні змінні примітивних типів ( <span class="text-orange">boolean</span> , <span class="text-orange">byte</span> , <span class="text-orange">short</span> , <span class="text-orange">char</span> , <span class="text-orange">int</span> , <span class="text-orange">long</span> , <span class="text-orange">float</span> , <span class="text-orange">double</span> ) повністю зберігаються в стеку потоків і не видно інших потоків. Один потік може передати копію примітивної змінної іншому потоку, але не може спільно використовувати примітивну локальну змінну.</p>
<h2>Купа (heap)</h2>
<p>Купа містить усі об'єкти, створені у вашій програмі, незалежно від того, який потік створив об'єкт. До цього відносяться і обгортки примітивних типів (наприклад, <span class="text-orange">Byte</span> , <span class="text-orange">Integer</span> , <span class="text-orange">Long</span> тощо). Неважливо, чи був об'єкт створений і присвоєний локальної змінної чи створений як змінна-член іншого об'єкта, він зберігається у купі.</p>
<p>Нижче діаграма, яка ілюструє стек викликів та локальні змінні (вони зберігаються у стеках), а також об'єкти (вони зберігаються у купі):</p><img data-max-width="800" data-id="7b8ec0e5-49eb-4a16-b473-7462cbbc4065" alt="Купа (heap)" src="https://cdn.javarush.com/images/article/7b8ec0e5-49eb-4a16-b473-7462cbbc4065/800.jpeg" style="width: 800px;">
<p>Якщо локальна змінна примітивного типу, вона зберігається в стеку потоку.</p>
<p>Локальна змінна може бути посиланням на об'єкт. І тут посилання (локальна змінна) зберігається у стеку потоків, але сам об'єкт зберігається у купі.</p>
<p>Об'єкт містить методи, які містять локальні змінні. Ці локальні змінні зберігаються в стеку потоків, навіть якщо об'єкт, якому належить метод, зберігається в купі.</p>
<p>Змінні-члени об'єкта зберігаються у купі разом із самим об'єктом. Це вірно як у випадку, коли змінна член має примітивний тип, так і в тому випадку, якщо вона є посиланням на об'єкт.</p>
<p>Статичні змінні класу також зберігаються у купі разом із визначенням класу.</p>
<h2>Взаємодія з об'єктами</h2>
<p>До об'єктів у купі можуть звертатися всі потоки, які мають посилання об'єкт. Якщо потік має доступ до об'єкта, він може отримати доступ до змінних цього об'єкта. Якщо два потоки викликають метод для одного і того ж об'єкта одночасно, вони обидва матимуть доступ до змінних-членів об'єкта, але кожен потік матиме свою власну копію локальних змінних.</p><img data-max-width="800" data-id="130d32a3-c025-4f2b-9a40-616ba1fd2080" alt="Взаємодія з об'єктами (heap)" src="https://cdn.javarush.com/images/article/130d32a3-c025-4f2b-9a40-616ba1fd2080/800.jpeg" style="width: 800px;">
<p>Два потоки мають набір локальних змінних.<mark class="user">Local Variable 2</mark>вказує на загальний об'єкт у купі (<mark class="green">Object 3</mark>). Кожен із потоків має свою копію локальної змінної зі своїм посиланням. Їхні посилання є локальними змінними і тому зберігаються в стеках потоків. Тим не менш, два різні посилання вказують на той самий об'єкт у купі.</p>
<p>Зверніть увагу, що загальний<mark class="green">Object 3</mark>має посилання на<mark class="green">Object 2</mark>і<mark class="green">Object 4</mark>як змінні члени (показано стрілками). Через ці посилання два потоки можуть отримати доступ до<mark class="green">Object 2</mark>і<mark class="green">Object</mark>4.</p>
<p>На діаграмі також показано локальну змінну (<mark class="user">Local variable 1</mark>з <span class="code text-orange">methodTwo</span> ). Кожна її копія містить різні посилання, які вказують на два різні об'єкти (<mark class="green">Object 1</mark>і<mark class="green">Object 5</mark>), а не на один і той самий. Теоретично обидва потоки можуть звертатися як до<mark class="green">Object 1</mark>, так і до<mark class="green">Object 5</mark>якщо вони мають посилання на обидва ці об'єкти. Але на діаграмі вище кожен потік має посилання лише на один із двох об'єктів.</p>
<h2>Приклад взаємодії з об'єктами</h2>
<p>Давай подивимося, як ми можемо продемонструвати роботу в коді:</p>
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MySomeRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> localOne <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

        <span class="token class-name">Shared</span> localTwo <span class="token operator">=</span> <span class="token class-name">Shared</span><span class="token punctuation">.</span>instance<span class="token punctuation">;</span>

        <span class="token comment">//… робимо щось із локальними змінними</span>

        <span class="token function">two</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">two</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Integer</span> localOne <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

        <span class="token comment">//… робимо щось із локальними змінними</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Shared</span> <span class="token punctuation">{</span>

    <span class="token comment">// зберігаємо інстанс на наш об'єкт у змінній</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Shared</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Shared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Змінні-члени, що вказують на два об'єкти в купі</span>

    <span class="token keyword">public</span> <span class="token class-name">Integer</span> object2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Integer</span> object4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">44</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>Метод <span class="code text-orange">run()</span> викликає метод <span class="code text-orange">one()</span> , а <span class="code text-orange">one()</span> своєю чергою викликає <span class="code text-orange">two()</span> .</p>
<p>Метод <span class="code text-orange">one()</span> оголошує примітивну локальну змінну (<mark class="user">localOne</mark>) типу <span class="text-orange">int</span> і локальну змінну (<mark class="user">localTwo</mark>), яка є посиланням на об'єкт.</p>
<p>Кожен потік, що виконує метод <span class="code text-orange">one()</span> , створить свою власну копію<mark class="user">localOne</mark>і<mark class="user">localTwo</mark>у своєму стеку. Змінні<mark class="user">localOne</mark>будуть повністю відокремлені один від одного, перебуваючи у стеку кожного потоку. Один потік не може бачити, які зміни вносить інший потік у свою копію<mark class="user">localOne</mark>.</p>
<p>Кожен потік, що виконує метод <span class="code text-orange">one()</span> , також створює свою власну копію<mark class="user">localTwo</mark>. Однак дві різні копії<mark class="user">localTwo</mark>зрештою вказують на той самий об'єкт у купі. Справа в тому що<mark class="user">localTwo</mark>вказує на об'єкт, на який посилається статична змінна<mark class="user">instance</mark>. Існує лише одна копія статичної змінної, і ця копія зберігається у купі.</p>
<p>Таким чином, обидві копії<mark class="user">localTwo</mark>зрештою вказують на той самий екземпляр <span class="code"><span class="text-green">Shared</span></span> . Примірник <span class="code"><span class="text-green">Shared</span></span> також зберігається у купі. Він відповідає<mark class="green">Object 3</mark>на діаграмі вище.</p>
<p>Зверніть увагу, що клас <span class="code"><span class="text-green">Shared</span></span> також містить дві змінні-члени. Самі змінні-члени зберігаються у купі разом із об'єктом. Дві змінні-члени вказують на два інші об'єкти<mark class="green">Integer</mark>. Ці цілі численні об'єкти відповідають<mark class="green">Object 2</mark>і<mark class="green">Object 4</mark>на діаграмі.</p>
<p>Також зверніть увагу, що метод <span class="code text-orange">two()</span> створює локальну змінну з ім'ям<mark class="user">localOne</mark>. Ця локальна змінна є посиланням на об'єкт типу <span class="text-orange">Integer</span> . Метод встановлює посилання<mark class="user">localOne</mark>для вказівки на новий екземпляр <span class="text-orange">Integer</span> . Посилання зберігатиметься у своїй копії<mark class="user">localOne</mark>для кожного потоку. Два екземпляри <span class="text-orange">Integer</span> будуть збережені в купі і, оскільки метод створює новий об'єкт <span class="text-orange">Integer</span> при кожному виконанні, два потоки, що виконують цей метод, будуть створювати окремі екземпляри <span class="text-orange">Integer</span> . Вони відповідають<mark class="green">Object 1</mark>і<mark class="green">Object 5</mark>на діаграмі вище.</p>
<p>Зверніть увагу також на дві змінні-члени в класі <span class="code"><span class="text-green">Shared</span></span> типу <span class="text-orange">Integer</span> , який є примітивним типом. Оскільки ці змінні є змінними членами, вони все ще зберігаються в купі разом з об'єктом. У стеку потоків зберігаються лише локальні змінні.</p>