<h2>Знайомство із трирівневою архітектурою</h2>
<p>Трирівнева архітектура - це найпоширеніша архітектура взаємодії в Інтернеті. Вона з'явилася, коли серверну частину дворівневої розділабо на дві частини: <span class="text-bold">шар логіки</span> та <span class="text-bold">шар даних</span> .</p>
<p>Виглядати це стало приблизно так:</p><img data-max-width="800" data-id="d4fe159e-3ea8-45fd-9db7-b9a97d7e173b" alt="" src="https://cdn.javarush.com/images/article/d4fe159e-3ea8-45fd-9db7-b9a97d7e173b/800.jpeg" style="width: 800px;">
<p><span class="text-bold">Шар клієнта</span> – це частина «розподіленої програми», яка відповідає за взаємодію з користувачем. Цей шар не повинен містити бізнес-логіки та не повинен зберігати критично важливі дані. Також він не повинен взаємодіяти з шаром бази даних безпосередньо, а лише через бізнес-логіку.</p>
<p>Однак якась логіка тут все ж таки є. По-перше, це взаємодія з користувачем через інтерфейс, валідація даних, що вводяться ним, робота з локальними файлуми. Ще сюди можна віднести все, що стосується авторизації користувача та шифрування даних під час роботи з сервером.</p>
<p>По-друге, це нескладна логіка бізнесу. Наприклад, надіслав інтернет-магазин список товарів, на стороні клієнта ми можемо їх відсортувати, відфільтрувати. І примітивне зберігання даних тут теж є: кешування, куки залогіненого користувача тощо.</p>
<p><span class="text-bold">Шар бізнес-логіки</span> розташовується на другому рівні, на ньому зосереджена більша частина бізнес-логіки. Поза його залишаються лише фрагменти, що експортуються на клієнта, а також елементи логіки, занурені в базу даних (збережені процедури та тригери).</p>
<p>Дуже частина сервера бізнес-логіки містять не лише цю саму логіку, але й вирішують завдання масштабування: код розбивається на частини та розноситься різними серверами. Деякі сервіси, що особливо затребувані, можуть запускатися на десятках серверів. Навантаженням між ними керує load balancer.</p>
<p>Серверні програми зазвичай проектуються таким чином, щоб легко можна було запустити ще одну копію сервера і почала працювати в кооперації з іншими його копіями. Тобто навіть у процесі написання серверного коду тебе ніколи не буде гарантій, що твій статичний клас запущений в єдиному екземплярі.</p>
<p><span class="text-bold">Шар даних</span> забезпечує зберігання даних і виноситься окремий рівень, реалізується, зазвичай, засобами систем управління базами даних (СУБД), підключення до цього компоненту забезпечується лише з рівня сервера додатків.</p>
<h2>Причини відокремлення шару даних</h2>
<p>Відділення шару даних у повноцінний третій шар відбулося з багатьох причин, але найголовніша — це зростання навантаження на сервер.</p>
<p>По-перше, <span class="text-bold">бази даних почали вимагати багато пам'яті</span> та процесорного часу на обробку даних. Тому їх почали виносити на окремі сервери.</p>
<p>Бекенд при збільшеному навантаженні можна було легко дублювати і підняти десять копій одного сервера, а дублювати базу даних було не можна - база все ще залишалася єдиним і неподільним компонентом системи.</p>
<p>По-друге, <span class="text-bold">бази даних стали розумними</span> — у них виникла власна бізнес-логіка. Вони стали підтримувати процедури, що зберігаються, тригери, власні мови типу PLSQL. І навіть з'явабося програмісти, які почали писати код, який виконує всередині СУБД.</p>
<p>Всю логіку, яка не була зав'язана на дані, виносабо в бекенд і паралельно запускали на десятках серверів. Все критично зав'язане на даних залишалося всередині СУБД і там уже проблеми навантаження, що виросло, доводилося вирішувати своїми методами:</p>
<ul>
 <li>Кластер бази даних — група серверів БД, які зберігають одні й самі дані і синхронізують їх у певному протоколі.</li>
 <li>Шардування - дані дробляться на логічні блоки і розносяться різними серверами БД. Дуже складно підтримувати зміни БД за такого підходу.</li>
 <li>Підхід NoSQL - зберігання даних у БД, які побудовані для зберігання величезної кількості даних. Це часто навіть не бази, а специфічні файлові сховища. Дуже бідний функціонал проти реляційними базами даних.</li>
 <li>Кешування даних. Замість простого кешу на рівні бази даних з'явабося цілі СУБД, що кешують, які зберігали результат тільки в пам'яті.</li>
</ul>
<p>Зрозуміло, що для управління цим зоопарком серверних технологій потрібні були окремі люди та/або цілі команди, що призвело до винесення шару даних в окремий шар.</p>
<p><span class="text-bold"><span class="text-red">Важливо! </span></span>Усі передові технології народжуються у надрах великих ІТ-корпорацій, коли старі підходи перестають справлятися з новими викликами. Винесення баз даних в окремий шар вигадав не якийсь програміст, а група інженерів десь у надрах Oracle або IBM.</p>
<p><span class="text-bold">Цікаво! </span>Коли Цукерберг починав писати Facebook, він працював просто на PHP+MySQL. Коли користувачів стало мільйони, то написали спеціальний транслятор, який переклав весь PHP код C++ і скомпілювали його в нативний машинний код.</p>
<p>Також MySQL не здатний зберігати дані мільярдів користувачів, тому Facebook розробив концепцію NoSQL баз даних і написав потужну серверну NoSQL-СУБД - Cassandra. До речі, вона повністю написана Java.</p>
<h2>Неоднозначність розташування логіки програми</h2>
<p>І хоча трирівнева архітектура практично однозначно розподіляє ролі між її частинами, не завжди можна правильно визначити, яке саме місце системи потрібно додати нову частину бізнес-логіки (новий код).</p>
<p>Приклад такої неоднозначності представлений на малюнку нижче:</p><img data-max-width="800" data-id="9eeb32e6-fd5a-4698-9a13-c26a8f459efa" alt="" src="https://cdn.javarush.com/images/article/9eeb32e6-fd5a-4698-9a13-c26a8f459efa/800.jpeg" style="width: 800px;">
<p>Сірим фоном залита серверна частина, білим клієнтська. Хороший приклад останнього підходу (крайній правий варіант) – це сучасні мобільні програми. На стороні клієнта (на телефоні) міститься уявлення (відображення), логіка та дані. І лише інколи ці дані синхронізуються із сервером.</p>
<p>Приклад крайнього лівого варіанту - це типовий PHP-сервер, у якого вся логіка знаходиться на сервері, і він віддає клієнту вже статичний HTML. Десь між цими двома крайніми варіантами і буде ваш проект.</p>
<p>На початку роботи, після того, як ти ознайомишся з проектом, тобі потрібно буде радитися з програмістами, які працюють над ним, щодо місць, де тобі краще реалізувати логіку чергового завдання.</p>
<p>Не соромся так робити. По-перше, до чужого монастиря зі своїм статутом не лізуть. По-друге, всім буде простіше (і тобі теж) знаходити потрібний вам код там, де ти очікуєш його знайти.</p>