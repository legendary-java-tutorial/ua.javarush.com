<p>- Привіт, Аміго! Хочу присвятити сьогоднішню лекцію&nbsp; <span class="red_text"><span class="text-red">інкапсуляції</span> . </span>&nbsp;Ти вже знаєш загалом, що це таке.</p><a href="https://cdn.javarush.com/images/article/3643bfbf-3555-4a07-a18f-abd3db9abd5e/original.jpeg" target="_blank"><img data-id="3643bfbf-3555-4a07-a18f-abd3db9abd5e" data-max-width="1024" alt="Інкапсуляція - 1" src="https://cdn.javarush.com/images/article/3643bfbf-3555-4a07-a18f-abd3db9abd5e/1024.jpeg" style="width: 1024px;"></a>
<p>У чому переваги інкапсуляції? Їх досить багато, але я можу виділити чотири, на мій погляд, основні:</p>
<h3>1) Валідний внутрішній стан.</h3>
<p>У програмах часто виникають ситуації, коли кілька класів, взаємодіють з тим самим об'єктом. Внаслідок їхньої спільної роботи порушується цілісність даних усередині об'єкта — об'єкт вже не може продовжити нормально працювати.</p>
<p><span class="text-green">Тому об'єкт повинен стежити за змінами своїх внутрішніх даних, а ще краще проводити їх сам.</span></p>
<p>Якщо ми не хочемо, щоб якась змінна класу змінювалася іншими класами, ми оголошуємо її <strong>private</strong> , і тоді лише методи її класу зможуть отримати до неї доступ. Якщо хочемо, щоб значення змінних можна було лише читати, але з змінювати, тоді потрібно додати <strong>public getter</strong> для потрібних змінних.</p>
<p>Наприклад, ми хочемо, щоб усі могли дізнатися кількість елементів у нашій колекції, але ніхто не міг його змінити без нашого дозволу. Тоді ми оголошуємо змінну <strong>private int count</strong> та метод <strong>public getCount()</strong> .</p>
<p>Правильне використання інкапсуляції гарантує, що <span class="text-red">жоден клас не може отримати прямого доступу до внутрішніх даних нашого класу і, отже, змінити їх без контролю з нашого боку. </span>Тільки через виклик методів того ж класу, що і змінні змінні.</p>
<p><span class="text-green">Краще виходити з того, що інші програмісти завжди будуть використовувати твої класи найзручнішим для них чином, а не найбезпечнішим для тебе (для твого класу). </span>Звідси і помилки, і спроби наперед позбутися їх.</p>
<h3>2) Контроль переданих аргументів.</h3>
<p>Іноді потрібно контролювати аргументи, що передаються методами нашого класу. Наприклад, наш клас описує об'єкт «людина» та дозволяє задати дату її народження. <span class="text-corporate">Ми повинні перевіряти всі дані, що передаються, на їх відповідність логіці програми та логіці нашого класу. </span>Наприклад, не допускати 13-й місяць, дату народження 30 лютого тощо.</p>
<p><span class="text-user">— А навіщо комусь вказувати у даті народження 30 лютого?</span></p>
<p>— По-перше, це може бути помилка введення даних від користувача.</p>
<p>По-друге, перш ніж програма працюватиме як годинник, у ній буде багато помилок. Наприклад, можлива така ситуація.</p>
<p>Програміст пише програму визначення людей, які мають день народження післязавтра. Наприклад сьогодні 3 березня. Програма додає до поточного дня місяця число 2 та шукає всіх, хто народився 5 березня. Начебто все правильно.</p>
<p>Ось тільки коли настане 30 березня програма не знайде нікого, т.к. у календарі немає 32 березня. У програмі стає набагато менше помилок, коли методи додають перевірку переданих даних.</p>
<p><span class="text-user">— Пам'ятаю, коли ми вивчали ArrayList, я дивився його код, і там була перевірка індексу в методах get і set: index більший або дорівнює нулю і менше довжини масиву. Там ще кидався виняток, якщо масив немає елемента з таким індексом.</span></p>
<p>- Так, <span class="text-green">це класичний приклад перевірки вхідних даних.</span></p>
<h3>3) Мінімізація помилок під час зміни коду класів.</h3>
<p>Припустимо, що ми написали один дуже корисний клас, коли брали участь у великому проекті. Він так сподобався всім, що інші програмісти почали використовувати його в сотнях місць у своєму коді.</p>
<p>Клас виявився настільки корисним, що ти вирішив його покращити. <span class="text-red">Але якщо ти видалиш якісь методи цього класу, код десятків людей перестане компілюватися. </span>Їм доведеться терміново все переробляти. І чим більше переробок, тим більше помилок. Ти поламаєш купу збірок, і тебе ненавидітимуть.</p>
<p>А коли ми змінюємо методи, оголошені як private, ми знаємо, що ніде немає жодного класу, який би викликав ці методи. Ми можемо їх переробити, змінити кількість параметрів та їх типи, і залежний код буде працювати далі. Ну, або, як мінімум, компілюватися.</p>
<h3>4) Задаємо спосіб взаємодії нашого об'єкта із сторонніми об'єктами.</h3>
<p>Ми можемо обмежити деякі дії, допустимі з нашим об'єктом. Наприклад, ми хочемо, щоб об'єкт можна було створити лише в одному екземплярі. Навіть якщо його створення відбувається у кількох місцях проекту одночасно. І ми можемо зробити це завдяки інкапсуляції.</p><a href="https://cdn.javarush.com/images/article/85b1f2fa-09fe-4777-890e-05d3a824a2bf/original.jpeg" target="_blank"><img data-id="85b1f2fa-09fe-4777-890e-05d3a824a2bf" data-max-width="850" alt="Інкапсуляція - 2" src="https://cdn.javarush.com/images/article/85b1f2fa-09fe-4777-890e-05d3a824a2bf/800.jpeg" style="width: 850px;"></a>
<p>Інкапсуляція дозволяє додавати <span class="text-red">додаткові обмеження</span> , які можна перетворити на <span class="text-red">додаткові переваги</span> . Наприклад, клас String реалізований як immutable (незмінний) об'єкт. Об'єкт класу String незмінний з моменту створення і до смерті. Усі методи класу String (remove, substring, …) <span class="text-green">повертають новий рядок, абсолютно не змінюючи об'єкт, у якого вони були викликані.</span></p>
<p><span class="text-user">- Нічого собі. Ось воно як, виявляється.</span></p>
<p>— Інкапсуляція — дуже цікава штука.</p>
<p><span class="text-user">- Ага.</span></p>