<p>- Привіт, Аміго! У нас нова та дуже важка тема. Співчуваю. Часто вона вважається однією з найскладніших у Java, а й у програмуванні взагалі. Це –&nbsp; <em><strong><span class="text-red">багатонитковість (multithreading)</span></strong></em> .</p>
<p>Уяви собі середню комп'ютерну гру, наприклад, гонки на зорельотах. Ти летиш просторами космосу, ухиляючись від метеоритів і патрульних крейсерів, а з тобою ще два десятки таких же учасників цих нелегальних перегонів.</p>
<p>Допустимо, ти вирішив написати таку саму гру. Твоєї програми доведеться відстежувати команди управління (введення з клавіатури), переміщати зорельоти, розраховувати їх траєкторії та наслідки зіткнення, а також малювати все це на екрані користувача. Це дуже складна робота.</p>
<p>Згадай, як ми вирішабо проблему великої складності в тому прикладі про зростання кур'єрської компанії.</p>
<p><span class="text-user">— Ми розділабо її на незалежні відділи та жорстко задали (стандартизували) способи їхньої взаємодії.</span></p>
<p><strong>— Але що робити, коли незалежним частинам потрібно виконати якийсь обсяг роботи паралельно з іншими частинами?! Відповідь це питання – нитки(треды) (чи як їх неправильно називають – потоки).</strong></p>
<p><strong>Спробуй уявити програму, як&nbsp; <span class="text-red">такого маленького робота</span> , який&nbsp; <span class="text-red">бігає за кодом та виконує команди</span> . Спочатку виконав команду, написану в одному рядку, потім перейшов на наступний і так далі.</strong></p>
<p><span class="text-user">- Уявив. Нічого складного!</span></p>
<p>- Чудово. А тепер уяви, що таких роботів у тебе кілька. І доки один займається введенням від користувача, другий змінює об'єкти відповідно до нього. Третій виконує код, відображаючи ці об'єкти на екран, а четвертий кілька разів на секунду перевіряє – чи не зіткнулися кораблі і, у разі зіткнення, прораховує його результати.</p>
<p>Таким чином, ми можемо розділити програму не тільки на незалежні частини/об'єкти, але й досягти того, що ці частини виконуватимуть свою роботу незалежно одна від одної. А що менше взаємодії між окремими частинами, то менша складність програми.</p>
<p>Уяви, що&nbsp; <strong>ти зміг&nbsp; <span class="text-red">замінити менеджера - скриптом</span></strong> , <strong>що розсилає листи</strong> . А решта відділів компанії про це навіть не здогадалася. Такі приклади вже мали місце у 26 столітті та показали відмінні результати.&nbsp;<strong>Більшість менеджерів і навіть топ-менеджерів може бути успішно замінено скриптом середньої складності. </strong>&nbsp;Тільки після втручання "профспілки офісного планктону" вдалося зупинити масові звільнення менеджерів. Але це так – відволікання від теми.</p>
<p><span class="text-user">- Як цікаво.</span></p>
<p>— Мало того, що у програмі може бути кілька таких «маленьких роботів», які виконують код, то ці роботи можуть ще спілкуватися один з одним і породжувати нових роботів.</p>
<p><span class="text-user">— Створювати нових роботів?</span></p>
<p>— Так, для виконання нових завдань. Іноді вигідно створити ще одного робота (ще одну нитку), яка виконуватиме якусь дію одночасно з поточною ниткою (роботом).</p>
<p class="text-user">— Думаю, що це гарна річ, хоч поки що не можу придумати, де б я цим користувався.</p>
<p class="text-user">А чому це називається «нитки»?</p>
<p>— Уяви, що всі роботи різного кольору і кожен робот позначає своїм кольором усі команди, які він виконав. Таким чином, за маленьким роботом, як за олівцем, тягтиметься слід. Цей слід тягнеться за роботом, як нитка за голкою.</p>
<p>Кожен такий «маленький робот» має завдання, для виконання якого його створабо. І нитка – це набір команд, виконаних у процесі виконання цього завдання.</p>
<p>Допустимо, ти летиш на зорельоті, щоб доставити вантаж. Тоді "доставити вантаж" - це твоє завдання, ти в процесі його виконання. А шлях, який ти пролетів – це твоя нитка. Можна сказати, що кожному новому завданню, кожному ще не вирішеному завданню відповідає своя нитка – шлях, який ще належить пройти.</p>
<p><span class="text-user">— Іншими словами, є завдання і «маленький робот», який його виконує, а нитка – це лише погляд на поточний стан справ із боку?</span></p>
<p>- Саме так.</p>
<p>А ось як усе це працює глибоко усередині. Т.к. процесор у комп'ютера один, він може виконувати лише одну команду одночасно. Тому відбувається ось що: процесор постійно перемикається між нитками. Переключився на нову нитку, виконав кілька її команд, потім переключився на наступну нитку, виконав кілька її команд тощо.&nbsp;<span class="text-red">Але т.к. перемикання між нитками відбувається сотні разів на секунду, збоку здається, що всі нитки працюють одночасно.</span></p><a href="https://cdn.javarush.com/images/article/821343b2-82b0-4b58-9aef-840d7565d6b1/original.jpeg" target="_blank"><img data-id="821343b2-82b0-4b58-9aef-840d7565d6b1" data-max-width="850" alt="Багатопотоковість або багатонитковість - 1" src="https://cdn.javarush.com/images/article/821343b2-82b0-4b58-9aef-840d7565d6b1/800.jpeg" style="width: 850px;"></a>