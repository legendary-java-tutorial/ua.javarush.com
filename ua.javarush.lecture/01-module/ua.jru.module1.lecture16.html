Життєвий цикл об’єкта
<p>----------------------------------------</p>
Думаю, ти не сильно здивуєшся, якщо тобі сказати, що розмір пам’яті на твоєму комп’ютері обмежений :) Навіть жорсткий диск, який у рази більший за оперативну пам’ять, можна забити під зав’язку улюбленими іграми, серіалами та іншим...
<p>----------------------------------------</p>
<p>Вітаю!</p>
<p>Навіть жорсткий диск, який у рази більший за оперативну пам’ять, можна забити під зав’язку улюбленими іграми, серіалами
та іншим. Щоб цього не сталося, необхідно стежити за поточним станом пам’яті та видаляти з компа непотрібні файли.</p>

<p>Яке відношення до всього цього має програмування на Java? Пряме! Адже під час створення будь-якого об’єкта Java-машиною
під нього виділяється пам’ять. У реальній великій програмі створюються десятки та сотні тисяч об’єктів, під кожен із
яких у пам’яті виділяється свій шматочок.</p>

<p>Але як ти думаєш, скільки існують всі ці об’єкти? Чи «живуть» вони весь час, поки працює наша програма? Зрозуміло, що
ні.</p>

<p>За всіх переваг Java-об’єктів вони не безсмертні :) Об’єкти мають власний життєвий цикл.</p>

<p>Сьогодні ми трохи відпочинемо від написання коду і розглянемо цей процес :) Тим більше, що він є дуже важливим для
розуміння роботи програми та розпорядження ресурсами.</p>

<p>Отже, з чого ж починається життя об’єкта? Як і в людини — з його народження, тобто створення.</p>

<pre class="lang-java line-numbers"><code>
Cat cat = new Cat();//ось зараз і розпочався життєвий цикл нашого об’єкта Cat!
</code></pre>
<p>Спочатку віртуальна Java-машина виділяє необхідний обсяг пам’яті для створення об’єкта.</p>

<p>Потім вона створює на нього посилання, у нашому випадку — <code>cat</code>, щоб мати можливість його відстежувати. Після
цього відбувається ініціалізація всіх змінних, виклик конструктора і ось — наш свіжий об’єкт вже живе своїм життям :)</p>

<p>Строк життя у об’єктів різний, точних цифр тут не існує. У будь-якому випадку протягом певного часу він живе всередині
програми та виконує свої функції.</p>

<p>Якщо говорити точно, об’єкт є «живим» поки на нього є посилання. Тільки-но посилань не залишається, — об’єкт «вмирає».</p>

<p>Наприклад:</p>

<pre class="lang-java line-numbers"><code>
public class Car {
  
   String model;

   public Car(String model) {
       this.model = model;
   }

   public static void main(String[] args) {
       Car lamborghini  = new Car("Lamborghini Diablo");
       lamborghini = null;

   }

}
</code></pre>
<p>У методі <code>main()</code> об’єкт машини Lamborghini Diablo перестає бути живим уже на другому рядку. На нього було лише одне
посилання, а тепер цьому посиланню було присвоєно <code>null</code>. Оскільки на Lamborghini Diablo не залишилося посилань, він стає
«сміттям».</p> 

<p>Посилання при цьому не обов’язково обнуляти:</p>

<pre class="lang-java line-numbers"><code>
public class Car {

   String model;

   public Car(String model) {
       this.model = model;
   }

   public static void main(String[] args) {
       Car lamborghini  = new Car("Lamborghini Diablo");

       Car lamborghiniGallardo = new Car("Lamborghini Gallardo");
       lamborghini = lamborghiniGallardo;
   }

}
</code></pre>
<p>Тут ми створили другий об’єкт, після чого взяли посилання <code>lamborghini</code> і присвоїли йому цей новий об’єкт. Тепер на об’єкт
<code>Lamborghini Gallardo</code> вказують два посилання, а на об’єкт <code>Lamborghini Diablo</code> — жодне. Тому об’єкт <code>Diablo</code> стає сміттям. </p>

<p>І в цей момент в роботу вступає вбудований механізм Java під назвою збирач сміття, або по-іншому — Garbage Collector, GC.
<div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="90f951c8-7932-4b1b-91d8-ba17fae210fc" data-max-width="850" alt="Життєвий цикл об’єкта  - 2" src="https://cdn.javarush.com/images/article/90f951c8-7932-4b1b-91d8-ba17fae210fc/1024.jpeg"></div></div>Збирач сміття – внутрішній механізм Java, який відповідає за звільнення пам’яті, тобто видалення з неї непотрібних об’єктів.</p>

<p>Ми не дарма обрали для його зображення картинку з роботом-пилососом. Адже збирач сміття працює приблизно так само: у
фоновому режимі він «їздить» по твоїй програмі, збирає сміття, і при цьому ти з ним практично не взаємодієш.</p>

<p>Його робота – видаляти об’єкти, які вже не використовуються у програмі. Отже, він звільняє в комп’ютері пам’ять для інших об’єктів. Пам’ятаєш на початку лекції ми говорили, що у звичайному житті тобі доводиться стежити за станом твого комп’ютера та видаляти старі файли?</p>

<p>Так от, у випадку з Java-об’єктами збирач сміття робить це замість тебе.</p>

<p>Garbage Collector запускається багаторазово протягом роботи твоєї програми: його не треба викликати спеціально та
віддавати команди, хоча технічно це можливо.</p>

<p>Пізніше ми ще поговоримо про нього та розберемо процес його роботи детальніше.</p>

<p>У момент, коли збирач сміття дістався об’єкта, перед самим його знищенням, у об’єкта викликається спеціальний метод — <code>finalize().</code></p>

<p>Його можна використовувати, щоб звільнити якісь додаткові ресурси, які використовував об’єкт.</p>

<p>Метод <code>finalize()</code> належить до класу <code>Object</code>. Тобто нарівні з <code>equals()</code>, <code>hashCode()</code> і <code>toString()</code>, з якими ти вже ознайомився раніше, він є у будь-якого об’єкта.</p>

<p>Його відмінність від інших методів полягає у тому, що він... як би це сказати... дуже норовливий.</p>

<p>А саме перед знищенням об’єкта він викликається далеко не завжди.</p>

<p>Програмування — штука точна. Програміст каже комп’ютеру щось зробити — комп’ютер це робить. Ти, гадаю, вже звик до такої
поведінки, і тобі спочатку може бути складно прийняти ідею: «Перед знищенням об’єктів викликається метод <code>finalize()</code>
класу <code>Object</code>. Або не викликається. Як пощастить!»</p>

<p>Проте, це дійсно так. Java-машина сама визначає, чи викликати метод <code>finalize()</code>у кожному конкретному випадку, чи ні.</p>

<p>Наприклад, давай спробуємо заради експерименту запустити такий код:</p>

<pre class="lang-java line-numbers"><code>
public class Cat {

   private String name;

   public Cat(String name) {
       this.name = name;
   }

   public Cat() {
   }

   public static void main(String[] args) throws Throwable {
       for (int i = 0 ; i &lt; 1000000; i++) {
           Cat cat = new Cat();
           cat = null;//ось тут перший об’єкт стає доступним збирачу сміття
       }
   }

   @Override
   protected void finalize() throws Throwable {
       System.out.println("Об’єкт Cat знищено!");
   }
}
</code></pre>
<p>Ми створюємо об’єкт <code>Cat</code> і вже в наступному рядку коду обнуляємо єдине посилання на нього. І так мільйон разів. </p>

<p>Ми явно перевизначили метод <code>finalize()</code>, і він має мільйон разів вивести рядок у консоль, щоразу перед знищенням об’єкта
<code>Cat</code>.</p>

<p>Але ні! Якщо бути точним, на моєму комп’ютері він відпрацював лише 37346 разів! Тобто тільки в 1 випадку з 27-ми
встановлена у мене Java-машина приймала рішення викликати метод <code>finalize()</code>, в інших випадках збирання сміття проходило
без цього.</p>

<p>Спробуй запустити цей код у себе: швидше за все, результат відрізнятиметься.</p>

<p>Як бачиш, <code>finalize()</code> важко назвати надійним партнером :)</p>

<p>Тому невелика порада на майбутнє: не варто покладатися на метод <code>finalize()</code> у випадку зі звільненням якихось критично
важливих ресурсів. Може, JVM його викличе, а, може, ні. Хто знає? Якщо твій об’єкт за життя займав якісь суперважливі
для продуктивності ресурси, наприклад, тримав відкритим з’єднання з базою даних, краще створи у своєму класі спеціальний
метод для їхнього звільнення та виклич його явно, коли об’єкт вже буде не потрібен. Так ти точно знатимеш, що
продуктивність твоєї програми не постраждає.</p>

<p>На самому початку ми сказали, що робота з пам’яттю та видалення сміття є дуже важливими, і це дійсно так. Неналежна
робота з ресурсами та нерозуміння процесу збирання непотрібних об’єктів можуть призвести до витоку пам’яті. Це одна з
найвідоміших помилок у програмуванні.</p>

<p>Неправильно написаний програмістом код може призвести до того, що для новостворених об’єктів щоразу виділятиметься нова
пам’ять, при цьому старі непотрібні об’єкти будуть недоступні для видалення збирачем сміття.</p>

<p>Оскільки ми навели аналогію з роботом-пилососом, уяви, що буде, якщо перед запуском робота розкидати по дому шкарпетки,
розбити скляну вазу і залишити на підлозі розібраний конструктор Lego. Робот, звісно, спробує щось зробити, але одного
разу він застрягне.
<p><div class="row justify-content-center jr-image-wrap"><div class="col-12 col-sm-10 col-md-8"><img data-id="f1d8aa4a-eff7-41c2-ac32-5753ac45bee3" data-max-width="850" alt="Життєвий цикл об’єкта  - 3" src="https://cdn.javarush.com/images/article/f1d8aa4a-eff7-41c2-ac32-5753ac45bee3/1024.jpeg"></div></div>Для його правильної роботи потрібно тримати підлогу у нормальному стані та прибирати звідти все, з чим не впорається
пилосос.</p>

<p>За таким самим принципом працює і збирач сміття. Якщо у програмі буде залишатися багато об’єктів, які він не може
зібрати (як носок або Lego для робота-пилососа), одного разу пам’ять закінчиться. І може зависнути не тільки написана
тобою програма, а й інші програми, запущені у цей момент на комп’ютері. Для них також може не вистачати пам’яті.
<p>Це не потрібно заучувати: достатньо просто зрозуміти принцип роботи.</p>
<jr-widget-youtube videoid="HrKFVVCbSyo"></jr-widget-youtube>