Будова Java-програми
<p>----------------------------------------</p>
Об'єкти та класи. Сьогодні ви дізнаєтеся трохи про те, як влаштовано типову програму мовою Java. І головна новина:&nbsp;кожна програма, написана мовою Java, складається з класів і об'єктів. Що таке класи, ви вже знаєте, а що таке об'єкти? Почну з аналогії. Уявіть, що ви хочете побудувати невеликий корабель.
<p>----------------------------------------</p>
<h2>1. Об'єкти та класи</h2>
<p>Сьогодні ви дізнаєтеся трохи про те, як влаштовано типову програму мовою Java. І головна новина:&nbsp;кожна програма, написана мовою Java, складається з класів і об'єктів.</p>
<p>Що таке класи, ви вже знаєте, а що таке об'єкти?</p>
<p>Почну з аналогії. Уявіть, що ви хочете побудувати невеликий корабель. Спочатку потрібно створити креслення, потім віддати його на завод, де за цим кресленням виготовлять корабель. Або десяток. Та й узагалі, скільки завгодно кораблів. За одним кресленням будують десятки ідентичних кораблів — от що важливо.</p>
<p>У програмуванні мовою Java все так само.</p>
<p><strong>Креслення</strong></p>
<p>Програміст чимось схожий на проєктувальника. Тільки проєктувальник виконує креслення, а Java-програміст пише класи.&nbsp;Потім на основі креслень створюють деталі, а на основі класів — об'єкти.</p>
<p>Спочатку ми пишемо класи (робимо креслення), а відтак під час виконання програми на основі цих класів Java-машина створює об'єкти. Точнісінько так само, як кораблі споруджують на основі креслень.</p>
<p>Креслення одне, а кораблів може бути багато. Кораблі різні, у них різні назви, вони перевозять різні вантажі. Однак вони дуже схожі: це кораблі з ідентичною конструкцією та можуть виконувати подібні завдання.</p>
<p>А от інша аналогія…</p>
<p><strong>Мурашник</strong></p>
<p>Мурашник — це гарний приклад взаємодії об'єктів. У найпростішому мурашнику є три класи мурах: королева, солдати й робітники.</p>
<p>Кількість мурах кожного класу різна. Королева — одна на весь мурашник, солдатів — десятки, а робочих мурах — сотні. Три класи й сотні об'єктів. Мурахи взаємодіють одна з одною, з такими самими мурахами й мурахами інших класів за чітко визначеними правилами.</p>
<p>Це просто ідеальний приклад. У типовій програмі все так само. Є головний об'єкт, який створює об'єкти всіх інших класів. Об'єкти починають взаємодіяти один з одним та із «зовнішнім світом» програми. Усередині цих об'єктів жорстко запрограмовано їхню поведінку.</p>
<p>Обидва пояснення — це два боки однієї медалі. Істина — посередині. Перший приклад (про креслення й кораблі) демонструє зв'язок між класом і об'єктами цього класу. Аналогія дуже сильна. Другий приклад (про мурашник) показує зв'язок між об'єктами, що існують під час роботи програми, і написаними класами.</p>
<p>Спершу ви повинні створити класи для всіх наявних у програмі об'єктів, і до того ж описати взаємодію цих об'єктів. Саме так, але це легше, ніж здається.</p>
<p>У Java всі сутності під час роботи програми є об'єктами, а написання програми зводиться до опису різних способів взаємодії між ними. Об'єкти просто викликають методи один одного та передають у них потрібні дані.</p>
<p><strong>Документація</strong></p>
<p>А як дізнатися, які дані слід передавати в методи? Тут все вже придумано до вас.</p>
<p>Зазвичай кожний клас має опис, з якого зрозуміло, для чого цей клас створено. Так само і кожний публічний метод зазвичай має опис: що він робить і які дані слід у нього передавати.</p>
<p>Для використання класу потрібно в загальних рисах знати, що він робить. Крім того, потрібно точно знати, що робить кожен його метод. І зовсім&nbsp;необов'язково знати, як він це робить. Така собі чарівна паличка.</p>
<p>Погляньмо, наприклад, на код для копіювання файлу:</p>
<table>
    <tbody>
    <tr>
        <th>Копіювання файлу c:\data.txt у файл c:\result.txt</th>
    </tr>
    <tr>
        <td>
<pre class="language-java"><code>package com.javarush.lesson2;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class FileCopy
{
   public static void main(String[] args) throws IOException
   {
      FileInputStream fileInputStream = new FileInputStream("c:\\data.txt");
      FileOutputStream fileOutputStream = new FileOutputStream("c:\\result.txt");

      while (fileInputStream.available() &gt; 0)
      {
         int data = fileInputStream.read();
         fileOutputStream.write(data);
      }

      fileInputStream.close();
      fileOutputStream.close();
   }
}</code></pre>
        </td>
    </tr>
    </tbody>
</table>
<p>Якщо прочитати цей код по рядках, можна приблизно здогадатися, що він робить. Щоправда тут потрібні досвід і практика. Отож через деякий час цей код вам буде здаватися знайомим і зрозумілим.</p>
<hr>
<h2>2. Проєктування програми</h2>
<p>Проєктування програми — це справжнє мистецтво. Це і просто, і складно водночас. Просто, оскільки ніяких суворих законів немає: що не заборонено — те дозволено. Ну а складно з тієї самої причини: є дуже багато способів щось зробити, тому нелегко обрати найкращий.</p>
<p>Проєктувати програму — це як писати книгу. З одного боку, ви просто пишете літери, слова, речення. А з іншого — важливими є сюжет, характери героїв, внутрішні суперечності, конфлікти, стиль оповіді, інтрига тощо.</p>
<p>Головне — розуміти, для кого ви пишете код. А код ви пишете <strong>для інших програмістів.</strong></p>
<p>Розробка будь-якого продукту — це внесення змін: додали тут, видалили там, переробили тут. І так маленькими ітераціями народжуються великі, величезні й гігантські проєкти.</p>
<p>Основна вимога до коду — <strong>він має бути зрозумілим іншим програмістам.</strong> <span class="text-green">Неправильний, але зрозумілий код можна виправити. <span class="text-orange">Правильний і незрозумілий код покращити не вдасться.</span></span>&nbsp;Його залишиться тільки викинути.</p>
<p>Отже, як писати хороший і зрозумілий код?</p>
<p>Для цього потрібно робити три речі:</p>
<ul>
    <li>Писати хороший і зрозумілий код усередині методів (найпростіше)</li>
    <li>Вирішувати, які сутності мають бути в програмі</li>
    <li>Правильно розбивати програму на логічні частини</li>
</ul>
<p>Що ж стоїть за цими поняттями?</p>
<p><strong>Писати хороший код усередині методів</strong></p>
<p>Якщо ви хоча б на початковому рівні знаєте англійську, то, можливо, звернули увагу, як іноді легко читається код — ніби речення англійською мовою:</p>
<ul>
    <li><code>class Cat extends Pet</code> — &nbsp;клас Кіт розширює клас СвійськаТварина</li>
    <li><code>while(stream.ready())</code> — поки потік готовий…</li>
    <li><code>if (a&lt;b) return a; else return b</code> — якщо <code>а</code> менше за <code>b</code>, повернути <code>а</code>, інакше повернути <code>b</code>.</li>
</ul>
<p>Так зробили навмисно. Java — одна з кількох мов, якими легко писати самодокументований код, тобто код, зрозумілий без коментарів. У хорошому коді на мові Java багато методів читаються просто як речення англійською мовою.</p>
<p>Ваше завдання під час написання коду — теж робити його якомога простішим і лаконічнішим. Просто думайте, наскільки легко читатиметься ваш код, і ви почнете рухатися в правильному напрямку.</p>
<p>У Java заведено писати легкочитний код. Бажано, щоб кожен метод цілком вміщався на екрані (довжина методу — 20–30 рядків). Це норма для всієї Java-спільноти. <strong>Якщо код можна поліпшити, його треба поліпшити.</strong></p>
<p>Найкращий спосіб навчитися писати хороший код — постійна практика. Пишіть багато коду, аналізуйте чужий, просіть досвідченіших колег перевірити ваш код.</p>
<p>І пам'ятайте, що в той момент, коли ви скажете собі: «І так добре!», ваш розвиток зупиниться.</p>
<p><strong>Вирішувати, які сутності мають бути в програмі</strong></p>
<p>Вам потрібно писати код, зрозумілий іншим програмістам. Якщо 9 із 10 програмістів, проєктуючи програму, зроблять у ній класи A, B і С, то й вам також треба зробити у своїй програмі класи A, B, і C. Ваш код мають розуміти інші.</p>
<p>Відмінний, працюючий, швидкий нестандартний код — це поганий код.</p>
<p>Вам потрібно вивчати чужі проєкти: це найкращий, найпростіший і найлегший спосіб перейняти всю мудрість, яка десятиріччями накопичувалася в ІТ-індустрії.</p>
<p>І, до речі, у вас уже є напохваті чудовий, популярний, добре документований проєкт — <strong>Java SDK</strong>. Почніть із нього.</p>
<p>Розбирайте класи й структури класів. Думайте, чому одні методи зроблено статичними, а інші — ні. Чому методи мають саме такі параметри, а не інші. Чому саме такі методи, чому класи називаються саме так і містяться саме в таких пакетах.</p>
<p>Коли ви почнете розуміти відповіді на всі ці запитання, ви зможете писати код, зрозумілий іншим.</p>
<p>Проте хочу застерегти вас від розбору <strong>коду в методах</strong> Java SDK. Код багатьох методів було переписано з метою максимального збільшення швидкості роботи, тому такий код не завжди легкочитний.</p>
<p><strong>Правильно розбивати програму на логічні частини</strong></p>
<p>Будь-яку програму зазвичай розбивають на частини або модулі. Кожна частина відповідає за свій аспект програми.</p>
<p>От у комп'ютера є системний блок, монітор, клавіатура, і все це — окремі, малозалежні один від одного компоненти. Ба більше, їх взаємодію стандартизовано: USB, HDMI тощо. Натомість якщо ви проллєте каву на клавіатуру, її можна просто помити під краном, просушити й користуватися далі.</p>
<p>А от ноутбук — це приклад монолітної архітектури: логічні частини нібито і є, але інтегровані вони між собою набагато щільніше. Приміром, щоб почистити клавіатуру MacBookPro, потрібно розібрати половину ноутбука. А якщо пролити на нього чай, доведеться замовити новий. Але це буде не чай.</p>
<hr>
<h2>3. Створення власних класів</h2>
<p>Оскільки ви лише вчитеся програмувати, слід починати з малого — вчитися створювати власні класи.</p>
<p>Ви їх, звісно, вже створювали, але вам важливо розвивати розуміння того, які класи мають бути в програмі, як вони мають називатися, які в них мають бути методи. І як вони мають один з одним взаємодіяти.</p>
<p><strong>Список сутностей</strong></p>
<p>Якщо ви не знаєте, з чого почати, почніть з початку.</p>
<p>На самому початку проєктування програми ви можете просто записати на аркуші список сутностей (об'єктів), які вона має містити. А відтак запрограмувати їх за таким принципом: кожна сутність — окремий клас.</p>
<p><strong>Приклад</strong></p>
<p>Припустімо, ви хочете написати гру в шахи. Вам знадобляться такі сутності: шахівниця і 6 типів фігур. Фігури ходять по-різному, мають різну цінність — логічно, що це окремі класи. І взагалі, на самому початку що більше класів, то краще.</p>
<p>Зустріти програміста-початківця, який замість двох класів написав би десять, — велика рідкість. От замість десяти створити два, а то й один — це новачки полюбляють. Отже, більше класів, панове програмісти. І ваш код стане зрозумілішим для всіх, окрім, можливо, вас 😛</p>
<p><strong>Шахи</strong></p>
<p>Припустімо, ми вирішили створити класи для шахів: який вигляд вони матимуть?</p>
<p>Шахівниця — це просто масив 8 на 8? Краще зробіть для неї окремий клас, який усередині зберігає посилання на масив. Тоді в клас «Шахівниця» ви зможете додати багато корисних методів, які, наприклад, перевіряють, клітинка порожня чи зайнята.</p>
<p>Загалом кажучи, на початку завжди можна керуватися таким принципом: У програмі є різні Сутності, а Сутність має тип. Оцей тип як раз і є класом.</p>
<hr>
<h2>4. Статичні змінні й методи</h2>
<p>Також не забувайте користуватися статичними змінними й методами. Якщо у вас одна шахова фігура взаємодіє з іншою на шахівниці, значить, ваш код має містити метод, в який передаються посилання на першу фігуру, на другу та на шахівницю.</p>
<p>Щоби постійно не передавати посилання на об'єкти, які «існують завжди», їх зазвичай роблять статичними змінними, і до них можна звернутися з будь-якого місця програми.</p>
<p>Наприклад, отак:</p>
<table>
    <tbody>
    <tr>
        <th>Код</th>
        <th>Примітка</th>
    </tr>
    <tr>
        <td>
<pre class="language-java"><code>public class <span class="text-neon">ChessBoard</span>
{
   public static <span class="text-neon">ChessBoard</span> <span class="text-red">board</span> = new <span class="text-neon">ChessBoard</span>();
   public <span class="text-viola">ChessItem</span>[][] <span class="text-user">cells</span> = new <span class="text-viola">ChessItem</span>[8][8];
   ...
}

public class Game
{
   public static void main(String[] args)
   {
      var <span class="text-green">board</span> = <span class="text-neon">ChessBoard</span>.<span class="text-red">board</span>;
      <span class="text-green">board</span>.<span class="text-user">cells</span>[<span class="text-user">0</span>][<span class="text-user">3</span>] = new <span class="text-viola">King</span>(Color.WHITE);
      <span class="text-green">board</span>.<span class="text-user">cells</span>[<span class="text-user">0</span>][<span class="text-user">4</span>] = new <span class="text-viola">Queen</span>(Color.WHITE);
      ...
   }
}</code></pre>
        </td>
        <td><br/><br/>Посилання на єдиний об'єкт типу <code>ChessBoard</code>.<br/> Двовимірний масив 8×8, нестатична змінна.<br/><br/><br/><br/><br/><br/><br/><br/><br/> Додаємо фігури на шахівницю.</td>
    </tr>
    </tbody>
</table>
<p>Також замість статичної змінної можна зробити метод, який повертає єдиний об'єкт. Наприклад, отак:</p>
<pre class="language-java"><code>public class <span class="text-neon">ChessBoard</span>
{
   private static <span class="text-neon">ChessBoard</span> <span class="text-red">board</span> = new <span class="text-viola">ChessBoard</span>();
   public static <span class="text-neon">ChessBoard</span> getBoard()
   {
      return <span class="text-red">board</span>;
   }

   public <span class="text-viola">ChessItem</span>[][] <span class="text-user">cells</span> = new <span class="text-viola">ChessItem</span>[8][8];
   ...
}

public class <span class="text-viola">Game</span>
{
   public static void main(String[] args)
   {
      var <span class="text-green">board</span> = <span class="text-neon">ChessBoard</span>.<span class="text-red">getBoard</span>();
      <span class="text-green">board</span>.<span class="text-user">cells</span>[<span class="text-user">0</span>][<span class="text-user">3</span>] = new <span class="text-viola">King</span>(Color.WHITE);
      <span class="text-green">board</span>.<span class="text-user">cells</span>[<span class="text-user">0</span>][<span class="text-user">4</span>] = new <span class="text-viola">Queen</span>(Color.WHITE);
      ...
   }
}</code></pre>