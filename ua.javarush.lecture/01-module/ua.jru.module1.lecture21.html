Поради щодо використання колекцій
<p>----------------------------------------</p>
Як ти можеш пам’ятати, Java має зручний інструмент для зберігання об’єктів однакових типів – колекції. Спробуймо згадати основні інтерфейси колекцій...
<p>----------------------------------------</p>
<h2>1. Список колекцій</h2>

    <p>Як ти можеш пам’ятати, Java має зручний інструмент для зберігання об’єктів однакових типів – колекції.</p>

    <p>Спробуймо згадати основні інтерфейси колекцій:</p>

    <p><span class="text-neon"><span class="text-bold">List</span></span>, <span class="text-neon"><span class="text-bold">Set</span></span>, <span class="text-neon"><span class="text-bold">Map</span></span> и <span class="text-neon"><span class="text-bold">Queue</span></span>.</p>

    <p>Зазвичай немає правильних або неправильних інструментів, якщо використовувати їх за призначенням. А для цього ми з тобою
    повинні добре розібратися в їхніх особливостях, щоб знати, коли і яку колекцію використовувати.</p>

    <h3>1. List</h3>

    <p>Давай почнемо з найчастіше використовуваної колекції.</p>

    <p><span class="text-neon"><span class="text-bold">List</span></span> максимально схожий на звичайнісінький масив. Назва ж нам говорить про те, що це список (list).</p>

    <p>Ця колекція дає нам можливість зручно зберігати в собі список об’єктів одного типу, не переймаючись розміром самої
    колекції, як ми це робили, використовуючи масиви. Звертання до елементів колекції відбувається за індексом. Якщо ми
    точно знаємо, на якому місці знаходиться об’єкт, і нам необхідно часто до нього звертатися, при цьому нам не потрібно
    часто додавати або видаляти елементи, <span class="text-neon"><span class="text-bold">List</span></span> — це ідеальний
    варіант.</p>

    <h3>2. Set</h3>

    <p><span class="text-neon"><span class="text-bold">Set</span></span> (множина) має зовсім іншу структуру.</p>

    <p>Насамперед, <span class="text-neon"><span class="text-bold">Set</span></span> варто використовувати, коли нам потрібно
    зберігати унікальні об’єкти. Припустимо, це набір авторів у бібліотеці, де кожен автор унікальний. Але ми не можемо
    просто так звернутися до нашого набору авторів і дістати з нього конкретного автора. Функціонал <span
        class="text-neon"><span class="text-bold">Set</span></span>-а дає нам можливість швидко перевірити, чи представлений
    конкретний автор у нашій бібліотеці, наприклад, перевірити його наявність у колекції <span class="text-neon"><span
            class="text-bold">Set</span></span>. Також є можливість пройтися всією колекцією, кожним елементом, але це не
    оптимально.</p>

    <p>Тобто в нашій бібліотеці <span class="text-neon"><span class="text-bold">Set</span></span> може бути чимось на кшталт
    набору всіх авторів для швидкої перевірки, чи представлений цей автор у бібліотеці.</p>

    <h3>3. Map</h3>

    <p><span class="text-neon"><span class="text-bold">Map</span></span> (словник) більше схожа на картотеку, де кожна комірка
    підписана, і в ній ми можемо зберігати як окремі об’єкти, так і цілі структури. <span class="text-neon"><span
            class="text-bold">Map</span></span> варто використовувати у випадках, коли потрібно зберегти відповідність
    одного значення до іншого.</p>

    <p>У <span class="text-neon"><span class="text-bold">Map</span></span> це називається відповідність ключ-значення.</p>

    <p>З такою структурою в нашій бібліотеці ми зможемо використовувати об’єкт автора як ключ, а список (<span
        class="text-neon"><span class="text-bold">List</span></span>) книг – як значення. Отже, перевіривши в <span
        class="text-neon"><span class="text-bold">Set</span></span> наявність автора в бібліотеці, ми зможемо по цьому
    самому об’єкту автора дістати List із його книгами з <span class="text-neon"><span class="text-bold">Map</span></span>.</p>

    <h3>4. Queue</h3>

    <p><span class="text-neon"><span class="text-bold">Queue</span></span> (черга) – є колекцією, яка побудована як черга.
    Причому ця черга може бути не лише <span class="text-bold">LIFO</span> (Last In First Out – останній зайшов, перший
    вийшов), а й <span class="text-bold">FIFO</span> (First In First Out – перший зайшов, перший вийшов). А ще черга може
    бути двоспрямованою з виходами з обох боків.</p>

    <p>Цей інструмент зручний у випадках, коли об’єкти, що надходять до нашого класу, метод необхідно використовувати в порядку
    їх надходження. Наприклад, у нашій бібліотеці.</p>

    <p>Ми можемо додавати новоприбулих відвідувачів у <span class="text-neon"><span class="text-bold">Queue</span></span>, і по
    черзі їх обслуговувати, видаючи книги, за якими вони до нас приходять.</p>

    <p>Як ми з тобою можемо бачити, всі структури гарні, якщо використовувати їх за призначенням. І в межах одного прикладу,
    бібліотеки, ми використовували всі чотири типи колекцій.</p>

    <h2>2. Складність</h2>

    <p>Як вже було зазначено, колекції, які ми розглядали вище, – це інтерфейси, а отже у них мають бути реалізації, які ми і
    будемо використовувати.</p>

    <p>Оскільки забивати цвяхи мікроскопом — не найкраща ідея, нам варто знати, яку саме реалізацію колекції краще
    використовувати у тій чи іншій ситуації.</p>

    <p>Найчастіше, обираючи той чи інший інструмент, ми дивимося на 2 показники:</p>

    <ul>
        <li>наскільки цей інструмент підходить під завдання</li>
        <li>наскільки швидко відбуватиметься робота з ним</li>
    </ul>

    <p>Якщо з вибором інструменту, що підходить під завдання, ми абияк розібралися, то швидкість його роботи – це щось
    новеньке.</p>

    <p>Показник швидкості роботи часто виражають через тимчасову складність і позначають великою літерою О.</p>

    <p>Що взагалі таке ця тимчасова складність?</p>

    <p>Простими словами, ця складність вказує на час відпрацювання алгоритму, закладеного в колекцію для тієї чи іншої дії
    (додавання, видалення елемента, пошук).</p>

    <h3>ArrayList vs LinkedList</h3>

    <p>Давай розглянемо це на прикладі двох реалізацій інтерфейсу <span class="text-neon"><span class="text-bold">List</span></span> — <span class="text-bold"><span class="text-red">ArrayList</span></span> i <span class="text-bold"><span class="text-red">LinkedList</span></span>.</p>

    <p>Частково про відмінність цих двох реалізацій згадується <a href="https://habr.com/ru/post/162017/" target="_blank">у цій статті</a>.</p>

    <p>Зовні робота із цими колекціями схожа:</p>

    <pre class='language-java line-numbers'><code>
List&lt;String&gt; arrayList = new ArrayList&lt;&gt;();
arrayList.add(String);
arrayList.get(index);
arrayList.remove(index);
arrayList.remove(String);
 
List&lt;String&gt; linkedList = new LinkedList&lt;&gt;();
 
linkedList.add(String);
 
linkedList.get(index);
linkedList.remove(index);
linkedList.remove(String);
    </code></pre>
 
    <p>Як ти міг помітити, в обох випадках ми однаково додаємо, беремо та видаляємо елемент зі списку. Це через те, що ми
    створюємо реалізації на основі одного інтерфейсу. Але на цьому схожість у них закінчується.</p>

    <p>Завдяки різній реалізації інтерфейсу <span class="text-neon"><span class="text-bold">List</span></span> ці дві структури
    мають різну ефективність за різного використання.</p>

    <p>Розглянемо приклад операції видалення та додавання елемента.</p>

    <p>Якщо нам потрібно буде видалити елемент із середини списку <span class="text-bold"><span
            class="text-red">ArrayList</span></span>, щоразу ми будемо переписувати решту списку, що йде за елементом, який
    ми видаляємо.</p>

    <p>Припустимо, у нас є список із 5-ти елементів і нам потрібно видалити 3-й.</p>

    <pre class='language-java line-numbers'><code>
List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);
list.remove(2);
    </code></pre>

    <p>У такому разі після видалення у нас звільниться одна комірка, і ми будемо змушені перезаписати 4-й елемент на місце 3-го, а 5-й – на місце 4-го.</p>
 
<img data-max-width="512" data-id="f5c06436-cbb2-40ff-92a9-70dc0400bc5d" src="https://cdn.javarush.com/images/article/f5c06436-cbb2-40ff-92a9-70dc0400bc5d/512.jpeg" alt="">

    <p>Це максимально неефективно.</p>

    <p>Те саме відбуватиметься і у разі додавання елемента в середину списку.</p>

    <img data-max-width="512" data-id="7df9fb75-bcca-42b1-94b5-6385b635473b" src="https://cdn.javarush.com/images/article/7df9fb75-bcca-42b1-94b5-6385b635473b/512.jpeg" alt="">

    <p>LinkedList же влаштований інакше. Додавання або видалення елементів із нього відбувається швидко, оскільки нам всього
    лише потрібно змінити посилання в попередньому і наступному елементі, виключивши з ланцюжка елементів об’єкт, який ми
    видаляємо.</p>

    <p>На прикладі того самого списку з 5-ти елементів, видаливши з нього 3-й, ми повинні просто змінити посилання на наступний
    елемент у 2-му та посилання на попередній у 4-му елементі.</p>
 
    <img data-max-width="512" data-id="9d6f648d-9b2f-4bdd-a9cb-bf277a2f9f29" src="https://cdn.javarush.com/images/article/9d6f648d-9b2f-4bdd-a9cb-bf277a2f9f29/original.png" alt="">

    <p>Те саме, тільки навпаки, відбувається у разі додавання елемента до списку.</p>

    <p>Зверніть увагу, наскільки менше дій нам необхідно виконати в <span class="text-bold"><span
            class="text-red">LinkedList</span></span> порівняно з <span class="text-bold"><span
            class="text-red">ArrayList</span></span>. А це тільки 5 елементів. Якби у списку було 100 і більше елементів,
    перевага <span class="text-bold"><span class="text-red">LinkedList</span></span> була б більш відчутною.</p>

    <p>Але як зміниться ситуація, якщо ми звертатимемося до елемента за індексом?</p>

    <p>Тут все буде рівно навпаки.</p>

    <p>Оскільки <span class="text-bold"><span class="text-red">ArrayList</span></span> влаштований як звичайний масив, нам
    буде просто взяти будь-який елемент за його індексом. Ми просто перемістимо вказівник на певне місце і візьмемо з
    комірки елемент.</p>

    <p>Але в <span class="text-bold"><span class="text-red">LinkedList</span></span> так просто не вийде. Нам доведеться
    пройтися всіма елементами масиву, щоб знайти елементи з певним індексом. Тільки в цьому випадку є сенс називати це не
    індекс, а порядковий номер.</p>

    <p>Давай спробуємо виразити це все через велику О?</p>

    <p>Почнемо зі звернення до елемента за індексом.</p>

    <p>В <span class="text-bold"><span class="text-red">ArrayList</span></span> це відбувається в одну дію, незалежно від
    розташування елемента у списку. На початку він або в кінці.</p>

    <p>Тимчасова складність у цьому випадку буде <span class="text-bold">О(1)</span>.</p>

    <p>У <span class="text-bold"><span class="text-red">LinkedList</span></span> нам доведеться перебрати ту кількість
    елементів, індекс якого нам потрібний.</p>

    <p>Тимчасова складність для такої дії буде <span class="text-bold">О(n)</span>, де n – це індекс елемента, який нам
    потрібний.</p>

    <p>Виходить, під дужки великої О ми поміщаємо число, яке відповідає кількості дій, що здійснюються.</p>

    <p>Повернемося до видалення та додавання?</p>

    <p><span class="text-bold">Почнемо з LinkedList.</span></p>

    <p>Оскільки нам не потрібно робити велику кількість дій для додавання або видалення елемента, і швидкість цієї операції
    жодним чином не залежить від того, де знаходиться елемент, складно матиме такий вигляд – <span
        class="text-bold">О(1)</span> і називається константною.</p>

    <p>Складність цієї самої операції для <span class="text-bold"><span class="text-red">ArrayList</span></span> буде вже <span
        class="text-bold">О(n)</span> і називається лінійною.</p>

    <p>В алгоритмах із лінійною складністю час роботи напряму залежить від кількості елементів, які потрібно обробити. Також це
    може залежати і від положення елемента, на початку списку або ближче до кінця.</p>

    <p>Складність ще буває логарифмічною. Виглядає вона так — <span class="text-bold">O(log n)</span>.</p>

    <p>Як приклад можемо розглянути відсортований <span class="text-bold"><span class="text-red">TreeSet</span></span> список
    із 10-ти чисел, у якому нам потрібно знайти число 2.</p>

    <p>Оскільки список відсортований і в ньому немає дублікатів, ми можемо розділити його навпіл і перевірити, в якій частині
    списку залишилася шукане число, відкинути одну з частин і повторити дії знову, поки не дійдемо до шуканого елемента. У
    підсумку ми знайдемо число, обробивши log(n) кількість елементів.</p>

    <p>Давай поглянемо на таблицю, в якій описані складності інших колекцій.</p>
 
    <table>
        <tbody>
            <tr>
                <th></th>
                <th>За індексом</th>
                <th>За ключем</th>
                <th>Пошук</th>
                <th>Вставлення в кінець</th>
                <th>Вставлення в середину</th>
                <th>Видалення</th>
            </tr>

            <tr>
                <th>ArrayList</th>
                <td>O(1)</td>
                <td>N/A</td>
                <td>О(n)</td>
                <td>O(1)</td>
                <td>O(n)</td>
                <td>O(n)</td>
            </tr>

            <tr>
                <th>LinkedList</th>
                <td>O(n)</td>
                <td>N/A</td>
                <td>O(n)</td>
                <td>O(1)</td>
                <td>O(1)</td>
                <td>O(1)</td>
            </tr>

            <tr>
                <th>HashSet</th>
                <td>N/A</td>
                <td>O(1)</td>
                <td>O(1)</td>
                <td>N/A</td>
                <td>O(1)</td>
                <td>O(1)</td>
            </tr>

            <tr>
                <th>TreeSet</th>
                <td>N/A</td>
                <td>O(1)</td>
                <td>O(log n)</td>
                <td>N/A</td>
                <td>O(log n)</td>
                <td>O(log n)</td>
            </tr>

            <tr>
                <th>HashMap</th>
                <td>N/A</td>
                <td>O(1)</td>
                <td>O(1)</td>
                <td>N/A</td>
                <td>O(1)</td>
                <td>O(1)</td>
            </tr>

            <tr>
                <th>TreeMap</th>
                <td>N/A</td>
                <td>O(1)</td>
                <td>O(log n)</td>
                <td>N/A</td>
                <td>O(log n)</td>
                <td>O(log n)</td>
            </tr>

            <tr>
                <th>ArrayDeque</th>
                <td>N/A</td>
                <td>N/A</td>
                <td>O(n)</td>
                <td>O(1)</td>
                <td>O(1)</td>
                <td>O(1)</td>
            </tr>
        <tbody>
    </table>

    <p>Тепер, коли у нас із тобою є таблиця, в якій зазначена тимчасова складність для популярних колекцій, ми можемо
    відповісти на запитання, чому з такої кількості колекцій ми найчастіше використовуємо <span class="text-bold"><span class="text-red">ArrayList</span></span>, <span class="text-neon"><span class="text-bold">HashSet</span></span> i <span class="text-neon"><span class="text-bold">HashMap</span></span>.</p>

    <p>Вони просто максимально ефективні для більшості завдань:)</p>