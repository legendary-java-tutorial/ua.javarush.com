Git
<p>----------------------------------------</p>
Сьогодні поговоримо про систему контролю версій — Git (читається як ГІТ). Без знання та розуміння цього інструмента неможливо бути програмістом. Само собою, для постійної роботи не потрібно пам’ятати всі команди та можливості. Потрібно знати набір команд, які допоможуть розуміти все, що відбувається...
<p>----------------------------------------</p>
<h1>1. Детальний гайд Git для новачків</h1>

    <p>Сьогодні поговоримо про систему контролю версій — Git (читається як ГІТ).</p>

    <p>Без знання та розуміння цього інструмента неможливо бути програмістом. Само собою, для постійної роботи не потрібно
    пам’ятати всі команди та можливості. Потрібно знати набір команд, які допоможуть розуміти все, що відбувається.</p>

    <h2>Основи Git</h2>

    <p>Git — це розподілена система контролю версій нашого коду. Для чого вона нам? Для команди потрібна якась система
    керування роботою. Вона потрібна, щоб відстежувати зміни, які відбуваються з часом.</p>

    <p>Тобто крок за кроком ми бачимо, які файли змінилися і як. Особливо це важливо, коли аналізуєш, що було зроблено в межах
    одного завдання: це дає можливість повертатися назад.</p>

    <p>Уявімо ситуацію: був працюючий код, все в ньому було добре, але ми вирішили щось поліпшити чи підправити. Все нічого,
    але таке поліпшення зламало половину функціоналу, унеможливило роботу. І що далі? Без Гіта треба було б годинами сидіти
    і згадувати, як усе було спочатку. А так ми просто відкочуємось на коміт назад — і все.</p>

    <p>Чи що робити, якщо є два розробники, які роблять одночасно свої зміни у коді? Без Гіта це виглядає так: вони скопіювали
    код із оригіналу, зробили що потрібно. Настає момент, і обидва хочуть додати свої зміни до головної папки. І що робити в
    цій ситуації?..</p>

    <p>Таких проблем не буде взагалі, якщо користуватися Гітом.</p>

    <h2>Установка Git</h2>

    <p>Встановимо гіт на комп’ютер. Для різних OS цей процес трохи відрізняється.</p>

    <h3>Встановлення для Windows</h3>

    <p>Як завжди, потрібно завантажити exe файл і запустити його. Тут все просто: тиснемо на <a
        href="https://git-scm.com/downloads" target="_blank">перше посилання гугла</a>, встановлюємо і все. Для роботи
    будемо використовувати bash консоль, яку вони надають.</p>

    <p>Щоб працювати у Windows, потрібно запустити Git Bash. Ось як він виглядає в меню пуск:</p>

<img data-max-width="800" data-id="f517966f-a576-4570-91ab-0054c1f2151a" src="https://cdn.javarush.com/images/article/f517966f-a576-4570-91ab-0054c1f2151a/original.png" alt="">

    <p>І це вже консоль, у якій можна працювати.</p>

    <p>Щоб не переходити щоразу в папку з проєктом, щоб там відкрити гіт, можна в папці правою кнопкою миші відкрити консоль із
    потрібним нам шляхом:</p>

<img data-max-width="1024" data-id="d7e783c4-6136-4fc0-b98b-a567cd552f15" src="https://cdn.javarush.com/images/article/d7e783c4-6136-4fc0-b98b-a567cd552f15/original.png" alt="">

    <h3>Встановлення для Linux</h3>

    <p>Зазвичай git вже встановлений і є в дистрибутивах лінуксу, тому що це інструмент, який вперше був написаний для розробки
    ядра лінуксу. Але бувають ситуації, коли його нема. Щоб перевірити це, треба відкрити термінал і прописати: git
    --version. Якщо буде зрозуміла відповідь, нічого встановлювати не потрібно.</p>

    <p>Відкриваємо термінал та встановлюємо. Для Ubuntu треба написати: sudo apt-get install git. І все: тепер у будь-якому
    терміналі можна користуватися гітом.</p>

    <h3>Встановлення на macOS</h3>

    <p>Тут також спочатку потрібно перевірити, чи є вже гіт (дивися вище, як на лінуксі).</p>

    <p>Якщо все ж ні, найпростіший шлях — це a href="https://sourceforge.net/projects/git-osx-installer/files/"
    target="_blank". Якщо встановлений XCode, то гіт вже точно буде автоматично встановлений.</p>

    <h3>Налаштування Git</h3>

    <p>У гіта є налаштування користувача, від якого буде йти робота. Це розумна і необхідна річ, оскільки коли створюється
    коміт, гіт бере саме цю інформацію для поля Author.</p>

    <p>Щоб налаштувати ім’я користувача та пароль для всіх проєктів, потрібно прописати такі команди:</p>

<div class="terminal"><p>git config --global user.name ”Ivan Ivanov”</p>
<p>git config --global user.email ivan.ivanov@gmail.com</p></div>

    <p>Якщо є необхідність для конкретного проєкту змінити автора (для особистого проєкту, наприклад), можна прибрати --global,
    і тоді вийде:</p>

<div class="terminal"><p>git config user.name ”Ivan Ivanov”</p>
<p>git config user.email ivan.ivanov@gmail.com</p></div>

    <h3>Трохи теорії</h3>

    <p>Щоб бути в темі, бажано додати до свого звернення кілька нових слів і дій… А то говорити нема про що. Звісно, це такий
    собі жаргон і калька з англійської, тому я додаватиму значення англійською.</p>

    <p>Які слова та дії?</p>

    <ul>
        <li>гіт репозиторій (git repository);</li>
        <li>коміт (commit);</li>
        <li>гілка (branch);</li>
        <li>змерджити (merge);</li>
        <li>конфлікти (conflicts);</li>
        <li>спулити (pull);</li>
        <li>запушити (push);</li>
        <li>як ігнорувати певні файли (.gitignore).</li>
    </ul>

    <p>І так далі.</p>

    <h3>Стани в Git</h3>

    <p>У Гіта є кілька станів, які потрібно зрозуміти та запам’ятати:</p>

    <ul>
        <li>невідстежуваний (untracked);</li>
        <li>змінений (modified);</li>
        <li>підготовлений (staged);</li>
        <li>закомічений (committed).</li>
    </ul>

    <h4>Як це розуміти?</h4>

    <p>Це стани, в яких перебувають файли із нашого коду. Тобто їхній життєвий шлях зазвичай виглядає так:</p>

    <ul>
        <li>Файл, який створений і не доданий в репозиторій, буде в стані untracked.
</li>
        <li>Робимо зміни у файлах, які вже додані в гіт репозиторій — перебувають у стані modified.
</li>
        <li>З тих файлів, які ми змінили, обираємо тільки ті (або всі), які потрібні нам (наприклад, скомпільовані класи нам не
        потрібні), і ці класи зі змінами потрапляють у стан staged.
</li>
        <li>Із заготовлених файлів зі стану staged створюється коміт і перетворюється вже на гіт репозиторій. Після цього staged
        стан — порожній. А ось modified ще може щось містити.
</li>
    </ul>

    <p>Виглядає це так:</p>

<img data-max-width="800" data-id="ef35cd8e-590b-4cab-bbb7-77d6223948f1" src="https://cdn.javarush.com/images/article/ef35cd8e-590b-4cab-bbb7-77d6223948f1/original.png" alt="">

    <h3>Що таке коміт</h3>

    <p>Коміт — це основний об’єкт в керуванні контролю версій. Він містить усі зміни під час цього коміту. Коміти пов’язані між
    собою як однозв’язний список.</p>

    <p>А саме: є перший коміт. Коли створюється другий коміт, то він (другий) знає, що йде після першого. І в такий спосіб
    можна відстежити інформацію.</p>

    <p>Також коміт має ще свою інформацію, так звані метадані:</p>

    <ul>
        <li>унікальний ідентифікатор коміту, за яким можна його знайти;</li>
        <li>ім’я автора коміту, який створив його;</li>
        <li>дата створення коміту;</li>
        <li>коментар, який визначає, що було зроблено під час цього коміту.</li>
    </ul>

    <p>Ось як це виглядає:</p>

<img data-max-width="512" data-id="d80d3a26-bd59-478c-85fa-9a988575352b" src="https://cdn.javarush.com/images/article/d80d3a26-bd59-478c-85fa-9a988575352b/original.png" alt="">

    <h3>Що таке гілка</h3>

<img data-max-width="512" data-id="80f5b58d-cb22-4fe4-9bb2-81f57d33cf9c" src="https://cdn.javarush.com/images/article/80f5b58d-cb22-4fe4-9bb2-81f57d33cf9c/512.jpeg" alt="">

    <p>Гілка — це покажчик певного коміту. Оскільки коміт знає, який коміт був до нього, коли гілка вказує на певний коміт, до неї належать і всі ті попередні.</p>

    <p>З огляду на це можна сказати, що гілок, що вказують на той самий коміт, може бути скільки завгодно багато.</p>

    <p>Робота відбувається у гілках, тому коли створюється новий коміт, гілка переносить свій покажчик на новіший коміт.</p>

    <h2>Початок роботи з Git</h2>

    <p>Можна працювати і лише з локальним репозиторієм, і з віддаленим.</p>

    <p>Для відпрацювання необхідних команд можна скористатися лише локальним репозиторієм. Він зберігає всю інформацію лише локально у проєкті в папці .git.</p>

    <p>Якщо говорити про віддалений, то вся інформація зберігається десь на віддаленому сервері: локально зберігається лише копія проєкту, зміни якої можна запушити (git push) у віддалений репозиторій.</p>

    <p>Тут і далі будемо обговорювати роботу з гітом у консолі. Звісно, можна користуватися певними графічними рішеннями
    (наприклад, в Intellij IDEA), але спершу потрібно розібратися, які команди відбуваються і що вони означають.</p>

    <h3>Робота з гітом у локальному репозиторії</h3>

    <p>Щоб створити локальний репозиторій, потрібно написати:</p>

<div class="terminal">git init</div>

<img data-max-width="800" data-id="218e78b6-d26c-44f8-a655-44e590317a6c" src="https://cdn.javarush.com/images/article/218e78b6-d26c-44f8-a655-44e590317a6c/original.png" alt="">

    <p>Після цього буде створена прихована папка .git у тому місці, де перебуває консоль.</p>

    <p>.git — це папка, яка зберігає всю інформацію про гіт репозиторій. Її видаляти не потрібно ;)</p>

    <p>Далі додаються файли у цей проєкт, і їхній стан стає Untracked. Щоб подивитися, який статус роботи на цей момент пишемо:</p>

<div class="terminal">git status</div>

<img data-max-width="800" data-id="fde62d18-a75d-4342-9f83-0acd4e1d1f1b" src="https://cdn.javarush.com/images/article/fde62d18-a75d-4342-9f83-0acd4e1d1f1b/original.png" alt="">

    <p>Ми перебуваємо в master гілці, і поки ми не перейдемо в іншу, так все й залишиться.</p>

    <p>Таким чином, видно, які файли змінені, але ще не додані у стан staged. Щоб додати їх у стан staged, потрібно написати
    git add. Тут може бути кілька варіантів, наприклад:</p>

    <ul>
        <li>git add -A — додати всі файли зі стану в staged;</li>
        <li>git add . — додати всі файли із цієї папки та всіх внутрішніх. По суті те саме, що й попереднє;</li>
        <li>git add <ім’я файлу> — додає лише конкретний файл. Тут можна користуватися регулярними виразами, щоб додавати за
            якимось шаблоном. Наприклад, git add *.java: це означає, що потрібно додати лише файли з розширенням java.</li>
    </ul>

    <p>Зрозуміло, що перші два варіанти прості, а ось із додаванням буде цікавіше, тому пишемо:</p>

<div class="terminal">git add *.txt</div>

    <p>Щоб перевірити статус, використовуємо вже відому нам команду:</p>

<div class="terminal">git status</div>

<img data-max-width="800" data-id="0c82c10c-f970-449c-b1ce-20efab908c0c" src="https://cdn.javarush.com/images/article/0c82c10c-f970-449c-b1ce-20efab908c0c/original.png" alt="">

    <p>Звідси видно, що регулярний вираз відпрацював правильно, і тепер test_resource.txt перебуває в staged стані.</p>

    <p>І, нарешті, останній етап (у разі локального репозиторію, з віддаленим буде ще один ;)) — закомітити та створити новий
    коміт:</p>

<div class="terminal">git commit -m “all txt files were added to the project”</div>

<img data-max-width="800" data-id="4d91e463-8948-476a-8c19-366571d09ae6" src="https://cdn.javarush.com/images/article/4d91e463-8948-476a-8c19-366571d09ae6/original.png" alt="">

    <p>Далі є чудова команда, щоб подивитися на історію комітів у гілці. Скористаємося нею:</p>

<div class="terminal">git log</div>

<img data-max-width="800" data-id="2233dc68-5cc1-433d-8c23-2f0214e9ad7c" src="https://cdn.javarush.com/images/article/2233dc68-5cc1-433d-8c23-2f0214e9ad7c/original.png" alt="">

    <p>Тут уже видно, що з’явився наш перший коміт із текстом, який ми передали. Дуже важливо зрозуміти, що текст, який ми
    передаємо, має максимально точно визначати те, що було зроблено за цей коміт. Це в майбутньому допомагатиме багато
    разів.</p>

    <p>Допитливий читач, який ще не заснув, може сказати: а що сталося із файлом GitTest.java? Зараз дізнаємося, використаємо
    для цього:</p>

<div class="terminal">git status</div>

<img data-max-width="800" data-id="2ee337ec-e4ef-4353-90fb-eb637e350112" src="https://cdn.javarush.com/images/article/2ee337ec-e4ef-4353-90fb-eb637e350112/original.png" alt="">

    <p>Як бачимо, він так і залишився у стані untracked і чекає свого часу. А може, ми зовсім не хочемо його додавати у проєкт?
    Буває й таке.</p>

    <p>Далі, щоб стало цікавіше, спробуємо змінити наш текстовий файл test_resource.txt. Додамо туди якийсь текст і перевіримо
    стан:</p>

<div class="terminal">git status</div>

<img data-max-width="800" data-id="62ccd4b1-447d-422d-a28f-47ad5d39c9dd" src="https://cdn.javarush.com/images/article/62ccd4b1-447d-422d-a28f-47ad5d39c9dd/original.png" alt="">

    <p>Тут добре видно різницю між двома станами — untracked і modified.</p>

    <p>GitTest.java перебуває у стані untracked, а test_resource.txt перебуває у modified.</p>

    <p>Тепер, коли вже є файли у стані modified, ми можемо подивитися на зміни, які були зроблені з ними. Зробити це можна за
    допомогою команди:</p>

<div class="terminal">git diff</div>

<img data-max-width="800" data-id="be25b293-9720-4332-99fe-921a7a285297" src="https://cdn.javarush.com/images/article/be25b293-9720-4332-99fe-921a7a285297/original.png" alt="">

    <p>Тобто тут добре видно, що я додав у наш текстовий файл hello world!</p>

    Додаємо зміни в текстовому файлі та комітимо:

<div class="terminal">git add test_resource.txt</div>
<div class="terminal">git commit -m “added hello word! to test_resource.txt”</div>

    <p>Щоб подивитися на всі коміти, пишемо:</p>

<div class="terminal">git log</div>

<img data-max-width="800" data-id="0e748579-2e48-4be2-bf91-ecfb88150956" src="https://cdn.javarush.com/images/article/0e748579-2e48-4be2-bf91-ecfb88150956/original.png" alt="">

    <p>Як бачимо, вже є два коміти.</p>

    <p>Так само додаємо і GitTest.java. Тепер без коментарів, просто команди:</p>

<div class="terminal">git add GitTest.java</div>
<div class="terminal">git commit -m “added GitTest.java”</div>
<div class="terminal">git status</div>

<img data-max-width="800" data-id="e73028fb-3b33-42ef-befe-235a038b692b" src="https://cdn.javarush.com/images/article/e73028fb-3b33-42ef-befe-235a038b692b/original.png" alt="">

    <h3>Робота з .gitignore</h3>

    <p>Зрозуміло, що ми хочемо зберігати лише вихідний код і нічого іншого в репозиторії. А що може бути ще? Як мінімум, скомпільовані класи та/або файли, які створюють середовища розробки.</p>

    <p>У цьому прикладі гіт ігнор виглядатиме так:</p>

<div class="terminal">
*.class<br/>
target/<br/>
*.iml<br/>
.idea/<br/>
</div>

    <p>Дивимося тепер:</p>

    <ul>
        <li>перший рядок — це ігнорування всіх файлів із розширенням .class;</li>
        <li>другий рядок — це ігнорування папки target та всього, що вона містить;</li>
        <li>третій рядок — це ігнорування всіх файлів із розширенням .iml;</li>
        <li>четвертий рядок — це ігнорування папки .idea.</li>
    </ul>

    <p>Спробуємо на прикладі. Щоб подивитися, як це працює, додамо скомпільований клас GitTest.class у проєкт і подивимося
    статус проєкту:</p>

<div class="terminal">git status</div>

<img data-max-width="800" data-id="9f5cff1c-f541-4bb9-8cd9-2c5195f71529" src="https://cdn.javarush.com/images/article/9f5cff1c-f541-4bb9-8cd9-2c5195f71529/original.png" alt="">

    <p>Зрозуміло, що ми не хочемо якось випадково (якщо використовувати git add -A) додати скомпільований клас у проєкт. Для
    цього створюємо .gitignore файл і додаємо все, що описувалося раніше:</p>

<img data-max-width="800" data-id="5a78638d-0e90-4ab6-a9f2-1b985902f2a6" src="https://cdn.javarush.com/images/article/5a78638d-0e90-4ab6-a9f2-1b985902f2a6/original.png" alt="">

    <p>Тепер додамо новим комітом гіт ігнор у проєкт:</p>

<div class="terminal">git add .gitignore</div>
<div class="terminal">git commit -m “added .gitignore file”</div>

    <p>І тепер момент істини: у нас є в untracked стані скомпільований клас GitTest.class, який ми не хотіли додавати в гіт
    репозиторій.</p>

    <p>Ось тут і повинен запрацювати гіт ігнор:</p>

<div class="terminal">git status</div>

<img data-max-width="800" data-id="b0cf652f-0ac6-4b47-b6de-caaa2d35249d" src="https://cdn.javarush.com/images/article/b0cf652f-0ac6-4b47-b6de-caaa2d35249d/original.png" alt="">

    <p>Все чисто) Гіт ігнору +1).</p>

    <h3>Робота з гілками</h3>

    <p>Звісно, працювати в одній гілці незручно одному і неможливо, коли в команді більше ніж одна людина. Для цього існує
    розгалуження.</p>

    <p>Гілка — це просто рухомий покажчик, що вказує на коміти.</p>

    <p>У цій частині розглянемо роботу в різних гілках: як змерджити зміни однієї гілки в іншу, які можуть виникнути конфлікти
    та багато іншого.</p>

    <p>Щоб подивитися список усіх гілок у репозиторії та зрозуміти, на якій перебуваєш, потрібно написати:</p>

<div class="terminal">git branch -a</div>

<img data-max-width="800" data-id="645fec04-03b2-4a92-b179-47d925cc9307" src="https://cdn.javarush.com/images/article/645fec04-03b2-4a92-b179-47d925cc9307/original.png" alt="">

    <p>Видно, що у нас тільки одна гілка master, і зірочка перед нею вказує, що ми перебуваємо на ній. До речі, щоб дізнатися,
    на якій гілці ми перебуваємо, можна скористатися і перевіркою статусу (git status).</p>

    <p>Далі є кілька варіантів створення гілок (може, їх і більше, я використовую ці):</p>

    <ul>
        <li>створити нову гілку на основі тієї, на якій перебуваємо (99 % випадків);</li>
        <li>створити гілку на основі конкретного коміту (1 %).</li>
    </ul>

    <h4>Створюємо гілку на основі конкретного коміту</h4>

    <p>Спиратися будемо на унікальний ідентифікатор коміту. Щоб знайти його, напишемо:</p>

<div class="terminal">git log</div>

<img data-max-width="800" data-id="a0633270-4f07-40ad-95bd-9075a74e4c6a" src="https://cdn.javarush.com/images/article/a0633270-4f07-40ad-95bd-9075a74e4c6a/original.png" alt="">

    <p>Виділимо коміт із коментарем “added hello world…”. У нього унікальний ідентифікатор —
    “6c44e53d06228f888f2f454d3cb8c1c976dd73f8”. Ми хочемо створити гілку development із цього коміту. Для цього напишемо:</p>

<div class="terminal">git checkout -b development 6c44e53d06228f888f2f454d3cb8c1c976dd73f8</div>

    <p>Створюється гілка, в якій будуть лише перші два коміти з гілки master. Щоб перевірити це, ми спершу переконаємося, що
    перейшли в іншу гілку, і подивимося на кількість комітів у ній:</p>

<div class="terminal">git status</div>
<div class="terminal">git log</div>

<img data-max-width="800" data-id="a7d8a049-7854-45ac-b18e-c8c43b881dff" src="https://cdn.javarush.com/images/article/a7d8a049-7854-45ac-b18e-c8c43b881dff/original.png" alt="">

    <p>І дійсно: вийшло, що у нас два коміти. До речі, цікавий момент: у цій гілці ще немає файлу .gitignore, тому наш
    скомпільований файл (GitTest.class) тепер підсвічується в untracked стані.</p>

    <p>Тепер можемо провести ще раз ревізію наших гілок, написавши:</p>

<div class="terminal">git branch -a</div>

<img data-max-width="800" data-id="1ac27563-c3b7-4180-b2a8-8671859fe6c9" src="https://cdn.javarush.com/images/article/1ac27563-c3b7-4180-b2a8-8671859fe6c9/original.png" alt="">

    <p>Видно, що є дві гілки — master та development — і зараз стоїмо на development.</p>

    <h4>Створюємо гілку на основі поточної</h4>

    <p>Другий спосіб створення гілки — створення на основі іншої. Створимо гілку на основі master гілки: для цього потрібно
    спершу перейти на неї, а вже наступним кроком створити нову. Дивимося:</p>

    <ul>
        <li>git checkout master — переходимо на гілку master;</li>
        <li>git status — перевіряємо, чи точно на мастері.</li>
    </ul>

<img data-max-width="800" data-id="968f1ec0-ce0a-4e48-907e-9e90917dc75d" src="https://cdn.javarush.com/images/article/968f1ec0-ce0a-4e48-907e-9e90917dc75d/original.png" alt="">

    <p>Ось тут видно, що ми перейшли на master гілку, тут вже працює гіт ігнор, і скомпільований клас уже не світиться як
    untracked.</p>

    <p>Тепер створюємо нову гілку на основі master гілки:</p>

<div class="terminal">git checkout -b feature/update-txt-files</div>

<img data-max-width="800" data-id="c1e06a9a-bccf-49e1-852e-41690dd823c3" src="https://cdn.javarush.com/images/article/c1e06a9a-bccf-49e1-852e-41690dd823c3/original.png" alt="">

    <p>Якщо є сумніви, що ця гілка буде не такою самою, як і master, можна це легко перевірити, написавши git log, і подивитися
    на всі коміти. Там їх має бути чотири.</p>

    <h3>Резолвимо конфлікти</h3>

    <p>Перш ніж розібратися з тим, що таке конфлікт, слід поговорити про злиття (змерджування) однієї гілки в іншу.</p> 

    <p>За допомогою ось такого рисунку можна показати процес, коли одну гілку мерджать в іншу:</p>

<img data-max-width="512" data-id="c417cc45-2cfb-40d8-a6bf-6b8bf3ed9563" src="https://cdn.javarush.com/images/article/c417cc45-2cfb-40d8-a6bf-6b8bf3ed9563/original.png" alt="">

    <p>Тобто є головна гілка. Від неї в певний момент створюють другорядну, в якій відбуваються зміни. Щойно роботу зроблену,
    потрібно злити одну гілку в іншу.</p>

    <p>На нашому прикладі ми створили гілку feature/update-txt-files. Як написано в імені гілки — оновимо текст.</p>

<img data-max-width="800" data-id="dee60445-8d14-4a27-b588-5340924819cc" src="https://cdn.javarush.com/images/article/dee60445-8d14-4a27-b588-5340924819cc/original.png" alt="">

    <p>Тепер потрібно створити під це новий коміт:</p>

<div class="terminal">git add *.txt</div>
<div class="terminal">git commit -m “updated txt files”</div>
<div class="terminal">git log</div>

<img data-max-width="800" data-id="7c3cd527-3183-4ece-9e6b-ed0ee2aa4d16" src="https://cdn.javarush.com/images/article/7c3cd527-3183-4ece-9e6b-ed0ee2aa4d16/original.png" alt="">

    <p>Тепер, якщо ми хочемо змерджити feature/update-txt-files гілку у master, треба перейти у master і написати git merge
    feature/update-txt-files:</p>

<div class="terminal">git checkout master</div>
<div class="terminal">git merge feature/update-txt-files</div>
<div class="terminal">git log</div>

<img data-max-width="800" data-id="fc3b02c2-01ed-4ac2-843a-3448ed916e1c" src="https://cdn.javarush.com/images/article/fc3b02c2-01ed-4ac2-843a-3448ed916e1c/original.png" alt="">

    <p>Як результат — тепер і в мастер гілці є коміт, який був доданий у feature/update-txt-files.</p>

    <p>Ця функціональність додана, тому можна видалити фіче (feature) гілку. Для цього напишемо:</p>

<div class="terminal">git branch -D feature/update-txt-files</div>

    <p>Ускладнюємо ситуацію: тепер припустимо, що знову потрібно змінити txt файл. Але тепер ще й у мастері цей файл буде
    змінений також. Тобто він буде паралельно змінюватися, і гіт не зможе зрозуміти, що треба робити в ситуації, коли ми
    захочемо змерджити в master гілку новий код.</p>

    <p>Створюємо нову гілку на основі master, робимо зміни в text_resource.txt і створюємо коміт під це:</p>

<div class="terminal">git checkout -b feature/add-header</div>
<p>... робимо зміни у файлі</p>

<img data-max-width="800" data-id="84ef38d3-8851-4f71-ba88-9ab69d3400bc" src="https://cdn.javarush.com/images/article/84ef38d3-8851-4f71-ba88-9ab69d3400bc/original.png" alt="">

<div class="terminal">git add *.txt</div>
<div class="terminal">git commit -m “added header to txt”</div>

<img data-max-width="800" data-id="d7b1f440-c876-43d2-9af0-4768dd0a293d" src="https://cdn.javarush.com/images/article/d7b1f440-c876-43d2-9af0-4768dd0a293d/original.png" alt="">

    <p>Переходимо на master гілку і також оновлюємо цей текстовий файл у тому самому рядку, що й фіче гілка:</p>

<div class="terminal">git checkout master</div>
<p>… обновили test_resource.txt</p>

<img data-max-width="800" data-id="4ef49b9b-3cde-4cd3-b894-b3c475bb1277" src="https://cdn.javarush.com/images/article/4ef49b9b-3cde-4cd3-b894-b3c475bb1277/original.png" alt="">

<div class="terminal">git add test_resource.txt</div>
<div class="terminal">git commit -m “added master header to txt”</div>

    <p>І тепер найцікавіший момент: потрібно змерджити зміни із feature/add-header гілки в master. Ми перебуваємо в мастер
    гілці, тому потрібно тільки написати:</p>

<div class="terminal">git merge feature/add-header</div>

    <p>Але ми отримаємо результат із конфліктом у файлі test_resource.txt:</p>

<img data-max-width="800" data-id="50a26f73-9286-4d33-9a7b-faabd35fa32b" src="https://cdn.javarush.com/images/article/50a26f73-9286-4d33-9a7b-faabd35fa32b/original.png" alt="">

    <p>І тут ми можемо бачити, що гіт не зміг самостійно вирішити, як змерджити цей код, і каже, що треба спочатку розрезолвити
    конфлікт, а вже потім зробити коміт.</p>

    <p>Ок, відкриваємо у текстовому редакторі файл, у якому конфлікт, і бачимо:</p>

<img data-max-width="800" data-id="9b5a2b9f-3ce7-42fd-8fa1-a29f429460c8" src="https://cdn.javarush.com/images/article/9b5a2b9f-3ce7-42fd-8fa1-a29f429460c8/original.png" alt="">

    <p>Щоб зрозуміти, що тут зробив гіт, треба згадати, що ми де писали, і порівняти:</p>

    <ol>
        <li>Між “<<<<<<< HEAD” та “=======” знаходяться зміни мастер, які були в цьому рядку в мастер гілці.</li>
        <li>Між “=======” та “>>>>>>> feature/add-header” знаходяться зміни, які були в feature/add-header гілці.</li>
    </ol>

    <p>У такий спосіб гіт показує, що в цьому місці він не зміг зрозуміти, як злити в одне ціле цей файл, розділив цю ділянку
    на дві частини з різних гілок і запропонував вирішити нам самим.</p>

    <p>Добре, вирішую прибрати усе і залишити лише слово header:</p>

<img data-max-width="800" data-id="e4e6acfb-1b7f-4f48-a445-5235340944ae" src="https://cdn.javarush.com/images/article/e4e6acfb-1b7f-4f48-a445-5235340944ae/original.png" alt="">

    <p>Подивимося на статус змін, опис буде дещо іншим. Буде не modified стан, а Unmerged. Тому сміливо можна було додати
    п’ятий стан… Але я думаю, що це зайве, подивимося:</p>

<div class="terminal">git status</div>

<img data-max-width="800" data-id="c13fa252-9322-4aaf-abcb-ce0c6198d3cf" src="https://cdn.javarush.com/images/article/c13fa252-9322-4aaf-abcb-ce0c6198d3cf/original.png" alt="">

    <p>Переконалися, що це інший випадок, незвичайний. Продовжуємо:</p>

<div class="terminal">git add *.txt</div>

<img data-max-width="800" data-id="e0674e1a-9d45-4deb-bc3d-f381b7dea5cf" src="https://cdn.javarush.com/images/article/e0674e1a-9d45-4deb-bc3d-f381b7dea5cf/original.png" alt="">

    <p>В описі можна помітити, що пропонують написати лише git commit. Слухаємо та пишемо:</p>

<div class="terminal">git commit</div>

<img data-max-width="800" data-id="337a32e7-777e-47e2-84c0-c87ff43ee142" src="https://cdn.javarush.com/images/article/337a32e7-777e-47e2-84c0-c87ff43ee142/original.png" alt="">

    <p>І все: таким чином ми зробили це — розрезолвили конфлікт у консолі.</p>

    <p>Звісно, в середовищах розробки можна це зробити трохи простіше, наприклад, у Intellij IDEA все налаштовано так добре, що
    можна виконувати всі необхідні дії у ній. Але середовище розробки робить багато чого “під капотом”, і ми часто не
    розуміємо, що саме там сталося. А коли немає розуміння, тоді можуть виникнути й проблеми.</p>

    <h2>Робота з віддаленими репозиторіями</h2>

    <p>Останній крок — розібратися ще з кількома командами, які потрібні для роботи з віддаленим репозиторієм.</p>

    <p>Як я вже казав, віддалений репозиторій — це місце, де зберігається репозиторій і звідки можна його клонувати.</p>

    <p>Які бувають видалені репозиторії? Прикладів безліч:</p>

    <ul>
        <li>GitHub — це величезне сховище для репозиторіїв та спільної розробки.</li>
        <li>GitLab — веб-інструмент життєвого циклу DevOps з відкритим кодом, що представляє систему управління репозиторіями коду для Git з особистим вікв, системою відслідковування помилок, CI/CD пайплайн та іншими функциями.</li>
        <li>BitBucket — вебсервіс для хостингу проєктів та їх спільної розробки, заснований на системі контролю версій Mercurial
        та Git. У свій час мав велику перевагу над GitHub у тому, що у нього були безкоштовні приватні репозиторії. Минулого
        року GitHub також відкрив цю можливість для всіх безкоштовно.</li>
        <li>І так далі...</li>
    </ul>

    <p>Перше, що потрібно зробити у роботі з віддаленим репозиторієм, — клонувати проєкт собі у локальний.</p>

    <p>Для цього експортуємо проєкт, який ми робили локально. Тепер кожен його може собі клонувати, написавши:</p>

<div class="terminal">git clone https://github.com/romankh3/git-demo</div>

    <p>Тепер локально є повна копія проєкту. Щоб бути впевненим, що локально знаходиться остання копія проєкту, потрібно, як
    кажуть, спулити дані, написавши:</p>

<div class="terminal">git pull</div>

<img data-max-width="800" data-id="085baafe-99f0-45b9-8eb4-39c78e7a6f7e" src="https://cdn.javarush.com/images/article/085baafe-99f0-45b9-8eb4-39c78e7a6f7e/original.png" alt="">

    <p>У нашому випадку зараз нічого не змінилося віддалено, тому і відповідь: Already up to date.</p>

    <p>Але якщо ми внесемо будь-які зміни у віддаленому репозиторії, локальний оновиться після того, як ми їх спулимо.</p>

    <p>І, нарешті, остання команда — запушити дані на віддалений репозиторій. Коли ми локально щось зробили і хочемо це
    передати на віддалений репозиторій, потрібно спочатку створити новий коміт локально. Для цього додамо в наш текстовий
    файл ще щось:</p>

<img data-max-width="800" data-id="94a8c820-aee8-4e79-94b8-2a9a54391d42" src="https://cdn.javarush.com/images/article/94a8c820-aee8-4e79-94b8-2a9a54391d42/original.png" alt="">

    <p>Тепер уже звичайна для нас річ — створюємо коміт під це:</p>

<div class="terminal">git add test_resource.txt</div>
<div class="terminal">git commit -m “prepated txt for pushing”</div>

    <p>І тепер команда, щоб відправити це на віддалений репозиторій:</p>

<div class="terminal">git push</div>

    <p>Ось і все!</p>

    <table>
        <tbody>
            <tr>
                <th>Корисні посилання</th>
            </tr>
            <tr>
                <td>
                    <ul>
                        <li>Офіційна <a href="https://git-scm.com/book/uk/v2" target="_blank">документація на Git</a>. Рекомендуємо як довідковий посібник.</li>
                        <li><a href="https://tproger.ru/translations/difference-between-git-and-github/" target="_blank">• Git і GitHub: що це таке і в чому різниця</a></li>
                        <li>Хабр: <a href="https://habr.com/ru/post/342116/" target="_blank">Git на практиці</a></li>
                    </ul>
                </td>
            </tr>
        </tbody>
    </table>

    <h1>2. Як працювати з Git в IntelliJ IDEA</h1>

    <p>У цій частині ти дізнаєшся, як працювати з Git в Intellij IDEA.</p>

    <h2>Необхідні дії для підготовки:</h2>

    <ol>
        <li>Прочитати, повторити та зрозуміти попередню частину. Це допоможе бути впевненим, що все вже налаштоване та готове до
        роботи.</li>
        <li>Встановити Intellij IDEA. З цим все має бути гаразд :)</li>
        <li>Виділити годину для повного засвоєння.</li>
    </ol>

    <p>Для роботи візьмемо <a href="https://github.com/romankh3/git-demo" target="_blank">демопроєкт</a>, який використовувався
    у лекції про Git.</p>

    <h2>Клонуємо проєкт локально</h2>

    <p>Тут є два варіанти.</p>

    <ol>
        <li>Якщо вже є гітхаб акаунт і хочеться щось потім запушити, краще зробити форк проєкту до себе і клонувати свою копію.
        Як зробити форк — можеш почитати в цій статті, у главі приклад the forking workflow.</li>
        <li>Клонувати з репозиторію і зробити все локально без можливості все це запушити на сервер.</li>
    </ol>

    <p>Щоб клонувати проєкт із гітхабу, потрібно скопіювати посилання на проєкт і передати його в IntelliJ IDEA:</p>

    <ol>
        <li><p>Копіюємо адресу проєкту:</p>
<img data-max-width="1024" data-id="19b7469c-f5c5-461f-8332-7e9659259de3" src="images/19b7469c-f5c5-461f-8332-7e9659259de3.jpg" alt=""></li>
        <li><p>Відкриваємо Intellij IDEA та обираємо Get from Version Control:</p>
<img data-max-width="800" data-id="8cfb51b2-9087-4882-a736-4d3a347822fe" src="https://cdn.javarush.com/images/article/8cfb51b2-9087-4882-a736-4d3a347822fe/original.png" alt=""></li>
        <li><p>Копіюємо, вставляємо адресу на проєкт:</p>
<img data-max-width="800" data-id="9ba60369-5c93-4600-9538-e7e238241d80" src="https://cdn.javarush.com/images/article/9ba60369-5c93-4600-9538-e7e238241d80/original.png" alt=""></li>
        <li><p>Вам запропонують створити Intellij IDEA проєкт. Приймаємо пропозицію:</p>
<img data-max-width="800" data-id="9808f1ed-b67a-4254-b53c-467defa28a05" src="https://cdn.javarush.com/images/article/9808f1ed-b67a-4254-b53c-467defa28a05/original.png" alt=""></li>
        <li><p>Оскільки немає системи збирання, обираємо Create project from existing sources:</p>
<img data-max-width="800" data-id="8bca15d7-aa1c-4f79-b2ab-4a8460604e11" src="https://cdn.javarush.com/images/article/8bca15d7-aa1c-4f79-b2ab-4a8460604e11/original.png" alt=""></li>
        <li><p>Далі буде така картина:</p>
<img data-max-width="1024" data-id="79fbb8fb-653f-4741-8e45-517137bda74a" src="images/79fbb8fb-653f-4741-8e45-517137bda74a.jpg" alt=""></li>
    </ol>

    <p>З клонуванням розібралися, тепер вже можна й озирнутися на всі боки.</p>

    <h2>Перший погляд на Intellij IDEA як на гіт UI</h2>

    <p>Придивись ще раз уважно до клонованого проєкту: там можна отримати багато інформації про систему контролю версій.</p>

    <p>Перше — це Version Control панель у нижньому лівому куті. У ній можна знайти всі локальні зміни та отримати список
    комітів (аналог git log).</p>

    <p>Перейдемо в лекцію Log. Є певна візуальна складова, яка допомагає зрозуміти, як саме відбувався процес розробки.
    Наприклад, видно, що створювалася нова гілка з комітом added header to txt, який потім влився в мастер-гілку. Якщо
    натиснути на коміт, у правому куті можна побачити всю інформацію про коміт: всі зміни та його метадані.</p>

<img data-max-width="1024" data-id="79c6c4f7-dc94-4857-a494-b07fcad66ae1" src="https://cdn.javarush.com/images/article/79c6c4f7-dc94-4857-a494-b07fcad66ae1/original.png" alt="">

    <p>Більше того, можна побачити, які були зроблені зміни. Тим паче, що там же було розрезолвлено конфлікт. Це IDEA теж
    чудово показує.</p>

    <p>Якщо натиснути двічі на файл, який був змінений за цей коміт, побачимо, як резолвили кофлікт:</p>

<img data-max-width="1024" data-id="f75644b6-260c-471c-9435-9536ac860998" src="https://cdn.javarush.com/images/article/f75644b6-260c-471c-9435-9536ac860998/original.png" alt="">

    <p>Помітно, що праворуч і ліворуч були два варіанти одного файлу, який потрібно було змерджити в один. А посередині —
    результат, який був отриманий.</p>

    <p>Коли в проєкті безліч гілок, комітів і користувачів, які працюють у проєкті, необхідно пошукати окремо за гілкою
    (branch), користувачем (user) та датою (date):</p>

<img data-max-width="1024" data-id="432c834b-1cb9-4abd-be7a-2bf16a954f84" src="https://cdn.javarush.com/images/article/432c834b-1cb9-4abd-be7a-2bf16a954f84/original.png" alt="">

    <p>Також перед початком роботи слід пояснити, як зрозуміти, в якій гілці ми перебуваємо.</p>

    <p>У правому нижньому куті є кнопка Git: master, де після Git: показано, на якій гілці перебуває зараз проєкт. Якщо
    натиснути на кнопку, можна зробити безліч корисних речей: перейти на іншу гілку, створити нову, перейменувати існуючу
    тощо.</p>

<img data-max-width="1024" data-id="ec71d9e1-9094-4575-918b-f9c033c5b742" src="https://cdn.javarush.com/images/article/ec71d9e1-9094-4575-918b-f9c033c5b742/original.png" alt="">

    <h2>Робота з репозиторієм</h2>

    <h3>Корисні гарячі клавіші</h3>

    <p>Щоб далі працювати, потрібно запам’ятати кілька дуже корисних гарячих клавіш:</p>

    <ol>
        <li><span class="text-bold">ctrl + t</span> — отримати останні зміни з віддаленого репозиторію (git pull).</li>
        <li><span class="text-bold">ctrl + k</span> — зробити коміт/подивитися всі зміни, які є на даний момент. Сюди входять і untracked, і modified файли (git commit).</li>
        <li><span class="text-bold">ctrl + shift + k</span> — це команда створення пуша змін на віддалений репозиторій. Всі коміти, які були створені локально і ще не перебувають на віддаленому, будуть запропоновані для пуша (git push).</li>
        <li><span class="text-bold">alt + ctrl + z</span> — відкотити у конкретному файлі зміни до стану останнього створеного коміту в локальному репозиторії. Якщо у верхньому лівому куті виділити весь проєкт, то можна буде відкотити зміни всіх файлів.</li>
    </ol>

    <h2>Що ми хочемо?</h2>

    <p>Нам для роботи треба освоїти базовий сценарій, який використовується скрізь.</p>

    <p>Постає завдання реалізувати нову функціональність в окремій гілці та запушити її на віддалений репозиторій (далі
    потрібно створити ще пул-реквест на головну гілку, але це виходить за межі нашої лекції).</p>

    <p>Що потрібно для цього зробити?</p>

    <ol>
        <li><p>Отримати всі зміни на цей момент в основний гілці (master, наприклад).</p></li>
        <li><p>На базі цієї основної створити окрему для своєї роботи.</p></li>
        <li><p>Реалізувати нову функціональність.</p></li>
        <li><p>Перейти на основну гілку та перевірити, чи не було нових змін за час, поки працювали. Якщо не було, то все добре, а
        якщо було, то робимо таке: переходимо на працюючу гілку та робимо <a href="https://habr.com/ru/post/161009/"
            target="_blank">ребейз</a> змін з основної гілки в нашу. Якщо все пройшло успішно, то чудово. Але цілком можуть бути
        і конфлікти. І їх якраз можна буде заздалегідь вирішити, не гаючи часу на віддаленому репозиторії.</p>
    <p><em>Здавалося б, навіщо це робити? Це правило доброго тону, яке запобігає виникненню конфліктів вже після пуша своєї гілки
    на локальний репозиторій (є, звісно, ймовірність, що все одно вони будуть, але вона стає <span
        class="text-bold">значно</span> меншою).</em>.</p></li>
        <li><p>Запушити свої зміни на віддалений репозиторій.</p></li>
    </ol>

    <h3>Як отримати зміни з віддаленого сервера</h3>
    <p>Ми додали опис у README у вигляді нового коміту і хочемо ці зміни отримати. Пропонується вибір між мерджем та ребейзом у
    разі, якщо були зроблені зміни і в локальному репозиторії, і у віддаленому. Обираємо мерж.</p>

    <p>Вводимо <span class="text-bold">ctrl + t</span>:</p>

<img data-max-width="1024" data-id="5c72afca-c605-40be-baec-b044d9555833" src="https://cdn.javarush.com/images/article/5c72afca-c605-40be-baec-b044d9555833/original.png" alt="">

    <p>В результаті видно, як змінився README, тобто зміни з віддаленого репозиторію підтяглися, і в правому нижньому куті
    можна переглянути всі деталі тих змін, які прийшли із сервера.</p>

<img data-max-width="1024" data-id="192f52f3-7d69-4d38-acfc-4e51b8959327" src="https://cdn.javarush.com/images/article/192f52f3-7d69-4d38-acfc-4e51b8959327/original.png" alt="">

    <h3>Створити нову гілку на основі master</h3>

    <p>Тут все просто.</p>

    <p>Переходимо в правий нижній кут і натискаємо на <span class="text-bold">Git: master</span>, обираємо <span class="text-bold">+ New Branch</span>.</p>

<img data-max-width="512" data-id="43cbb574-d986-4835-a553-4bf11e789b03" src="https://cdn.javarush.com/images/article/43cbb574-d986-4835-a553-4bf11e789b03/original.png" alt="">

Залишаємо галочку <span class="text-bold">Checkout branch</span> і пишемо ім’я нової гілки. У нашому випадку це буде <span class="text-bold">readme-improver</span>.

<img data-max-width="512" data-id="52260cdd-fd57-41b5-b570-3fce47c90bd8" src="https://cdn.javarush.com/images/article/52260cdd-fd57-41b5-b570-3fce47c90bd8/original.png" alt="">

    <p>Після цього <span class="text-bold">Git: master</span> зміниться на <span class="text-bold">Git: readme-improver</span>.</p>

    <h3>Імітуємо паралельну роботу</h3>

    <p>Щоб конфлікти виникли, їх хтось має створити.</p>

    <p>Відредагуємо через браузер README у вигляді нового коміту і таким чином зімітуємо паралельну роботу. Мовляв, хтось під
    час роботи зробив зміни у тому самому файлі, що й ми, що призведе до конфлікту. Видалимо слово «повністю» з 10 рядка.</p>

    <h2>Реалізувати свою функціональність</h2>

    <p>Завдання полягає в тому, щоб змінити README та додати опис до нової статті, тобто те, що робота в гіті йде через
    Intellij IDEA. Додаємо це:</p>

<img data-max-width="1024" data-id="666f0816-af10-4d33-8f46-43eea4cdae82" src="https://cdn.javarush.com/images/article/666f0816-af10-4d33-8f46-43eea4cdae82/original.png" alt="">

    <p>Зміни виконані, тепер можна створити коміт. Натискаємо гарячу клавішу <span class="text-bold">ctrl + k</span>,
    отримаємо:</p>

<img data-max-width="800" data-id="e74703dc-9dcb-4329-9da4-7019de72d7d3" src="https://cdn.javarush.com/images/article/e74703dc-9dcb-4329-9da4-7019de72d7d3/original.png" alt="">

    <p>Перш ніж створити коміт, потрібно уважно подивитися на те, що пропонується в цьому вікні.</p>

    <p>В секції <span class="text-bold">Commit Message</span> пишемо текст коміту, і, щоб він створився, потрібно натиснути
    кнопку <span class="text-bold">Commit</span>. </p>

    <p>Пишемо, що README змінився, та створюємо коміт. В результаті в лівому нижньому куті спливає оповіщення, в якому буде
    ім’я коміту:</p>

<img data-max-width="512" data-id="22b731d0-d034-4389-9402-dc56c0c7589d" src="https://cdn.javarush.com/images/article/22b731d0-d034-4389-9402-dc56c0c7589d/original.png" alt="">

    <h3>Перевірити, чи не змінилася основна гілка</h3>

    <p>Виконали завдання, все працює, тести написали, все гаразд. Але перш ніж пушити на сервер, потрібно перевірити, чи не
    було змін в основній гілці за цей час. Як це могло статися? Дуже просто: комусь дали завдання після вас, і цей хтось
    виконав його швидше за вас.</p>

   <p>Тому переходимо на master гілку. Для цього треба в правому нижньому куті зробити те, що показано нижче на рисунку:</p>

<img data-max-width="512" data-id="7e3b5947-e12a-48e0-a976-295568cd7a42" src="https://cdn.javarush.com/images/article/7e3b5947-e12a-48e0-a976-295568cd7a42/original.png" alt="">

    <p>У master гілці натискаємо <span class="text-bold">ctrl + t</span>, щоб отримати її останні зміни з віддаленого сервера.
    Якщо подивитися, які були зміни, легко можна помітити, що сталося:</p>

<img data-max-width="1024" data-id="9f366692-f62c-4a48-8fe6-553d8c7f5d61" src="https://cdn.javarush.com/images/article/9f366692-f62c-4a48-8fe6-553d8c7f5d61/original.png" alt="">

    <p>Як бачимо, було видалено слово «повністю». Можливо, це був хтось із маркетингу, і він вирішив, що так не можна писати, і
    дав розробникам завдання оновити це.</p>

    <p>Тепер у нас локально остання версія master гілки. Переходимо назад на <span class="text-bold">readme-improver</span>.</p>

    <p>Тепер треба заребейзити зміни з мастер гілки в нашу. Робимо:

<img data-max-width="512" data-id="50aa8901-8646-471e-86ca-a0db9959cbcf" src="https://cdn.javarush.com/images/article/50aa8901-8646-471e-86ca-a0db9959cbcf/original.png" alt="">

    <p>Якщо ви все правильно виконували зі мною, в результаті має з’явитися конфлікт у README файлі:</p>

<img data-max-width="800" data-id="f4478512-2490-4d36-aef8-118117ac0ee1" src="https://cdn.javarush.com/images/article/f4478512-2490-4d36-aef8-118117ac0ee1/original.png" alt="">

    <p>Тут також багато інформації, яку варто було б зрозуміти й засвоїти. Тут показано список (у нашому випадку з одного
    елемента) файлів, у яких конфлікти. Ми можемо обрати три опції:</p>

    <ol>
        <li>accept yours — прийняти тільки зміни з readme-improver.</li>
        <li>accept theirs — прийняти тільки зміни з master.</li>
        <li>merge — самому обрати, що потрібно залишити, а що — прибрати.</li>
    </ol>

<p>Незрозуміло, що там змінилося, і якщо вже зміни є в мастері, отже, вони потрібні там, і просто прийняти наші зміни не
можна, тому обираємо <span class="text-bold">merge</span>:

<img data-max-width="1080" data-id="2b109118-e031-4fe9-ac0a-137ce9f81251" src="https://cdn.javarush.com/images/article/2b109118-e031-4fe9-ac0a-137ce9f81251/original.png" alt="">

    <p>Тут видно, що є три частини:</p>

    <ol>
        <li>Це зміни з readme-improver.</li>
        <li>Результат. Поки що там так, як було до змін.</li>
        <li>Зміни з master гілки.</li>
    </ol>

    <p>Нам потрібно таким чином зібрати результат, щоби він усіх задовольнив. Тому вивчили, що зробили ДО нас, зрозуміли, що
    просто прибрали слово «повністю». Ну, окей, без проблем. Отже, і ми його приберемо в результаті і додамо наші зміни. Як
    тільки виправимо результат, можна натиснути <span class="text-bold">Apply</span>. </p>

    <p>Після цього з’явиться оповіщення, що ребейз пройшов успішно:</p>

<img data-max-width="512" data-id="b1d89a4f-b0c9-4124-934e-c99b6b9b8bfb" src="https://cdn.javarush.com/images/article/b1d89a4f-b0c9-4124-934e-c99b6b9b8bfb/original.png" alt="">

    <p>Ось так ми зарезолвили свій перший конфлікт через Intellij IDEA.</p>

    <h3>Запушити зміни на віддалений сервер</h3>

    <p>Наступний крок — запушити зміни на віддалений сервер і створювати пул-реквест. Для цього просто натискаємо <span
        class="text-bold">ctrl + shift + k</span>, після чого отримаємо:</p>

<img data-max-width="800" data-id="a50a5ffe-b7e9-4185-ab97-c72792f29a0d" src="https://cdn.javarush.com/images/article/a50a5ffe-b7e9-4185-ab97-c72792f29a0d/original.png" alt="">

    <p>Ліворуч буде список комітів, які не запушені на віддалений репозиторій, а праворуч будуть усі файли, які змінені. І все:
    натискаємо <span class="text-bold">Push</span>, і буде вам щастя :)</p>

    <p>У разі успішного пуша буде ось таке повідомлення в нижньому правому куті:</p>

<img data-max-width="512" data-id="b0845cd5-3492-4d72-bf67-6b76e074e9ac" src="https://cdn.javarush.com/images/article/b0845cd5-3492-4d72-bf67-6b76e074e9ac/original.png" alt="">

    <h2>Бонус: створення пул-реквесту</h2>

    <p>Переходимо на гітхаб репозиторій і бачимо, що гітхаб вже знає, що нам запропонувати:</p>

<img data-max-width="1024" data-id="a5000a13-d403-4cb9-8ebf-d0d480ee5a73" src="images/a5000a13-d403-4cb9-8ebf-d0d480ee5a73.jpg" alt="">

    <p>Натискаємо на <span class="text-bold">Compare & pull request</span>, після чого натискаємо <span
        class="text-bold">Create pull request</span>. Завдяки тому, що ми заздалегідь вирішили конфлікти, тепер під час
    створення пул-реквесту його одразу можна мерджити:

<img data-max-width="1024" data-id="f21b12a2-3415-4b8f-afcc-ab584e70116a" src="https://cdn.javarush.com/images/article/f21b12a2-3415-4b8f-afcc-ab584e70116a/original.jpeg" alt="">

    <p>Ось і все!</p>