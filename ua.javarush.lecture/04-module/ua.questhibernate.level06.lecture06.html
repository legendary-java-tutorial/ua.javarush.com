INDEX: індекси
<p>----------------------------------------</p>
Причини появи індексів
Додавання індексів до таблиці
<p>----------------------------------------</p>
<h2>1. Причини появи індексів</h2>
<p>Ще одна важлива річ, без якої не може бути баз даних, — це індекси.</p>
<p>Уяви собі ситуацію, коли в таблиці <strong>user</strong> є 10 мільйонів користувачів, і тобі потрібно вивести всіх, у кого рівень вищий за 90. Цей запит написати дуже просто:</p>
 <div class="lesson-example lesson-example-center">
    <pre class="lecture-code lecture-code--present language-java"><code>
<span class="text-brown">SELECT</span> * <span class="text-brown">FROM</span> <span class="text-yellow">user</span> <span class= "text-brown">WHERE</span> <span class="text-green">level</span> &gt; 90
        </code></pre>
</div>
<p>Добре, ми написали запит менше ніж за хвилину. Скільки часу займатиме виконання цього запиту в SQL-сервера? Для виконання такого запиту йому доведеться пройти по 10 мільйонів записів, і навіть якщо шукається лише один запис, це займе купу часу.</p>
<p>Як би ми зробили аналогічне завдання Java? Ми спочатку відсортували б колекцію користувачів по level, а потім можна було б дуже швидко знайти потрібні записи за допомогою бінарного пошуку. Сподіваюся, чи не треба пояснювати, що це таке?</p>
<p>Добре, а що робити, якщо тепер нам потрібно відібрати користувачів, чия дата реєстрації була до 2020 року? Знову сортувати за датою реєстрації та використовувати бінарний пошук.</p>
<p>Ага, <span class="text-green">якщо ми виконуємо фільтр за якомось полем, причому не один раз, а часто, буде дуже корисно зберігати дані відсортованими за цим полем.</span></p>
<p>А як зберігати дані, відсортовані одночасно за різними полями?</p>
<p>Відповідь дуже проста — потрібно зберігати не самі дані, а їх індекси в якійсь глобальній таблиці.</p>
<p>Припустимо, є 10 користувачів з id: <code>{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}</code>.</p>
<p>Ти вирішуєш відсортувати їх за рівнем: тоді масив їх id буде, наприклад, таким: <code>{9, 2, 3, 1, 5, 4, 8, 6, 7, 10}</code>. </p>
<p>А якщо відсортувати їх за датою, ми отримаємо, скажімо: <code>{10, 1, 8, 7, 2, 3, 5, 9, 6}</code>.</p>
<p><strong>Масиви цих id називаються індексами</strong>. Самі елементи великі, їх ми не чіпаємо. У Java ми не чіпаємо об'єкти, а зберігаємо їх посилання, в SQL ми не чіпаємо реальні рядки, а зберігаємо їх номери.</p>
<p>Давай я ще раз запишу це у вигляді Java-коду:</p>
<pre class='language-java line-numbers'><code>
List&lt;String&gt; list = List.of("А", "С", "B", "Z", "Сc", "Bb", "Zz", "Y"); // це список об'єктів
List&lt;String&gt; alphabeticsList = новий ArrayList(list);
Collections.sort(alphabeticsList); //колекція відсортована за абеткою
 
List&lt;String&gt; lengthList = новий ArrayList(list);
Collections.sort(lengthList, lengthComparator); //колекція відсортована за довжиною рядків
</code></pre>
<p>Сортування колекцій не означає переміщення реальних елементів. Колекція зберігає не реальні об'єкти, а посилання на них. Також і в таблицях SQL. Реальні рядки лежать собі та й лежать. </p>
<p>І коли нам потрібно часто робити вибірки за якимось полем, то ми <strong>додаємо ще один індекс до таблиці</strong> (аналог нової колекції в Java) і сортуємо рядки таблиці, зберігаємо їх відсортований порядок у спеціальному файлі індексів.</p>
<p>Сподіваюся, порівняння з Java трохи допомогло. Трохи практики — і для тебе використання індексів також стане найочевиднішим рішенням. </p>
<h2>2. Додавання індексів до таблиці</h2>
<p>Індекс можна вказати одразу під час створення таблиці або додати після. Найчастіше зустрічається саме другий сценарій — індекси додають по мірі зростання розмірів таблиці та уповільнення вибірки даних.</p>
<p>Додати індекс до таблиці дуже просто:</p>
 <div class="lesson-example lesson-example-center">
    <pre class="lecture-code lecture-code--present language-java"><code>
<span class="text-brown">ALTER TABLE</span> <span class="text-yellow">таблиця</span>
    <span class="text-red">ADD INDEX</span> <span class="text-user">ім'я_індексу</span> (<span class="text-green">колонка</span>);
        </code></pre>
</div>
<p>Якщо ти часто шукаєш записи за кількома колонками одночасно, можеш вказати зіставний індекс: для його складання SQL використовує кілька колонок.</p>
<p>Додати зіставний індекс до таблиці теж дуже просто:</p>
 <div class="lesson-example lesson-example-center">
    <pre class="lecture-code lecture-code--present language-java"><code>
<span class="text-brown">ALTER TABLE</span> <span class="text-yellow">таблиця</span>
    <span class="text-red">ADD INDEX</span> <span class="text-user">ім'я_індексу</span> (<span class="text-green">колонка1</span>, <span class="text-green">колонка2</span>, <span class="text-green">колонка3</span>, ...);
        </code></pre>
</div>
<p>Індекси займають досить багато місця на диску, тому якщо якийсь індекс тобі більше не потрібен, ти завжди можеш видалити його:</p>
 <div class="lesson-example lesson-example-center">
    <pre class="lecture-code lecture-code--present language-java"><code>
<span class="text-brown">ALTER TABLE</span> <span class="text-yellow">таблиця</span>
    <span class="text-red">DROP INDEX</span> <span class="text-user">ім'я_індексу</span>;
        </code></pre>
</div>
<p>Самі індекси — це доволі прихована частина бази даних. Вони не впливають на формат написання запитів. Просто їх наявність прискорює вибірку даних та уповільнює їх додавання та бекап.</p>
<p>Але враховуючи те, наскільки важливою є швидкість у сучасному світі і яке дешеве місце на дисках, не соромся додавати індекси на всі випадки життя. Хай пробачать мені адміни…</p>
