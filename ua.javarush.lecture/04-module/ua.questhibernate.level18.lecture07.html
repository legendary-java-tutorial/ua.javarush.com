  Як реалізувати ACID у додатку: практика <p>---------------------------------------- </p> ID транзакцій. Повторні спроби ("Retries"). Розширений інструментарій для любителів транзакцій. Як зрозуміти, коли мені потрібні гарантії ACID? У яких випадках мені не потрібні ACID? <p>----------------------------------------</p> <h2> 8.1 ID транзакцій </h2> <p>Позначається як XID або TxID (якщо є різниця – підкажіть). Як TxID можна використовувати timestamps, що може зіграти на руку, якщо ми захочемо відновити всі дії до якогось моменту часу. Проблема може виникнути, якщо timestamp недостатньо гранулярний - тоді транзакції можуть отримати один і той же ID. </p> <p>Тож найбільш надійний варіант – це генерувати унікальні ID проде UUID. У Python це робиться дуже просто: </p> <pre><code>>>> import uuid >>> str(uuid.uuid4()) 'f50ec0b7-f960-400d-91f0-c42a6d44e3d0' >>> str(uuid .uuid4()) 'd15bed89-c0a5-4a72-98d9-5507ea7bc0ba' </code></pre> <p>Також є варіант хешувати набір визначальних транзакцію даних і використовувати цей хеш як TxID.</p> <h2> 8.2 Повторні спроби ("retries") </h2> <p>Якщо ми знаємо, що певна функція або програма ідемпотентна, це означає, що ми можемо і повинні намагатися повторити її виклик у разі помилки. А ми просто повинні бути готові до того, що якась операція видасть помилку – враховуючи, що сучасні програми розподілені по мережі та залізу, помилка має розглядатися не як виняток, а як норма. Помилка може статися через падіння сервера, помилки мережі, перевантаження віддаленої програми. Як повинний поводитися наш додаток? Правильно, спробувати повторити операцію. </p> <p>Оскільки один шматочок коду може сказати більше, ніж ціла сторінка слів, то давайте на одному прикладі розберемо, як в ідеалі має працювати механізм повторення операції в дусі naive retrying. Я продемонструю це з використанням бібліотеки Tenacity (у неї настільки продуманий дизайн, що навіть якщо ви не плануєте використовувати її, приклад повинен наочно показати, як можна спроектувати механізм повторення): </p> <pre class='language-java line-numbers '><code> import logging import random import sys from tenacity import retry, stop_after_attempt, stop_after_delay, wait_exponential, retry_if_exception_type, before_log logging.basicConfig(stream=sys.stderr, level=logging.DEBUG) logger = logging.getLogger(__name__) @ retry( stop=(stop_after_delay(10) | stop_after_attempt(5)), wait=wait_exponential(multiplier=1, min=4, max=10), retry=retry_if_exception_type(IOError), before=before_log(logger, logging. ) def do_something_unreliable(): if random.randint(0, 10) > 1: raise IOError("Broken sauce, everything is hosed!!!111one") else: return "Awesome sauce!" print(do_something_unreliable.retry.statistics) </code></pre> <p>>Про всяк випадок скажу: \@retry(...) — це такий спеціальний синтаксис Python, що називається "декоратором". Це функція retry(...) , яка обертає іншу функцію і виконує деякі дії до чи після виконання. </p> <p>Як ми бачимо, повторні спроби можна оформити креативно: </p> <ul> <li>Можна обмежити спроби за часом (10 секунд) або кількістю спроб (5).</li> <li> Можна експоненційно (тобто, 2 ** деяке число n , що збільшується). або якось ще (наприклад, фіксовано) збільшувати час між окремими спробами. Експонентний варіант носить назву "congestion collapse".</li> <li>Можна робити повторні спроби лише для деяких видів помилок (IOError).</li> <li>Повторні спроби можна попереджати або завершувати якимись спеціальними записами в балку. </li> </ul> <p>Тепер, коли ми пройшли курс молодого бійця і знаємо основні цеглини, які знадобляться нам для роботи з транзакціями на стороні програми, познайомимося з двома методами, які дозволяють втілювати транзакції в розподілених системах. </p> <h2>8.3 Просунутий інструментарій для любителів транзакцій </h2> <p>Я лише дам досить загальні визначення, оскільки ця тема варта окремої великої статті.</p> <p><strong>Two-phase commit ( 2pc)</strong>. 2pc має дві фази: фазу підготовки та фазу фіксації. На етапі підготовки всім мікросервісам буде запропоновано підготуватись до деяких змін даних, які можуть бути виконані атомарно. Як тільки всі вони будуть готові, то на етапі фіксації будуть внесені фактичні зміни. Для координації процесу необхідний глобальний координатор, який блокує необхідні об'єкти, тобто вони стають недоступними для змін, поки координатор їх не розблокує. Якщо окремий мікросервіс не готовий до змін (наприклад, не відповідає), координатор перерве транзакцію і почне процес відкату. </p> <p>Чим хороший цей протокол? Він забезпечує атомарність. До того ж він гарантує ізоляцію під час запису та читання. Це означає, що зміни однієї транзакції не видно іншим, поки координатор не зафіксує зміни. Але в цих властивостях криється і мінус: оскільки цей протокол синхронний (блокуючий), він уповільнює роботу системи (при тому, що виклик RPC сам по собі досить повільний). І знову-таки виникає небезпека взаємного блокування. </p> <p><strong>Saga</strong>. У цьому шаблоні розподілена транзакція виконується асинхронними локальними транзакціями у всіх пов'язаних мікросервісах. Мікросервіси зв'язуються між собою через шину подій („event bus“). Якщо мікросервіс не може завершити свою локальну транзакцію, інші мікросервіси виконають компенсаційні транзакції для відкату змін. </p> <p>Плюси Saga у тому, що жодні об'єкти не блокуються. Але є, звісно, і мінуси. </p> <p>Saga складно налагоджувати, особливо коли задіяно багато мікросервісів. Ще один недолік шаблону Saga – у ньому відсутня ізоляція читання. Тобто, якщо нам важливі властивості, позначені ACID, то Saga нам не дуже підходить. </p> <p>Що ми бачимо з опису цих двох технік? Те, що у розподілених системах відповідальність за атомарність та ізоляцію лягає на додаток. Те саме відбувається і при використанні БД, які не надають гарантії ACID. Тобто такі речі, як вирішення конфліктів, відкати, комміти та вивільнення місця лягають на плечі розробника. </p> <h2>8.4 Як зрозуміти, коли мені потрібні гарантії ACID? </h2> <p><strong>Коли є велика ймовірність того, що кілька користувачів або процесів одночасно працюватимуть над тими самими даними</strong>.</p> <p>Вибачте за банальність, але типовий приклад - Фінансові транзакції. </p> <p><strong>Коли порядок виконання транзакцій має значення. </strong></p> <p>Уявіть собі, що ваша компанія зібралася переходити з месенджера FunnyYellowChat до месенджера FunnyRedChat, тому що у FunnyRedChat можна відсилати гіфки, а у FunnyYellowChat - не можна. Але ви не просто змінюєте месенджер — ви мігруєте листування вашої компанії з одного месенджера до іншого. Ви робите це, тому що ваші програмісти лінувалися документувати програми та процеси десь централізовано, і натомість усе публікували у різних каналах у месенджері. Та й ваші продажники деталі переговорів та угод публікували там же. Коротше, все життя вашої компанії - там, і оскільки ніхто не має часу переносити всю цю справу в сервіс для документації, а пошук у месенджерів працює непогано, ви вирішили замість розгрібання завалів просто скопіювати всі повідомлення в нове місце. Черговість повідомлень важлива, тому що інакше все може переплутатися, і ви, наприклад, не розумітимете, де саме знаходиться відповідь на те чи інше питання. </p> <p>До речі, для листування в месенджері взагалі важлива черговість, але коли дві людини одночасно пишуть щось в одному чаті, то загалом не так важливо, чиє повідомлення здасться першим. Отже, саме для цього сценарію ACID був би не потрібен. </p> <p>Інший можливий приклад — біоінформатика. Я в цьому зовсім не розуміюся, але припускаю, що при розшифровці геному людини порядок важливий. Втім, я чув, що біоінформатики взагалі якісь свої інструменти для всього використовують — можливо, у них і свої БД. </p> <p><strong>Коли не можна видати користувачеві або процесу застарілі дані.</strong> </p> <p>І знову — фінансові транзакції. Щиро кажучи, не вигадав іншого прикладу. </p> <p><strong>Коли незавершені транзакції пов'язані зі значними витратами.</strong> Уявіть собі проблеми, які можуть виникнути, коли лікар і медсестра одночасно оновлюють карту пацієнта та стирають зміни один одного, тому що БД не може ізолювати транзакції. Система охорони здоров'я — це ще одна сфера, окрім фінансової, для якої гарантії ACID, як правило, є критично важливими. </p> <h2>8.5 У яких випадках мені не потрібні ACID? </h2> <p><strong>Коли користувачі оновлюють лише свої приватні дані.</strong></p> <p>Наприклад, користувач залишає коментарі або sticky notes до веб-сторінки. Або редагує особисті дані в особистому кабінеті провайдера будь-яких послуг. </p> <p><strong>Коли користувачі взагалі не оновлюють дані, а лише доповнюють новими (append). </strong></p> <p>Наприклад, додаток для бігу, який зберігає дані про ваші пробіжки: скільки пробігли, за який час, маршрут і т.д. Кожна нова пробіжка – нові дані, а старі взагалі не редагуються. Можливо, на підставі даних ви отримуєте аналітику - і якраз БД NoSQL хороші для цього сценарію. </p> <p><strong>Коли бізнес-логіка не визначає потреби певного порядку виконання транзакцій. </strong></p> <p>Напевно, для блогера на Youtube, який під час чергового прямого ефіру збирає пожертвування для виробництва нового матеріалу, не так важливо, хто колись саме і в якій черзі кинув йому гроші. </p> <p>Коли користувачі будуть знаходитися на одній і тій же веб-сторінці або вікні програми кілька секунд або навіть хвилин, тому вони так чи інакше бачитимуть застарілі дані. </p> <p>Теоретично, це будь-які новинні онлайн-медіа, або той же Youtube. Або "Хабр". <strong>Коли вам немає значення, що в системі тимчасово можуть зберігатися неповні транзакції — ви можете їх ігнорувати без будь-яких збитків.</strong> </p> <p>Якщо ви агрегуєте дані з безлічі джерел, причому дані, які оновлюються з високою періодичністю — наприклад, дані про зайнятість місць для паркування в місті, які змінюються як мінімум кожні 5 хвилин, то теоретично для вас не буде великої проблеми, якщо в якийсь момент транзакція для однієї з парковок не пройде. Хоча, звичайно, залежить від того, що ви хочете робити з цими даними.</p>