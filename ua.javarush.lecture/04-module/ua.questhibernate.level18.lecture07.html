  Як реалізувати ACID у додатку: практика
  <p>---------------------------------------- </p>
  ID транзакцій.
  Повторні спроби ("Retries").
  Розширений інструментарій для любителів транзакцій.
  Як зрозуміти, коли мені потрібні гарантії ACID?
  У яких випадках мені не потрібні ACID?
  <p>----------------------------------------</p>
  <h2>1. ID транзакцій </h2>
  <p>Позначається як XID або TxID (якщо є різниця — підкажіть). Як TxID можна використовувати timestamps, що може зіграти на руку, якщо ми захочемо відновити всі дії до якогось моменту часу. Проблема може виникнути, якщо timestamp недостатньо гранулярний — тоді транзакції можуть отримати один і той же ID. </p>
  <p>Тож найбільш надійний варіант — це генерувати унікальні ID проде UUID. У Python це робиться дуже просто: </p>

  <pre><code>>>> import uuid
>>> str(uuid.uuid4())
'f50ec0b7-f960-400d-91f0-c42a6d44e3d0'
>>> str(uuid.uuid4())
'd15bed89-c0a5-4a72-98d9-5507ea7bc0ba'
</code></pre>

  <p>Також є варіант хешувати набір даних, що визначають транзакцію, і використовувати цей хеш як TxID.</p>
  <h2>2. Повторні спроби ("retries") </h2>
  <p>Якщо ми знаємо, що певна функція або програма ідемпотентна, це означає, що ми можемо і повинні намагатися повторити її виклик у разі помилки. А ми просто повинні бути готові до того, що якась операція видасть помилку — враховуючи, що сучасні програми розподілені мережею та залізом, помилка має розглядатися не як виняток, а як норма. Помилка може статися через падіння сервера, помилки мережі, перевантаження віддаленої програми. Як повинний поводитися наш застосунок? Правильно, спробувати повторити операцію. </p>
  <p>Оскільки один шматочок коду може сказати більше, ніж ціла сторінка слів, то давай на одному прикладі розберемо, як в ідеалі має працювати механізм повторення операції в дусі naive retrying. Я продемонструю це з використанням бібліотеки Tenacity (у неї настільки продуманий дизайн, що навіть якщо ти не плануєш використовувати її, приклад повинен наочно показати, як можна спроектувати механізм повторення):

  <pre class='language-java line-numbers'><code>
import logging
import random
import sys
from tenacity import retry, stop_after_attempt, stop_after_delay, wait_exponential, retry_if_exception_type, before_log

logging.basicConfig(stream=sys.stderr, level=logging.DEBUG)
logger = logging.getLogger(__name__)

@retry(
	stop=(stop_after_delay(10) | stop_after_attempt(5)),
	wait=wait_exponential(multiplier=1, min=4, max=10),
	retry=retry_if_exception_type(IOError),
	before=before_log(logger, logging.DEBUG)
)
def do_something_unreliable():
	if random.randint(0, 10) > 1:
    	raise IOError("Broken sauce, everything is hosed!!!111one")
	else:
    	return "Awesome sauce!"

print(do_something_unreliable.retry.statistics)
</code></pre>

  <p>>Про всяк випадок скажу: \@retry(...) — це такий спеціальний синтаксис Python, що називається "декоратором". Це функція retry(...) , яка обертає іншу функцію і виконує деякі дії до чи після виконання. </p>
  <p>Як ми бачимо, повторні спроби можна оформити креативно: </p>
  <ul>
    <li>Можна обмежити спроби за часом (10 секунд) або кількістю спроб (5).</li>
    <li> Можна експоненційно (тобто, 2 ** деяке число n , що збільшується), або якось ще (наприклад, фіксовано) збільшувати час між окремими спробами. Експонентний варіант носить назву "congestion collapse".</li>
    <li>Можна робити повторні спроби лише для деяких видів помилок (IOError).</li>
    <li>Повторні спроби можна попереджати або завершувати якимись спеціальними записами в балку. </li>
  </ul>
  <p>Тепер, коли ми пройшли курс молодого бійця і знаємо основні цеглини, які знадобляться нам для роботи з транзакціями на стороні програми, познайомимося з двома методами, які дозволяють втілювати транзакції в розподілених системах. </p>
  <h2>3. Просунутий інструментарій для любителів транзакцій </h2>
  <p>Я лише дам доволі загальні визначення, оскільки ця тема варта окремої великої статті.</p>
  <p><strong>Two-phase commit ( 2pc)</strong>. 2pc має дві фази: фазу підготовки та фазу фіксації. На етапі підготовки всім мікросервісам буде запропоновано підготуватись до деяких змін даних, які можуть бути виконані атомарно. Як тільки всі вони будуть готові, то на етапі фіксації будуть внесені фактичні зміни. Для координації процесу необхідний глобальний координатор, який блокує необхідні об'єкти, тобто вони стають недоступними для змін, поки координатор їх не розблокує. Якщо окремий мікросервіс не готовий до змін (наприклад, не відповідає), координатор перерве транзакцію і почне процес відкату. </p>
  <p>Чим хороший цей протокол? Він забезпечує атомарність. До того ж він гарантує ізоляцію під час запису та читання. Це означає, що зміни однієї транзакції не видно іншим, поки координатор не зафіксує зміни. Але в цих властивостях криється і мінус: оскільки цей протокол синхронний (блокуючий), він уповільнює роботу системи (при тому, що виклик RPC сам по собі досить повільний). І знову ж таки виникає небезпека взаємного блокування. </p>
  <p><strong>Saga</strong>. У цьому шаблоні розподілена транзакція виконується асинхронними локальними транзакціями у всіх пов'язаних мікросервісах. Мікросервіси зв'язуються між собою через шину подій („event bus“). Якщо мікросервіс не може завершити свою локальну транзакцію, інші мікросервіси виконають компенсаційні транзакції для відкату змін. </p>
  <p>Плюси Saga у тому, що жодні об'єкти не блокуються. Але є, звісно, і мінуси. </p>
  <p>Saga складно налагоджувати, особливо коли задіяно багато мікросервісів. Ще один недолік шаблону Saga — у ньому відсутня ізоляція читання. Тобто, якщо нам важливі властивості, позначені ACID, то Saga нам не дуже підходить. </p>
  <p>Що ми бачимо з опису цих двох технік? Те, що у розподілених системах відповідальність за атомарність та ізоляцію лягає на програму. Те саме відбувається і у разі використання БД, які не надають гарантії ACID. Тобто такі речі, як вирішення конфліктів, відкати, комміти та вивільнення місця лягають на плечі розробника. </p>
  <h2>4. Як зрозуміти, коли мені потрібні гарантії ACID? </h2>
  <p><strong>Коли є велика ймовірність того, що кілька користувачів або процесів одночасно працюватимуть над тими самими даними</strong>.</p>
  <p>Вибач за банальність, але типовий приклад — Фінансові транзакції. </p>
  <p><strong>Коли порядок виконання транзакцій має значення. </strong></p>
  <p>Уяви, що твоя компанія зібралася переходити з месенджера FunnyYellowChat нао месенджер FunnyRedChat, тому що у FunnyRedChat можна надсилати гіфки, а у FunnyYellowChat не можна. Але ви не просто змінюєте месенджер — ви мігруєте листування вашої компанії з одного месенджера до іншого. Ви робите це, тому що ваші програмісти лінувалися документувати програми та процеси десь централізовано, і натомість усе публікували у різних каналах у месенджері. Та й ваші продажники деталі переговорів та угод публікували там же. Коротше, все життя вашої компанії — там, і оскільки ніхто не має часу переносити всю цю справу в сервіс для документації, а пошук у месенджерів працює непогано, ти вирішуєш замість розгрібання завалів просто скопіювати всі повідомлення в нове місце. Черговість повідомлень важлива, тому що інакше все може переплутатися, і ви, наприклад, не розумітимете, де саме знаходиться відповідь на те чи інше питання. </p>
  <p>До речі, для листування в месенджері взагалі важлива черговість, але коли дві людини одночасно пишуть щось в одному чаті, то загалом не так важливо, чиє повідомлення здасться першим. Отже, саме для цього сценарію ACID був би не потрібен. </p>
  <p>Інший можливий приклад — біоінформатика. Я в цьому зовсім не розуміюся, але припускаю, що під час розшифровки геному людини порядок важливий. Втім, я чув, що біоінформатики взагалі якісь свої інструменти для всього використовують — можливо, у них і свої БД. </p>
  <p><strong>Коли не можна видати користувачеві або процесу застарілі дані.</strong> </p>
  <p>І знову — фінансові транзакції. Щиро кажучи, не вигадав іншого прикладу. </p>
  <p><strong>Коли незавершені транзакції пов'язані зі значними витратами.</strong> Уяви собі проблеми, які можуть виникнути, коли лікар і медсестра одночасно оновлюють карту пацієнта та стирають зміни один одного, тому що БД не може ізолювати транзакції. Система охорони здоров'я — це ще одна сфера, окрім фінансової, для якої гарантії ACID, як правило, є критично важливими. </p>
  <h2>5. У яких випадках мені не потрібні ACID? </h2>
  <p><strong>Коли користувачі оновлюють лише свої приватні дані.</strong></p>
  <p>Наприклад, користувач залишає коментарі або sticky notes до вебсторінки. Або редагує особисті дані в особистому кабінеті провайдера будь-яких послуг. </p>
  <p><strong>Коли користувачі взагалі не оновлюють дані, а лише доповнюють новими (append). </strong></p>
  <p>Наприклад, застосунок для бігу, який зберігає дані про твої пробіжки: скільки пробігли, за який час, маршрут тощо. Кожна нова пробіжка — нові дані, а старі взагалі не редагуються. Можливо, на підставі даних ти отримуєш аналітику — і БД NoSQL хороші саме для цього сценарію. </p>
  <p><strong>Коли бізнес-логіка не визначає потреби певного порядку виконання транзакцій. </strong></p>
  <p>Напевно, для блогера на Youtube, який під час чергового прямого ефіру збирає пожертвування для виробництва нового матеріалу, не так важливо те, хто, коли саме і в якій черговості кинув йому гроші. </p>
  <p>Коли користувачі будуть знаходитися на одній і тій самій вебсторінці або вікні програми кілька секунд або навіть хвилин, вони так чи інакше бачитимуть застарілі дані. </p>
  <p>Теоретично, це будь-які новинні онлайн-медіа, або той же Youtube. <strong>Коли тобі неважливо, що в системі тимчасово можуть зберігатися неповні транзакції, ти можеш їх ігнорувати без будь-яких збитків.</strong> </p>
  <p>Якщо ти агрегуєш дані з безлічі джерел, причому дані, які оновлюються з високою періодичністю — наприклад, про зайнятість місць для паркування в місті, які змінюються як мінімум кожні 5 хвилин, то теоретично для тебе не буде великою проблемою, якщо в якийсь момент транзакція для однієї з парковок не пройде. Хоча, звісно, залежить від того, що ти хочеш робити з цими даними.</p>