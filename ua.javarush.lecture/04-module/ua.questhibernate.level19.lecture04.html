Apache Cassandra: зберігання даних у кластері
<p>----------------------------------------</p>
Розподіл даних.
Узгодженість даних під час запису.
Узгодженість даних під час читання.
<p>----------------------------------------</p>
<h2>5.1 Розподіл даних</h2>

<p>Розглянемо як дані розподіляються залежно від ключа по вузлам кластера (cluster nodes). Кассандра дозволяє ставити стратегію розподілу даних. Перша така стратегія розподіляє дані залежно від md5 значення ключа – випадковий розмітник (random partitioner). Друга враховує саме бітове уявлення ключа - порядковий розмітник (byte-ordered partitioner). </p>

<p>Перша стратегія, здебільшого, дає більше переваг, оскільки вам не потрібно дбати про рівномірний розподіл даних між серверами та подібні проблеми. Другу стратегію використовують у поодиноких випадках, наприклад, якщо необхідні інтервальні запити (range scan). Важливо зауважити, що вибір цієї стратегії проводиться перед створенням кластера і фактично не може бути змінено без перезавантаження даних. </p>

<p>Для розподілу даних касандра використовує техніку, відому як узгоджене хешування (consistent hashing). Цей підхід дозволяє розподілити дані між вузлами і зробити так, що при додаванні та видаленні нового вузла кількість даних, що пересилаються, була невеликою. Для цього кожному вузлу ставиться у відповідність мітка (token), яка розбиває на частини безліч всіх md5 значень ключів. Оскільки в більшості випадків використовується RandomPartitioner, розглянемо його.</p>
  
<p>Як я вже казав, RandomPartitioner обчислює 128-бітний md5 для кожного ключа. Для визначення в яких вузлах будуть зберігатися дані, просто перебираються всі мітки вузлів від меншого до більшого, і, коли значення мітки стає більше, ніж значення md5 ключа, цей вузол разом з деякою кількістю наступних вузлів (в порядку міток) вибирається для збереження. Загальна кількість вибраних вузлів має дорівнювати рівню реплікації (replication factor). Рівень реплікації задається кожного простору ключів і дозволяє регулювати надмірність даних (data redundancy). </p>

<img data-max-width="1024" data-id="f1d64198-6325-4195-8f44-7f0dc43f6898" src="https://cdn.javarush.com/images/article/f1d64198-6325-41 -7f0dc43f6898/original.png" alt="">
 
<p>Перед тим, як додати вузол до кластера, необхідно задати йому мітку. Від того, який відсоток ключів покриває проміжок між цією міткою та наступною, залежить, скільки даних буде зберігатися на вузлі. Весь набір міток кластера називається кільцем (ring). </p>

<p>Ось ілюстрація, що відображає за допомогою вбудованої утиліти nodetool кільце кластера з 6 вузлів з рівномірно розподіленими мітками. </p>

<img data-max-width="1024" data-id="51a9b82a-d1e9-40df-b6c3-143968efb3b9" src="https://cdn.javarush.com/images/article/51a9b82a-d1e9-40 -143968efb3b9/original.png" alt="">
 
<h2>5.2 Узгодженість даних під час запису </h2>

<p>Вузли кластера кассандри рівноцінні, і клієнти можуть з'єднуватися з будь-яким із них, як для запису, так і для читання. Запити проходять стадію координації, під час якої, з'ясувавши за допомогою ключа та розмітника на яких вузлах повинні розташовуватись дані, сервер надсилає запити до цих вузлів. Будемо називати вузол, який виконує координацію - <strong>координатором</strong> (coordinator), а вузли, які вибрані для збереження запису з цим ключем - <strong>вузлами-реплік</strong> (replica nodes). Фізично координатором може бути один із вузлів-реплік – це залежить тільки від ключа, розмітника та міток. </p>

<p>Для кожного запиту як на читання, так і на запис є можливість задати рівень узгодженості даних. </p>

<p><strong>Для запису</strong> цей рівень впливатиме на кількість вузлів-реплік, з яких очікується підтвердження вдалого закінчення операції (дані записалися) перед тим, як повернути користувачеві управління. Для запису є такі рівні узгодженості: </p>

<ul>
<li><strong>ONE</strong> — координатор шле запити всім вузлам-реплікам, але, дочекавшись підтвердження від першого ж вузла, повертає керування користувачеві; </li>
<li><strong>TWO</strong> — те саме, але координатор чекає підтвердження від двох перших вузлів, перш ніж повернути управління; </li>
<li><strong>THREE</strong> — аналогічно, але координатор чекає на підтвердження від трьох перших вузлів, перш ніж повернути управління; </li>
<li><strong>QUORUM</strong> — збирається кворум: координатор чекає на підтвердження запису від більш ніж половини вузлів-реплік, а саме round(N / 2) + 1, де N — рівень реплікації; </li>
<li><strong>LOCAL_QUORUM</strong> — координатор чекає підтвердження від більш ніж половини вузлів-реплік у тому самому центрі обробки даних, де розташований координатор (для кожного запиту потенційно свій). Дозволяє позбутися затримок, пов'язаних з пересиланням даних до інших центрів обробки даних. Питання роботи з багатьма центрами обробки даних розглядаються у цій статті побіжно; </li>
<li><strong>EACH_QUORUM</strong> — кооринатор чекає підтвердження від більш ніж половини вузлів-реплік у кожному центрі обробки даних незалежно; </li>
<li><strong>ALL</strong> — координатор чекає на підтвердження від усіх вузлів-реплік; </li>
<li><strong>ANY</strong> — дозволяє записати дані, навіть якщо всі вузли-репліки не відповідають. Координатор чекає або першої відповіді від одного з вузлів-реплік, або коли дані збережуться за допомогою направленої відправки (hinted handoff) координатору. </li>
</ul>
 
<img data-max-width="1024" data-id="521841e0-1890-4d30-8b36-eadbd4a7b1f4" src="https://cdn.javarush.com/images/article/521841e0-1890-3d -eadbd4a7b1f4/original.png" alt="">

<h2>5.3 Узгодженість даних під час читання </h2>

<p><strong>Для читання</strong> рівень узгодженості впливатиме на кількість вузлів-реплік, з яких читатиметься. Для читання є такі рівні узгодженості: </p>

<ul>
<li><strong>ONE</strong> — координатор надсилає запити до найближчого вузла-репліки. Інші репліки також читаються з метою читання з виправленням (read repair) із заданою конфігурації кассандри ймовірністю; </li>
<li><strong>TWO</strong> — те саме, але координатор шле запити до двох найближчих вузлів. Вибирається значення, яке має велику мітку часу; </li>
<li><strong>THREE</strong> — аналогічно до попереднього варіанту, але з трьома вузлами; </li>
<li><strong>QUORUM</strong> — збирається кворум, тобто координатор шле запити до більш ніж половини вузлів-реплік, а саме round(N/2) + 1, де N — рівень реплікації; </li>
<li><strong>LOCAL_QUORUM</strong> — збирається кворум у тому центрі обробки даних, у якому відбувається координація, та повертаються дані з останньою міткою часу; </li>
<li><strong>EACH_QUORUM</strong> — координатор повертає дані після збору кворуму в кожному центрі обробки даних; </li>
<li><strong>ALL</strong> — координатор повертає дані після прочитання з усіх вузлів-реплік. </li>
</ul>
 
<img data-max-width="1024" data-id="ed9df03b-6ba0-4e7a-9281-59e4fb476fc8" src="https://cdn.javarush.com/images/article/ed9df03b-6ba0-4e7a-9 -59e4fb476fc8/original.png" alt="">

<p>Таким чином, можна регулювати тимчасові затримки операцій читання, запису та налаштовувати узгодженість (tune consistency), а також доступність (availability) кожної з видів операцій. По суті, доступність безпосередньо залежить від рівня узгодженості операцій читання та запису, оскільки він визначає, скільки вузлів-реплік може вийти з ладу, і при цьому ці операції все ще будуть підтверджені. </p>

<p>Якщо кількість вузлів, з яких приходить підтвердження про запис, у сумі з числом вузлів, з яких відбувається читання, більша, ніж рівень реплікації, то у нас є гарантія, що після запису нове значення завжди буде прочитане, і це називається суворим. узгодженістю (strong consistency). За відсутності суворої узгодженості існує можливість, що операція читання поверне застарілі дані. </p>

<p>У будь-якому випадку, значення зрештою пошириться між репліками, але вже після того, як закінчиться координаційне очікування. Таке поширення називається підсумковою узгодженістю (eventual consistency). Якщо не всі вузли-репліки будуть доступні під час запису, то рано чи пізно будуть задіяні засоби відновлення, такі як читання з виправленням та антиентропійне відновлення вузла (anti-entropy node repair). Про це трохи згодом. </p>

<p>Таким чином, при рівні узгодженості QUORUM на читання та на запис завжди підтримуватиметься строга узгодженість, і це буде певний баланс між затримкою операції читання та запису. При записі ALL, а читанні ONE буде сувора узгодженість, і операції читання будуть виконуватися швидше і будуть мати більшу доступність, тобто кількість вузлів, що вийшли з ладу, при якому читання все ще буде виконано, може бути більшим, ніж при QUORUM. </p>

<p>Для операцій запису потрібні всі робочі вузли-реплік. При записі ONE, читанні ALL теж буде сувора узгодженість, і операції запису виконуватимуться швидше і доступність запису буде великою, адже буде достатньо підтвердити лише, що операція запису пройшла хоча б на одному із серверів, а читання — повільніше і вимагатиме всіх вузлів-реплік . Якщо ж до додатка немає вимоги про сувору узгодженість, то з'являється можливість прискорити операції читання та операції запису, а також поліпшити доступність за рахунок виставлення менших рівнів узгодженості.</p>