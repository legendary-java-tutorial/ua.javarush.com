  Шардування
  <p>----------------------------------------</p>
  Що таке шардування?
  Ділимо неподільне.
  Простий приклад "як зробити руками".
  Amdahl права.
  <p>----------------------------------------</p>
  <h2> 1. Що таке шардування? </h2>
  <p>Якщо завзято гуглити, то з'ясується, що між так званим партиціонуванням і так званим шардингом досить розмиті межі. Кожен називає все, що хоче, чим хоче. Одні люди розрізняють горизонтальне партиціонування та шардинг. Інші кажуть, що шардинг — це певний вид горизонтального партиціонування. </p>
  <p>Єдиного термінологічного стандарту, який був би схвалений батьками-засновниками та в ISO сертифікований, я не знайшов. Особисте внутрішнє переконання приблизно таке: Partitioning в середньому — це "ріжемо базу на шматки" довільним чином. </p>
  <ul>
      <li><strong>Vertical partitioning</strong> — поколоночно. Наприклад, є гігантська таблиця на пару мільярдів записів із 60 колоноками. Замість того, щоб тримати одну таку гігантську таблицю, тримаємо 60 не менших гігантських таблиць по 2 млрд записів — і це не поколоночна база, а вертикальне партиціонування (як приклад термінології). </li>
      <li><strong>Horizontal partitioning</strong> — ріжемо рядково, можливо, всередині сервера. </li>
  </ul>
  <p>Незручний момент тут у тонкій відмінності між горизонтальним партиціонуванням і шардуванням. Мене можна на шматки різати, але я впевнено вам не скажу, у чому воно полягає. Є відчуття, що шардування та горизонтальне партиціонування — це приблизно одне й те саме. </p>
  <p><strong>Шардування</strong> — це загалом, коли велика таблиця в термінах баз або проколекція документів, об'єктів, якщо у вас не зовсім база даних, а document store, ріжеться саме по об'єктах. Тобто з 2 млрд об'єктів вибираються шматки неважливо якого розміру. Об'єкти самі по собі всередині кожного об'єкта не розрізаємо на шматки, окремі колонки не розкладаємо, а саме пачками розкладаємо в різні місця. </p>
  <p>Далі вже пішли тонкі термінологічні відмінності. Наприклад, умовно кажучи, розробники на Postgres можуть сказати, що горизонтальне партиціонування — це коли всі таблиці, на які розділена основна таблиця, лежать в одній схемі, а коли на різних машинах — це вже шардування. </p>
  <p>У загальному сенсі, не прив'язуючись до термінології конкретної бази даних та конкретної системи управління даними, є відчуття, що <strong>шардування — це просто нарізка рядково/підокументно</strong> тощо — і все. </p>
  <p>Наголошую, типово. У тому сенсі, що ми все це робимо не просто так, щоб нарізати 2 млрд документів на 20 таблиць, кожна з яких була б більш manageable, а для того, щоб розподілити це на багато ядер, багато дисків чи багато різних фізичних чи віртуальних серверів.</p>
  <h2>2. Ділимо неподільне </h2>
  <p>Допускається, що ми це робимо для того, щоб кожен шард — кожен шматок даних — багаторазово реплікувати. Але насправді ні.</p>

  <pre><code>INSERT INTO docs00
SELECT * FROM documents WHERE (id%16)=0
...

INSERT INTO docs15
SELECT * FROM documents WHERE (id%16)=15
</code></pre>
 <p>Насправді, якщо ти зробите таку нарізку даних, і з однієї гігантської SQL таблиці на MySQL на твоєму доблесному ноутбуці згенеруєте 16 маленьких табличок, не виходячи за рамки жодного ноутбука, жодної схеми, жодної бази даних тощо — все, у вас уже шардування. </p>
  <p>Це призводить до наступного: </p>
  <ul>
      <li>Збільшується bandwidth — пропускна спроможність. </li>
      <li>Latency не змінюється, тобто кожен, так би мовити, worker чи consumer у цьому випадку отримує своє. Різні запити обслуговуються приблизно за один час. </li>
      <li>Або те й інше, і ще high availability (реплікація). </li>
  </ul>
  <p><strong>Навіщо bandwidth?</strong> У нас іноді можуть виникати такі обсяги даних, які не влазять — не зрозуміло куди, але не влазять — на 1 {ядро | диск | сервер | ...}. Просто не вистачає ресурсів, і все. Щоб з цим великим датасетом працювати, треба його нарізати. </p>
  <p><strong>Навіщо latency?</strong> На одному ядрі просканувати таблицю з 2 млрд рядків у 20 разів повільніше, ніж просканувати 20 таблиць на 20 ядрах, роблячи це паралельно. Дані надто повільно обробляються однією ресурсі. </p>
  <p><strong>Навіщо high availability?</strong> Або нарізаємо дані, для того щоб робити і одне, й інше одночасно, і заразом кілька копій кожної шарди — реплікація забезпечує високу доступність. </p>
  <h2>3. Простий приклад «як зробити руками» </h2>
  <p>Умовний шардинг можна випиляти за допомогою тестової таблиці test.documents на 32 документи, і генерацією з цієї таблиці 16 тестових таблиць приблизно по 2 документи test. docs00, 01, 02, ..., 15. </p>

  <pre><code>INSERT INTO docs00
SELECT * FROM documents WHERE (id%16)=0
...

INSERT INTO docs15
SELECT * FROM documents WHERE (id%16)=15
</code></pre>
 <p>Чому приблизно? Тому що апріорі ми не знаємо, як розподілені id. Якщо від 1 до 32 включно, то буде рівно по 2 документи, інакше — ні. </p>
  <p><strong>Робимо ми це ось для чого.</strong> Після того, як ми зробили 16 таблиць, ми можемо «захавати» 16 того, що нам потрібно. Незалежно від того, на що ми вперлися, ми можемо на ці ресурси розпаралелітися. Наприклад, якщо не вистачає дискового простору, буде мати сенс розкласти ці таблиці за окремими дисками. </p>
  <p>Все це, на жаль, не безкоштовно. Підозрюю, що у випадку з канонічним SQL-стандартом (давно не перечитував SQL-стандарт, можливо його давно не оновлювали), немає офіційного стандартизованого синтаксису для того, щоб будь-якому SQL-серверу сказати: «Дорогий SQL-сервер, зроби мені 32 шарди і розклади їх на 4 диски». Але в окремо взятих реалізаціях найчастіше є конкретний синтаксис для того, щоб зробити в принципі те саме. У PostgreSQL є механізми для партиціонування, у MySQL є MariaDB, Oracle напевно це все зробив вже дуже давно. </p>
  <p>Проте, якщо ми це робимо руками, без підтримки бази даних і в межах стандарту, то <strong>платимо умовною складністю доступу до даних</strong>. Там, де було простим SELECT * FROM documents WHERE id=123, тепер 16 x SELECT * FROM docsXX. І добре, якщо ми намагалися діставати запис за ключем. Значно цікавіше, якщо ми намагалися діставати ранній діапазон записів. Тепер (якщо ми, наголошую, ніби дурні, і залишаємося в межах стандарту) результати цих 16 SELECT * FROM доведеться об'єднувати у застосунку. </p>
  <p><strong>Якої зміни продуктивності очікувати? </strong></p>
  <ul>
      <li>Інтуїтивно — лінійної.</li>
      <li>Теоретично — сублінійної, тому що Amdahl law. </li>
      <li>Практично — можливо, майже лінійно, можливо, ні. </li>
  </ul>
  <p>Насправді правильна відповідь — невідомо. Спритним застосуванням техніки шардування можна досягти значного надлінійного погіршення роботи твоєї програми, та ще й DBA прибіжить з розпеченою кочергою. </p>
  <p>Подивимося, як цього можна досягти. Зрозуміло, що просто поставити налаштування в PostgreSQL shards = 16, а далі воно саме злітає — це не цікаво. Давай подумаємо, як можна домогтися того, щоб від шардування в 16 разів ми загальмували б у 32 — це цікаво з того погляду, як би цього не робити.</p>
  <p>Наші спроби прискоритися або загальмувати завжди будуть впиратися в класику — у старий-добрий закон Амдала (Amdahl law), який каже, що немає ідеальної розпаралелізації будь-якого запиту, завжди є якась послідовна частина. </p>
  <h2>4. Amdahl law </h2>
  <p><span class="text-green">Завжди є serialized частина. </span></p>
  <p>Завжди є частина виконання запиту, яка паралельна, і завжди є частина, яка не паралельна. Навіть якщо тобі здається, що ідеально паралельний запит, як мінімум збір рядка результату, яку ви збираєтеся надіслати на клієнта, з рядків, отриманих з кожного шарда, завжди є, і він завжди послідовний. </p>
  <p>Завжди є якась послідовна частина. Вона може бути крихітною, абсолютно непомітною на загальному тлі, вона може бути гігантською і відповідно сильно впливає на паралелізацію, але вона є завжди. </p>
  <p>До того ж, її вплив змінюється і може відчутно зрости, наприклад, якщо ми наріжемо нашу таблицю — давай піднімемо ставки — із 64 записів на 16 таблиць по 4 записи, ця частина зміниться. Звісно ж, судячи з таких гігантських обсягів даних, ми працюємо на мобільному телефоні і 86 процесорі 2 МГц, у нас і файлів бракує, які можна одночасно тримати відкритими. Мабуть, з такими вхідними даними ми по одному файлу за раз відкриваємо. </p>
  <ul>
      <li>Було <strong>Total = Serial + Parallel</strong>. Де, наприклад, parallel — це вся робота всередині DB, а serial — надсилання результату в клієнта. </li>
      <li>Стало <strong>Total2 = Serial + Parallel/N + Xserial</strong>. Наприклад, коли загальний ORDER BY, Xserial>0. </li>
  </ul>
  <p>Цим нехитрим прикладом я намагаюся показати, що з'являється якесь Xserial. Окрім того, що завжди є серіалізована частина, і того, що ми намагаємося працювати з даними паралельно, з'являється додаткова частина для забезпечення нарізки даних. Грубо кажучи, нам може знадобитися: </p>
  <ul>
      <li>знайти у внутрішньому словнику бази даних ці 16 таблиць; </li>
      <li>відкрити файли; </li>
      <li>аллокувати пам'ять; </li>
      <li>розаллокувати пам'ять; </li>
      <li>смерджити результати; </li>
      <li>синхронізуватися між ядрами.</li>
  </ul>
  <p>Якісь розсинхронізаційні ефекти все одно обов'язково з'являються. Вони можуть бути незначними і позичати одну мільярдну від загального часу, але завжди ненульові і завжди є. З їх допомогою ми і можемо різко втратити у продуктивності після шардування. </p>
  <img data-max-width="1024" data-id="271eab10-2784-46cd-bc06-65a0aa0211c7" src="https://cdn.javarush.com/images/article/271eab10-2784-46c -65a0aa0211c7/original.png" alt="">
  <p>Це стандартна картинка про закон Амдала. Тут важливо те, що лінії, які повинні в ідеалі бути прямими і лінійно зростати, упираються в асимптоту. Але оскільки графік з інтернету нечитабельний, я виготовив, як на мене, наочніші таблиці з цифрами. </p>
  <p>Припустимо, ми маємо певну серіалізовану частину обробки запиту, яка займає лише 5%: <strong>serial = 0.05 = 1 / 20</strong>. </p>
  <p>Інтуїтивно здавалося б, що при серіалізованій частині, яка займає лише 1/20 від обробки запиту, якщо ми розпаралелімо обробку запиту на 20 ядер, вона стане приблизно в 20, у гіршому випадку — у 18 разів швидше. </p>
  <p>Насправді <strong>математика — штука безсердечна</strong>: </p>
  <p>wall = 0.05 + 0.95/num_cores, speedup = 1 / (0.05 + 0.95/num_cores) </p>
  <p>Виявляється, що якщо акуратно порахувати, при серіалізованій частині в 5%, прискорення буде в 10 разів (10,3), а це 51% порівняно з теоретичним ідеальним. </p>

  <table>
      <tbody>
      <tr>
          <td>8 cores </td>
          <td>= 5.9 </td>
          <td>= 74% </td>
      </tr>
      <tr>
          <td>10 cores </td>
          <td>= 6.9 </td>
          <td>= 69% </td>
      </tr>
      <tr>
          <td>20 cores </td>
          <td>= 10.3 </td>
          <td>= 51% </td>
      </tr>
      <tr>
          <td>40 cores </td>
          <td>= 13.6 </td>
          <td>= 34% </td>
      </tr>
      <tr>
          <td>128 cores </td>
          <td>= 17.4 </td>
          <td>= 14% </td>
      </tr>
      </tbody>
  </table>
  <p>Використовуючи 20 ядер ( 20 дисків, якщо завгодно) на те завдання, над яким раніше працювало одне, ми навіть теоретично прискорення більше ніж у 20 разів ніколи не отримаємо, а практично — набагато менше. Причому зі збільшенням числа паралелей неефективність сильно зростає. </p>
  <p>Коли залишається лише 1% серіалізованої роботи, а 99% паралелюється, значення прискорення дещо покращуються: </p>

  <table>
      <tbody>
      <tr>
          <td>8 cores </td>
          <td>= 7.5 </td>
          <td>= 93% </td>
      </tr>
      <tr>
          <td>16 cores </td>
          <td>= 13.9 </td>
          <td>= 87% </td>
      </tr>
      <tr>
          <td>32 cores </td>
          <td>= 24.4 </td>
          <td>= 76% </td>
      </tr>
      <tr>
          <td>64 cores </td>
          <td>= 39.3 </td>
          <td>= 61% </td>
      </tr>
      </tbody>
  </table>
  <p>Для геть термоядерного запиту, який натурально виконується годинами, і підготовча робота зі збирання результату займає дуже мало часу (serial = 0.001), ми побачимо вже хорошу ефективність: </p>

  <table>
      <tbody>
      <tr>
          <td>8 cores </td>
          <td>= 7.94 </td>
          <td>= 99% </td>
      </tr>
      <tr>
          <td>16 cores </td>
          <td>= 15.76 </td>
          <td>= 99% </td>
      </tr>
      <tr>
          <td>32 cores </td>
          <td>= 31.04 </td>
          <td>= 97% </td></td>
      </tr>
      <tr>
          <td>64 cores </td>
          <td>= 60.20 </td>
          <td>= 94% </td>
      </tr>
      </tbody>
  </table>
  <p>Зверни увагу: <strong>100% ми не побачимо ніколи</strong>. В особливо вдалих випадках можна побачити, наприклад, 99,999%, але не рівно 100%.</p>