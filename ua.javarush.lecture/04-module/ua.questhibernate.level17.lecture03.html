Залежності між таблицями у базі даних
<p>----------------------------------------</p>
Відношення one to one
Відношення one to many
Відношення many to many
<p>----------------------------------------</p>
<h2>1. Вступ </h2>
<p>Перетворивши таблиці бази даних на звичайні таблиці, ти можеш проаналізувати зв'язки, що є між ними. Кількість елементів, що взаємодіють між двома зв'язаними таблицями, називається кардинальністю. Кардинальність допоможе тобі проконтролювати, наскільки ефективно дані розбито на таблиці. </p>
<p>Теоретично всі сутності можуть підтримувати між собою зв'язки, проте на практиці виділяються три різновиди зв'язків між сутностями: </p>
<ul>
<li><strong>Один до одного</strong> </li>
<li><strong>Один до багатьох</strong> </li>
<li><strong>Багато багатьох</strong> </li>
</ul>
<h2>2. Зв'язок один до одного</h2>
<p>Якщо на кожен екземпляр сутності Б припадає лише один екземпляр сутності А, вважається, що між ними існує зв'язок один до одного (який часто позначається 1:1). На ER-діаграмах такий зв'язок позначається лінією з невеликою межею на кожному кінці: </p>
<img data-max-width="800" data-id="0f4b8ae1-8f1d-4b91-beee-42a7dc7a6d43" src="https://cdn.javarush.com/images/article/0f4b8ae1-8f1d-4b9 -42a7dc7a6d43/800.jpeg" alt="">
<p>Зв'язок 1:1 зазвичай вказує на те, що, якщо в тебе немає вагомих причин тримати їх окремо, дані двох таблиць краще об'єднати в одну. </p>
<p>Проте, за деяких обставин, використання таблиць зі зв'язками 1:1 цілком доцільно. Якщо у твоїх таблицях є поля з необов'язковими даними, наприклад описами, і в багатьох випадках вони порожні, є сенс перенести всі описи до окремої таблиці, що дозволить тобі позбавитися частих прогалин і підвищити ефективність роботи своєї бази даних. </p>
<p>Потім, щоб правильно зіставити дані, тобі доведеться включити як мінімум один ідентичний стовпець до кожної таблиці (для цього краще вибрати первинний ключ).</p>
<h2>3. Зв'язок один до багатьох </h2>
Відносини такого роду виникають, коли запис однієї таблиці пов'язаний з декількома сутностями іншої. Наприклад, той самий клієнт міг розмістити кілька замовлень, а відвідувач бібліотеки за один візит запозичити одразу декілька книг. Зв'язки «один до багатьох» (або скорочено «1:М») виражаються на схемі у вигляді нотації «воронячої лапки», як показано на прикладі нижче: </p>
<img data-max-width="800" data-id="5aba6739-39b5-407d-9b73-d6f34e433100" src="https://cdn.javarush.com/images/article/5aba6739-39b5-407d-9 -d6f34e433100/800.jpeg" alt="">
<p>Щоб застосувати зв'язок 1:М під час планування бази даних, просто додай первинний ключ з таблиці «один» як атрибут до таблиці «багато». Якщо первинний ключ знаходиться в іншій таблиці, він має назву «зовнішній ключ». Таблиця «один» вважається батьківською, тоді як таблиця «багато» — дочірня.</p>
<h2>4. Зв'язок «багато до багатьох» </h2>
<p>Коли кілька сутностей однієї таблиці можуть бути з'єднані з декількома сутностями іншої, вважається, що між ними існує зв'язок типу «багато до багатьох» (або «М:М»). Наприклад, такий зв'язок існує між студентами та заняттями, оскільки кожен студент може відвідати кілька різних занять, а на кожне заняття, відповідно, може прийти багато студентів. </p>
<p>На ER-діаграмі цей тип зв'язку відображається так: </p>
<img data-max-width="800" data-id="f93e6b36-0af0-4b54-ad91-e742f312fb84" src="https://cdn.javarush.com/images/article/f93e6b36-0af0-4b54-ad -e742f312fb84/800.jpeg" alt="">
<p>На жаль, безпосередньо реалізувати такий зв'язок у базі даних неможливо. Тому її доведеться розбити на два зв'язки на кшталт «один до багатьох». </p>
<p>Для цього тобі знадобиться створити нову сутність між двома таблицями. Якщо зв'язок М:М встановлений між продажами та товарами, нову сутність можна назвати «продані товари», оскільки в ній буде представлений вміст кожного продажу. </p>
<p>З «проданими товарами» і в таблиці «продажу», і в таблиці «товари» буде встановлено зв'язок типу 1:М. У різних моделях такі проміжні сутності називаються по-різному — «сполучні таблиці», «асоціативні сутності» або «вузлові таблиці». </p>
<p>Кожний запис сполучної таблиці поєднує між собою дві різні сутності сусідніх таблиць (а також може містити додаткову інформацію). Наприклад, сполучна таблиця між студентами та заняттями може виглядати так: </p>
<img data-max-width="800" data-id="32d7695b-e54e-4dc9-8179-3bf0bd4dcc07" src="https://cdn.javarush.com/images/article/32d7695b-e54e-4dc -3bf0bd4dcc07/800.jpeg" alt="">
<h2>5. Обов'язково чи ні?</h2>
Ще один підхід до аналізу зв'язків полягає в тому, щоб встановити, яка зі сполучених сутностей є обов'язковою умовою наявності іншої сутності. Необов'язкова сторона зв'язку відзначається довкола сполучної лінії. </p>
<p>Наприклад, щоб у держави був власний представник в ООН, вона має існувати на карті світу, проте твердження про протилежне буде хибним: </p>
<img data-max-width="800" data-id="e52ad077-5f55-4bc5-8d3f-b04bc75394ea" src="https://cdn.javarush.com/images/article/e52ad077-5f55-4bc5-8 -b04bc75394ea/800.jpeg" alt="">
<p>Дві сутності можуть бути взаємозалежними (тобто одна не може існувати без іншої).</p>
<h4>Рекурсивні зв'язки </h4>
<p>Іноді таблиця може посилатися на себе. Наприклад, у таблиці співробітників може бути атрибут «менеджер», який відсилатиме нас до іншого співробітника в тій же таблиці. Це і є рекурсивний зв'язок. </p>
<h4>Зайві зв'язки </h4>
<p>Зв'язки вважаються зайвими, якщо вони виражаються більше ніж один раз. Як правило, один можна видалити без втрати важливої інформації. Наприклад, якщо сутність «студенти» пов'язані з сутністю «викладачі» не лише безпосередньо, а й опосередковано, через «заняття», є сенс видалити зв'язок між сутностями «студенти» і «викладачі». Обґрунтовано це рішення тим, що призначити студентів викладачам можна лише за допомогою занять. </p>
<h2>6. Цілісність посилань даних</h2>
<p>Під час зміни первинних та зовнішніх ключів слід дотримуватись такого аспекту як <strong>посилальна цілісність даних</strong> (referential integrity). Її основна ідея полягає в тому, щоб дві таблиці в базі даних, які зберігають ті самі дані, підтримували їхню узгодженість.</p>
<p>Цілісність даних являє собою правильно збудовані відносини між таблицями з коректною установкою посилань між ними. У яких випадках цілісність даних може порушуватись: </p>
<ul>
<li><strong>Аномалія видалення</strong> (deletion anomaly). Виникає у разі видалення рядка з головної таблиці. У цьому випадку зовнішній ключ із залежної таблиці продовжує посилатися на віддалений рядок із головної таблиці.
</li>
<li><strong>Аномалія вставки</strong> (insertion anomaly). Виникає при вставці рядка у залежну таблицю. У цьому випадку зовнішній ключ із залежної таблиці не відповідає первинному ключу жодного рядка з головної таблиці.</li>
<li><strong>Аномалії оновлення</strong> (update anomaly). При подібній аномалії кілька рядків однієї таблиці можуть містити дані, які належать одному й тому об'єкту. Під час зміни даних в одному рядку вони можуть суперечити даними з іншого рядка. </li>
</ul>
<h4>Аномалія видалення </h4>
<p>Для вирішення аномалії видалення для зовнішнього ключа слід встановлювати одне з двох обмежень: </p>
<p>Якщо рядок із залежної таблиці обов'язково вимагає наявності рядка із головної таблиці, то для зовнішнього ключа встановлюється каскадне видалення. Тобто при видаленні рядка із головної таблиці відбувається видалення зв'язаного рядка (рядків) із залежної таблиці. </p>
<p>Якщо рядок із залежної таблиці допускає відсутність зв'язку з рядком із головної таблиці (тобто такий зв'язок необов'язковий), то для зовнішнього ключа при видаленні зв'язаного рядка із головної таблиці задається встановлення значення NULL. У цьому стовпець зовнішнього ключа повинен допускати значення NULL. </p>
<h4>Аномалія вставки </h4>
<p>Для розв'язання аномалії вставки при додаванні в залежну таблицю даних стовпець, який представляє зовнішній ключ, повинен допускати значення NULL. І таким чином, якщо об'єкт, що додається, не має зв'язку з головною таблицею, то в стовпці зовнішнього ключа стоятиме значення NULL. </p>
<h4>Аномалії оновлення </h4>
<p>Для вирішення проблеми аномалії оновлення застосовується нормалізація, яку було розглянуто раніше. </p>
