Оптимізація швидкості вибірки даних
<p>----------------------------------------</p>
Індекси
Денормалізація таблиць
Оптимізація запитів: приклади
Кешування
<p>----------------------------------------</p>
<h2>1. Вступ</h2>
<p>А тепер перейдемо від теорії до практики. </p>
<center><span class="text-green">«У теорії між теорією та практикою відмінностей немає. На практиці вони є.»</span></center>
<p>Ми живемо в реальному світі, і всі програмні продукти створюються, зрештою, для живих людей. І цих живих людей дуже дратують сайти, які повільно вантажаться, та програми, які підгальмовують.</p>
<p>І якщо запит до бази даних виконується більше секунди, це <strong>неприйнятно</strong>. Користувачі просто не користуватимуться таким продуктом, де є сторінки/функціонал, які настільки гальмують.</p>
<p>Адже часто, щоб відобразити одну сторінку, потрібно виконати кілька десятків запитів до бази. І якщо вони виконуються послідовно, то ліміт у тебе уже не секунда, а скажімо, 100мс на запит.</p>
<p>Нижче я наведу 5 основних способів, якими програмісти прискорюють роботу запитів до бази даних:</p>
<ol>
<li>Додаємо індекси до таблиць у базі даних.</li>
<li>Переписуємо та оптимізуємо запити.</li>
<li>Включаємо (і налаштовуємо) кешування на боці БД.</li>
<li>Включаємо кешування на стороні клієнта.</li>
<li>Виконуємо денормалізацію бази даних.</li>
</ol>
<p>Ти вже здебільшого знаєш всі ці речі, тому далі будуть лише практичні поради.</p>
<h2>2. Індекси</h2>
<p>Ні для кого не секрет, що робота з базою даних займає більшу частину роботи практично будь-якого сайту. І саме робота з БД найчастіше є вузьким місцем вебзастосунків.</p>
<p>У цій статті хотілося б дати практичні поради щодо використання MySQL.</p>
<p>Одразу зазначу:</p>
<ul>
<li>ця стаття написана про MySQL, хоча загальні речі найімовірніше справедливі для будь-якої СУБД.</li>
<li>все написане у статті є моєю особистою точкою зору, і не є істиною в останній інстанції.</li>
<li>поради не претендують на новизну і є результатом узагальнення прочитаної літератури та особистого досвіду.</li>
<li>у межах цієї статті я не торкатимусь питань конфігурування MySQL.</li>
</ul>
<p>Проблеми під час використання MySQL можна розділити на три групи (у порядку значимості):</p>
<ol>
<li>Невикористання або неправильне використання індексів.</li>
<li>Неправильна структура БД.</li>
<li>Неправильні \ неоптимальні SQL запити.</li>
</ol>
<p>Зупинимося на кожній із цих груп докладніше.</p>
<h3>Використання індексів</h3>
<p>Невикористання або неправильне використання індексів — це те, що найчастіше уповільнює запити. Для тих, хто недостатньо знайомий з механізмом роботи індексів або ще не читав про це у мануалі, дуже раджу почитати.</p>
<p><strong>Поради щодо використання індексів:</strong> </p>
<ul>
<li><span class="text-red">Не потрібно індексувати все поспіль</span>. Досить часто, не розуміючи сенсу, люди просто індексують усі поля таблиці. Індекси прискорюють вибірки, але уповільнюють вставки та оновлення рядків, тому вибір кожного індексу має бути осмислений.</li>
<li>Один із основних параметрів, що характеризує індекс — селективність (selectivity) — кількість різних елементів в індексі. Немає сенсу індексувати поле, в якому є два-три можливі значення. Користі від такого індексу буде мало.</li>
<li>Вибір індексів має починатися з аналізу всіх запитів до цієї таблиці. Дуже часто після такого аналізу замість трьох-чотирьох індексів можна зробити один складений.</li>
<li>При використанні складових індексів порядок полів в індексі має вирішальне значення.</li>
<li>Не забувай про індекси, що покривають (covering). Якщо всі дані в запиті можна отримати з індексу, MySQL не буде звертатися безпосередньо до таблиці. Подібні запити виконуватимуться дуже швидко. Наприклад, для запиту <code>SELECT name FROM user WHERE login='test'</code> за наявності індексу (login, name) звернення до таблиці не потрібно. Іноді має сенс додати до складового індексу додаткове поле, яке зробить індекс покриваючим та прискорить запити.</li>
<li>Для індексів рядків часто достатньо індексувати лише частину рядка. Це може значно зменшити розмір індексу.</li>
<li>Якщо <code>%</code> стоїть на початку <code>LIKE(SELECT * FROM table WHERE field LIKE '%test')</code>, індекси не використовуватимуться.</li>
<li><strong>FULLTEXT</strong> індекс використовується лише з синтаксисом <strong>MATCH</strong> … <strong>AGAINST</strong>.</li>
</ul>
<h2>3. Структура БД</h2>
<p>Грамотно спроектована БД — запорука швидкої та ефективної роботи з базою. З іншого боку, погано продумана БД — це головний біль для розробників.</p>
<p><strong>Поради з проєктування БД:</strong> </p>
<ol>
<li>Використовуй мінімально можливі типи даних. Чим більший тип даних, тим більша таблиця, тим більше звернень до дисків потрібно для отримання даних. Використовуй дуже зручну процедуру: <code>SELECT * FROM table_name PROCEDURE ANALYSE();</code> для визначення мінімально можливих типів даних.</li>
<li>На етапі проєктування дотримуйся нормальних форм. Часто програмісти вдаються до денормалізації вже на цьому етапі. Однак у більшості випадків на початку проєкту не очевидно, у що це може вилитися. Денормалізувати таблицю набагато простіше, ніж страждати від неоптимально денормалізованої. Та й <code>JOIN</code> часом працює швидше, ніж неправильно денормалізовані таблиці.</li>
<li>Не використовуй <code>NULL</code> стовпці за винятком випадків, коли вони тобі свідомо потрібні.</li>
</ol>
<h2>4. SQL запити.</h2>
<p>Так само часто виникає бажання переписати всі запити на native SQL, щоб запит був максимально швидким. Якщо ти зважишся на таке, то ось тобі кілька порад:</p>
<ol>
<li>Уникай запитів у циклі. SQL — мова множин, і до написання запитів потрібно підходити не мовою функцій, а мовою множин.</li>
<li>Уникай <code>*</code> (зірочки) у запитах. Не полінуйтеся перерахувати ті поля, які ти обираєш. Це скоротить кількість даних, що вибираються і пересилаються. До того ж, не забувай про індекси, що покривають. Навіть якщо ти дійсно вибираєш всі поля у таблиці, краще їх перерахувати. <strong>По-перше</strong>, це підвищує читабельність коду. В разі використання зірочок неможливо дізнатися, які поля є в таблиці без заглядання в неї. <strong>По-друге</strong>, сьогодні у твоїй таблиці п'ять <strong>INT</strong> стовпців, а через місяць додалося ще одне <strong>TEXT</strong> та <strong>BLOB</strong>, а зірочка як була, так і залишилася.</li>
<li>Під час посторінкового вибору для отримання загальної кількості записів використовуй <code>SQL_CALC_FOUND_ROWS</code> та <code>SELECT FOUND_ROWS();</code> Під час використання <code>SQL_CALC_FOUND_ROWS MySQL</code> кешує обрану кількість рядків (до застосування LIMIT) і при <code>SELECT FOUND_ROWS()</code> лише віддає це закешоване значення без необхідності повторного виконання запиту.</li>
<li>Не забувай, що <code>INSERT</code> має синтаксис для множинної вставки. Один запит буде виконуватися набагато швидше, ніж безліч запитів у циклі.</li>
<li>Використовуй <code>LIMIT</code> там, де тобі не потрібні всі дані.</li>
<li>Використовуй <code>INSERT… ON DUPLICATE KEY UPDATE…</code> замість вибірки та <code>INSERT</code> або <code>UPDATE</code> після неї, а також часто замість <code>REPLACE</code>.</li>
<li>Не забувай про чудову функцію <code>GROUP_CONCAT</code>. Вона може допомогти у разі складних запитів.</li>
</ol>
