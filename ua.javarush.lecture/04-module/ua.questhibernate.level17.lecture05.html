Оптимізація швидкості вибірки даних
<p>----------------------------------------</p>
Індекси
Денормалізація таблиць
Оптимізація запитів: приклади
Кешування
<p>----------------------------------------</p>
<h2>6.1 Вступ</h2>
<p>А тепер перейдемо від теорії до практики. </p>
<center><span class="text-green">«У теорії між теорією та практикою відмінностей немає. На практиці вони є.»</span></center>
<p>Ми живемо в реальному світі і всі програмні продукти створюються, зрештою, для живих людей. І цих живих людей дуже дратують сайти, які повільно вантажаться, та програми, які підгальмовують.</p>
<p>І якщо запит до бази даних виконується більше секунди, це <strong>неприйнятно</strong>. Користувачі просто не користуватимуться таким продуктом, де є сторінки/функціонал, який настільки гальмує.</p>
<p>Адже часто, щоб відобразити одну сторінку, потрібно виконати кілька десятків запитів до бази. І якщо вони виконуються послідовно, то ліміт у вас уже не секунда, а скажімо 100мс на запит.</p>
<p>Нижче я наведу 5 основних способів, якими програмісти прискорюють роботу запитів до бази даних:</p>
<ol>
<li>Додаємо індекси до таблиць у базі даних.</li>
<li>Переписуємо та оптимізуємо запити.</li>
<li>Включаємо (і налаштовуємо) кешування на боці БД.</li>
<li>Включаємо кешування на стороні клієнта.</li>
<li>Виконуємо денормалізацію бази даних.</li>
</ol>
<p>Ви вже здебільшого знайомі з усіма цими речами, тому далі будуть лише практичні поради.</p>
<h2>6.2 Індекси</h2>
<p>Ні для кого не секрет, що робота з базою даних займає більшу частину роботи практично будь-якого сайту. І саме робота з БД найчастіше є вузьким місцем веб-додатків.</p>
<p>У цій статті хотілося б дати практичні поради щодо використання MySQL.</p>
<p>Відразу зазначу:</p>
<ul>
<li>дана стаття написана про MySQL, хоча загальні речі найімовірніше справедливі для будь-якої СУБД.</li>
<li>все написане у статті є моєю особистою точкою зору, і не є істиною в останній інстанції.</li>
<li>поради не претендують на новизну і є результатом узагальнення прочитаної літератури та особистого досвіду.</li>
<li>у рамках цієї статті я не стосуватимусь питань конфігурування MySQL.</li>
</ul>
<p>Проблеми при використанні MySQL можна розділити на три групи (у порядку значимості):</p>
<ol>
<li>Невикористання або неправильне використання індексів.</li>
<li>Неправильна структура БД.</li>
<li>Неправильні \ неоптимальні SQL запити.</li>
</ol>
<p>Зупинимося на кожній із цих груп докладніше.</p>
<h3>Використання індексів</h3>
<p>Невикористання або неправильне використання індексів – це те, що найчастіше уповільнює запити. Для тих, хто мало знайомий з механізмом роботи індексів або ще не читав про це у мануалі, дуже раджу почитати.</p>
<p><strong>Поради щодо використання індексів:</strong> </p>
<ul>
<li><span class="text-red">Не потрібно індексувати все поспіль</span>. Досить часто, не розуміючи сенсу, люди просто індексують усі поля таблиці. Індекси прискорюють вибірки, але уповільнюють вставки та оновлення рядків, тому вибір кожного індексу має бути осмислений.</li>
<li>Один із основних параметрів, що характеризує індекс - селективність (selectivity) - кількість різних елементів в індексі. Немає сенсу індексувати поле, в якому два-три можливі значення. Користування від такого індексу буде мало.</li>
<li>Вибір індексів має починатися з аналізу всіх запитів до цієї таблиці. Дуже часто після такого аналізу замість трьох-чотирьох індексів можна зробити один складовий.</li>
<li>При використанні складових індексів порядок полів в індексі має визначальне значення.</li>
<li>Не забувайте про індекси, що покривають (covering). Якщо всі дані в запиті можуть бути отримані з індексу, MySQL не буде звертатися безпосередньо до таблиці. Подібні запити виконуватимуться дуже швидко. Наприклад, для запиту <code>SELECT name FROM user WHERE login='test'</code> за наявності індексу (login, name) звернення до таблиці не потрібно. Іноді має сенс додати до складового індексу додаткове поле, яке зробить індекс покриваючим та прискорить запити.</li>
<li>Для індексів рядків часто достатньо індексувати лише частину рядка. Це може значно зменшити розмір індексу.</li>
<li>Якщо <code>%</code> на початку <code>LIKE(SELECT * FROM table WHERE field LIKE '%test')</code> індекси не використовуватимуться.</li>
<li><strong>FULLTEXT</strong> індекс використовується лише з синтаксисом <strong>MATCH</strong> … <strong>AGAINST</strong>.</li>
</ul>
<h2>6.3 Структура БД</h2>
<p>Грамотно спроектована БД — запорука швидкої та ефективної роботи з базою. З іншого боку, погано продумана БД — це головний біль для розробників.</p>
<p><strong>Поради з проектування БД:</strong> </p>
<ol>
<li>Використовуйте мінімально можливі типи даних. Чим більший тип даних, тим більше таблиця, тим більше звернень до дисків потрібно для отримання даних. Використовуйте дуже зручну процедуру: <code>SELECT * FROM table_name PROCEDURE ANALYSE();</code> для визначення мінімально можливих типів даних.</li>
<li>На етапі проектування дотримуйтесь нормальних форм. Часто програмісти вдаються до денормалізацію вже на цьому етапі. Однак у більшості випадків на початку проекту далеко не очевидно, чим це може вилитися. Денормалізувати таблицю набагато простіше, ніж страждати від неоптимально денормалізованої. Та й <code>JOIN</code> часом працює швидше, ніж неправильно денормалізовані таблиці.</li>
<li>Не використовуйте <code>NULL</code> стовпці за винятком випадків, коли вони вам свідомо потрібні.</li>
</ol>
<h2>6.4 SQL запити.</h2>
<p>Так само часто виникає бажання переписати всі запити на native SQL, щоб запит був максимально швидким. Якщо ви зважитеся на таке, то ось вам кілька порад:</p>
<ol>
<li>Уникайте запитів у циклі. SQL - мова множин і до написання запитів потрібно підходити не мовою функцій, а мовою множин.</li>
<li>Уникайте <code>*</code> (зірочки) у запитах. Не полінуйтеся перерахувати ті поля, які ви вибираєте. Це скоротить кількість даних, що вибираються і пересилаються. Крім цього, не забувайте про індекси, що покривають. Навіть якщо ви дійсно вибираєте всі поля у таблиці, краще їх перерахувати. <strong>По-перше</strong>, це підвищує читабельність коду. При використанні зірочок неможливо дізнатися, які поля є в таблиці без заглядання в неї. <strong>По-друге</strong>, сьогодні у вашій таблиці п'ять <strong>INT</strong> стовпців, а через місяць додалося ще одне <strong>TEXT</strong> та <strong>BLOB</strong>, а зірочка як була, так і залишилася.</li>
<li>При посторінковому виборі для отримання загальної кількості записів використовуйте <code>SQL_CALC_FOUND_ROWS</code> та <code>SELECT FOUND_ROWS();</code> При використанні <code>SQL_CALC_FOUND_ROWS MySQL</code> кешує вибрану кількість рядків(до застосування LIMIT) і при <code>SELECT FOUND_ROWS()</code> тільки віддає це закешоване значення без необхідності повторного виконання запиту.</li>
<li>Не забувайте, що <code>INSERT</code> має синтаксис для множинної вставки. Один запит буде виконуватися набагато швидше, ніж безліч запитів у циклі.</li>
<li>Використовуйте <code>LIMIT</code> там, де вам не потрібні всі дані.</li>
<li>Використовуйте <code>INSERT… ON DUPLICATE KEY UPDATE…</code> замість вибірки та <code>INSERT</code> або <code>UPDATE</code> після неї, а також часто замість <code>REPLACE< /code>.</li>
<li>Не забувайте про чудову функцію <code>GROUP_CONCAT</code>. Вона може допомогти за складних запитів.</li>
</ol>
