Object Relational Mapping
<p>----------------------------------------</p>
Мапінг класів на таблиці
Поява Hibernate
Поява JPA
Maven для Hibernate
<p>----------------------------------------</p>
<h2>1. Мапінг класів на таблиці</h2>
<p>Після вивчення JDBC у тебе швидше за все склалася думка, що працювати з базою даних із Java-програми — те ще задоволення. А якщо я скажу, що всю цю роботу можна зробити в 10 разів простіше?</p>
<p>У чому головна перевага мови SQL? Це декларативна мова — вона визначає, що ми хочемо отримати, і зовсім нічого не говорить про те, як це зробити. Як — це вже клопіт SQL-сервера.</p>
<p>Той самий підхід можна використовувати і при роботі з базами даних.</p>
<p>В ідеальному світі ми могли би просто писати SQL-запити до бази, а у відповідь нам приходили б готові Java-об'єкти, ну або колекції Java-об'єктів, якщо ми зробили запит на кілька штук.</p>
<p>Що сказати, саме так подумали кілька хлопців у 2000 році та вирішили написати свій ORM framework.</p>
<img data-max-width="800" data-id="b796a58f-f10c-46d2-af0c-6da048ec2bca" src="https://cdn.javarush.com/images/article/b796a58f-f10c-46d2-af0 -6da048ec2bca/800.jpeg" alt="">
<p><strong>ORM</strong> розшифровується як <strong>Object-Relational Mapping</strong> і по суті є мапінгом Java-об'єктів на SQL-запити.</p>
<p>Хлопці вигадали дуже просту річ — <span class="text-green">кожній таблиці в базі даних повинен відповідати якийсь клас у Java-програмі</span>. У програмі Java ми оперуємо об'єктами, а ці об'єкти вже вміють самі зберігати себе в базі даних.</p>
<p>Було три підходи до вирішення цього завдання, і вони виглядали приблизно так:</p>
<ol>
<li>Об'єкт сам себе зберігає в базі даних та оновлює свої поля на основі інформації з БД.</li>
<li>Об'єкт вміє зберігати себе в базі даних, але ніколи не виступає ініціатором цієї справи.</li>
<li>Об'єкт містить лише дані, і хтось його зберігає в базі даних і завантажує з БД.</li>
</ol>
<p>Спочатку домінував перший підхід: тоді були популярні Application-сервери та Enterprise Java Beans. Був навіть цілий клас бінів, які мали назву Persistence EJB, які вміли себе зберігати в базу самі.</p>
<p>Але одного разу все змінилося...</p>
<h2>2. Поява Hibernate</h2>
<p>У 2001 році випустили першу версію фреймворку Hibernate. Це був простий фреймворк, але він дозволяв використовувати звичайні "дурні об'єкти", які нічого не знали про те, як їх потрібно зберігати до бази або завантажувати звідти.</p>
<img data-max-width="512" data-id="2898bb0c-234c-4863-bd67-43401f7e5757" src="https://cdn.javarush.com/images/article/2898bb0c-234c-6863 -43401f7e5757/512.jpeg" alt="">
<p>Мапінг полів Java-класів і колонок у таблиці в базі встановлювався за допомогою XML-файлу. І іноді вони були досить громіздкими. Гаразд, кого я обманюю. Це були величезні полотна XML-коду. І ситуацію рятувало лише те, що 20 років тому не було таких гігантських баз даних, як зараз.</p>
<p>Але насправді найсильнішим рішенням було <strong>нарешті відокремити об'єкт, який потрібно зберігати в базу, від коду, який його туди зберігав</strong>. Це рішення насправді неочевидне. Тому що принцип інкапсуляції стверджує, що об'єкт найкраще знає про те, як його потрібно зберігати та завантажувати.</p>
<img data-max-width="800" data-id="62e2da06-e135-48f9-bea6-1c57f934870b" src="https://cdn.javarush.com/images/article/62e2da06-e135-48f9- -1c57f934870b/800.jpeg" alt="">
<p>І підхід ORM справді ламає цю концепцію. Data-клас виставляє назовні своє внутрішнє влаштування, проте оперувати групами об'єктів різних типів стало значно простіше.</p>
<p><span class="text-green">Серйозний прорив стався після виходу Java 5</span>, коли в JDK з'явилися дві речі:</p>
<ul>
<li><strong>Анотації</strong></li>
<li><strong>Proxy</strong></li>
</ul>
<p><mark class="green">Анотації</mark> швидко витіснили XML, і тепер прямо в Java-класі можна було легко вказати всі потрібні налаштування для мапінгу Java-класу на таблицю в базі даних.</p>
<p><mark class="green">Проксі</mark> не такі помітні для користувача Hibernate, але їх внесок був ще серйознішим. Коли ти робиш запит на певний об'єкт або об'єкти у Hibernate, він просто повертає тобі заглушку (proxy) і перехоплює всі звернення до її методів.</p>
<p>Це дозволило реалізувати різні механізми Lazy Loading-у та підняло швидкість та ефективність роботи Hibernate на зовсім захмарний рівень для того часу. Hibernate став не просто стандартом галузі де-факто — його почали перекладати на інші мови. Так, наприклад, для C# з'явився Framework NHibernate.</p>
<h2>3. Поява JPA</h2>
<p>За де-факто прийшло й визнання де-юре. Розробники JDK вирішили створити специфікацію щодо того, як правильно мапити об'єкти на таблиці в базі даних. Ця специфікація називається <mark class="orange">JPA</mark> — Java Persistence API.</p>
<p>Це саме специфікація. Вона описує, як усе має працювати і якими анотаціями потрібно відзначати різні частини класу, якщо ми хочемо, щоб його об'єкти зберігалися до бази даних.</p>
<p>Таке відчуття, що хлопці просто взяли за основу Hibernate та поміняли у нього імена пакетів. Тому що всі анотації, які були в Hibernate, майже в тому ж вигляді переїхали до JPA.</p>
<img data-max-width="512" data-id="4c4522ec-1832-4222-8570-f2ce8b948a5f" src="https://cdn.javarush.com/images/article/4c4522ec-1832-4222 -f2ce8b948a5f/512.jpeg" alt="">
<p>Нині Hibernate повністю реалізує всю специфікацію JPA, а також має деякі додаткові можливості, які роблять роботу з ним ще комфортнішою. Тому з точки зору стандартизації можна сказати, що Hibernate має два набори функцій:</p>
<ul>
<li><strong>JPA-стандарт</strong></li>
<li><strong>Hibernate Native API</strong> (додаткова функціональність)</li>
</ul>
<p>В офіційній документації Hibernate це описується так:</p>
<img data-max-width="512" data-id="b41f7eb8-4a43-44d0-9f24-d8c423051a0c" src="https://cdn.javarush.com/images/article/b41f7eb8-4a43-44d -d8c423051a0c/512.jpeg" alt="">
<p>Але і на основі свого досвіду, і після повторного прочитання документації з Hibernate я можу сказати, що JPA та Hibernate API збігаються на 95%. Це просто тотожні поняття.</p>
<h2>4. Maven для Hibernate</h2>
<p>Якщо я вже так сильно розхвалив Hibernate, думаю, настав час перейти до роботи з ним трохи щільніше.</p>
<p>По-перше, є офіційний сайт, де просто купа англомовної документації. Вона, звісно, має ухил у довідкову інформацію, а не в навчальну. Але все одно краще так, ніж дебажити вихідники, чи не так? :)</p>
<p>Інструкція:</p>
<ol>
<li>Відкриваєш <a href="https://hibernate.org/orm/" target="_blank">посилання</a>.</li>
<li>Довго на нього дивишся.</li>
<li>Повертаєшся на JavaRush.</li>
<li>Читаєш подальші лекції.</li>
</ol>
<p>Моя робота полягає в тому, щоб спрощувати складні речі і пояснювати їх простими словами. І якщо твоє навчання дійшло до цього рівня, значить у мене це виходить.</p>
<p>Ну, а щоб приступити до роботи з Hibernate, тобі потрібно додати його до свого pom.xml. На сьогоднішній день доступна вже 6-та версія Hibernate, а точніше 6.1.1, тож будемо вчитися працювати з останньою версією.</p>
<p>Просто додай до свого pom.xml такі рядки:</p>
<pre class='line-numbers'><code>
&lt;dependency&gt;
&lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;
&lt;version&gt;6.1.1.Final&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>Якщо ти читаєш цю лекцію і за вікном 2023+ рік, тоді нову версію можна <a href="https://mvnrepository.com/artifact/org.hibernate/hibernate-core" target="_blank">завантажити тут</a>.</p>
<p><strong>Важливо!</strong> Деякі бібліотеки, які використовує Hibernate, були виключені з JDK 11 та JDK 17, тому якщо у тебе виникають проблеми із запуском проєкту, додай до нього такі залежності:</p>
<pre class='line-numbers'><code>
  &lt;dependency&gt;
        &lt;groupId&gt;jakarta.xml.bind&lt;/groupId&gt;
        &lt;artifactId&gt;jakarta.xml.bind-api&lt;/artifactId&gt;
      &lt;version&gt;4.0.0&lt;/version&gt;
  &lt;/dependency&gt;
 
  &lt;dependency&gt;
        &lt;groupId&gt;org.glassfish.jaxb&lt;/groupId&gt;
        &lt;artifactId&gt;jaxb-runtime&lt;/artifactId&gt;
      &lt;version&gt;4.0.0&lt;/version&gt;
  &lt;/dependency&gt;
 
  &lt;dependency&gt;
        &lt;groupId&gt;org.javassist&lt;/groupId&gt;
        &lt;artifactId&gt;javassist&lt;/artifactId&gt;
        &lt;version&gt;3.29.0-GA&lt;/version&gt;
  &lt;/dependency&gt;

</code></pre>

