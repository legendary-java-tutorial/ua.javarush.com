  Денормалізація таблиць у БД
  <p>----------------------------------------</p>
  Навіщо потрібна денормалізація?
  Коли потрібна денормалізація?
  Плюси та мінуси денормалізації
  Як грамотно реалізувати денормалізацію
  <p>--------------------------------------- -</p>
  <h2>1. Навіщо потрібна денормалізація?</h2>
  <p>Найдорожча з погляду обчислювальних ресурсів операція між великими таблицями — з'єднання. Отже, якщо в одному запиті необхідно «провентилювати» кілька таблиць, що складаються з багатьох мільйонів рядків, то СУБД витратить досить багато часу на таку обробку.</p>
  <p>Користувач у цей час може відійти випити кави. Інтерактивність обробки практично зникає і наближається до обробки пакетної. Навіть гірше, у пакетному режимі користувач зранку отримує всі дані, на які зробив запит напередодні, та спокійно працює з ними, готуючи нові запити до вечора. Щоб уникнути ситуації важких з'єднань, таблиці денормалізують. Але не аби як. Існують деякі правила, що дозволяють вважати денормалізовані з точки зору транзакційної обробки таблиці «нормалізованими» згідно з правилами побудови таблиць для сховищ даних». Назви добре відображають суть і випливають безпосередньо з картинки зв'язаних таблиць.</p>
  <p>В обох випадках центральним елементом схеми є так звані таблиці фактів, що містять події, транзакції, документи та інші речі, що цікавлять аналітика. Але якщо в транзакційній БД один документ «розмазаний» по кількох таблицях (як мінімум по двох: заголовки та рядки-зміст), то в таблиці фактів одному документу, а точніше, кожному його рядку або набору згрупованих рядків, відповідає один запис. </p>
  <p>Зробити це можна за допомогою денормалізації двох вищезгаданих таблиць.</p>
  <img data-max-width="1024" data-id="07bd1f49-716c-4226-8326-886e52968e41" src="https: //cdn.javarush.com/images/article/07bd1f49-716c-4226-8326-886e52968e41/1024.jpeg" alt="">
  <h2>2. Приклад денормалізації</h2>
  <p>Тепер можна оцінити, наскільки полегшиться для виконання СУБД запит, скажімо, такого вигляду: визначити обсяги продажу борошна клієнтам «ТОВ Тістечка» та «ЗАТ Ватрушки» за період.</p>
  <p>У нормалізованій транзакційній БД:</p>
  <pre class='line-numbers'><code>
SELECT
   SUM(dl.qty) AS total qty, SUM(dl.price) AS total amount, c.name
FROM
   docs d
   INNER JOIN doc lines dl ON d.id doc = dl.id doc
   INNER JOIN customers c ON d.id customer = c.id customer
   INNER JOIN products p ON dl.id product = p.id product
WHERE
   c.name IN (’ТОВ Пиріжки’,	’ЗАТ Ватрушки’) AND
   р.name = ’Борошно’ AND
   d.date BETWEEN ’2014-01-01’ AND ’2014-02-01’
GROUP BY c.name
</code></pre>
  <p>В аналітичній БД:</p>
  <pre class='line-numbers'><code>
SELECT
   SUM(s.qty) AS total_qty, SUM(s.amount) AS total_amount, c.name
FROM
   sales s
   INNER JOIN customers c ON d.id_customer = c.id_customer
   INNER JOIN products p ON dl.id_product = p.id_product
WHERE
   c.name IN ('ТОВ Пиріжки', 'ЗАТ Ватрушки') AND
   p.name = 'Борошно' AND
   s.date BETWEEN '2014-01-01' AND '2014-02-01'
GROUP BY c.name
</code></pre>
  <p>Замість важкого з'єднання між двома таблицями документів та їх складу з мільйонами рядків, СУБД дістається пряма робота з таблицею фактів та легкі з'єднання з невеликими допоміжними таблицями, без яких також можна обійтися, якщо знати ідентифікатори.</p>
  <pre class='line-numbers'><code>
SELECT
   SUM(s.qty) AS total_qty, SUM(s.amount) AS total_amount, s.id_customer
FROM
   sales s
WHERE
   s.id_customer IN (1025, 20897) AND
   s.id_product = 67294 AND
   s.date BETWEEN '2014-01-01' AND '2014-02-01'
GROUP BY s.id_customer
</code></pre>
  <p>Повернемося до схемам «зірка» та «сніжинка». За кадром першого малюнка залишилися таблиці клієнтів, їх груп, магазинів, продавців та, власне, товарів. У разі денормалізації ці таблиці, які називаються вимірами, також з'єднуються з таблицею фактів. Якщо таблиця фактів посилається на таблиці-виміри, які мають посилання на інші виміри (виміри другого рівня та вище), то така схема називається «сніжинка».</p>
  <img data-max-width="1024" data-id=" e81a6085-ffdc-4b0c-9645-cdd17b1c1691" src="https://cdn.javarush.com/images/article/e81a6085-ffdc-4b0c-9645-cdd17b1c1691/10"
  <p>Як можна помітити, для запитів, що включають фільтрацію за групами клієнтів, доводиться робити додаткове з'єднання.</p>
  <pre class='line-numbers'><code>
SELECT sum(amount)
FROM sales s
   INNER JOIN customers c ON s.id_customer = c.id_customer
WHERE c.id_customer_group IN (1, 2, 10, 55)
</code></pre>
  <p>У такому разі денормалізацію можна продовжити та опустити вимірювання другого рівня на перший, полегшивши запити до таблиці фактів.</p>
  <p>Схема, в якій таблиця фактів посилається тільки на вимірювання, що не мають другого рівня, називається «зірка». Число таблиць вимірювань відповідає числу «променів» у зірці.</p>
  <p>Схема «Зірка» повністю виключає ієрархію вимірювань та необхідність з'єднання відповідних таблиць в одному запиті.</p>
  <pre class='line-numbers'><code>
SELECT sum(amount)
FROM sales s
WHERE s.id_customer_group IN (1, 2, 10, 55)
</code></pre>
  <img data-max-width="1024" data-id="2abb3172- bf4e-41d9-b687-66c668783596" src="https://cdn.javarush.com/images/article/2abb3172-bf4e-41d9-b687-66c668783596/1024.jpeong>"
  <p><strong>Зворотною стороною денормалізації</strong> завжди є <strong>надмірність</strong>, що є причиною збільшення розміру БД як у випадку транзакційних, так і аналітичних додатків. Давай порахуємо зразкову дельту на наведеному вище прикладі перетворення «сніжинки» на «зірку».</p>
  <p>У деяких СУБД, наприклад Oracle, спеціальні цілочисельні типи на рівні визначень схеми БД відсутні, необхідно використовувати універсальний логічний тип <code>numeric (N)</code>, де N — число розрядів, що зберігаються. Розмір зберігання такого числа розраховується за спеціальною формулою, що наводиться у документації з фізичного зберігання даних, і, як правило, він перевищує такий для низькорівневих типів на кшталт «16 бітне ціле» на 1-3 байти. </p>
  <p>Припустимо, таблиця продажів не використовує компресію даних і містить близько 500 мільйонів рядків, а кількість груп покупців близько 1000. У цьому випадку ми можемо використовувати як тип ідентифікатора <code>id_customer_group</code> коротке ціле (shortint, smallint), що займає 2 байти.</p>
  <p>Вважатимемо, що наша СУБД підтримує двобайтовий цілочисельний тип (наприклад, PostgreSQL, SQL Server, Sybase та інші). Тоді додавання відповідної колонки <code>id_customer_group</code> до таблиці продажів викличе збільшення її розміру як мінімум на <code>500 000 000 * 2 = 1 000 000 000 байт ~ 1 гігабайт</code>.</p>
  <h2>3. Коли потрібна денормалізація?</h2>
  <p>Розглянемо деякі поширені ситуації, в яких денормалізація може бути корисною.</p>
  <p><strong>Велика кількість з'єднань таблиць</strong> </p>
  <p> У запитах до повністю нормалізованої базі нерідко доводиться поєднувати до десятка, або навіть більше, таблиць. А кожне з'єднання — операція дуже ресурсомістка. Як наслідок, такі запити є ресурси сервера і виконуються повільно.</p>
  <p>У такій ситуації може допомогти:</p>
  <ul>
      <li>Денормалізація шляхом скорочення кількості таблиць. Краще об'єднувати в одну кілька таблиць, що мають невеликий розмір, що містять рідко змінювану (як часто кажуть, умовно-постійну, або нормативно-довідкову) інформацію, причому інформацію, за змістом тісно пов'язану між собою.</li>
      <li>У загальному випадку, якщо у великій кількості запитів потрібно об'єднувати понад п'ять або шість таблиць, слід розглянути варіант денормалізації бази даних.</li>
      <li>Денормалізація шляхом введення додаткового поля в одну з таблиць. При цьому з'являється надмірність даних, потрібні додаткові дії для збереження цілісності БД.</li>
  </ul>
  <p><strong>Розрахункові значення</strong> </p>
  <p>Як правило повільно виконуються та вимагають багато ресурсів запити, у яких виконуються якісь складні обчислення, особливо у разі використання угруповань і агрегатних функцій (Sum, Max тощо.). Іноді має сенс додати до таблиці 1-2 додаткові стовпці, які містять розрахункові дані, що часто використовуються (і складно обчислюються).</p>
  <p>Припустимо, що необхідно визначити загальну вартість кожного замовлення. Для цього спочатку слід визначити вартість кожного продукту (за формулою «кількість одиниць продукту» * «Ціна одиниці продукту» – знижка). Після цього необхідно згрупувати ціни на замовлення.</p>
  <p>Виконання цього запиту є досить складним, і якщо в базі даних зберігаються відомості про велику кількість замовлень, воно може тривати багато часу. Замість виконання такого запиту можна на етапі розміщення замовлення визначити його вартість та зберегти її в окремому стовпці таблиці замовлень. У цьому випадку для отримання необхідного результату достатньо витягти з цього стовпця попередньо розраховані значення.</p>
  <p>Створення стовпця, який містить значення, що заздалегідь розраховуються, дозволяє значно заощадити час під час виконання запиту, проте вимагає своєчасної зміни даних у цьому стовпці.</p>
  <p><strong>Довгі поля</strong></p>
  <p>Якщо у нас в базі даних є великі таблиці, що містять довгі поля (Blob, Long і т.п.), то серйозно прискорити виконання запитів до такої таблиці ми зможемо, якщо винесемо довгі поля окрему таблицю. Скажімо, створити в базі каталог фотографій, у тому числі зберігати в blob-полях і самі фотографії (професійної якості, з високою роздільною здатністю та відповідного розміру). З точки зору нормалізації абсолютно правильною буде така структура таблиці: </p>
  <ul>
      <li>ID фотографії</li>
      <li>ID автора</li>
      <li>ID моделі фотоапарата</li>
      <li>сама фотографія (blob-поле)</li>
  </ul>
  <p>А зараз уявімо, скільки часу буде працювати запит, який підраховує кількість фотографій, зроблених яким-небудь автором…</p>
  <p>Правильним рішенням (хоч і порушуючим принципи нормалізації) у такій ситуації буде створити ще одну таблицю, що складається лише з двох полів — ID фотографії та blob-поле з самою фотографією. Тоді вибірки з основної таблиці (у якій величезного blob-поля зараз уже немає) будуть йти моментально, а коли захочемо подивитися саму фотографію — що ж, почекаємо… </p>
  <p>Як визначити, коли денормалізація виправдана?</p>
  <h2>4.Плюси та мінуси денормалізації</h2>
  <p>Один із способів визначити, наскільки виправдані ті чи інші кроки, — провести аналіз у термінах витрат та можливих вигод. Скільки коштуватиме денормалізована модель даних?</p>
  <p>Визначити вимоги (чого хочемо досягти) → визначити вимоги до даних (що потрібно дотримуватися) → знайти мінімальний крок, який задовольняє ці вимоги → підрахувати витрати на реалізацію → реалізувати.</p>
  <p>Витрати включають фізичні аспекти, такі як дисковий простір, ресурси, необхідні для управління цією структурою, і втрачені можливості через тимчасові затримки, пов'язані з обслуговуванням цього процесу. За денормалізацію треба платити. У денормалізованій базі даних підвищується надлишковість даних, що може підвищити продуктивність, але вимагатиме більше зусиль для контролю за пов'язаними даними. Ускладниться процес створення програм, оскільки дані повторюватимуться, і їх важче відстежувати. До того ж, здійснення цілісності посилань стає непростою справою — пов'язані дані виявляються розділеними за різними таблицями. Крім того, можна отримати й інші переваги, у тому числі збільшення пропускної спроможності, рівня задоволеності клієнтів та продуктивності, а також ефективніше використання інструментарію зовнішніх розробників.</p>
  <p><strong>Частота запитів та стійкість продуктивності</strong> </p>
  <p>Наприклад, 72% із тисячі запитів, які щодня генеруються підприємством, є запитами рівня зведених, а не детальних даних. У разі використання таблиці зведених даних запити виконуються приблизно 6 секунд замість 4 хвилин, тобто час обробки менше на 3000 хвилин. Навіть із поправкою на ті 100 хвилин, які потрібно щотижня витрачати на підтримку таблиць зведених даних, в результаті економиться 2500 хвилин на тиждень, що повністю виправдовує створення таблиці зведених даних. Згодом може статися так, що більшість запитів буде звернено не до зведених даних, а до детальних даних. Чим менша кількість запитів, що використовують таблицю зведених даних, тим простіше від неї відмовитися без впливу на інші процеси.</p>
  <p><strong>А також…</strong> </p>
  <p>Перераховані вище критерії — не єдині, що слід враховувати у прийнятті рішення про те, чи слід робити наступний крок в оптимізації. Необхідно враховувати й інші чинники, зокрема пріоритети бізнесу та потреби кінцевих користувачів. Користувачі повинні розуміти, як з технічного погляду на архітектуру системи впливає вимога користувачів, які бажають, щоб усі запити виконувалися за кілька секунд. Найпростіше досягти цього розуміння можна, якщо окреслити витрати, пов'язані зі створенням таких таблиць та їх управлінням.</p>
  <h2>5. Як грамотно реалізувати денормалізацію.</h2>
  <p><strong>Зберегти детальні таблиці</strong> </p>
  <p>Щоб не обмежувати можливості бази даних, важливих для бізнесу, необхідно дотримуватися стратегії співіснування, а не заміни, тобто зберегти детальні таблиці для глибинного аналізу, додавши до них денормалізовані структури. Наприклад, лічильник відвідувань. Для бізнесу потрібно знати кількість відвідувань вебсторінки. Але для аналізу (за періодами, країнами…) нам дуже ймовірно знадобляться детальні дані — таблиця з інформацією про кожне відвідування.</p>
  <p><strong>Використання тригерів</strong> </p>
  <p>Можна денормалізувати структуру бази даних і при цьому продовжувати користуватися перевагами нормалізації, якщо користуватися тригерами баз даних для збереження <code>цілісності</code> (integrity) інформації, ідентичності даних, що дублюються.</p>
  <p>Наприклад, в разі додавання обчислюваного поля до кожного зі стовпців, від яких обчислюване поле залежить, вішається тригер, що викликає єдину процедуру, що зберігається (це важливо!), яка і записує потрібні дані в обчислюване поле. Треба лише не пропустити жоден зі стовпців, від яких залежить обчислюване поле.</p>
  <p><strong>Програмна підтримка</strong> </p>
  <p>Якщо не використовувати вбудовані тригери і процедури, що зберігаються, то піклуватися про забезпечення несуперечності даних у денормалізованій базі повинні розробники застосунків.</p>
  <p>За аналогією з тригерами має бути одна функція, що оновлює всі поля, що залежать від поля, яке змінюється.</p>
  <p><strong>Висновки</strong></p>
  <p>При деноралізації важливо зберегти баланс між підвищенням швидкості роботи бази та збільшенням ризику появи суперечливих даних, між полегшенням життя програмістам, які пишуть <code>Select'и</code>, та ускладненням завдання тих, хто забезпечує наповнення бази та оновлення даних. Тому проводити денормалізацію бази треба дуже акуратно, дуже вибірково, тільки там, де без цього ніяк не обійтися. для оптимізації проблемних запитів проводити денормалізацію.</p>
  <p>Денормалізацію важливо впроваджувати поступово і тільки для тих випадків, коли є повторні вибірки пов'язаних даних з різних таблиць. Пам'ятай, що у разі дублювання даних виросте кількість записів, але зменшиться кількість читань. Розраховані дані також зручно зберігати в колонках, щоб уникнути непотрібних агрегатних вибірок.</p>