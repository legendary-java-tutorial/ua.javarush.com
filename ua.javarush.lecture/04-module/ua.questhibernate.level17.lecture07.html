  Денормалізація таблиць у БД <p>----------------------------------------</p> > Навіщо потрібна денормалізація? Коли потрібна денормалізація? Плюси та мінуси денормалізації Як грамотно реалізувати денормалізацію <p>--------------------------------------- -</p> <h2>8.1 Навіщо потрібна денормалізація?</h2> <p>Найдорожча з погляду обчислювальних ресурсів операція між великими таблицями — з'єднання. Відповідно, якщо в одному запиті необхідно «провентилювати» кілька таблиць, що складаються з багатьох мільйонів рядків, то СУБД витратить досить багато часу на таку обробку. </p> <p>Користувач у цей час може відійти випити кави. Інтерактивність обробки практично зникає і наближається до такої обробки пакетної. Навіть гірше, у пакетному режимі користувач з ранку отримує всі запитані напередодні дані та спокійно працює з ними, готуючи нові запити до вечора. Щоб уникнути ситуації важких з'єднань таблиці денормалізують. Але не аби як. Існують деякі правила, що дозволяють вважати денормалізовані з точки зору транзакційної обробки таблиці «нормалізованими» згідно з правилами побудови таблиць для сховищ даних. ». Назви добре відображають суть і випливають безпосередньо з картинки зв'язаних таблиць.</p> <p>В обох випадках центральним елементом схеми є так звані таблиці фактів, що містять події, транзакції, документи та інші цікаві речі, що цікавлять аналітика. Але якщо в транзакційній БД один документ «розмазаний» по кількох таблицях (як мінімум по двох: заголовки та рядки-зміст), то в таблиці фактів одному документу, точніше, кожному його рядку або набору згрупованих рядків, відповідає один запис. </p> <p>Зробити це можна денормалізацією двох вищезгаданих таблиць.</p> <img data-max-width="1024" data-id="07bd1f49-716c-4226-8326-886e52968e41" src="https: //cdn.javarush.com/images/article/07bd1f49-716c-4226-8326-886e52968e41/1024.jpeg" alt=""> <h2>8.2 Приклад денормалізації</h2> <p>Тепер можна оцінити, для виконання СУБД запит, наприклад, наступного виду: визначити обсяги продажу борошна клієнтам «ТОВ Тістечка» та «ЗАТ Ватрушки» за період.</p> <p>У нормалізованій транзакційній БД:</p> <pre class='line- numbers'><code> SELECT SUM(dl.qty) AS total qty, SUM(dl.price) AS total amount, c.name FROM docs d INNER JOIN doc lines dl ON d.id doc = dl.id doc INNER JOIN customers c ON d.id customer = c.id customer INNER JOIN products p ON dl.id product = p.id product WHERE c.name IN ('ТОВ Тістечка', 'ЗАТ Ватрушки') AND р.name = 'Борошно' AND d.date BETWEEN '2014-01-01' AND '2014-02-01' GROUP BY c.name </code></pre> <p>В аналітичній БД:</p> <pre class='line -numbers'><code> SELECT SUM(s.qty) AS total_qty, SUM(s.amount) AS total_amount, c.name FROM sales s INNER JOIN customers c ON d.id_customer = c.id_customer INNER JOIN products p ON dl .id_product = p.id_product WHERE c.name IN ('ТОВ Тістечка', 'ЗАТ Ватрушки') AND p.name = 'Борошно' AND s.date BETWEEN '2014-01-01' AND '2014-02-01' GROUP BY c.name </code></pre> <p>Замість важкого з'єднання між двома таблицями документів та їх складу з мільйонами рядків, СУБД дістається пряма робота з таблицею фактів та легкі з'єднання з невеликими допоміжними таблицями, без яких також можна обійтися , знаючи ідентифікатори.</p> <pre class='line-numbers'><code> SELECT SUM(s.qty) AS total_qty, SUM(s.amount) AS total_amount, s.id_customer FROM sales s WHERE s.id_customer IN (1025, 20897) AND s.id_product = 67294 AND s.date BETWEEN '2014-01-01' AND '2014-02-01' GROUP BY s.id_customer </code></pre> <p>Повернемося до схемам «зірка» та «сніжинка». За кадром першого малюнка залишилися таблиці клієнтів, їх груп, магазинів, продавців та, власне, товарів. При денормалізації ці таблиці, які називаються вимірами, також з'єднуються з таблицею фактів. Якщо таблиця фактів посилається на таблиці-виміри, які мають посилання на інші виміри (виміри другого рівня та вище), то така схема називається «сніжинка».</p> <img data-max-width="1024" data-id=" e81a6085-ffdc-4b0c-9645-cdd17b1c1691" src="https://cdn.javarush.com/images/article/e81a6085-ffdc-4b0c-9645-cdd17b1c1691/10" можна помітити, для запитів, що включають фільтрацію по групах клієнтів, доводиться робити додаткове з'єднання.</p> <pre class='line-numbers'><code> = c.id_customer WHERE c.id_customer_group IN (1, 2, 10, 55) </code></pre> <p>У такому разі денормалізацію можна продовжити та опустити вимірювання другого рівня на перший, полегшивши запити до таблиці фактів.< /p> Схема, в якій таблиця фактів посилається тільки на вимірювання, що не мають другого рівня, називається «зірка». Число таблиць вимірювань відповідає числу «променів» у зірці.</p> <p>Схема «Зірка» повністю виключає ієрархію вимірювань та необхідність з'єднання відповідних таблиць в одному запиті.</p> <pre class='line-numbers'><< code> SELECT sum(amount) FROM sales s WHERE s.id_customer_group IN (1, 2, 10, 55) </code></pre> <img data-max-width="1024" data-id="2abb3172- bf4e-41d9-b687-66c668783596" src="https://cdn.javarush.com/images/article/2abb3172-bf4e-41d9-b687-66c668783596/1024.jpeong>" Зворотною стороною денормалізації</strong> завжди є <strong>надмірність</strong>, що є причиною збільшення розміру БД як у випадку транзакційних, так і аналітичних додатків. Давайте порахуємо зразкову дельту на наведеному вище прикладі перетворення «сніжинки» на «зірку».</p> <p>У деяких СУБД, наприклад Oracle, спеціальні цілочисельні типи на рівні визначень схеми БД відсутні, необхідно використовувати універсальний логічний тип <code>numeric (N)</code>, де N - число розрядів, що зберігаються. Розмір зберігання такого числа розраховується за спеціальною формулою, що наводиться у документації з фізичного зберігання даних, і, як правило, він перевищує такий для низькорівневих типів на кшталт «16 бітне ціле» на 1-3 байти. </p> <p>Припустимо, таблиця продажів не використовує компресію даних і містить близько 500 мільйонів рядків, а кількість груп покупців близько 1000. У цьому випадку ми можемо використовувати як тип ідентифікатора <code>id_customer_group</code> коротке ціле ( shortint, smallint), що займає 2 байти.</p> <p>Вважатимемо, що наша СУБД підтримує двобайтовий цілочисельний тип (наприклад, PostgreSQL, SQL Server, Sybase та інші). Тоді додавання відповідної колонки <code>id_customer_group</code> до таблиці продажів викличе збільшення її розміру як мінімум на <code>500 000 000 * 2 = 1 000 000 000 байт ~ 1 гігабайт</code>.</p> <h2 >8.3 Коли потрібна денормалізація?</h2> <p>Розглянемо деякі поширені ситуації, в яких денормалізація може бути корисною.</p> <p><strong>Велика кількість з'єднань таблиць</strong> </p> <p> У запитах до повністю нормалізованої базі нерідко доводиться поєднувати до десятка, або навіть більше, таблиць. А кожне з'єднання — операція дуже ресурсомістка. Як наслідок, такі запити є ресурси сервера і виконуються повільно.</p> <p>У такій ситуації може допомогти:</p> <ul> <li>денормалізація шляхом скорочення кількості таблиць. Краще об'єднувати в одну кілька таблиць, що мають невеликий розмір, що містять рідко змінювану (як часто кажуть, умовно-постійну, або нормативно-довідкову) інформацію, причому інформацію, за змістом тісно пов'язану між собою.</li> <li>У загальному випадку , якщо у великій кількості запитів потрібно об'єднувати понад п'ять або шість таблиць, слід розглянути варіант денормалізації бази даних.</li> <li>Денормалізація шляхом введення додаткового поля в одну з таблиць. При цьому з'являється надмірність даних, потрібні додаткові дії для збереження цілісності БД. у яких виробляються якісь складні обчислення, особливо у використанні угруповань і агрегатних функцій (Sum, Max тощо.). Іноді має сенс додати до таблиці 1-2 додаткові стовпці, які містять розрахункові дані, що часто використовуються (і складно обчислюються).</p> <p>Припустимо, що необхідно визначити загальну вартість кожного замовлення. Для цього спочатку слід визначити вартість кожного продукту (за формулою «кількість одиниць продукту» * «Ціна одиниці продукту» – знижка). Після цього необхідно згрупувати ціни на замовлення.</p> <p>Виконання цього запиту є досить складним і, якщо в базі даних зберігаються відомості про велику кількість замовлень, може тривати багато часу. Замість виконання такого запиту можна на етапі розміщення замовлення визначити його вартість та зберегти її в окремому стовпці таблиці замовлень. У цьому випадку для отримання необхідного результату достатньо витягти з цього стовпця попередньо розраховані значення.</p> <p>Створення стовпця, що містить значення, що попередньо розраховуються, дозволяє значно заощадити час при виконанні запиту, проте вимагає своєчасної зміни даних у цьому стовпці.</p> <p> p> <p><strong>Довгі поля</strong> </p> <p>Якщо у нас в базі даних є великі таблиці, що містять довгі поля (Blob, Long і т.п.), то серйозно прискорити виконання запитів до такої таблиці ми зможемо, якщо винесемо довгі поля окрему таблицю. Хочемо ми, скажімо, створити в базі каталог фотографій, у тому числі зберігати в blob-полях і самі фотографії (професійної якості, з високою роздільною здатністю та відповідного розміру). З точки зору нормалізації абсолютно правильною буде така структура таблиці: </p> <ul><li>ID фотографії</li> <li>ID автора</li> <li>ID моделі фотоапарата</li> <li>сама фотографія (blob-поле)</li> </ul> <p>А зараз уявімо, скільки часу буде працювати запит, який підраховує кількість фотографій, зроблених яким-небудь автором…</p> <p>Правильним рішенням (хоч і порушуючим) принципи нормалізації) у такій ситуації буде створити ще одну таблицю, що складається всього з двох полів - ID фотографії та blob-поле з самою фотографією. Тоді вибірки з основної таблиці (у якій величезного blob-поля зараз уже немає) будуть йти моментально, а коли захочемо подивитися саму фотографію — що ж, почекаємо… Як визначити, коли денормалізація виправдана?</p> > <h2>8.4 Плюси та мінуси денормалізації</h2> <p>Один із способів визначити, наскільки виправдані ті чи інші кроки, — провести аналіз у термінах витрат та можливих вигод. Скільки коштуватиме денормалізована модель даних?</p> <p>Визначити вимоги (чого хочемо досягти) → визначити вимоги до даних (що потрібно дотримуватися) → знайти мінімальний крок, який задовольняє ці вимоги → підрахувати витрати на реалізацію → реалізувати.</p> > <p>Витрати включають фізичні аспекти, такі як дисковий простір, ресурси, необхідні для управління цією структурою, і втрачені можливості через тимчасові затримки, пов'язані з обслуговуванням цього процесу. За денормалізацію треба платити. У денормалізованій базі даних підвищується надмірність даних, що може підвищити продуктивність, але вимагатиме більше зусиль для контролю за пов'язаними даними. Ускладниться процес створення програм, оскільки дані повторюватимуться і їх важче відстежуватиме. Крім того, здійснення цілісності посилань виявляється не простою справою — пов'язані дані виявляються розділеними за різними таблицями. Крім того, можна отримати й інші переваги, у тому числі збільшення пропускної спроможності, рівня задоволеності клієнтів та продуктивності, а також ефективніше використання інструментарію зовнішніх розробників.</p> <p><strong>Частота запитів та стійкість продуктивності</strong> </p> <p>Наприклад, 72% із тисячі запитів, які щодня генеруються підприємством, є запитами рівня зведених, а не детальних даних. При використанні таблиці зведених даних запити виконуються приблизно 6 секунд замість 4 хвилин, т. е. час обробки менше 3000 хвилин. Навіть із поправкою на ті 100 хвилин, які потрібно щотижня витрачати на підтримку таблиць зведених даних, в результаті економиться 2500 хвилин на тиждень, що повністю виправдовує створення таблиці зведених даних. Згодом може статися так, що більшість запитів буде звернено не до зведених даних, а до детальних даних. Чим менше кількість запитів, що використовують таблицю зведених даних, тим простіше від неї відмовитися, не торкаючись інших процесів. єдині, які слід враховувати, приймаючи рішення про те, чи слід робити наступний крок оптимізації. Необхідно враховувати й інші чинники, зокрема пріоритети бізнесу та потреби кінцевих користувачів. Користувачі повинні розуміти, як з технічного погляду на архітектуру системи впливає вимога користувачів, які бажають, щоб усі запити виконувалися за кілька секунд. Найпростіше досягти цього розуміння — окреслити витрати, пов'язані зі створенням таких таблиць та їх управлінням.</p> <h2>8.5 Як грамотно реалізувати денормалізацію.</h2> <p><strong>Зберегти детальні таблиці</strong> </ Щоб не обмежувати можливості бази даних, важливих для бізнесу, необхідно дотримуватися стратегії співіснування, а не заміни, тобто зберегти детальні таблиці для глибинного аналізу, додавши до них денормалізовані структури. Наприклад, лічильник відвідин. Для бізнесу потрібно знати кількість відвідувань веб-сторінки. Але для аналізу (за періодами, країнами…) нам дуже ймовірно знадобляться детальні дані – таблиця з інформацією про кожне відвідування.</p> <p><strong>Використання тригерів</strong> </p> <p>Можна денормалізувати структуру бази даних і при цьому продовжувати користуватися перевагами нормалізації, якщо користуватися тригерами баз даних для збереження <code>цілісності</code> (integrity) інформації, ідентичності даних, що дублюються.</p> <p>Приміром, при додаванні обчислюваного поля на кожен зі стовпців, від яких обчислюване поле залежить, вішається тригер, що викликає єдину процедуру, що зберігається (це важливо!), яка і записує потрібні дані в обчислюване поле. Треба тільки не пропустити жоден зі стовпців, від яких залежить обчислюване поле.</p> <p><strong>Програмна підтримка</strong> </p> <p>Якщо не використовувати вбудовані тригери і процедури, що зберігаються, то піклуватися про забезпечення несуперечності даних у денормалізованій базі повинні розробники додатків.</p> <p>За аналогією з тригерами має бути одна функція, що оновлює всі поля, що залежать від поля, що змінюється.</p> <p><strong>Висновки</strong> </p> <p>При деноралізації важливо зберегти баланс між підвищенням швидкості роботи бази та збільшенням ризику появи суперечливих даних, між полегшенням життя програмістам, які пишуть <code>Select'и</code>, та ускладненням завдання тих, хто забезпечує наповнення бази та оновлення даних. Тому проводити денормалізацію бази треба дуже акуратно, дуже вибірково, тільки там, де без цього ніяк не обійтися. для оптимізації проблемних запитів проводити денормалізацію.</p> <p>Денормалізацію важливо впроваджувати поступово і тільки для тих випадків, коли є повторні вибірки пов'язаних даних з різних таблиць. Пам'ятайте, що при дублюванні даних виросте кількість записів, але зменшиться кількість читань. Розраховані дані також зручно зберігати в колонках, щоб уникнути непотрібних агрегатних вибірок.