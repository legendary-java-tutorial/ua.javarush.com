Проєкт на тему: Hibernate (2)
<p>----------------------------------------</p>
Проєкт на тему: Hibernate (2)
<p>----------------------------------------</p>
<h3>Сьогодні наше завдання — виконати другий проєкт на тему Hibernate. Його суть — розібратися в структурі БД, зробити мапінг ентіті на існуючі таблиці та додати мінімальний функціонал для перевірки того, чи мапінг виконаний правильно.</h3>
<p><strong>Тепер докладніше: </strong></p>
<ol>
<li> <a href="https://javarush.com/downloads/ide/javarush/dump-hibernate-2.sql" target="_blank">Завантаж дамп-файл</a> та розгорни його у себе на локальній машині. За БД ми будемо використовувати тестову БД, яка поширюється як приклад разом із інсталяційним пакетом MySQL. Дамп необхідний для того, щоб зафіксувати стан БД, оскільки ми не можемо гарантувати, що вона не зміниться через день-місяць-рік. </li>
<li>Темпліту проєкту ми не матимемо, тому проєкт створи самостійно. Це повинен бути maven проєкт з усіма необхідними залежностями (<strong>hibernate-core-jakarta</strong>, <strong>mysql-connector-java</strong>, <strong>p6spy</strong>). </li>
<li>Підключи в IDEA нашу локальну розгорнуту БД як datasource. Після цього у вкладці Database постав курсор на схему movie і натисни комбінацію клавіш <code>Alt+Ctrl+Shift+U</code> (працює лише в Ultimate версії). Це покаже структуру всієї схеми movie (з назвою колонок, ключами тощо). Виглядає це приблизно так:
<img data-max-width="1024" data-id="2b71a9bb-4d0b-4693-81fb-b1119978a0e3" src="https://cdn.javarush.com/images/article/2b71a9bb-4d0b-469 -b1119978a0e3/1024.jpeg" alt="">
<p>Згоден, дивитися не дуже зручно. Вимкни показ назви всіх колонок та коментарів: </p>
<img data-max-width="512" data-id="24c31d79-1015-41a8-90d4-5c4e0a3513c3" src="https://cdn.javarush.com/images/article/24c31d79-1015-41a -5c4e0a3513c3/512.jpeg" alt="">
<p>У результаті отримаєш схему БД, яку вже можна аналізувати:</p>
<img data-max-width="1024" data-id="85a773a5-42a9-4cb9-b885-f05e859df442" src="https://cdn.javarush.com/images/article/85a773a5-42a984 -f05e859df442/1024.jpeg" alt="">
</li>
<li>Схема виглядає складно, але не так погано. Для аналізу структури БД необхідно визначити з чого почати. Одної правильної відповіді немає, але рекомендуємо почати з таблиці <code>film</code>. Давай розглянемо кілька взаємозв'язків як приклад:
<ul>
<li>Зв'язок між таблицями <code>film</code> та <code>film_text</code> — це явний зв'язок <strong>OneToOne</strong>, тому що в таблиці <code>film_text</code> є поле <code>film_id</code>, яке <mark class="red">НЕ</mark> посилається на <strong>ID</strong> з таблиці <code>film</code> (немає foreign key). Але з огляду на назву та логіку, цей зв'язок має бути. До того ж, у таблиці <code>film_text</code> поле <code>film_id</code> виступає первинним ключем, що гарантує, що одному «фільму» відповідає лише один «текст фільму». </li>
<li>Тепер давай подивимося на таблиці <code>film</code> та <code>category</code>. З погляду логіки, фільм може мати кілька категорій. І одна категорія може бути в різних фільмів. Крім цього, між двома таблицями є проміжна таблиця зв'язку <code>film_category</code>. Виходячи з усього, що перераховано вище, це явний зв'язок <strong>ManyToMany</strong>. </li>
<li>Дивимося на таблиці <code>film</code> та <code>language</code>. З точки зору логіки, у фільму може бути переклад різними мовами і різні фільми можуть бути однією мовою. Тобто напрошується <strong>ManyToMany</strong>. Але якщо подивитися на вміст <code>film</code>, ми можемо помітити, що кожен рядок таблиці — це унікальний фільм. І в рядку є тільки одне поле <strong>language_id</strong> (є ще original_language_id, але у всіх записах воно null, тому можемо не звертати на нього увагу). Тобто в одного фільму може бути лише одна мова. І одна мова може бути в різних фільмів. Зв'язок — <strong>ManyToOne</strong> (зв'язок, спрямований від film до language). </li>
</ul>
</li>
<li>Тепер основне завдання — створити всі необхідні ентіті класи та замапити їх на таблиці схеми <code>movie</code>. </li>
<li>Додати метод, який вміє створювати нового покупця (таблиця customer) з усіма залежними полями. Не забудь зробити так, щоб спосіб був транзакційним (щоб не потрапити в ситуацію, що адресу покупця записали до БД, а самого покупця — ні). </li>
<li>Додати транзакційний метод, який описує подію «покупець пішов і повернув раніше орендований фільм». Покупця та подію оренди обери будь-які на власний розсуд. Рейтинг фільму не треба перераховувати. </li>
<li>Додати транзакційний метод, який описує подію «покупець сходив до магазину (store) та орендував (rental) там інвентар (inventory). При цьому він здійснив оплату (payment) у продавця (staff)». Фільм (через інвентар) обери на власний розсуд. Єдине обмеження — фільм має бути доступним для оренди. Тобто або у rental не повинно бути взагалі записів про інвентар, або має бути заповнена колонка <strong>return_date</strong> таблиці <code>rental</code> для останньої оренди цього інвентарю. </li>
<li>Додати транзакційний метод, який описує подію «зняли новий фільм, і він став доступним для оренди». Фільм, мову, акторів, категорії тощо обери на власний розсуд. </li>
<li>Структуру таблиць міняти не можна. Але внести свої пропозиції щодо покращення — потрібно. Одне проблемне місце ми виявили в п.4 (відсутність <strong>foreign key</strong> у таблиці <code>film_text</code> на полі <code>film_id</code> таблиці <code>film</code>). Подивися, чи є ще у структурі БД такі «ляпи». Якщо так — додай readme файл у корінь проекту та опиши ці ляпи. </li>
</ol>

<hr>
<p>Розбір проєкту:</p>
<ul>
<li><a href="https://youtu.be/QIdL2bZI4jY" target="_blank">Частина 1</a></li>
<li><a href="https://youtu.be/vKxB8S43otI" target="_blank">Частина 2</a></li>
<li><a href="https://youtu.be/QvfmO82iV98" target="_blank">Частина 3</a></li>
</ul>