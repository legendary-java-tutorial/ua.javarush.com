Проект на тему: Hibernate (2)
<p>----------------------------------------</p>
Проект на тему: Hibernate (2)
<p>----------------------------------------</p>
<h3>Сьогодні наше завдання – виконати другий проект на тему Hibernate. Його суть – розібратися у структурі БД, зробити мапінг ентіті на існуючі таблиці, та додати мінімальний функціонал для перевірки, що мапінг виконаний правильно.</h3>
<p><strong>Тепер докладніше: </strong></p>
<ol>
<li> <a href="https://javarush.com/downloads/ide/javarush/dump-hibernate-2.sql" target="_blank">Скачати дамп-файл</a> і розгорнути його у себе на локальної машини. Як БД ми будемо використовувати тестову БД, яка поширюється як приклад разом із інсталяційним пакетом MySQL. Дамп необхідний у тому, щоб зафіксувати стан БД, тому що ми можемо гарантувати, що вона зміниться через день-месяц-год. </li>
<li>Темпліту проекту ми не матимемо, тому проект створювай самостійно. Це повинен бути проект проекту з усіма необхідними залежностями (<strong>hibernate-core-jakarta</strong>, <strong>mysql-connector-java</strong>, <strong>p6spy</strong>). </li>
<li>Підключи в Ідеї нашу локальну розгорнуту БД як datasource. Після цього у вкладці Database постав курсор на схему movie і натисніть комбінацію клавіш <code>Alt+Ctrl+Shift+U</code> (працює лише в Ultimate версії). Це покаже структуру всієї схеми movie (з назвою колонок, ключами тощо). Виглядає приблизно так:
<img data-max-width="1024" data-id="2b71a9bb-4d0b-4693-81fb-b1119978a0e3" src="https://cdn.javarush.com/images/article/2b71a9bb-4d0b-469 -b1119978a0e3/1024.jpeg" alt="">
<p>Згоден, дивитися не дуже зручно. Відключи показ назви всіх колонок та коментарів: </p>
<img data-max-width="512" data-id="24c31d79-1015-41a8-90d4-5c4e0a3513c3" src="https://cdn.javarush.com/images/article/24c31d79-1015-41a -5c4e0a3513c3/512.jpeg" alt="">
<p>У результаті отримаєш схему БД, яку вже можна аналізувати:</p>
<img data-max-width="1024" data-id="85a773a5-42a9-4cb9-b885-f05e859df442" src="https://cdn.javarush.com/images/article/85a773a5-42a984 -f05e859df442/1024.jpeg" alt="">
</li>
<li>Схема виглядає складно, але не так погано. Для аналізу структури БД необхідно визначити з чого почати. Єдиної правильної відповіді немає, але я рекомендував би почати з таблиці <code>film</code>. Давай розглянемо кілька взаємозв'язків як приклад:
<ul>
<li>Зв'язок між таблицями <code>film</code> та <code>film_text</code> – це явний зв'язок <strong>OneToOne</strong>, тому що в таблиці <code>film_text</code> є поле <code>film_id</code>, яке <mark class="red">НЕ</mark> посилається на <strong>ID</strong> з таблиці <code>film</code> (немає foreign key). Але за назвою та логікою, цей зв'язок має бути. Крім того, у таблиці <code>film_text</code> поле <code>film_id</code> виступає первинним ключем, що гарантує, що одному «фільму» відповідає лише один «текст фільму». </li>
<li>Тепер давай подивимося на таблиці <code>film</code> та <code>category</code>. З погляду логіки, фільм може мати кілька категорій. І одна категорія, можливо, у різних фільмів. Крім цього, між двома таблицями є проміжна таблиця зв'язку <code>film_category</code>. Виходячи з усього перерахованого вище, це явний зв'язок <strong>ManyToMany</strong>. </li>
<li>Дивимося на таблиці <code>film</code> та <code>language</code>. З точки зору логіки, у фільму, можливо, переклад різними мовами і різні фільми можуть бути однією мовою. Тобто напрошується <strong>ManyToMany</strong>. Але якщо подивитися на вміст <code>film</code>, ми можемо помітити, що кожен рядок таблиці - це унікальний фільм. І в рядку є тільки одне поле <strong>language_id</strong> (Є ще original_language_id, але у всіх записах воно null, тому можемо знехтувати ним). Тобто в одного фільму може бути лише одна мова. І одна мова, можливо, у різних фільмів. Зв'язок – <strong>ManyToOne</strong> (зв'язок спрямований від film до language). </li>
</ul>
</li>
<li>Тепер основне завдання – потрібно створити всі необхідні ентіті класи та замапити їх на таблиці схеми <code>movie</code>. </li>
<li>Додати метод, який вміє створювати нового покупця (таблиця customer) із усіма залежними полями. Не забудь зробити щоб спосіб був транзакційним (щоб не потрапити в ситуацію, що адресу покупця записали в БД, а самого покупця – ні). </li>
<li>Додати транзакційний метод, який описує подію «покупець пішов і повернув раніше орендований фільм». Покупця та подію оренди вибери будь-яке на власний розсуд. Рейтинг фільму не треба перераховувати. </li>
<li>Додати транзакційний метод, який описує подію «покупець сходив до магазину (store) і орендував (rental) там інвентар (inventory). При цьому він здійснив оплату (payment) у продавця (staff)». Фільм (через інвентар) вибери на власний розсуд. Єдине обмеження – фільм має бути доступним для оренди. Тобто або у rental не повинно бути взагалі записів по інвентарю, або має бути заповнена колонка <strong>return_date</strong> таблиці <code>rental</code> для останньої оренди цього інвентарю. </li>
<li>Додати транзакційний метод, який описує подію «зняли новий фільм, і він став доступним для оренди». Фільм, мову, акторів, категорії тощо вибери на власний розсуд. </li>
<li>Структуру таблиць міняти не можна. Але внести свої пропозиції щодо покращення – потрібно. Одне проблемне місце ми виявили в п.4 (відсутність <strong>foreign key</strong> у таблиці <code>film_text</code> на полі <code>film_id</code> таблиці <code>film</code>) . Подивися, чи є ще у структурі БД такі «ляпи». Якщо так – додай readme файл у корінь проекту та опиши ці ляпи. </li>
</ol>

<hr>
<p>Розбір проекту:</p>
<ul>
<li><a href="https://youtu.be/QIdL2bZI4jY" target="_blank">Частина 1</a></li>
<li><a href="https://youtu.be/vKxB8S43otI" target="_blank">Частина 2</a></li>
<li><a href="https://youtu.be/QvfmO82iV98" target="_blank">Частина 3</a></li>
</ul>