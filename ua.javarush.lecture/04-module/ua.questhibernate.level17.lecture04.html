   Ключі бази даних <p>----------------------------------------</p> > Primary key Foreign key Custom Key <p>---------------------------------------- </p> <h2>5.1 Вступ</h2> <p>В Інтернеті повно догматичних заповідей про те, як потрібно вибирати та використовувати ключі в реляційних базах даних. Іноді суперечки навіть переходять у холівари: і використовувати природні чи штучні ключі? Автоінкрементні цілі чи UUID?</strong> </p> <p>Прочитавши шістдесят чотири статті, перегорнувши розділи п'яти книг і поставивши купу питань у IRC і StackOverflow, я (автор оригінальної статті Joe «begriffs» Nelson), як мені здається, зібрав шматки паззла воєдино і тепер зможу примирити супротивників. Багато суперечок щодо ключів виникають насправді через неправильне розуміння чужої точки зору.</p> <p>Давайте розділимо проблему на частини, а в кінці зберемо її знову. Для початку поставимо запитання – що ж таке «ключ»? Забудемо на хвилину про первинні ключі, нас цікавить спільніша ідея. Ключ - це колонка (column) або колонки, що не мають у рядках дублюючих значень</span>. Крім того, колонки повинні бути непривідно унікальними, тобто ніяке підмножина колонок не має такої унікальності. Але для початку трохи теорії: Первісний ключ </strong> <p><mark class="green">Primary key</mark> безпосередньо застосовується для ідентифікації рядків у таблиці. Він повинен відповідати наступним обмеженням:</p> <ul> <li>Первинний ключ повинен бути <strong>унікальним</strong> весь час.</li> <li>Він повинен <strong>постійно бути присутнім</strong> в таблиці і мати значення.</li> <li>Він не повинен часто змінювати своє значення. В ідеалі він взагалі <strong>не повинен змінювати значення</strong>.</li> </ul> <p>Як правило, первинний ключ представляє один стовпець таблиці, але також може бути складним і складатися з кількох стовпців. p> <p><strong>Складений ключ</strong></p> <p><mark class="green">Custom Key</mark> - комбінація атрибутів (стовпців), які унікально ідентифікують кожен рядок таблиці. Це можуть бути всі стовпці, і кілька, і один. При цьому рядки, які містять значення цих атрибутів, не повинні повторюватися.</p> <p><strong>Потенційний ключ</strong></p> <p><mark class="green">Candidate key</mark > - мінімальний складовий ключ відношення (таблиці), тобто набір атрибутів, який задовольняє ряду умов:</p> <ul> <li><strong>Непривідність</strong>: він не може бути скорочений, він містить мінімально можливий набір атрибутів.</li> <li><strong>Унікальність</strong>: він повинен мати унікальні значення незалежно від зміни рядка.</li> <li><strong>Наявність значення</strong>: він не має повинен мати значення NULL, тобто він обов'язково повинен мати значення. 5.2 Цікавий випадок первинних ключів Те, що в попередньому розділі ми назвали просто «ключами», зазвичай називається "потенційними ключами" (candidate keys). Термін «candidate» передбачає, що всі такі ключі конкурують за почесну роль «первинного ключа» (primary key), а ті, що залишилися, призначаються «альтернативними ключами» (alternate keys).</p> <p>Потрібен якийсь час, щоб В реалізаціях SQL зникла невідповідність ключів і реляційної моделі, ранні бази даних були заточені під низькорівневу концепцію первинного ключа. Первинні ключі в таких базах були потрібні для ідентифікації фізичного розташування рядка на носіях з послідовним доступом до даних. Ось як це пояснює Джо Селко: Термін "ключ" означав ключ сортування файлу, який був потрібен для виконання будь-яких операцій обробки в послідовній файловій системі. Набір перфокарт зчитувався в одному і лише в одному порядку; неможливо було "повернутись назад". Перші накопичувачі на магнітних стрічках імітували таку ж поведінку та не дозволяли виконувати двонаправлений доступ. Тобто, початковий Sybase SQL Server для читання попереднього рядка вимагав «перемотування» таблиці на початок.</span></p> <p>У сучасному SQL не потрібно орієнтуватися на фізичне подання інформації, таблиці моделюють зв'язки та внутрішній порядок рядків взагалі важливий. Однак, і зараз SQL-сервер за замовчуванням створює кластерний індекс для первинних ключів і, за старою традицією, фізично вибудовує порядок рядків.</p> <p>У більшості баз даних первинні ключі збереглися як пережиток минулого, і навряд чи забезпечують що- те, крім відображення чи визначення фізичного розташування. Наприклад, у таблиці PostgreSQL оголошення первинного ключа автоматично накладає обмеження <code>NOT NULL</code> та визначає зовнішній ключ за умовчанням. До того ж, первинні ключі є кращими стовпцями для оператора <code>JOIN</code>.</p> <p>Перший ключ не скасовує можливості оголошення та інших ключів. У той же час, якщо жоден ключ не призначений первинним, то таблиця все одно нормально працюватиме. Блискавка, принаймні, у вас не вдарить.</p> <h2>5.3 Знаходження природних ключів</h2> <p>Розглянуті вище ключі називаються «природними», тому що вони є властивостями об'єкта, що моделюється, цікавими самі по собі, навіть якщо ніхто не прагне зробити з них ключ.</p> <img data-max-width="800" data-id="eadd7f32-0792-44f1-9ab2-483666f8f44c" src="https://cdn.javarush. <p>Перше, що варто пам'ятати при дослідженні таблиці на предмет можливих природних ключів - потрібно намагатися не перемудрити. Користувач sqlvogel на StackExchange дає таку пораду: У деяких людей виникають складнощі з вибором «природного» ключа через те, що вони вигадують гіпотетичні ситуації, в яких певний ключ може бути унікальним. Вони не розуміють самого сенсу завдання. Сенс ключа в тому, щоб визначити правило, за яким атрибути у будь-який момент часу мають бути і завжди будуть унікальними у конкретній таблиці. Таблиця містить дані у конкретному і добре розуміється контексті (в «предметній області» або в «області дискурсу») і єдине значення має застосування обмеження у цій конкретній галузі. </span></p> <p>Практика показує, що потрібно вводити обмеження по ключу, коли колонка унікальна за наявних значень і залишатиметься такою за можливих сценаріїв. А при необхідності обмеження можна усунути (якщо це вас турбує, то нижче ми розповімо про стабільність ключа.)</p> <p>Наприклад, база даних членів хобі-клубу може мати унікальність у двох колонках — <code>first_name</code >, <code>last_name</code>. При невеликому обсязі даних дублікати малоймовірні, і до виникнення реального конфлікту використовувати такий ключ цілком розумно. З ростом бази даних і збільшенням обсягу інформації, вибір природного ключа може стати складнішим. Дані, що зберігаються, є спрощенням зовнішньої реальності, і не містять у собі деякі аспекти, якими розрізняються об'єкти у світі, такі як їх змінюються з часом координати. Якщо у об'єкта відсутній будь-який код, то як розрізнити дві банки з напоєм або дві коробки з вівсянкою, окрім як за їх розташуванням у просторі чи невеликими відмінностями у вазі чи упаковці?</p> <p>Саме тому органи стандартизації створюють і наносять на продукцію розрізнювальні мітки. На автомобілях штампується <strong>Vehicle Identification Number (VIN)</strong>, у книгах друкується <strong>ISBN</strong>, на упаковці харчових товарів є <strong>UPC</strong>. Ви можете заперечити, що ці цифри не здаються природними. То чому ж я називаю їх природними ключами?</p> <p>Природність чи штучність унікальних властивостей у базі даних відносна до зовнішнього світу. Ключ, який при своєму створенні в органі стандартизації чи державній установі був штучним, стає для нас природним, тому що в цілому світі він стає стандартом та/або друкується на об'єктах.</p> <p>Існує безліч галузевих, громадських та міжнародних стандартів для різних об'єктів, у тому числі для валют, мов, фінансових інструментів, хімічних речовин та медичних діагнозів. Ось деякі з значень, які часто використовуються як природні ключі: </p> <ul> <li>Коди країн ISO 3166</li> <li>Коди мов ISO 639</li> <li>Коди валют по ISO 4217</li> <li>Біржові позначення ISIN</li> <li>UPC/EAN, VIN, GTIN, ISBN</li> <li>імена логінів</li> <li>адреси електронної пошти</li > <li>номера кімнат</li> <li>mac-адреса в мережі</li> <li>широта, довгота для точок на поверхні Землі</li> </ul> <p>Рекомендую оголошувати ключі, коли це можливо і розумно, можливо, навіть кілька ключів на таблицю. Але пам'ятайте, що всі перераховані вище можуть бути винятки.</p> <ul> <li>Не всі мають адресу електронної пошти, хоча в деяких умовах використання бази даних може бути прийнятним. Крім того, люди іноді змінюють свої електронні адреси. (Докладніше про стабільність ключів пізніше.)</li> <li>Біржові позначення ISIN час від часу змінюються, наприклад, символи GOOG та GOOGL не точно описують реорганізацію компанії з Google до Alphabet. Іноді може виникнути плутанина, як, наприклад, з TWTR і TWTRQ, деякі інвестори помилково купували останні під час IPO Twitter. Крім того, після крадіжки документів люди можуть одержати нові номери. Нарешті, той самий номер може ідентифікувати і особу, і ідентифікатор податку на прибуток.</li> <li>Поштові індекси — поганий вибір для міст. У деяких містах загальний індекс, або навпаки, в одному місті буває кілька індексів. знаходяться унікальні значення, одним із способів його створення є шахрайство – у кожний рядок можна записати вигадані унікальні значення. Це і є штучні ключі: придуманий код, що використовується для посилання на дані або об'єкти.</p> https://cdn.javarush.com/images/article/e0feb953-16ae-4313-ba14-37c9f8fb7eba/800.jpeg" alt=""> <p>Дуже важливо те, що код генерується з самої бази даних і невідомий нікому крім користувачів бази даних. Саме це відрізняє штучні ключі від стандартизованих природних ключів.</p> <p>Перевага природних ключів полягає у захисті від дублювання або суперечливості рядків таблиці, штучні ключі корисні тому, що вони дозволяють людям або іншим системам простіше посилатися на рядок, а також підвищують швидкість операцій пошуку та об'єднання, тому що не використовують порівняння рядкових (або багатостовпцевих) ключів.</p> <h3>Сурогати</h3> <p><span class="text-green">Штучні ключі використовуються як прив'язка – незалежно від зміни правил і стовпчиків, один рядок завжди можна ідентифікувати однаковим способом. Штучний ключ, який використовується для цієї мети, називається «сурогатним ключем» і вимагає особливої уваги. Сурогати ми розглянемо нижче.</span></p> <p>Сурогатами, що не є, штучні ключі зручні для посилань на рядок зовні бази даних. Штучний ключ коротко ідентифікує дані або об'єкт: він може бути вказаний як URL-адреса, прикріплена до рахунку, продиктована по телефону, отримана в банку або надрукована на номерному знаку. (Номірний знак автомобіля для нас є природним ключем, але розроблений державою як штучний ключ.)</p> <p>Штучні ключі потрібно вибирати, враховуючи можливі способи їх передачі, щоб мінімізувати помилки та помилки. Треба врахувати, що ключі можуть вимовляти, читати надрукованим, відправляти по SMS, читати написаним від руки, вводити з клавіатури та вбудовувати в URL. Додатково деякі штучні ключі, наприклад номери кредитних карток, містять контрольну суму, щоб при виникненні певних помилок їх можна було хоча б розпізнати.</p> <p>Приклади:</p> <ul> <li>Для номерних знаків США існують правила про використання неоднозначних ознак, наприклад O та 0.</li> <li>Лікарні та аптеки повинні бути особливо акуратними, враховуючи почерк лікарів.</li> <li>Передаєте есемесський код підтвердження? Не виходьте за межі набору символів GSM 03.38.</li> <li>На відміну від Base64, що кодує довільні байтові дані, Base32 використовує обмежений набір символів, який зручно використовувати людям та обробляти на старих комп'ютерних системах.</li> <li> Proquints – це ідентифікатори, що читаються, записуються та вимовляються. Це вимовляються (PRO-nouncable) п'ятірки (QUINT-uplets) однозначно зрозумілих приголосних і голосних букв.</li> </ul> <p>Майте на увазі, що як тільки ви познайомите світ зі своїм штучним ключем, люди дивним чином почнуть надавати йому особливу увагу. Достатньо подивитися на «блатні» номерні знаки або на систему створення ідентифікаторів, що вимовляються, яка перетворилася на сумнозвісний автоматизований генератор лайок.</p> <p>Навіть, якщо обмежитися числовими ключами, є табу типу тринадцятого поверху. Незважаючи на те, що proquints мають більшу щільність інформації на склад, що вимовляється, числа теж непогані в багатьох випадках: в URL, пін-клавіатурах і написаних від руки записах, якщо одержувач знає, що ключ складається тільки з цифр.</p> <p >Однак, зверніть увагу, що не варто використовувати послідовний порядок у публічно відкритих числових ключах, оскільки це дозволяє копатися в ресурсах (/videos/1.mpeg, /videos/2.mpeg, і так далі), а також створює витік інформації про кількість даних. Накладіть на послідовність чисел мережу Фейстеля та збережіть унікальність, приховавши при цьому порядок чисел.</p> <p>Єдиним аргументом проти оголошення додаткових ключів є те, що кожен новий несе за собою ще один унікальний індекс та збільшує витрати на запис до таблиці. Звичайно, залежить від того, наскільки вам важлива коректність даних, але, швидше за все, ключі все ж таки варто оголошувати.</p> <p>Також варто оголошувати кілька штучних ключів, якщо вони є. Наприклад, організація має кандидатів на роботу (Applicants) і співробітників (Employees). Кожен співробітник колись був кандидатом, і належить до кандидатів за власним ідентифікатором, який також повинен бути і ключем співробітника. Ще один приклад, можна задати ідентифікатор співробітника та ім'я логіна як два ключі в Employees. Він не повинен бути коротким і переданим, як інші штучні ключі, а використовується як внутрішня мітка, яка завжди ідентифікує рядок. Він використовується в SQL, але додаток не звертається до нього явним чином.</p> <img data-max-width="800" data-id="43b5ec60-2937-43f2-9431-b18c81e9a442" /cdn.javarush.com/images/article/43b5ec60-2937-43f2-9431-b18c81e9a442/800.jpeg" alt=""> <p>Якщо вам знайомі системні колонки (system columns) з PostgreSQL, то ви можете сприймати майже як параметр реалізації бази даних (на кшталт ctid), який, проте, будь-коли змінюється. Значення сурогату вибирається один раз для кожного рядка і потім ніколи не змінюється.</p> <p>Сурогатні ключі відмінно підходять як зовнішні ключі, при цьому необхідно вказати каскадні обмеження <code>ON UPDATE RESTRICT</code>, щоб відповідати незмінності сурогату.</p> <p>З іншого боку, зовнішні ключі до публічно переданих ключів повинні бути позначені <code>ON UPDATE CASCADE</code>, щоб забезпечити максимальну гнучкість. Каскадне оновлення виконується на тому ж рівні ізоляції, що й навколишня транзакція, тому не турбуйтеся про проблеми з паралельним доступом – база даних впорається, якщо вибрати суворий рівень ізоляції.</p> <p>Не робіть сурогатні ключі «природними». Як тільки ви покажете значення сурогатного ключа кінцевим користувачам, або, що гірше, дозволите їм працювати з цим значенням (зокрема через пошук), то фактично надасте ключу значимість. Потім показаний ключ із вашої бази даних може стати природним ключем у чиїйсь чужій БД.</p> <p>Примус зовнішніх систем до використання інших штучних ключів, спеціально призначених для передачі, дозволяє нам при необхідності змінювати ці ключі відповідно до змінних потребами, водночас підтримуючи внутрішню цілісність посилань за допомогою сурогатів.</p> <h3>Автоінкрементні INT/BIGINT</h3> <p>Найчастіше для сурогатних ключів використовують автоінкрементну колонку <strong>«bigserial»</strong> , також відомий як <strong>IDENTITY</strong>. (Насправді, PostgreSQL 10 тепер, як і Oracle, підтримує конструкцію IDENTITY, див. CREATE TABLE.)</p> <p>Однак, я вважаю, що автоінкрементне ціле поганий вибір для сурогатних ключів. Така думка непопулярна, тому дозвольте мені порозумітися.</p> <p>Недоліки послідовних ключів:</p> <ul> <li>Якщо всі послідовності починаються з 1 і поступово збільшуються, то рядки з різних таблиць мають однакові значення ключів. . Такий варіант неідеальний, краще все ж таки використовувати непересічні безлічі ключів у таблицях, щоб, наприклад, запити не змогли б випадково переплутати константи в <code>JOIN</code> і повернути несподівані результати. (Як варіант для забезпечення відсутності перетинів, можна скласти кожну послідовність з чисел, кратних різним простим, але це буде досить трудомістко.)</li> <li>Виклик <code>nextval() </code>для генерації послідовності в сучасних розподілених SQL призводить до того, що вся система гірше масштабується.</li> <li>Поглинання даних з бази даних, в якій також використовувалися послідовні ключі, призведе до конфліктів, тому що послідовні значення не будуть унікальними в різних системах.</li> > <li>З філософської погляду послідовне збільшення чисел пов'язані з старими системами, у яких мав на увазі порядок рядків. Якщо ж ви тепер хочете впорядкувати рядки, то робіть це явно, за допомогою колонки міток часу або чогось, що має сенс у ваших даних. В іншому випадку порушується перша нормальна форма.</li> <li>Слабка причина, але ці короткі ідентифікатори так і тягне повідомити когось.</li> </ul> <h3>UUID</h3> <p>Давайте розглянемо інший варіант: використання великих цілих чисел (128-бітних), що генеруються відповідно до випадкового шаблону. Алгоритми генерації таких універсальних унікальних ідентифікаторів (universally unique identifier, UUID) мають надзвичайно малу можливість вибору одного значення двічі, навіть при одночасному виконанні на двох різних процесорах.</p> <p>У такому випадку <strong>UUID</strong> здаються природним вибором для використання як сурогатних ключів, чи не так? Якщо ви хочете помітити рядки унікальним чином, то ніщо не зрівняється з унікальною міткою! Так чому ж всі не користуються ними в PostgreSQL? На це є кілька надуманих причин і одна логічна, яку можна обійти, і я представлю бенчмарки, щоб проілюструвати свою думку.</p> <p>Для початку розповім про надумані причини. Деякі люди думають, що UUID це рядки, тому що вони записуються в традиційному шістнадцятковому вигляді з дефісом: <code>5bd68e64-ff52-4f54-ace4-3cd9161c8b7f</code>. Дійсно, деякі бази даних не мають компактного (128-бітного) типу uuid, але в PostgreSQL він є і має розмір двох bigint, тобто, в порівнянні з обсягом іншої інформації в базі даних, витрати незначні.</p> <p>Ще UUID незаслужено звинувачується у громіздкості, але хто їх вимовлятиме, друкуватиме або читатиме? Ми говорили, що це має сенс для штучних ключів, що показуються, але ніхто (за визначенням) не повинен побачити сурогатний UUID. Можливо, з UUID буде мати справу розробник, який запускає команди SQL у psql для налагодження системи, але на цьому все. А розробник може посилатися на рядки і за допомогою більш зручних ключів, якщо вони задані. Реальна проблема з UUID у тому, що сильно рандомізовані значення призводять до збільшення обсягу запису. (write amplification) із-за записів повних сторінок у журнал із випереджаючим записом (write-ahead log, WAL)</span>. Однак, насправді, зниження продуктивності залежить від алгоритму генерації UUID. </p> <p>Давайте виміряємо <strong>write amplification</strong>. Правду кажучи, проблема в старих файлових системах. Коли PostgreSQL виконує запис на диск, вона змінює сторінку на диску. При відключенні живлення комп'ютера більшість файлових систем повідомить про успішний запис ще до того, як дані безпечно збереглися на диску. Якщо PostgreSQL наївно сприйме таку дію завершеною, то при подальшому завантаженні системи база даних буде пошкоджена. сторінки в журнал із попереджувальним записом (write-ahead log), який можна використовувати для відновлення після можливого збою. Індексування сильно рандомізованих значень на зразок UUID зазвичай зачіпає купу різних сторінок диска і призводить до запису повного розміру сторінки (зазвичай 4 або 8 КБ) WAL для кожного нового запису. Це так званий повносторінковий запис (full-page write, FPW).</p> <p>Деякі алгоритми генерації UUID (такі, як «snowflake» від Twitter або uuid_generate_v1() у розширенні uuid-ossp для PostgreSQL) створюють на кожній машині значення, що монотонно збільшуються. Такий підхід консолідує записи в меншу кількість сторінок диска і знижує FPW. по застосуванню їх у ваших базах даних.</p> <p>Для кожної таблиці:</p> <ul> <li>Визначте та оголосіть усі природні ключі.</li> <li>Створіть сурогатний ключ <code>&lt ;table_name&gt;_id</code> типу <strong>UUID</strong> зі значенням за промовчанням у <code>uuid_generate_v1()</code>. Можете навіть помітити його як первинний ключ. Якщо додати до цього ідентифікатора назву таблиці, це спростить <code>JOIN</code>, тобто. отримайте <code>JOIN foo USING (bar_id)</code> замість <code>JOIN foo ON (foo.bar_id = bar.id)</code>. Не передавайте цей ключ клієнтам і взагалі не виводьте за межі бази даних.</li> <li>Для проміжних таблиць, через які відбувається <code>JOIN</code>, оголошуйте всі колонки зовнішніх ключів як єдиний складовий первинний ключ.</li> <li> li> <li>При необхідності додайте штучний ключ, який можна використовувати в URL або інших вказівках посилання на рядок. Використовуйте <strong>сітку Фейстеля</strong> або <strong>pg_hashids</strong>, щоб замаскувати автоінкрементні цілі.</li> <li>Вказуйте каскадне обмеження <code>ON UPDATE RESTRICT</code>, використовуючи сурогатні UUID в як зовнішніх ключів, а для зовнішніх штучних ключів – <code>ON UPDATE CASCADE</code>. Вибирайте природні ключі, виходячи з власної логіки.</li> </ul> <p>Такий підхід забезпечує стабільність внутрішніх ключів, одночасно допускаючи і навіть захищаючи природні ключі. До того ж, видимі штучні ключі не стають до чогось прив'язаними. Правильно у всьому розібравшись, можна не зациклюватися лише на «первинних ключах» і користуватися всіма можливостями застосування ключів.</p>