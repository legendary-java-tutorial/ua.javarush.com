Ключі бази даних
<p>----------------------------------------</p>
Primary key
Foreign key
Custom Key
<p>---------------------------------------- </p>
<h2>1. Вступ</h2>
<p>В Інтернеті повно догматичних заповідей про те, як потрібно вибирати та використовувати ключі в реляційних базах даних. Іноді суперечки навіть переходять у
    холівари: <strong>використовувати природні чи штучні ключі? Автоінкрементні цілі чи UUID?</strong> </p>
<p>Прочитавши шістдесят чотири статті, перегорнувши розділи п'яти книг і поставивши купу питань у IRC і StackOverflow, я (автор
    оригінальної статті Joe «begriffs» Nelson), як мені здається, зібрав шматки паззла разом і тепер зможу примирити
    супротивників. Багато суперечок щодо ключів виникають насправді через неправильне розуміння чужої точки зору.</p>
<p>Давай розділимо проблему на частини, а в кінці зберемо її знову. Для початку поставимо запитання: що ж таке
    «ключ»? Забудемо на хвилину про первинні ключі, нас цікавить спільніша ідея. Ключ — це колонка (column) або колонки,
    що не мають у рядках дублюючих значень</span>. Крім того, колонки повинні бути незвідно унікальними, тобто ніяке
    підмножина колонок не має такої унікальності. Але для початку трохи теорії:
<p><strong>Первісний ключ </strong></p>
<p><mark class="green">Primary key</mark> безпосередньо застосовується для ідентифікації рядків у таблиці. Він повинен відповідати наступним обмеженням:</p>
<ul>
    <li>Первинний ключ повинен бути <strong>унікальним</strong> весь час.</li>
    <li>Він повинен <strong>постійно бути присутнім</strong> в таблиці і мати значення.</li>
    <li>Він не повинен часто змінювати своє значення. В ідеалі він взагалі <strong>не повинен змінювати значення</strong>.</li>
</ul>
<p>Як правило, первинний ключ являє собою один стовпець таблиці, але також може бути складним і складатися з
    кількох стовпців.</p>
<p><strong>Складений ключ</strong></p>
<p><mark class="green">Custom Key</mark> — комбінація атрибутів (стовпців), які унікально ідентифікують кожен рядок таблиці. Це можуть бути всі стовпці, і
    кілька, і один. При цьому рядки, які містять значення цих атрибутів, не повинні повторюватися.</p>
<p><strong>Потенційний ключ</strong></p>
<p><mark class="green">Candidate key</mark> — мінімальний складовий ключ відношення (таблиці), тобто набір атрибутів, який задовольняє низці умов:</p>
<ul>
    <li><strong>Непривідність</strong>: він не може бути скорочений, він містить мінімально можливий набір атрибутів.</li>
    <li><strong>Унікальність</strong>: він повинен мати унікальні значення незалежно від зміни рядка.</li>
    <li><strong>Наявність значення</strong>: він не повинен мати значення NULL, тобто він обов'язково повинен мати
        значення.
<h2>2. Цікавий випадок первинних ключів</h2>
<p>Те, що в попередньому розділі ми назвали просто «ключами», зазвичай називається "потенційними ключами" (candidate keys). Термін «candidate» передбачає, що всі такі ключі конкурують за почесну роль «первинного ключа» (primary key), а ті, що залишилися, призначаються «альтернативними ключами» (alternate keys).</p>
<p>Потрібен якийсь час, щоб в реалізаціях SQL зникла невідповідність ключів і реляційної моделі, ранні бази даних були заточені під низькорівневу концепцію первинного ключа. Первинні ключі в таких базах були потрібні для ідентифікації фізичного розташування рядка на носіях з послідовним доступом до даних. Ось як це пояснює Джо Селко: Термін "ключ" означав ключ сортування файлу, який був потрібен для виконання будь-яких операцій обробки в послідовній файловій системі. Набір перфокарт зчитувався в одному і лише в одному порядку; неможливо було "повернутись назад". Перші накопичувачі на магнітних стрічках імітували таку ж поведінку та не дозволяли виконувати двонаправлений доступ. Тобто, початковий Sybase SQL Server для читання попереднього рядка вимагав «перемотування» таблиці на початок.</span></p>
<p>У сучасному SQL не потрібно орієнтуватися на фізичне подання інформації: таблиці моделюють зв'язки та внутрішній порядок рядків взагалі важливий. Однак, і зараз SQL-сервер за замовчуванням створює кластерний індекс для первинних ключів і, за старою традицією, фізично вибудовує порядок рядків.</p>
<p>У більшості баз даних первинні ключі збереглися як пережиток минулого, і навряд чи забезпечують щось крім відображення чи визначення фізичного розташування. Наприклад, у таблиці PostgreSQL оголошення первинного ключа автоматично накладає обмеження <code>NOT NULL</code> та визначає зовнішній ключ за замовчуванням. До того ж, первинні ключі є кращими стовпцями для оператора <code>JOIN</code>.</p>
<p>Перший ключ не скасовує можливості оголошення та інших ключів. Водночас, якщо жоден ключ не призначено первинним, то таблиця все одно нормально працюватиме. Блискавка, принаймні, у вас не вдарить.</p>
<h2>3. Знаходження природних ключів</h2>
<p>Розглянуті вище ключі називаються «природними», тому що вони є властивостями об'єкта, що модулюється, цікавими самі по собі, навіть якщо ніхто не прагне зробити з них ключ.</p>
<img data-max-width="800" data-id="eadd7f32-0792-44f1-9ab2-483666f8f44c" src="https://cdn.javarush.com/images/article/eadd7f32-0792-44f1-9ab2-483666f8f44c/800.jpeg" alt="">
<p>Перше, про що варто пам'ятати під час дослідження таблиці на предмет можливих природних ключів — варто старатися не перемудрувати. Користувач sqlvogel на StackExchange дає таку пораду:</p>
<p><span class="text-green"> У деяких людей виникають складнощі з вибором «природного» ключа через те, що вони вигадують гіпотетичні ситуації, в яких певний ключ може й не бути унікальним. Вони не розуміють сенсу завдання. Сенс ключа полягає в тому, щоб визначити правило, за яким атрибути в будь-який момент часу повинні бути і завжди будуть унікальними в конкретній таблиці. Таблиця містить дані в конкретному та зрозумілому контексті (в «предметній області» або в «області дискурсу») і єдине значення має застосування обмеження в цій конкретній області.
</span></p>
<p>Практика покаує, що потрібно вводити обмеження за ключем, коли колонка унікальна за наявних значень і буде залишатися такою при вірогідних сценаріях. А в разі потреби обмеження можна усунути (якщо це тебе турбує, то нижче ми розповімо про стабільність ключа).</p>
<p>Наприклад, база даних членів хоббі-клубу може мати унікальність у двох колонках — <code>first_name</code>, <code>last_name</code>. За невеликого обсягу даних дублікати маловірогідні, і до появи реального конфлікта використовувати такий ключ цілком розумно.</p>
<p>Зі зростанням бази даних та збільшенням обсягу інформацї вибір природного ключа може стати складнішим. Дані, які ми зберігаємо, є спрощенням зовнішньої реальності, и не містять деякі аспекти, якими відрізняються об'єкти в світі, такі як їх координати, що змінюються з часом. Якщо в об'єкта відсутній який-небудь код, як відрізнити дві банки з напоєм або дві коробки з вівсянкою, окрім як за їх положенням у просторі або за незначними відмінностями у вазі чи пакуванні?</p>
<p>Саме тому органи стандартизації створюють та наносять на продукцію мітки для розпізнавання. На автомобілях штампується <strong>Vehicle Identification Number (VIN)</strong>, в книгах друкується <strong>ISBN</strong>, на упаковці харчових товарів є <strong>UPC</strong>. Ви можете заперечити, що ці числа не здаються природними. Так чому ж я називаю їх природними ключами?</p>
<p>Природність або штучність унікальних властивостей в базі даних відносна до зовнішнього світу. Ключ, який під час створення в органі стандартизації або державній установі був штучним, стає для нас природним, тому що в цілому світі він стає стандартом та/або друкується на об'єктах.</p>
<p>Існує безліч галузевих, суспільних та міжнародних стандартів для різних об'єктів, в тому числі для валют, мов, фінансових інструментів, хімічних речовин та медичних діагнозів. Ось деякі зі значень, які часто використовуються як природні ключі: </p>
        <ul>
            <li>Коди країн за ISO 3166</li>
            <li>Коди мов за ISO 639</li>
            <li>Коди валют за ISO 4217</li>
            <li>Биржевые обозначения ISIN</li>
            <li>UPC/EAN, VIN, GTIN, ISBN</li>
            <li>імена логінів</li>
            <li>адреса електронної пошти</li>
            <li>номери кімнат</li>
            <li>mac-адрес в мережі</li>
            <li>широта, довгота для точок на поверхні Землі</li>
        </ul>
<p>Рекомендую оголошувати ключі, коли це можливо і доречно, можливо, навіть декілька ключів на таблицю. Але пам'ятай, що у всього, перерахованого вище, можуть бути винятки.</p>
        <ul>
            <li>Не у всіх є адреса електронної пошти, хоча в певних умовах використання бази даних це може бути прийнятно. До того ж, люди час від часу змінюють свої електронні адреси.</li>
            <li>Біржеві позначення ISIN час від часу змінюються, наприклад, символи GOOG та GOOGL не точно описують реорганізацію компанії з Google до Alphabet. Іноді може виникнути плутанина, як, наприклад, з TWTR та TWTRQ, деякі інвестори помилково купували останні під час IPO Twitter.</li>
            <li>Номери соціального страхування використовуються лише громадянами США, мають обмеження конфіденційності та повторно використовуються після смерті. До того ж, після кражі документів люди можуть отримати нові номери. Нарешті, один і той самий номер може ідентифікувати і особу, і ідентифікатор податку на прибуток.</li>
            <li>Поштові індекси — поганий вибір для міст. У деяких міст загальний індекс, або навпаки, в одному місті буває декілька індексів.</li>
        </ul>
<h2>4. Штучні ключі</h2>
<p>Враховуючи те, що ключ – це колонка, в кожному рядку якої знаходяться унікальні значення, одним зі способів його створення є шахрайство – до кожного рядка можна записати вигадані унікальні значення. Це і є штучні ключі: вигаданий код, що використовується для посиланні на данні або об'єкти.</p>
<img data-max-width="800" data-id="e0feb953-16ae-4313-ba14-37c9f8fb7eba" src="https://cdn.javarush.com/images/article/e0feb953-16ae-4313-ba14-37c9f8fb7eba/800.jpeg" alt="">
<p>Дуже важливим є те, що код генерується з самої бази даних та невідомий нікому, окрім користувачів бази даних. Саме це відрізняє штучні ключі від стандартизованих природних ключів.</p>
<p>Перевага природних ключів полягає в захисті від дублювання або суперечливості рядків таблиці, штучні ж ключі корисні тому, що вони дозволяють людям або іншим системам простіше посилатися на рядок, а також підвищують швидкість операцій пошуку та об'єднання, оскільки не використовують порівняння рядкових (або багатоколонкових) ключів.</p>
<h3>Сурогати</h3>
<p><span class="text-green">Штучні ключі використовуються як прив'язка — незалежно від зміни правил і стовпчиків, один рядок завжди можна ідентифікувати однаковим способом. Штучний ключ, який використовується для цієї мети, називається «сурогатним ключем» і вимагає особливої уваги. Сурогати ми розглянемо нижче.</span></p>
<p>Штучні ключі, що не э сурогатами, зручні для посилань на рядок зовні бази даних. Штучний ключ коротко
            ідентифікує дані або об'єкт: він може бути вказаний як URL-адреса, прикріплена до рахунку, продиктована по
            телефону, отримана в банку або надрукована на номерному знаку. (Номірний знак автомобіля для нас є природним
            ключем, але розроблений державою як штучний ключ.)</p>
<p>Штучні ключі потрібно вибирати, враховуючи можливі способи їх передачі, щоб мінімізувати помилки та помилки.
            Треба врахувати, що ключі можуть вимовляти, читати надрукованим, відправляти по SMS, читати написаним від
            руки, вводити з клавіатури та вбудовувати в URL. Додатково деякі штучні ключі, наприклад номери кредитних
            карток, містять контрольну суму, щоб при виникненні певних помилок їх можна було хоча б розпізнати.</p>
<p>Приклади:</p>
        <ul>
            <li>Для номерних знаків США існують правила про використання неоднозначних ознак, наприклад O та 0.</li>
            <li>Лікарні та аптеки повинні бути особливо акуратними, враховуючи почерк лікарів.</li>
            <li>Передаєте sms-код підтвердження? Не виходьте за межі набору символів GSM 03.38.</li>
            <li>На відміну від Base64, що кодує довільні байтові дані, Base32 використовує обмежений набір символів,
                який зручно використовувати людям та обробляти на старих комп'ютерних системах.</li>
            <li> Proquints — це ідентифікатори, що читаються, записуються та вимовляються. Це вимовляються
                (PRO-nouncable) п'ятірки (QUINT-uplets) однозначно зрозумілих приголосних і голосних букв.</li>
        </ul>
<p>Май на увазі, що як тільки ти познайомиш світ зі своїм штучним ключем, люди дивним чином почнуть надавати
            йому особливу увагу. Достатньо подивитися на «блатні» номерні знаки або на систему створення
            ідентифікаторів, що вимовляються, яка перетворилася на сумнозвісний автоматизований генератор лайок.</p>
<p>Навіть, якщо обмежитися числовими ключами, є табу типу тринадцятого поверху. Незважаючи на те, що proquints
            мають більшу щільність інформації на склад, що вимовляється, числа теж непогані в багатьох випадках: в URL,
            пін-клавіатурах і написаних від руки записах, якщо одержувач знає, що ключ складається тільки з цифр.</p>
<p>Однак, зверни увагу, що не варто використовувати послідовний порядок у публічно відкритих числових ключах,
            оскільки це дозволяє копатися в ресурсах (/videos/1.mpeg, /videos/2.mpeg, і так далі), а також створює витік
            інформації про кількість даних. Накладіть на послідовність чисел мережу Фейстеля та збережіть унікальність,
            приховавши при цьому порядок чисел.</p>
<p>Єдиним аргументом проти оголошення додаткових ключів є те, що кожен новий несе за собою ще один унікальний
            індекс та збільшує витрати на запис до таблиці. Звичайно, залежить від того, наскільки вам важлива
            коректність даних, але, швидше за все, ключі все ж таки варто оголошувати.</p>
<p>Також варто оголошувати кілька штучних ключів, якщо вони є. Наприклад, організація має кандидатів на роботу
            (Applicants) і співробітників (Employees). Кожен співробітник колись був кандидатом, і належить до
            кандидатів за власним ідентифікатором, який також повинен бути і ключем співробітника. Ще один приклад,
            можна задати ідентифікатор співробітника та ім'я логіна як два ключі в Employees. Він не повинен бути
            коротким і переданим, як інші штучні ключі, а використовується як внутрішня мітка, яка завжди ідентифікує
            рядок. Він використовується в SQL, але додаток не звертається до нього явним чином.</p>
<img data-max-width="800" data-id="43b5ec60-2937-43f2-9431-b18c81e9a442"/cdn.javarush.com/images/article/43b5ec60-2937-43f2-9431-b18c81e9a442/800.jpeg" alt="">
<p>Якщо тобі знайомі системні колонки (system columns) з PostgreSQL, то ти можеш сприймати майже як параметр реалізації бази
            даних (на кшталт ctid), який, проте, будь-коли змінюється. Значення сурогату вибирається один раз для
            кожного рядка і потім ніколи не змінюється.</p>
<p>Сурогатні ключі відмінно підходять як зовнішні ключі, при цьому необхідно вказати каскадні обмеження <code>ON
            UPDATE RESTRICT</code>, щоб відповідати незмінності сурогату.</p>
<p>З іншого боку, зовнішні ключі до публічно переданих ключів повинні бути позначені <code>ON UPDATE
            CASCADE</code>, щоб забезпечити максимальну гнучкість. Каскадне оновлення виконується на тому ж рівні
            ізоляції, що й навколишня транзакція, тому не турбуйтеся про проблеми з паралельним доступом – база даних
            впорається, якщо вибрати суворий рівень ізоляції.</p>
<p>Не роби сурогатні ключі «природними». Як тільки ти покажеш значення сурогатного ключа кінцевим
            користувачам, або, що гірше, дозволите їм працювати з цим значенням (зокрема через пошук), то фактично
            надасте ключу значимість. Потім показаний ключ із вашої бази даних може стати природним ключем у чиїйсь
            чужій БД.</p>
<p>Примус зовнішніх систем до використання інших штучних ключів, спеціально призначених для передачі, дозволяє
            нам при необхідності змінювати ці ключі відповідно до змінних потребами, водночас підтримуючи внутрішню
            цілісність посилань за допомогою сурогатів.</p>
<h3>Автоінкрементні INT/BIGINT</h3>
<p>Найчастіше для сурогатних ключів використовують автоінкрементну колонку <strong>«bigserial»</strong> , також
            відомий як <strong>IDENTITY</strong>. (Насправді, PostgreSQL 10 тепер, як і Oracle, підтримує конструкцію
            IDENTITY, див. CREATE TABLE.)</p>
<p>Однак, я вважаю, що автоінкрементне ціле поганий вибір для сурогатних ключів. Така думка непопулярна, тому
            дозвольте мені порозумітися.</p>
<p>Недоліки послідовних ключів:</p>
        <ul>
            <li>Якщо всі послідовності починаються з 1 і поступово збільшуються, то рядки з різних таблиць мають
                однакові значення ключів. Такий варіант неідеальний, краще все ж таки використовувати непересічні
                безлічі ключів у таблицях, щоб, наприклад, запити не змогли б випадково переплутати константи в <code>JOIN</code>
                і повернути несподівані результати. (Як варіант для забезпечення відсутності перетинів, можна скласти
                кожну послідовність з чисел, кратних різним простим, але це буде досить трудомістко.)</li>
            <li>Виклик <code>nextval()</code>для генерації послідовності в сучасних розподілених SQL призводить до
                того, що вся система гірше масштабується.</li>
            <li>Поглинання даних з бази даних, в якій також використовувалися послідовні ключі, призведе до конфліктів,
                тому що послідовні значення не будуть унікальними в різних системах.</li>
            <li>З філософської погляду послідовне збільшення чисел пов'язане зі старими системами, у яких було передбачено
                порядок рядків. Якщо ж ти тепер хочеш впорядкувати рядки, то роби це явно, за допомогою колонки міток
                часу або чогось, що має сенс у ваших даних. В іншому випадку порушується перша нормальна форма.</li>
            <li>Слабка причина, але ці короткі ідентифікатори так і тягне повідомити когось.</li>
        </ul>
<h3>UUID</h3>
<p>Давай розглянемо інший варіант: використання великих цілих чисел (128-бітних), що генеруються відповідно до
            випадкового шаблону. Алгоритми генерації таких універсальних унікальних ідентифікаторів (universally unique
            identifier, UUID) мають надзвичайно малу можливість вибору одного значення двічі, навіть при одночасному
            виконанні на двох різних процесорах.</p>
<p>У такому випадку <strong>UUID</strong> здаються природним вибором для використання як сурогатних ключів, чи
            не так? Якщо ви хочете помітити рядки унікальним чином, то ніщо не зрівняється з унікальною міткою! Так чому
            ж всі не користуються ними в PostgreSQL? На це є кілька надуманих причин і одна логічна, яку можна обійти, і
            я представлю бенчмарки, щоб проілюструвати свою думку.</p>
<p>Для початку розповім про надумані причини. Деякі люди думають, що UUID це рядки, тому що вони записуються в
            традиційному шістнадцятковому вигляді з дефісом: <code>5bd68e64-ff52-4f54-ace4-3cd9161c8b7f</code>. Дійсно,
            деякі бази даних не мають компактного (128-бітного) типу uuid, але в PostgreSQL він є і має розмір двох
            bigint, тобто, в порівнянні з обсягом іншої інформації в базі даних, витрати незначні.</p>
<p>Ще UUID незаслужено звинувачується у громіздкості, але хто їх вимовлятиме, друкуватиме або читатиме? Ми
            говорили, що це має сенс для штучних ключів, що показуються, але ніхто (за визначенням) не повинен побачити
            сурогатний UUID. Можливо, з UUID буде мати справу розробник, який запускає команди SQL у psql для
            налагодження системи, але на цьому все. А розробник може посилатися на рядки і за допомогою більш зручних
            ключів, якщо вони задані. Реальна проблема з UUID у тому, що сильно рандомізовані значення призводять до
            збільшення обсягу запису. (write amplification) із-за записів повних сторінок у журнал із випереджаючим
            записом (write-ahead log, WAL)</span>. Однак, насправді, зниження продуктивності залежить від алгоритму
            генерації UUID. </p>
<p>Давай виміряємо <strong>write amplification</strong>. Правду кажучи, проблема в старих файлових системах.
            Коли PostgreSQL виконує запис на диск, вона змінює сторінку на диску. При відключенні живлення комп'ютера
            більшість файлових систем повідомить про успішний запис ще до того, як дані безпечно збереглися на диску.
            Якщо PostgreSQL наївно сприйме таку дію завершеною, то при подальшому завантаженні системи база даних буде
            пошкоджена. сторінки в журнал із попереджувальним записом (write-ahead log), який можна використовувати для
            відновлення після можливого збою. Індексування сильно рандомізованих значень на зразок UUID зазвичай зачіпає
            купу різних сторінок диска і призводить до запису повного розміру сторінки (зазвичай 4 або 8 КБ) WAL для
            кожного нового запису. Це так званий повносторінковий запис (full-page write, FPW).</p>
<p>Деякі алгоритми генерації UUID (такі, як «snowflake» від Twitter або uuid_generate_v1() у розширенні
            uuid-ossp для PostgreSQL) створюють на кожній машині значення, що монотонно збільшуються. Такий підхід
            консолідує записи в меншу кількість сторінок диска і знижує FPW. по застосуванню їх у ваших базах даних.</p>
<p>Для кожної таблиці:</p>
        <ul>
            <li>Визнач та оголоси усі природні ключі.</li>
            <li>Створи сурогатний ключ <code>&lt ;table_name&gt;_id</code> типу <strong>UUID</strong> зі значенням за
                промовчанням у <code>uuid_generate_v1()</code>. Можеш навіть позначити його як первинний ключ. Якщо
                додати до цього ідентифікатора назву таблиці, це спростить <code>JOIN</code>, тобто. отримайте <code>JOIN
                    foo USING (bar_id)</code> замість <code>JOIN foo ON (foo.bar_id = bar.id)</code>. Не передавайте цей
                ключ клієнтам і взагалі не виводьте за межі бази даних.</li>
            <li>Для проміжних таблиць, через які відбувається <code>JOIN</code>, оголошуй всі колонки зовнішніх ключів
                як єдиний складовий первинний ключ.</li>
            <li>В разі необхідності додай штучний ключ, який можна використовувати в URL або інших вказівках посилання на
                рядок. Використовуй <strong>сітку Фейстеля</strong> або <strong>pg_hashids</strong>, щоб замаскувати
                автоінкрементні цілі.
            </li>
            <li>Вказуй каскадне обмеження <code>ON UPDATE RESTRICT</code>, використовуючи сурогатні UUID як
                зовнішні ключі, а для зовнішніх штучних ключів — <code>ON UPDATE CASCADE</code>. Обирай природні
                ключі, виходячи з власної логіки.</li>
        </ul>
<p>Такий підхід забезпечує стабільність внутрішніх ключів, одночасно допускаючи і навіть захищаючи природні
            ключі. До того ж, видимі штучні ключі не стають до чогось прив'язаними. Правильно у всьому розібравшись,
            можна не зациклюватися лише на «первинних ключах» і користуватися всіма можливостями застосування
            ключів.</p>