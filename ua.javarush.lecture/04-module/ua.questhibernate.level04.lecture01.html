Числові функції
<p>----------------------------------------</p>
Список числових функцій.
Арифметичні операції.
Бітові операції.
Функції округлення.
<p>----------------------------------------</p>
<h2>1. Список числових функцій </h2>
 
<p>Як ми говорили вище, для СУБД недостатньо просто зберігати дані певного типу: потрібно ще підтримувати великий набір супершвидких операцій над цими типами.</p>
 
<p>І, як ти знаєш, усі СУБД підтримують різноманітні числові типи та операції над ними. Сьогодні ти познайомишся із найпопулярнішими з них. </p>
 
<p>Всі числові функції MySQL можна умовно розділити на 5 груп: </p>

<ul>
<li>Арифметичні операції</li>
<li>Бітові операції</li>
<li>Функції округлення</li>
<li>Алгебраїчні функції</li>
<li>Тригонометричні функції</li>
</ul>

<p>До речі, з дуже багатьма з них ти знайомий завдяки мові Java, тому, думаю, вони не стануть для тебе сюрпризом. Але почнемо по порядку.</p>
 
<p>Повний перелік функцій можна знайти <a href="https://dev.mysql.com/doc/refman/8.0/en/mathematical-functions.html" target="_blank">за цим посиланням</a>.</p>

<h2>2. Арифметичні операції</h2>
 
<p>Тут у принципі нічого несподіваного, ті самі стандартні операції, як і скрізь: </p>

<table>
<tbody>
<tr>
<th>#</th>
<th></th>
<th>Приклад </th>
<th></th>
</tr>
<tr>
<td>1</td>
<td>+, -, *, /</td>
<td>2+2*2 </td>
<td>Додавання, віднімання, множення, ділення (не націло!)</td>
</tr>
<tr>
<td>2 </td>
<td>%</td>
<td>13 % 5 </td>
<td>Залишок від ділення </td>
</tr>
<tr>
<td>3 </td>
<td>MOD </td>
<td>13 MOD 5 </td>
<td>Залишок від ділення </td>
</tr>
<tr>
<td>4 </td>
<td>DIV </td>
<td>13 DIV 5 </td>
<td>Ділення націло </td>
</tr>
</tbody>
</table>
 
<p>З цікавого: під час розподілу двох цілих чисел вийде дійсне число. Для ділення потрібно використовувати оператор DIV. </p>
 
<p>Якщо ти хочеш отримати залишок від ділення націло, то потрібно використовувати або оператор MOD, або % як у Java. Прикладів наводити не буду, як на мене тут і так все очевидно. </p>

<h2>3. Бітові операції</h2>
 
<p>Над числами SQL можна також проводити бітові операції, приблизно як і в мові Java. Хоча є нюанси. Список доступних бітових операцій наведено в таблиці нижче: </p>

<table>
<tbody>
<tr>
<th>#</th>
<th></th>
<th>Приклад </th>
<th>Примітка </th>
</tr>
<tr>
<td>1 </td>
<td>&</td>
<td>0b1111 & 0b1000</td>
<td>Побітовий AND </td>
</tr>
<tr>
<td>2 </td>
<td>| </td>
<td>0b1111 | 0b0001 </td>
<td>Бітовий OR </td>
</tr>
<tr>
<td>3 </td>
<td>^</td>
<td>0b1111 ^0b1111</td>
<td>Бітовий XOR </td>
</tr>
<tr>
<td>4 </td>
<td>~</td>
<td>~0b1111 </td>
<td>Побітова інверсія </td>
</tr>
<tr>
<td>
<td>
<td>
<td>
</tr>
<tr>
<td>5 </td>
<td>&gt;&gt; </td>
<td>128 &gt;&gt; 5 </td>
<td>Бітове зрушення вправо </td>
</tr>
<tr>
<td>6 </td>
<td>&lt;&lt; </td>
<td>2 &lt;&lt; 5 </td>
<td>Бітове зрушення вліво </td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>7 </td>
<td>BIT_COUNT()</td>
<td>BIT_COUNT(255) </td>
<td>Повертає кількість біт, що дорівнює 1</td>
</tr>
</tbody>
</table>
 
<p>У MySQL до версії 8.0 такі операції можна було виконувати тільки з типом даних BIGINT, який складався з 64 біт і був аналогічний типу long Java. Однак у MySQL 8.0 (який ми розглядаємо) концепція змінилася. Тепер ці операції можна виконувати над спеціальними бінарними типами: </p>

<ul>
<li>BINARY</li>
<li>VARBINARY</li>
<li>А також над типами BLOB (що представляють собою масив байт)</li>
</ul>

<p>Всі інші типи просто приводяться до типу BIGINT і операції виконуються, як і раніше (тільки над першими 64 бітами). </p>

<h2>4. Функції округлення </h2>

<p>Для округлення MySQL використовуються до болю знайомі тобі функції. Список їх наведено в таблиці нижче: </p>

<table>
<tbody>
<tr>
<th>#</th>
<th></th>
<th>Приклад</th>
<th>Примітка </th>
</tr>
<tr>
<td>1 </td>
<td>CEIL(), CEILING() </td>
<td>CEIL (5.1) = 6</td>
<td>Округлює дійсне число вверх </td>
</tr>
<tr>
<td>2 </td>
<td>FLOOR() </td>
<td>FLOOR (5.9) = 5</td>
<td>Округлює дійсне число вниз</td>
</tr>
<tr>
<td>3 </td>
<td>ROUND() </td>
<td>ROUND(4.1) = 4</td>
<td>Округлює дійсне число до найближчого цілого </td>
</tr>
<tr>
<td>4 </td>
<td>TRUNCATE() </td>
<td>TRUNCATE(4.123, 2) = 4.12 </td>
<td>Обрізає число до N знаків після коми</td>
</tr>
<tr>
<td>5 </td>
<td>RAND() </td>
<td>0.61914388706828</td>
<td>Повертає випадкове речове число в діапазоні від 0 до 1 </td>
</tr>
<tr>
<td>6 </td>
<td>RAND(N)</td>
<td>0.93845168309142</td>
<td>Повертає випадкове речове число в діапазоні від 0 до 1. N використовується як seed value </td>
</tr>
</tbody>
</table>
 
<p>З усіма функціями округлення ти знайомий ще з часів першого модулю Java-курсу. Зацікавити тут може лише функція TRUNCATE() та RANDOM(N).</p>
 
<p>Функція <strong>TRUNCATE</strong> (число, кількість) приймає як перший параметр дійсне число, а як другий — кількість знаків після коми, яке має залишатися. Число обрізається до потрібної кількості знаків після коми.</p>
 
<p>Щодо функції RAND(N) все дещо складніше. Як ти напевно знаєш, комп'ютер не може генерувати випадкові числа. Натомість він генерує так звану послідовність псевдовипадкових чисел. Тобто, дивлячись на одне число не зрозуміло, випадкове воно чи ні, а от послідовність чисел вже може бути схожою на випадкову. Цим і користуються розробники, генеруючи послідовність чисел, яка дуже схожа на випадкову.</p>
  
<p>Водночас <span class="text-green">кожне нове число послідовності генерується за хитрим правилом на основі попереднього числа цієї послідовності</span>. Тому якщо ти передаси до алгоритму генерації випадкових чисел якесь стартове число (його ще називають seed), то <span class="text-user">щоразу будеш отримувати ту саму послідовність випадкових чисел</span>.</p>