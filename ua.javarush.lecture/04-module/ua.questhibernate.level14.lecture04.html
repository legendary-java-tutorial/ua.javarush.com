Кешування даних у Hibernate
<p>----------------------------------------</p>
Ніколи не пишіть своє рішення щодо кешування.
Кешування у базі даних.
Види кешування в Hibernate.
Кешування другого рівня.
<p>----------------------------------------</p>
<h2>Ніколи не пишіть своє рішення щодо кешування</h2>

<p>Ще один спосіб прискорити роботу з базою даних — це кешувати об'єкти, які ми вже запитували раніше.</p>

<p><strong>Важливо!</strong> Ніколи не пиши своє рішення щодо кешування. Це завдання має стільки підводного каміння, що тобі й не снилося.</p>

<p>Проблема 1 — <strong>скидання кешу</strong>. Іноді відбуваються події, коли потрібно видалити об'єкт із кешу або оновити його в ньому. Єдиний спосіб зробити це грамотно - пропускати всі запити до бази через двигун кешу. Інакше тобі щоразу доведеться явно вказувати кешу, які об'єкти варто видалити або оновити.</p>

<p>Проблема 2 — <strong>нестача пам'яті</strong>. Кешування здається чудовою ідеєю, поки ти не зіткнешся з тим, що об'єкти в пам'яті займають багато місця. Тобі потрібні додатково десятки гігабайт пам'яті для ефективної роботи кешу серверної програми.</p>

<p>А оскільки пам'яті завжди не вистачає, то потрібна ефективна стратегія видалення об'єктів із кешу. Це чимось нагадує збирач сміття у Java. І як ти пам'ятаєш, вже десятки років найкращі уми винаходять різні способи маркування об'єктів за поколіннями тощо.</p>

<p>Проблема 3 — <strong>різні стратегії</strong>. Як показує практика, для різних об'єктів ефективні різні стратегії зберігання та оновлення у кеші. Ефективна система кешування не може обійтися стратегією для всіх об'єктів.</p>

<p>Проблема 4 — <strong>ефективне зберігання об'єктів</strong>. Не можна просто зберігати об'єкти в кеші. Об'єкти занадто часто містять посилання на інші об'єкти тощо. Такими темпами тобі не знадобиться збирач сміття: йому просто нема чого видаляти.</p>

<p>Тому замість того, щоб зберігати самі об'єкти, іноді набагато ефективніше зберігати значення їхніх полів-примітивів. І системи швидкого конструювання об'єктів за ними.</p>

<p>На виході ти отримаєш цілу віртуальну СУБД у пам'яті, яка має швидко працювати та споживати мало пам'яті.</p>

<h2>Кешування в базі даних</h2>

<p>Крім кешування прямо в Java-програмі ще часто організовують кешування прямо в базі даних.</p>

<p>Там є чотири великі підходи:</p>

<p>Підхід перший — <strong>денормалізація бази даних</strong>. SQL-сервер у пам'яті зберігає дані негаразд, як вони зберігатися у таблицях.</p>

<p>Коли дані зберігаються на диску в таблицях, то дуже часто розробники намагаються максимально уникнути дублювання даних — такий процес називається нормалізацією бази даних. Для прискорення роботи з даними в пам'яті виконується зворотний процес — денормалізація бази даних. Купа зв'язаних таблиць може зберігатися вже в об'єднаному вигляді - у вигляді великих таблиць і т.п.</p>

<p>Другий підхід — <strong>кешування запитів</strong>. І результатів запитів.</p>

<p>СУБД бачить, що часто до неї приходять однакові або схожі запити. Тоді вона починає просто кешувати ці запити та відповіді на них. Але при цьому потрібно чітко стежити за тим, щоб з кешу вчасно видалялися рядки, що змінилися у базі.</p>

<p>Цей підхід може бути дуже ефективним за участю людини, яка може проаналізувати запити та допомогти СУБД зрозуміти, як їх краще кешувати.</p>

<p>Третій підхід — <strong>база даних у пам'яті</strong>.</p>

<p>Ще один підхід, що часто використовується. Між сервером та СУБД ставиться ще одна база, яка зберігає всі свої дані лише у пам'яті. Її ще називають In-Memory-DB.
Якщо у тебе багато різних серверів звертаються до однієї бази даних, то за допомогою In-Memory-DB можна організувати кешування, орієнтоване тип конкретного сервера.</p>

<p>Приклад:</p>

<img data-max-width="1024" data-id="9f2582a5-e5db-4280-88ff-6f605c256bdf" src="https://cdn.javarush.com/images/article/9f2582a5-e5db-4280 -6f605c256bdf/original.png" alt="">

<p>Підхід 4 — <strong>кластер баз даних</strong>. Декілька read-only баз.</p>

<p>Ще одне рішення - використання кластера: кілька СУБД одного типу містять ідентичні дані. При цьому читати дані можна з усіх баз, а писати лише в одну. Яка потім синхронізується з рештою баз.</p>

<p>Це дуже добре рішення, тому що його легко конфігурувати і воно працює на практиці. Зазвичай на один запит до бази змінення даних до неї надходить 10-100 запитів на читання даних.</p>

<h2>Види кешування в Hibernate</h2>

<p>Hibernate підтримує три рівні кешування:</p>

<ul>
<li>Кешування на рівні сесії (Session)</li>
<li>Кешування на рівні SessionFactory</li>
<li>Кешування запитів (та їх результатів)</li>
</ul>

<p>Цю систему можна спробувати уявити у вигляді такого малюнка:</p>

<img data-max-width="800" data-id="63696278-18d4-4dc4-ba87-fc9f4bc24c11" src="https://cdn.javarush.com/images/article/63696278-18d4-4dc4 -fc9f4bc24c11/original.png" alt="">

<p>Найпростіший вид кешування (його ще називають <strong>кешем першого рівня</strong>) реалізований на рівні Hibernate-сесії. <span class="text-green">Hibernate завжди за умовчанням використовує цей кеш</span> і <span class="text-red">його не можна вимкнути</span>.</p>

<p>Давай відразу розглянемо наступний приклад:</p>

<pre class='language-java line-numbers'><code>
Employee director1 = session.get(Employee.class, 4);
Employee director2 = session.get(Employee.class, 4);
 
assertTrue(director1 == director2);
</code></pre>
 
<p>Може здатися, що тут буде виконано два запити до бази, проте це не так. Після першого запиту до бази об'єкт Employee буде закешований. І якщо ти знову виконаєш запит об'єкта в тій самій сесії, то Hibernate поверне той же Java-об'єкт.</p>

<p>Той самий об'єкт — це означає, що навіть посилання на об'єкти будуть ідентичними. Це реально той самий об'єкт.</p>

<p>При використанні методів <span class="code text-orange">save()</span>, <span class="code text-orange">update()</span>, <span class="code text-orange">saveOrUpdate()</span>, <span class="code text-orange">load()</span>, <span class="code text-orange">get()</span> , <span class="code text-orange">list()</span>, <span class="code text-orange">iterate()</span> та <span class="code text-orange"> scroll()</span> завжди буде задіяний кеш першого рівня. Власне, тут нічого більше додати.</p>

<h2>Кешування другого рівня</h2>

<p>Якщо кеш першого рівня прив'язаний до об'єкта сесії, кеш другого рівня прив'язаний до об'єкта <mark class="green">SessionFactory</mark>. Що означає, що видимість об'єктів у цьому кеші набагато ширша, ніж у кеші першого рівня.</p>

<p>Приклад:</p>

<pre class='language-java line-numbers'><code>
Session session = factory.openSession();
Employee director1 = session.get(Employee.class, 4);
session.close();
 
Session session = factory.openSession();
Employee director2 = session.get(Employee.class, 4);
session.close();
 
assertTrue(director1! = director2);
assertTrue(director1.equals(director2));
</code></pre>
 
<p>У цьому прикладі буде виконано два запити до бази. Hibernate поверне ідентичні об'єкти, але це буде не той самий об'єкт — вони матимуть різні посилання.</p>

<p><strong>Кешування другого рівня за промовчанням <span class="text-red">відключено</span></strong>. Тому ми маємо два запити до бази замість одного.</p>

<p>Щоб його увімкнути, потрібно у файлі hibernate.cfg.xml написати такі рядки:</p>
 
<pre class='language-java line-numbers'><code>
&lt;property name="hibernate.cache.provider_class" value="net.sf.ehcache.hibernate.SingletEhCacheProvider"/>
&lt;property name="hibernate.cache.use_second_level_cache" value="true"/>
</code></pre>
 
<p>Після включення кешування другого рівня поведінка Hibernate трохи зміниться:</p>

<pre class='language-java line-numbers'><code>
Session session = factory.openSession();
Employee director1 = session.get(Employee.class, 4);
session.close();
 
Session session = factory.openSession();
Employee director2 = session.get(Employee.class, 4);
session.close();
 
assertTrue(director1 == director2);
</code></pre>
 
<p>Тільки після всіх цих маніпуляцій кеш другого рівня буде включений, і в прикладі вище буде виконано лише один запит до бази.</p>