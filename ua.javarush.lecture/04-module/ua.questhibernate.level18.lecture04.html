  Транзакції і не тільки <p>----------------------------------------</p> > Проблема одночасності Транзакції прийшли, щоб врятувати нас "I" та інші літери в ACID <p>------------------------------ ----------</p> <h2>5.1 Проблема одночасності</h2> <p>Для початку трохи віддаленої теорії.</p> <p>Будь-яка інформаційна система (або просто, додаток), яку створюють програмісти, складається з кількох типових блоків, кожен із яких забезпечують частину необхідної функціональності. Наприклад, кеш використовується для того, щоб запам'ятовувати результат ресурсомісткої операції для забезпечення більш швидкого читання даних клієнтом, інструменти потокової обробки дозволяють відправляти повідомлення іншим компонентам для асинхронної обробки, а інструменти пакетної обробки використовуються для того, щоб з деякою періодичністю «розгрібати» обсяги даних, що накопичилися. . </p> <p>І практично в кожному додатку так чи інакше задіяні бази даних (БД), які зазвичай виконують дві функції: зберігати при отриманні від вас дані та пізніше надавати їх вам на запит. Рідко хто задумує створити свою БД, тому що існує вже багато готових рішень. Але як вибрати саме ту, яка підійде вашому додатку? Отже, давайте уявімо собі, що ви написали програму, з мобільним інтерфейсом, який дозволяє завантажувати збережений раніше список справ по дому - тобто, читати з БД, та доповнювати його новими завданнями, а також розставляти пріоритети для кожного конкретного завдання – від 1 (найвищий) до 3 (найнижчий). Допустимо, ваш мобільний додаток у кожний момент часу використовує лише одна людина. Але ось ви наважилися розповісти про своє творіння мамі, і тепер вона стала другим постійним користувачем. Що станеться, якщо ви вирішите одночасно, прямо в ту ж мілісекунду, поставити якомусь завдання - "помити вікна" - різний ступінь пріоритету? 2 процесу, які здійснили запит до БД. Процес – це сутність комп'ютерної програми, яка може виконуватися в одному чи кількох потоках. Зазвичай процес має спосіб машинного коду, пам'яттю, контекстом та іншими ресурсами. Іншими словами, характеризувати процес можна як виконання інструкцій програми на процесорі. Коли ваша програма робить запит у БД, то ми говоримо про те, що ваша БД обробляє отриманий по мережі запит від одного процесу. Якщо користувачів, які одночасно сидять у додатку, двоє, то й процесів у якийсь конкретний момент часу може бути двоє. Система, що має стан ("stateful") - це така система, яка пам'ятає попередні події і зберігає інформацію, яка і називається "станом". Змінна, оголошена як <code>integer</code>, може мати стан 0, 1, 2 або, скажімо, 42. <strong>Mutex</strong> (взаємний виняток) має два стани: <strong>locked</strong > або <strong>unlocked</strong>, як і двійковий семафор ("required" vs. "released") і взагалі двійкові (бінарні) типи даних і змінні, які можуть мати лише два стани – 1 чи 0. </p> <p>На основі поняття стану базуються кілька математичних та інженерних конструкцій, таких як кінцевий автомат – модель, яка має по одному входу та виходу і в кожний момент часу знаходиться в одному з кінцевої множини станів – і шаблон проектування «стан », при якому об'єкт змінює поведінку залежно від внутрішнього стану (наприклад, залежно від того, яке значення присвоєно тій чи іншій змінній). часу може змінюватися: наша pipeline, що обробляє великий пакет даних, видає помилку і стає <strong>failed</strong>, або властивість об'єкта «Гаманець», що зберігає суму грошей, що залишилися на рахунку користувача, змінюється після надходження на рахунок зарплати. </p> <p>Перехід («transition») від одного стану до іншого – скажімо, від <strong>in progress</strong> до <strong>failed</strong> – називається операцією. Напевно, всім відомі операції <strong>CRUD</strong> – <code>create</code>, <code>read</code>, <code>update</code>, <code>delete</code>, або аналогічні їм методи <strong>HTTP</strong> - <code>POST</code>, <code>GET</code>, <code>PUT</code>, <code>DELETE</code>. Але програмісти у своєму коді часто дають операціям інші імена, тому що операція може бути складнішою, ніж просто прочитати якесь значення з бази даних - вона може заодно перевірити дані, і тоді наша операція, яка набула вигляду функції, буде називатися, наприклад, <code >validate()</code> А хто виконує ці операції-функції? Вже описані процеси. Ще трохи, і ви зрозумієте, чому я так докладно описую терміни! : <strong>час виклику (invocation time)</strong> та <strong>час завершення (completion time)</strong>, який буде строго більше часу виклику (дослідники з Jepsen виходять з теоретичного припущення, що обидва ці timestamp будуть дані уявним, повністю синхронізованим, глобально доступним годинником). </p> <p>Давайте уявімо наш додаток зі списком справ. Ви через мобільний інтерфейс робите запит у БД у <code>14:00:00.014</code>, а ваша мама у <code>13:59:59.678</code> (тобто, за 336 мілісекунд до цього) через той А інтерфейс оновила перелік справ, додавши в нього миття посуду. Враховуючи затримку мережі та можливу чергу завдань для вашої БД, якщо окрім вас з мамою вашим додатком користуються ще всі мамині подруги, БД може виконати запит мами вже після того, як обробить ваш. Іншими словами, є ймовірність того, що два ваші запити, а також запити маминих подруг будуть спрямовані на одні й ті самі дані одночасно (concurrently). - Конкурентність. Що може означати одночасність двох операцій? Якщо дані певна операція T1 і якась операція T2, то:</p> <ul> <li>Т1 може бути розпочата до часу початку виконання Т2, а закінчена між часом початку і кінця виконання Т2</li> <li>Т2 може бути розпочато до часу початку виконання Т1, а закінчена між часом початку і кінця виконання Т1</li> <li>Т1 може бути розпочата і закінчена між часом початку і кінця виконання Т1</li> <li>і будь-який інший сценарій, за умови якому T1 і T2 мають певний загальний час виконання</li> </ul> <p>Зрозуміло, що в рамках даної лекції ми говоримо в першу чергу про запити, що надходять до БД, і те, як система управління БД ці запити сприймає, Проте термін конкурентності важливий, наприклад, й у контексті операційних систем. Я не надто сильно відходитиму в бік від теми цієї статті, але вважаю важливим згадати, що конкурентність, про яку ми тут говоримо, не пов'язана з дилемою про конкурентність і паралелізм та їх різницю, яку обговорюють у контексті роботи операційних систем та high-performance computing. <strong>Паралелізм</strong> – це один із способів досягнення конкурентності в середовищі з кількома ядрами, процесорами або комп'ютерами. Ми ж говоримо про конкурентність у значенні одночасного доступу різних процесів до загальних даних.</p> <p>А що, власне, може піти не так, чисто теоретично? Проблеми, пов'язані з конкурентністю, також названі "race conditions". <strong>Перша проблема</strong> виникає тоді, коли процес отримує дані, які він не повинен був отримати: неповні, тимчасові, скасовані або з якоїсь іншої причини «неправильні» дані. <strong>Друга проблема</strong> – коли процес отримує неактуальні дані, тобто дані, які не відповідають останнім збереженим станом БД. Скажімо, якийсь додаток зняв гроші з рахунку користувача з нульовим балансом, тому що БД повернуло додатку стан рахунку, що не враховує останнє зняття грошей з нього, що відбулося буквально кілька мілісекунд назад. Ситуація така собі, чи не так?</p> <h2>5.2 Транзакції прийшли, щоб врятувати нас</h2> <p>Для того, щоб вирішувати такі проблеми, і з'явилося поняття транзакції – якоїсь групи послідовних операцій (змін стану) з БД, яка є логічно єдиною операцією. Знову наведу приклад із банком – і не випадково, адже концепція транзакції з'явилася, зважаючи на все, саме в контексті роботи з грошима. Класичний приклад транзакції - переказ грошей з одного банківського рахунку на інший: вам необхідно спочатку зняти суму з вихідного рахунку, а потім внести її на цільовий рахунок. : перевірка балансу відправника, блокування суми на рахунку відправника, додавання суми до рахунку одержувача та відрахування суми відправника. Вимог до такої транзакції буде кілька. Наприклад, програма не може отримати застарілу або неправильну інформацію про баланс – наприклад, якщо паралельна транзакція завершилася помилкою на півдорозі, і кошти з рахунку так і не списалися – а наш додаток вже отримав інформацію про те, що кошти були списані.</p> <p>Вирішити цю проблему була покликана така властивість транзакції, як «ізольованість»: наша транзакція виконується так, ніби інших транзакцій, які виконуються в той же час, не існує. Наша БД виконує одночасні операції так, ніби вона виконує їх одна за одною, <strong>sequentially</strong> – власне, найвищий рівень ізоляції і називається <strong>Strict Serializable</strong>. Так, найвищий, що означає, що рівнів буває кілька.</p> <p>Стоп, скажете ви. Попритримай коней, пане.</p> <p>Давайте згадаємо, як я описував, що кожна операція має час виклику та час виконання. Для зручності можна розглядати виклик та виконання як дві дії. Тоді відсортований список усіх дій виклику та виконання можна назвати історією БД. Тоді рівень ізоляції транзакцій – це набір історій. Ми використовуємо рівні ізоляції, щоб визначити, які історії є «хорошими». Коли ми говоримо, що історія «порушує серіалізується» або «не серіалізується», ми маємо на увазі, що історія не входить до набору історій, що серіалізуються.</p> <p>Щоб було зрозуміло, про які роди історії ми говоримо, наведу приклади . Наприклад, є такий вид історії - <strong>intermediate read</strong>. Він відбувається, коли транзакції А можна читати дані з рядка, яка була змінена іншою запущеною транзакцією Б і ще не зафіксована ("not committed") - тобто, фактично, зміни ще не були остаточно здійснені транзакцією Б, і вона може в будь-який момент їх скасувати. А, наприклад, <strong>aborted read</strong> – це якраз наш приклад із скасованою транзакцією зняття грошей</p> <p>Таких можливих аномалій кілька. Тобто аномалії – це якийсь небажаний стан даних, який може виникнути за конкурентного доступу до БД. І щоб уникнути тих чи інших небажаних станів, БД використовують різні рівні ізоляції – тобто різні рівні захисту даних від небажаних станів. Ці рівні (4 штуки) було перераховано у стандарті ANSI SQL-92. </p> <p>Опис цих рівнів деяким дослідникам видається розпливчастим, і вони пропонують свої, детальніші, класифікації. Раджу звернути увагу на вже згаданий Jepsen, а також проект Hermitage, який покликаний внести ясність у те, які саме рівні ізоляції пропонують конкретні СУБД, такі як MySQL або PostgreSQL. Якщо ви відкриєте файли з цього репозиторію, то ви можете побачити, яку низку SQL-команд вони застосовують, щоб тестувати БД на ті чи інші аномалії, і можете зробити щось подібне для БД, що вас цікавлять). Наведу один приклад з репозиторію, щоб зацікавити вас:</p> <pre class='line-numbers'><code>-- Database: MySQL -- = innodb; insert into test (id, value) values (1, 10), (2, 20); -- Test the "read uncommited" isolation level on the "Intermediate Reads" (G1b) аномально set session transaction isolation level read uncommitted; begin; -- T1 set session transaction isolation level read uncommitted; begin; -- T2 update test set value = 101 where id = 1; - T1 select * from test; - T2. Shows 1 => 101 update test set value = 11 where id = 1; - T1 commit; - T1 select * from test; - T2. Now shows 1 => 11 commit; -- T2 -- Result: doesn't prevent G1b</code></pre> <p>Важливо розуміти, що в одній і тій же БД, як правило, можна вибрати один із кількох видів ізоляції. Чому ж не вибрати найсильнішу ізоляцію? Тому що, як і все в інформатиці, обраний рівень ізоляції повинен відповідати компромісу, на який ми готові йти – в даному випадку компроміс за швидкістю виконання: чим сильніший рівень ізоляції, тим повільніше оброблятимуться запити. Щоб зрозуміти, який рівень ізоляції вам потрібен, вам потрібно зрозуміти вимоги до вашого додатку, а щоб зрозуміти, чи пропонує обрана вами БД цей рівень, доведеться лізти в документацію – для більшості додатків цього буде достатньо, але якщо у вас якісь особливо жорсткі вимоги, то краще влаштувати тест на кшталт того, що роблять хлопці з проекту Hermitage. </p> <h2>5.3 "I" та інші літери в ACID</h2> <p>Ізоляція – це, в основному, те, що і мають на увазі люди, коли говорять про ACID в цілому. І саме з цієї причини я почав розбирати цю абревіатуру з ізоляції, а не пішов по порядку, як зазвичай роблять ті, хто намагається пояснити цю концепцію. А тепер давайте розглянемо і три літери, що залишилися.</p> <p>Згадаймо знову наш приклад із банківським переказом. Транзакція з переказу коштів з одного рахунку на інший включає операцію виведення з першого рахунку і операцію поповнення на другому. Якщо операція поповнення другого рахунку не вдалася, ви, напевно, не хочете, щоб операція виведення коштів з першого відбулася. Іншими словами, або транзакція вдається повністю, або не відбувається взагалі, але вона не може бути зроблена лише на якусь частину. Ця властивість називається атомарністю ("atomicity"), і це "A" в ACID.</p> <p>Коли наша транзакція виконується, то, як і будь-яка операція, вона переводить БД з одного дійсного стану в інший. Деякі БД пропонують так звані <strong>constraints</strong> - тобто правила, що застосовуються до даних, що зберігаються, наприклад, що стосуються первинних або вторинних ключів, індексів, default-значень, типів стовпців і т.д. Так ось, при здійсненні транзакції ми маємо бути впевнені, що всі ці <strong>constraints</strong> будуть виконані. </p> <p>Ця гарантія отримала назву «узгодженість» (consistency) та букву <code>C</code> в ACID (не плутати з узгодженістю зі світу розподілених додатків, про яку ми поговоримо пізніше). Наведу зрозумілий приклад для consistency у сенсі ACID: додаток для онлайн-магазину хоче додати в таблицю <code>orders</code> рядок, і в стовпці <code>product_id</code> буде вказано <strong>ID</strong> з таблиці <code>products</code> – типовий <code>foreign key</code>. </p> <p>Якщо продукт, скажімо, був видалений з асортименту, і, відповідно, з БД, то операція вставки рядка не має статися, і ми отримаємо помилку. Ця гарантія, порівняно з іншими, трохи притягнута за вуха, на мій погляд – хоча б тому, що активне використання <strong>constraints</strong> від БД означає перекладення відповідальності за дані (а також часткове перекладання бізнес-логіки, якщо ми говоримо про таке constraint, як CHECK) з додатку на БД, що, як нині прийнято говорити, ну таке собі. . Системний збій або будь-який інший збій не повинен призводити до втрати результатів транзакції або вмісту БД. Тобто, якщо БД відповіла, що транзакція пройшла успішно, це означає, що дані були зафіксовані в енергонезалежній пам'яті – наприклад, на жорсткому диску. Це, до речі, означає, що ви негайно побачите дані при наступному read-запросе. </p> <p>Ось буквально днями я працював з DynamoDB від AWS (Amazon Web Services), і надіслав деякі дані на збереження, а отримавши відповідь <code>HTTP 200</code> (OK), або щось. Начебто, вирішив перевірити - і не бачив ці дані в базі протягом наступних 10 секунд. Тобто DynamoDB зафіксувала мої дані, але не всі вузли миттєво синхронізувалися, щоб отримати останню копію даних (хоча можливо, справа була і в кеші). Тут ми знову залізли на територію узгодженості в контексті розподілених систем, але момент поговорити про неї, як і раніше, не настав.</p> <p>Отже, тепер ми знаємо, що собою представляють гарантії ACID. І ми навіть знаємо, чому вони корисні. Але чи справді вони нам потрібні у кожному додатку? І якщо ні, то коли саме? Чи всі БД пропонують ці гарантії, а якщо ні, то що вони пропонують натомість?</p>