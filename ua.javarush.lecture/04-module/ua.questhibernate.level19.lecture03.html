Apache Cassandra
<p>----------------------------------------</p>
Опис
Модель даних.
Типи даних.
<p>----------------------------------------</p>
<h2>4.1 Опис </h2>

<p><strong>Apache Cassandra</strong> — розподілена система управління базами даних, що відноситься до класу NoSQL-систем і розрахована на створення високомасштабованих та надійних сховищ величезних масивів даних, представлених у вигляді хешу. </p>

<img data-max-width="256" data-id="3f1932c4-0cbf-42a9-a763-73770a3ad298" src="https://cdn.javarush.com/images/article/3f1932c4-0cbf-62a -73770a3ad298/original.jpeg" alt="">
 
<p>Спочатку проект був розроблений у надрах Facebook і в 2009 році передано під крило фонду Apache Software Foundation, ця організація продовжує розвиток проекту. Промислові рішення на базі Cassandra розгорнуті для забезпечення таких компаній, як Cisco, IBM, Cloudkick, Reddit, Digg, Rackspace, Huawei, Netflix, Apple, Instagram, GitHub, Twitter і Spotify. До 2011 року найбільший кластер серверів, що обслуговує єдину базу даних під керуванням Cassandra, налічував понад 400 машин та містив дані розміром понад 300 ТБ. </p>

<p>Написана <strong>мовою Java</strong>, реалізує розподілену хеш-систему, подібну до DynamoDB, що забезпечує практично лінійну масштабованість при збільшенні обсягу даних. Використовує модель зберігання даних на базі сімейства стовпців, чим відрізняється від систем, подібних до MemcacheDB, які зберігають дані тільки у зв'язці «ключ - значення», можливістю організувати зберігання хешів з кількома рівнями вкладеності. </p>

<p>Відноситься до категорії стійких до відмови СУБД: поміщені в базу дані автоматично реплікуються на кілька вузлів розподіленої мережі або навіть рівномірно розподіляються в декількох дата-центрах. При збої вузла його функції на льоту підхоплюються іншими вузлами, додавання нових вузлів у кластер та оновлення версії Cassandra проводиться на льоту, без додаткового ручного втручання та переконфігурації інших вузлів. </p>

<p>Проте настійно рекомендується заново згенерувати ключі (мітки) для кожного вузла, включаючи існуючі, щоб зберегти якість розподілу навантаження. Генерацію ключів для існуючих вузлів можна уникнути у разі кратного збільшення кількості вузлів (у 2 рази, у 3 рази і так далі). </p>

<img data-max-width="1024" data-id="fa60ab89-22de-439d-a6bf-931a891933c6" src="https://cdn.javarush.com/images/article/fa60ab89-22de-439d-a6 -931a891933c6/original.jpeg" alt="">
 
<h2>4.2 Модель даних</h2>

<p>У термінології кассандри додаток працює з простором ключів (keyspace), що відповідає поняттю схеми бази даних (database schema) у реляційній моделі. У цьому просторі ключів можуть бути кілька колонкових сімейств (column family), що відповідає поняттю реляційної таблиці. </p>

<p>У свою чергу, колонкові сімейства містять колонки (column), які об'єднуються за допомогою ключа (row key) у записі (row). Колонка складається з трьох частин: імені (column name), мітки часу (timestamp) та значення (value). Колонки у межах запису впорядковані. На відміну від реляційної БД, жодних обмежень на те, щоб записи (а в термінах БД це рядки) містили шпальти з такими ж іменами, як і в інших записах — немає. </p>

<p>Колонкові сімейства можуть бути кількох видів, але в цій статті ми опускатимемо цю деталізацію. Також в останніх версіях кассандри з'явилася можливість виконувати запити визначення та зміни даних (DDL, DML) за допомогою мови CQL, а також створювати вторинні індекси (secondary indices). </p>

<img data-max-width="1024" data-id="7c17039f-c0a3-4e11-9afb-abf68be2d8f6" src="https://cdn.javarush.com/images/article/7c17039f-c0a3-4e1 -abf68be2d8f6/original.jpeg" alt="">
 
<p>Конкретне значення, яке зберігається в касандрі, ідентифікується: </p>

<ul>
<li><strong>простір ключів</strong> — це прив'язка до програми (предметної області). Дозволяє одному кластері розміщувати дані різних додатків; </li>
<li><strong>колоночним сімейством</strong> — це прив'язка до запиту; </li>
<li><strong>ключом</strong> – це прив'язка до вузла кластера. Від ключа залежить які вузли потраплять збережені колонки; </li>
<li><strong>ім'ям колонки</strong> — це прив'язка до атрибуту запису. Дозволяє в одному записі зберігати кілька значень. </li>
</ul>

<p>З кожним значенням пов'язана мітка часу — число, яке задається користувачем, яке використовується для вирішення конфліктів під час запису: чим більше число, тим колонка вважається новішою, а при порівнянні перетирає старі колонки.</p>
 
<h2>4.3 Типи даних</h2>

<p>За типами даних: простір ключів та колонкове сімейство — це рядки (імена); мітка часу - це 64-бітове число; а ключ, ім'я колонки та значення колонки – це масив байтів. Також касандра має поняття типів даних (data type). Ці типи можуть за бажанням розробника (опціонально) задаватися під час створення колонкового сімейства. </p>

<p>Для імен колонок це називається порівнятелем (comparator), для значень та ключів - валідатором (validator). Перший визначає, які байтові значення допустимі для імен колонок і як їх упорядкувати. Другий - які байтові значення допустимі для значень колонок та ключів. </p>

<p>Якщо ці типи даних не задані, то касандра зберігає значення і порівнює їх як байтові рядки (BytesType), оскільки, по суті, вони зберігаються всередині. </p>

<o>Типи даних бувають такими: </p>

<ul>
<li><strong>BytesType</strong>: будь-які байтові рядки (без валідації)</li>
<li><strong>AsciiType</strong>: ASCII рядок </li>
<li><strong>UTF8Type</strong>: UTF-8 рядок </li>
<li><strong>IntegerType</strong>: число з довільним розміром </li>
<li><strong>Int32Type</strong>: 4-байтове число </li>
<li><strong>LongType</strong>: 8-байтове число </li>
<li><strong>UUIDType</strong>: UUID 1-го або 4-го типу </li>
<li><strong>TimeUUIDType</strong>: UUID 1-го типу </li>
<li><strong>DateType</strong>: 8-байтове значення мітки часу </li>
<li><strong>BooleanType</strong>: два значення: true = 1 або false = 0 </li>
<li><strong>FloatType</strong>: 4-байтове число з плаваючою комою </li>
<li><strong>DoubleType</strong>: 8-байтове число з плаваючою комою </li>
<li><strong>DecimalType</strong>: число з довільним розміром та плаваючою комою </li>
<li><strong>CounterColumnType</strong>: 8-байтовий лічильник </li>
</ul>

<p>У касандрі всі операції запису даних це завжди операції перезапису, тобто, якщо в колонкову сім'ю приходить колонка з таким же ключем і ім'ям, які вже існують, і мітка часу більша, ніж та збережена, то значення перезаписується. Записані значення ніколи не змінюються, просто приходять нові колонки з новими значеннями. </p>

<p>Запис у кассандру працює з більшою швидкістю, ніж читання. Це змінює підхід, який застосовується під час проектування. Якщо розглядати кассандру з погляду проектування моделі даних, то простіше уявити колонкове сімейство не як таблицю, бо як матеріалізоване уявлення (materialized view) — структуру, що представляє дані деякого складного запиту, але зберігає їх у диску. </p>
 
<p>Замість того, щоб намагатися скомпонувати дані за допомогою запитів, краще постаратися зберегти в коночне сімейство все, що може знадобитися для цього запиту. Тобто підходити необхідно не з боку відносин між сутностями або зв'язками між об'єктами, а з боку запитів: які поля потрібно вибрати; у якому порядку повинні йти записи; які дані, пов'язані з основними, повинні запитуватись спільно — все це вже повинно бути збережено в колонкове сімейство. </p>

<p>Кількість колонок у записі обмежена теоретично 2 мільярдами. Це короткий відступ, а докладніше — у статті про техніки проектування та оптимізацію. А тепер давайте заглибимося в процес збереження даних у кассандру та їх читання.</p>